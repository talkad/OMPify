{"code": "for(int b = 0; b<32; b++) \n      for(int fin = 0; fin<16; fin++) \n        for(int y = 0; y<112 + 2; y++)", "pragma": "parallel for ", "hash": "7d789e026e5a30021f42410a532a5d6ff3445f0e45b035d0b2ec95df7a504ffa"}
{"code": "for (int i = 0; i < static_cast<int>(numParticles); i++) \n\t\t{ \n\t\t\tm_omega[i] += dt*m_angularAcceleration[i]; \n\t\t}", "pragma": "for ", "hash": "1117deb2fd2e168d866df40d823ceb2e13dc53b4f5ceee0f9d97837bd414b206"}
{"code": "for (int s = 0; s <= reaction_data.NS-1; s++)\trhos_Ms[s]\t= 0.001 * rhos[s]/reaction_data.species_data[s].basic_data.M;", "pragma": "parallel for ", "hash": "c8de5233f8c18a7f8f4ced9e9329a6d44a5b6d5d05c214faa737b44cee601818"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tmreal x = d*(i%(nx*ns)), y = d*((i/(nx*ns))%(ny*ns)), z = d*(i/(nx*ny*ns*ns));\r \n\t\tmreal f = sp ? a->value(x,y,z) : a->linear(x,y,z), w=1;\r \n\t\tif(c)\tw = sp ? c->value(x,y,z) : c->linear(x,y,z);\r \n\t\tif(mgl_isnan(f) || mgl_isnan(w))\tcontinue;\r \n\t\tlong k = long(n*(f-v[0])/(v[1]-v[0]));\r \n\t\tif(k>=0 && k<n)\r \n#pragma omp critical(hist)\r \n\t\t\tb[k] += w * d*d*d;\r \n\t}", "pragma": "parallel ", "hash": "51012570e811e09538661752cd659b9ab360287f988d672e574a7ff304f8de00"}
{"code": "for (int j = 0; j < _size.height; j++)  \n  { \n    for (int i = 0; i < _size.width; i++)  \n    { \n      int p = j*_size.width + i; \n       \n      float weight_sum = 0; \n      float sum = 0; \n       \n      for (int k = -2; k <= 2; k++)  \n      { \n        for (int m = -2; m <= 2; m++)  \n        {                          \n          int i2 = i+m; \n          int j2 = j+k; \n          if ((j2 >= 0 && j2 < _size.height) && (i2 >= 0 && i2 < _size.width))  \n          { \n            int q = j2*_size.width + i2; \n            float weight = _discreteGuassian.valueAt(k)*_discreteGuassian.valueAt(m)*_discreteGuassian.valueAt(ref[p]-ref[q]); \n            weight_sum += weight; \n            sum += weight * in[q]; \n          } \n        } \n      } \n      out[p] = (T)(sum / weight_sum); \n    } \n  }", "pragma": "parallel for ", "hash": "022b1ee51ecf43d913fd6aecde9551887591565c737b00bab0637238efde43ba"}
{"code": "for (i = 0; i < height; i++) \n      { \n         double d = 0.0; \n         for (j = Ip[i], end = Ip[i+1]; j < end; j++) \n         { \n            d += Ap[j] * xp[Jp[j]]; \n         } \n         yp[i] += d; \n      }", "pragma": "parallel for private(end j)", "hash": "48ea1d31471f3798aa1d6f2fec5f37a09f1ec5aaa3984be0736daf43e64b2a3f"}
{"code": "for (qint64 fiberID = 0; fiberID < fiberCount; ++fiberID) \n\t\t{ \n\t\t\tauto it = d.curveInfo.find(fiberID); \n\t\t\t \n \n\t\t\tiAFiberData fiber(d.table, fiberID, mapping, (it != d.curveInfo.end())? it->second : std::vector<iAVec3f>()); \n\t\t\tgetBestMatches(fiber, mapping, ref.table, d.refDiffFiber[fiberID].dist, ref.curveInfo, \n\t\t\t\tm_diagonalLength, m_maxLength, m_measuresToCompute, m_optimizationMeasureIdx); \n\t\t}", "pragma": "parallel for ", "hash": "1cbecb7a99dbb24c6bf6524a0f7eacad2f965fec4b080588cbf4ecbbf49ecd28"}
{"code": "for(size_t p = 0;p<np;p++) \n  { \n    double s,sqrd; \n    RowVector3d n,c; \n    int i = -1; \n    RowVector3d q = P.row(p); \n    signed_distance_pseudonormal(tree,V,F,FN,VN,EN,EMAP,q,s,sqrd,i,c,n); \n    S(p) = s*sqrt(sqrd); \n    I(p) = i; \n    N.row(p) = n; \n    C.row(p) = c; \n  }", "pragma": "parallel for ", "hash": "90416207f1ccaf64bb063ebe38e6cbeb5177d7bfbecb2a107258923ebdd3f99c"}
{"code": "for(k=0;k<size_z;k++) { \n        for(j=1;j<size_y-1;j++) { \n            for(i=0;i<size_x;i++) { \n                 \n \n                vx_temp[l] = vx[l] +  -2*dt/(dens[l]+dens[lxm]) *(Pres[l]-Pres[lxm])/zone_size_x(j,k); \n                vx_temp[l] -= dt*(Pot[l]-Pot[lxm])/zone_size_x(j,k); \n                if (IndirectTerm) { \n                    vx_temp[l] -= dt*(indPot[l]-indPot[lxm])/zone_size_x(j,k); \n                } \n                 \n \n                vy_temp[l] = vy[l] -2*dt/(dens[l]+dens[lym])*(Pres[l]-Pres[lym])/(ymed(j)-ymed(j-1)); \n                vxc = .25*(vx[l]+vx[lxp]+vx[lym]+vx[lxp-pitch])+omf*ymin(j); \n                vy_temp[l] += dt*vxc*vxc/ymin(j); \n                vy_temp[l] -= dt*(Pot[l]-Pot[lym])/(ymed(j)-ymed(j-1)); \n                if (IndirectTerm) { \n                    vy_temp[l] -= dt*(indPot[l]-indPot[lym])/(ymed(j)-ymed(j-1)); \n                } \n            } \n        } \n    }", "pragma": "parallel for private(i j k vxc)", "hash": "d25f5cf4caf22acbeb04128a4349c7ce920579a1d47c28a19271162809dca7af"}
{"code": "for(size_t y=0; y < max_y; y+=1) \n    { \n        SlidingIntegralFeature sliding_feature(feature,integral_channels, \n                                               y, start_col, x_stride); \n        feature_values_t::reference feature_values_row = feature_values[y]; \n        for(size_t x=start_col; x < max_x; x+=1, sliding_feature.slide()) \n        { \n            feature_values_row[x] = sliding_feature.get_value(); \n        }  \n \n    }", "pragma": "parallel for ", "hash": "a428a63fad8a787fb5cd3234de020988c0444860f1853279105bb51cf6304bb9"}
{"code": "for(long j=0;j<n2;j++)\tfor(long i=0;i<n1;i++) \n\t\t\tr->a[i+n1*j] = d1->vthr(i)*d2->vthr(j);", "pragma": "parallel for ", "hash": "684726ce0cbf9d0488d31fd695237d98877154ddc6861eacc472549941ab01ed"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tb[i]=a[i];\r \n\t\tfor(long j=1;j<nz;j++)\tif(b[i]<a[i+nn*j]) b[i] = a[i+nn*j];\r \n\t}", "pragma": "parallel ", "hash": "889360563f39ad35f32e021266e7418c68f1667290569c64b899e4c23af66eb0"}
{"code": "for (vector<int>::iterator it = pointersToExtensions.begin();it != pointersToExtensions.end();it++) \n\t\t\tif (*it < min) \n\t\t\t\tmin = *it;", "pragma": "parallel for ", "hash": "fe514f79509f1813db02cd023d09a394b774dd6ea9008a57e11c4b0b49d81ebf"}
{"code": "for (int i = 0; i < (int)testImgDescriptors.size(); i++) \n    { \n        bool zq, zpq, Lzq; \n        double logP = 0; \n        for (int q = 0; q < infer->vocabSize(); q++) \n        { \n            zq = queryImgDescriptor.at<float>(0,q) > 0; \n            zpq = queryImgDescriptor.at<float>(0,infer->pq(q)) > 0; \n            Lzq = testImgDescriptors[i].at<float>(0,q) > 0; \n            logP += log(infer->PzGL(q, zq, zpq, Lzq, false)); \n        } \n        matches[startOfNewMatches+(size_t)i] = IMatch(0,i,logP,0); \n    }", "pragma": "parallel for ", "hash": "f22053d41102378133dba1be7973433dfdbb6c7c847e8a7a74f1bc2a4f7765dc"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      ++j; \n      #pragma omp ordered doacross(source:) \n      #pragma omp ordered doacross(sink:i-1) \n    }", "pragma": "for ", "hash": "718038e4badf5adfc7a340c2fc5a48e692c522ec897e5d5ad3d865ed73cf5879"}
{"code": "for (i = 0; i < ndata; i++) { \n                    if (DEFINED_VAL(stack[top][i]) && DEFINED_VAL(stack[j][i])) { \n\t\t        sq1 += (stack[top][i]-sum1)*(stack[top][i]-sum1); \n\t\t        sq2 += (stack[j][i]-sum2)*(stack[j][i]-sum2); \n\t\t        sq12 += (stack[top][i]-sum1)*(stack[j][i]-sum2); \n\t\t    } \n\t        }", "pragma": "parallel for reduction(+:sq1 sq12 sq2) private(i)", "hash": "99433759359d2bf673e866b0d61419b6e7919bafd18207b8ddd02dded2da3ce8"}
{"code": "for (uint64_t i = 0; i < weights->size(); ++i) { \n\t\t \n \n\t\tchar* const gzCommand[] = { \n\t\t\t\"tar\", \n\t\t\t\"-x\", \n\t\t\t\"-k\", \n\t\t\t\"-z\", \n\t\t\t\"--null\", \n\t\t\t\"-f\", \n\t\t\tstrToChar(weights->at(i).second), \n\t\t\t(char *) NULL \n\t\t}; \n\t\tif (verbose) { \n\t\t\tprintCommand(gzCommand, 7); \n\t\t} \n\t\texecute(gzCommand); \n\t\tdelete[] gzCommand[6]; \n\t}", "pragma": "parallel for ", "hash": "9cdc0cb255f3bb4a6894e9cba1909ed7a45505a0f63def0ec76995f39bdbc176"}
{"code": "for (k = 0; k < M; k++) \n    { \n      INT l; \n      INT j = (ths->flags & NFFT_SORT_NODES) ? ths->index_x[2*k+1] : k; \n      ths->f[j] = K(0.0); \n      for (l = 0; l < lprod; l++) \n        ths->f[j] += ths->psi[j*lprod+l] * g[ths->psi_index_g[j*lprod+l]]; \n    }", "pragma": "parallel for private(k)", "hash": "0803531c9a9735f6d6db7b70ae10cc6a45f6317607a0cf402eae4757b95674d2"}
{"code": "for (i=0; i<nPri; i++) { \n      sxx=0.00000e0; \n      indr=i*nPri; \n      for (j=0; j<nPri; j++) { \n         sxx+=cab[indr+j]*hxx[j]; \n      } \n      lap+=chi[i]*sxx; \n   }", "pragma": "parallel for reduction(+: lap) private(i indr j sxx)", "hash": "bf8f8466dc898062bc136635df9e2387c39631754478d6ba16d34993680e5baa"}
{"code": "for(int y = 0; y < result.height(); y++) { \n        QRgb *scanline = (QRgb*) result.scanLine(y); \n \n         \n \n        for(int x = 0; x < result.width(); x++) { \n            double intensity = 0.0; \n \n            const QColor pxColor = QColor(input.pixel(x, y)); \n \n            const double r = pxColor.redF() * redMultiplier; \n            const double g = pxColor.greenF() * greenMultiplier; \n            const double b = pxColor.blueF() * blueMultiplier; \n            const double a = pxColor.alphaF() * alphaMultiplier; \n \n            if(mode == IntensityMap::AVERAGE) { \n                 \n \n                intensity = (r + g + b + a) / multiplierSum; \n            } \n            else if(mode == IntensityMap::MAX) { \n                 \n \n                const double tempMaxRG = std::max(r, g); \n                const double tempMaxBA = std::max(b, a); \n                intensity = std::max(tempMaxRG, tempMaxBA); \n            } \n \n             \n \n            intensity *= scale; \n \n             \n \n            if(intensity > 1.0) \n                intensity = 1.0; \n \n             \n \n            int c = (int)(255.0 * intensity); \n             \n             \n \n            c = (int)contrastLookup[c]; \n             \n             \n \n            scanline[x] = qRgba(c, c, c, pxColor.alpha()); \n        } \n    }", "pragma": "parallel for ", "hash": "43ad790fa12209eeffb3af31ae33b4de5f2fc818d2b3aa1f01396130d25c2d23"}
{"code": "for (ix = 0; ix < nx; ix++) { \n    tt = sqrtf( powf((isx-ix)*dx,2) + z2 ) / vel; \n    cut = (int) (tt/dt) + wd;  \n \n    if (cut > nt) cut = nt; \n    t[ix] = cut; \n  }", "pragma": "parallel for private(cut ix tt)", "hash": "157ae49ae62d8e9ebebbabb43115b65e68d89056cee98a3d70ecc038e684e09b"}
{"code": "for (ompIndexType k = 0; k < nbElements; ++k) { \n        if (ptrA[k] < (T)0) { \n            ptrB[k] = (T)(-1); \n        } else if (ptrA[k] == (T)0) { \n            ptrB[k] = (T)(0); \n        } else { \n            ptrB[k] = (T)(1); \n        } \n    }", "pragma": "parallel for ", "hash": "5492d1b7cb8de23d4d89e2f4ab271dda5ea8cde6b90bcc9df445296fdb158aca"}
{"code": "for (i = 0; i < p->npe; i++) { \n    long j, k; \n    long lxp; \n    double *src, *dst; \n \n    lxp = p->plx; \n    for (j = 0; j < p->ly; j++) { \n      dst = inout + p->lx * i * 2 + p->py * j * 2; \n      src = p->sb + lxp * p->ly * i * 2 + lxp * j * 2; \n      for (k = 0; k < p->lx * 2; k++) \n\tdst[k] = src[k]; \n    } \n  }", "pragma": "parallel for ", "hash": "f0b02b040d00dd9e6203d8a0d026a6ced56e7f2b9f1afa74cd61010589847882"}
{"code": "for (long d = 0; d < dataSize; d++) { \n  #pragma omp atomic \n\t\tsum += HardSum(data[d]); \n\t}", "pragma": "parallel for ", "hash": "df2ed3b5c0366bedf22125b944267329a4e7e525e63dd029c6d6f280e2c5e433"}
{"code": "for( int planeNr=0; planeNr < nrOfPlanes; planeNr++ ) \n    { \n        IPLImagePlane* plane = image->plane( planeNr ); \n        IPLImagePlane* newplane = _result->plane( planeNr ); \n        IPLImagePlane* average = new IPLImagePlane(width, height); \n \n        for(int x=w2; x<width-w2; x++) \n        { \n             \n \n            notifyProgressEventHandler(100*progress++/maxProgress); \n            for(int y=w2; y<height-w2; y++) \n            { \n                ipl_basetype sum = 0; \n                for( int kx=-w2; kx<=w2; kx++ ) \n                { \n                    for( int ky=-w2; ky<=w2; ky++ ) \n                    { \n                        if( kx || ky ) sum += plane->p(x+kx, y+ky); \n                    } \n                } \n                average->p(x,y) = sum; \n            } \n        } \n        for(int x=w2; x<width-w2; x++) \n        { \n             \n \n            notifyProgressEventHandler(100*progress++/maxProgress); \n \n            for(int y=w2; y<height-w2; y++) \n            { \n                float minc = (area-1); \n                float maxc = 0; \n                for( int kx=-w2; kx<=w2; kx++ ) \n                { \n                    for( int ky=-w2; ky<=w2; ky++ ) \n                    { \n                        ipl_basetype img = average->bp(x+kx, y+ky); \n                        if( img > maxc) maxc = img; \n                        if( img < minc) minc = img; \n                    } \n                } \n                ipl_basetype img = average->p(x,y); \n                ipl_basetype d1 = img - minc; \n                ipl_basetype d2 = maxc - img; \n                ipl_basetype min = (d1 < d2)? d1 : d2; \n                min = (min<1.0)? min : 1.0; \n                min = (min>0.0)? min : 0.0; \n                newplane->p(x,y) = min; \n            } \n        } \n        delete average; \n    }", "pragma": "parallel for ", "hash": "68e3afe8f5f3f1458a56dbce236ad2d99e023092f6f5be8cb58e7a2ba7d97d45"}
{"code": "for (int i = 0; i < 500; ++i) { \n        queue.add(i); \n    }", "pragma": "parallel for ", "hash": "e95c3b0460db14747ddf3c8d74ca797cc8c34afc2901129e2c03b7ff91724fb2"}
{"code": "for (int i = 0; i < N; i++) \n \n\t\t{ \n\t\t\tfor (int j = i + 1; j < N; j++) \n\t\t\t{ \n\t\t\t\tif (graf1.Graph[i][j] != graf2.Graph[i][j]) \n\t\t\t\t{ \n\t\t\t\t\twynik = false; \n\t\t\t\t\tbreak; \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "df8752c04d32b822b81aa380e94566a58629c18f34f9c5721614cad4ad91969e"}
{"code": "for (size_t i = 0; i < people.size(); i++) \n        { \n        people[i]->eval(); \n        }", "pragma": "parallel for ", "hash": "dddff15253a0a857613c7126bf97c017c7acf430e0462d332b3c5cbd96a68be6"}
{"code": "for(intptr_t i = 0; i < static_cast<intptr_t>(c); ++i)\r \n\t{\r \n\t\tspoints[i] = GfxTL::Vector3Df(samples[i] - m_center);\r \n\t\tspoints[i].Normalize();\r \n\t}", "pragma": "parallel for ", "hash": "93f6c09994da5b62ffdaef2ccfdd85cbf581305c0e39683e414fc23999ff954b"}
{"code": "for (i = 0; i < len; i++) { \n\t\t \n \n\t\tsize = explode_sansnull(arr_ptr, str, *delimiter); \n\t}", "pragma": "parallel for ", "hash": "0d901442a059b394c0a632200ab3edf243409b0350a65c8da1842204cbc51811"}
{"code": "for(int k = 0; k <= nk; ++k) \n\t{ \n\t\t \n \n\t\t \n \n\t\tint pos_k_basis_index = (nm == 0) ? k : nk + k; \n\t\tint neg_k_basis_index = (nm == 0) ? 0 : nk - k; \n \n\t\t \n \n\t\t \n \n\t\tstd::vector<cv::Mat_<float>> intermediate_array(nj); \n \n\t\t \n \n\t\tfor(int j = 0; j < nj; ++j) \n\t\t{ \n\t\t\tintermediate_array[j] = cv::Mat_<float>::zeros(pad_ysize,pad_xsize); \n\t\t} \n \n\t\t \n \n\t\tfor (int x = 0 ; x < xswitch; ++x) \n\t\t{ \n\t\t\tfor (int y = 0 ; y < yswitch; ++y) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tconst float w_x = float(-x)/xsizef ; \n\t\t\t\tconst float w_y = float(y)/ysizef ; \n\t\t\t\tconst float rho = 2.0*M_PI*std::sqrt(w_x*w_x + w_y*w_y); \n \n\t\t\t\tfor(int j = 0; j < nj; ++j) \n\t\t\t\t{ \n\t\t\t\t\tconst float f = ((x == 0) && (y == 0)) ? 0.0 : coneHankel(rho,(j+1)*r_space,k)/area_normaliser; \n \n\t\t\t\t\tintermediate_array[j](y,x) = f;  \n \n\t\t\t\t\tif(x > 0) \n\t\t\t\t\t\tintermediate_array[j](y,pad_xsize-x) = f;  \n \n\t\t\t\t\tif(y > 0) \n\t\t\t\t\t\tintermediate_array[j](pad_ysize-y,x) = f;  \n \n\t\t\t\t\tif((x > 0) && (y > 0)) \n\t\t\t\t\t\tintermediate_array[j](pad_ysize-y,pad_xsize-x) = f;  \n \n\t\t\t\t} \n\t\t\t}  \n \n\t\t}  \n \n \n\t\t \n \n\t\t \n \n\t\tfor(int j = 0; j < nj; ++j) \n\t\t{ \n\t\t\tcv::Mat_<float> complex_parts[2], radial_part; \n \n\t\t\tswitch(j) \n\t\t\t{ \n\t\t\t\tcase 0: \n\t\t\t\t\t \n \n\t\t\t\t\tradial_part = 2*M_PI*intermediate_array[0]; \n\t\t\t\t\tbreak; \n\t\t\t\tcase 1: \n\t\t\t\t\tradial_part = 2*M_PI*(2*intermediate_array[1] - 2*intermediate_array[0]); \n\t\t\t\t\tbreak; \n\t\t\t\tdefault: \n\t\t\t\t\tradial_part = 2*M_PI*((j+1)*intermediate_array[j] - 2*j*intermediate_array[j-1] + (j-1)*intermediate_array[j-2]); \n\t\t\t\t\tbreak; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif(k == 0) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tswitch(j) \n\t\t\t\t{ \n\t\t\t\t\tcase 0: \n\t\t\t\t\t\tradial_part(0,0) = (1.0/3.0)*M_PI*std::pow(r_space,2.0); \n\t\t\t\t\t\tbreak; \n\t\t\t\t\tcase 1: \n\t\t\t\t\t\tradial_part(0,0) = 2.0*(1.0/3.0)*M_PI*std::pow(2*r_space,2.0) - 2.0*(1.0/3.0)*M_PI*std::pow(r_space,2.0); \n\t\t\t\t\t\tbreak; \n\t\t\t\t\tdefault: \n\t\t\t\t\t\tradial_part(0,0)= (j+1)*(1.0/3.0)*M_PI*std::pow((j+1)*r_space,2.0) - 2.0*j*(1.0/3.0)*M_PI*std::pow(j*r_space,2.0) + (j-1)*(1.0/3.0)*M_PI*std::pow((j-1)*r_space,2.0); \n\t\t\t\t\t\tbreak; \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\tradial_part(0,0) = radial_part(0,0)/area_normaliser; \n \n\t\t\t}  \n \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tpolarToCart(radial_part,k*psi,complex_parts[0],complex_parts[1]); \n \n\t\t\t \n \n\t\t\tswitch(k%4) \n\t\t\t{ \n\t\t\t\tcase 0:  \n \n\t\t\t\t\t \n \n\t\t\t\t\tbreak; \n \n\t\t\t\tcase 1:  \n \n\t\t\t\t{ \n\t\t\t\t\tcv::Mat_<float> temp = -complex_parts[0].clone(); \n\t\t\t\t\tcomplex_parts[0] = complex_parts[1]; \n\t\t\t\t\tcomplex_parts[1] = temp; \n\t\t\t\t} \n\t\t\t\t\tbreak; \n \n\t\t\t\tcase 2:  \n \n\t\t\t\t\tcomplex_parts[0] *= -1.0; \n\t\t\t\t\tcomplex_parts[1] *= -1.0; \n\t\t\t\t\tbreak; \n \n\t\t\t\tcase 3:  \n \n\t\t\t\t{ \n\t\t\t\t\tcv::Mat_<float> temp = complex_parts[0].clone(); \n\t\t\t\t\tcomplex_parts[0] = -complex_parts[1]; \n\t\t\t\t\tcomplex_parts[1] = temp; \n\t\t\t\t} \n\t\t\t\t\tbreak; \n\t\t\t} \n\t\t\tmerge(complex_parts,2,U_freq[pos_k_basis_index]); \n \n\t\t\t \n \n\t\t\tif(nm > 0) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tif((k)%2 == 0) \n\t\t\t\t\tcomplex_parts[1] *= -1.0; \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\telse \n\t\t\t\t\tcomplex_parts[0] *= -1.0; \n\t\t\t\tmerge(complex_parts,2,U_freq[neg_k_basis_index]); \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif(nm == 0) \n\t\t\t\tpos_k_basis_index += nk+1; \n\t\t\telse \n\t\t\t{ \n\t\t\t\tpos_k_basis_index += 2*nk+1; \n\t\t\t\tneg_k_basis_index += 2*nk+1; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "08b5bb7dbce1bc806e9929c5e1b85ff3d9a0f6957f709ca5c1adfa85f6c768fe"}
{"code": "for(int y=0;y<perRamCanvas.getNumPixY();y++) { \n    rcCNT::colorChanType maxCheckpointITR = 0; \n    double meanCheckpointITR = 0; \n    std::vector<std::complex<double>> lastZs(MAXITR); \n    std::chrono::time_point<std::chrono::system_clock> rowStartTime = std::chrono::system_clock::now(); \n \n    for(int x=0;x<perRamCanvas.getNumPixX();x++) { \n      std::complex<double> c(perRamCanvas.int2realX(x), perRamCanvas.int2realY(y)); \n      std::complex<double> z(0.0, 0.0); \n      rcCNT::colorChanType count = 1; \n      bool seekingUnderstanding = true; \n      rcCNT::colorChanType checkpointITR = 1024*8; \n \n      while(seekingUnderstanding) { \n        if ((MAXITR - checkpointITR) < checkpointITR) \n          checkpointITR = MAXITR; \n        else \n          checkpointITR *= 2; \n \n        if (maxCheckpointITR < checkpointITR) \n          maxCheckpointITR = checkpointITR; \n \n        while((std::norm(z)<MAXZSQU) && (count<checkpointITR)) { \n          z=std::pow(z, 2) + c; \n          lastZs[count] = z; \n          count++; \n        } \n \n        if (std::norm(z)>MAXZSQ) {  \n \n          escRamCanvas.drawPoint(x, y, count); \n          seekingUnderstanding = false; \n        } else {  \n \n          for(rcCNT::colorChanType period=1; period<(checkpointITR-2); period++) { \n            if(std::abs(z-lastZs[checkpointITR-1-period])<1e-7) {  \n \n              rcCNT::colorChanType stab; \n              for(stab=0; stab<(checkpointITR-period); stab++) { \n                if(std::abs(lastZs[checkpointITR-1-stab]-lastZs[checkpointITR-1-period-stab])>1e-7) {    \n                  break; \n                } \n              } \n              if (stab > period) {  \n \n                stbRamCanvas.drawPoint(x, y, checkpointITR-stab); \n                perRamCanvas.drawPoint(x, y, period); \n                noeRamCanvas.drawPoint(x, y, \"white\"); \n                seekingUnderstanding = false; \n                break; \n              } \n            } \n          } \n          if (seekingUnderstanding && (checkpointITR == MAXITR)) {  \n \n            noeRamCanvas.drawPoint(x, y, \"white\"); \n            seekingUnderstanding = false; \n            break; \n          } \n        } \n      } \n      meanCheckpointITR += checkpointITR / static_cast<double>(CSIZE); \n \n    } \n    std::chrono::duration<double> rowRunTime = std::chrono::system_clock::now() - rowStartTime; \n    std::cout << \"my: \" << CSIZE << \" y: \" << y << \" max: \" << maxCheckpointITR << \" mean: \" << meanCheckpointITR << \" secs: \" << rowRunTime.count() << std::endl; \n  }", "pragma": "parallel for ", "hash": "0e82ca359191fc343bcc0ca0f726254ebbd937622c7ce097671f3aea254723f2"}
{"code": "for (int j = Lcol[i + 1]; j < m; j++){ \n \n\t\t\tfor (int k = Lrowindex[j]; k < Lrowindex[j + 1]; k++){ \n\t\t\t\t \n \n\t\t\t\tBmat[j] -= Bmat[Lloc[k].index] * valueL[k]; \n\t\t\t\t \n \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "2d7f30c4e39e4db2471006b1774f07e7a94022fbf0d218142495bb8a0f7ee98a"}
{"code": "for (uint brkpt_ctr_0 = 0; brkpt_ctr_0 < number_of_haploid_breakpoints_0; ++brkpt_ctr_0) \n\t\t    { \n\t\t\tfor (uint brkpt_ctr_1 = 0; brkpt_ctr_1 < number_of_haploid_breakpoints_1; ++brkpt_ctr_1) \n\t\t\t{   \n\t\t\t    set_breakpoints_using_breakpoint_space(breakpoints__haploid_0, breakpoint_space__hap_0, brkpt_ctr_0); \n\t\t\t    set_breakpoints_using_breakpoint_space(breakpoints__haploid_1, breakpoint_space__hap_1, brkpt_ctr_1); \n\t\t\t     \n\t\t\t     \n \n \n \n\t\t\t     \n\t\t\t    real prod_PER__diploid_sum_m__mPER( \n\t\t\t\t\t\tevent_being_summed_out->second.calculate_or_get_Read_Depth_for_these_state_vectors_and_breakpoints \n\t\t\t\t\t\t\t\t\t\t(*it_states_0, *it_states_1, \n\t\t\t\t\t\t\t\t\t\tbreakpoints__haploid_0, breakpoints__haploid_1)); \n\t\t\t     \n \n \n \n \n\t\t\t     \n\t\t\t    const double PER_loop_time_begin = omp_get_wtime(); \n\t\t\t    for (type_map_string_to_PER::iterator it_PER = event_being_summed_out->second.PERs_on_this_profile.begin(); \n\t\t\t\t    it_PER != event_being_summed_out->second.PERs_on_this_profile.end(); \n\t\t\t\t    ++it_PER) \n\t\t\t    { \n\t\t\t\tconst type_uint__real haploid_0__sum_P_mPER( \n\t\t\t\t\t\t    it_PER->second.calculate_or_get__haploid_sum_P_mPER__cond__sparse_haploid_state_vector_and_breakpoints \n\t\t\t\t\t\t\t\t\t\t\t(false, \n\t\t\t\t\t\t\t\t\t\t\t*it_states_0, \n\t\t\t\t\t\t\t\t\t\t\tbreakpoints__haploid_0)); \n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\tconst type_uint__real haploid_1__sum_P_mPER( \n\t\t\t\t\t\t    it_PER->second.calculate_or_get__haploid_sum_P_mPER__cond__sparse_haploid_state_vector_and_breakpoints \n\t\t\t\t\t\t\t\t\t\t\t(true, \n\t\t\t\t\t\t\t\t\t\t\t*it_states_1, \n\t\t\t\t\t\t\t\t\t\t\tbreakpoints__haploid_1)); \n\t\t\t\t \n\t\t\t\tconst uint total_diploid_contributions =  haploid_0__sum_P_mPER.first + haploid_1__sum_P_mPER.first;  \n\t\t\t\t\t     \n \n\t\t\t\t \n\t\t\t\tswitch (total_diploid_contributions) \n\t\t\t\t{ \n\t\t\t\t    case 0:  \n\t\t\t\t\tbreak; \n\t\t\t\t    case 1: \n\t\t\t\t\tprod_PER__diploid_sum_m__mPER *= (haploid_0__sum_P_mPER.second + haploid_1__sum_P_mPER.second); \n\t\t\t\t\tbreak;                                             \n\t\t\t\t    default: \n\t\t\t\t\tprod_PER__diploid_sum_m__mPER *= (haploid_0__sum_P_mPER.second + haploid_1__sum_P_mPER.second); \n\t\t\t\t\tprod_PER__diploid_sum_m__mPER /=  total_diploid_contributions;  \n\t\t\t\t\tbreak;                                                                         \n\t\t\t\t}    \n\t\t\t    }   \n \n\t\t\t     \n \n \n\t\t\t     \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n                             \n \n\t\t\t    rank_specific___piece_of_new_PSF.save_diploid_partial_sum_for_these_sparse_state_vectors_and_breakpoints \n\t\t\t\t\t\t\t\t\t\t    (*it_states_0, *it_states_1, \n\t\t\t\t\t\t\t\t\t\t    breakpoints__haploid_0, breakpoints__haploid_1, \n\t\t\t\t\t\t\t\t\t\t    prod_PER__diploid_sum_m__mPER);                                                                 \n\t\t\t\t\t\t\t \n\t\t\t}   \n \n\t\t    }", "pragma": "for ", "hash": "529e0e9e973a53ce47e94f3216433de27b3bc24da930269ea3c37eb7166bb7a1"}
{"code": "for(size_t y = 0; y < oheight; y++) \n    { \n      const size_t a_start = ((y + yoffs) * iwidth + xoffs) * DT_BLENDIF_RGB_CH; \n      const size_t b_start = y * stride; \n      _copy_mask(a + a_start, b + b_start, stride); \n    }", "pragma": "parallel for ", "hash": "27f0b21e46f595c3bb1dc9b30e4874eb1eecf8230a1ff78ac05e54670d110bf5"}
{"code": "for (i = 0; i < num_ir_gp; i++) { \n     \n \n    for (l = 0; l < 24; l++) { \n      for (q = 0; q < 4; q++) { \n        for (r = 0; r < 3; r++) { \n          g_addr[r] = grid_address[ir_grid_points[i]][r] + \n            relative_grid_address[l][q][r]; \n        } \n        rgd_get_double_grid_address(address_double, \n                                    g_addr, \n                                    mesh, \n                                    is_shift); \n        ir_gps[l][q] = gp2ir[rgd_get_double_grid_index(address_double, mesh)]; \n      } \n    } \n \n    for (k = 0; k < num_band; k++) { \n      for (l = 0; l < 24; l++) { \n        for (q = 0; q < 4; q++) { \n          tetrahedra[l][q] = frequencies[ir_gps[l][q] * num_band + k]; \n        } \n      } \n      for (j = 0; j < num_freq_points; j++) { \n        iw = thm_get_integration_weight(freq_points[j], tetrahedra, 'I') * weights[i]; \n        for (m = 0; m < num_coef; m++) { \n          dos[i * num_band * num_freq_points * num_coef + \n              k * num_coef * num_freq_points + j * num_coef + m] += \n            iw * coef[i * num_coef * num_band + m * num_band + k]; \n        } \n      } \n    } \n  }", "pragma": "parallel for private(          address_double g_addr ir_gps iw j k l m q r tetrahedra)", "hash": "965e70b24300e4de34586a49094f6e2f9d7f916d01666bb1c2696fbc50d598d5"}
{"code": "for (int y = window_size + 1; y < height - (window_size + 1); y += 2) \n \n\t\t{ \n\t\t\tMat alpha_coeff(1, 4, CV_32F); \n\t\t\tMat offset(1, 4, CV_32F); \n\t\t\tMat vectorY(window_area, 1, CV_32F); \n\t\t\tMat matrixC(window_area, 4, CV_32F); \n\t\t\tMat CtC(4, 4, CV_32F); \n\t\t\tMat CInv(4, 4, CV_32F); \n\t\t\tMat c(4, 1, CV_32F); \n\t\t\tMat colsum(4, 1, CV_32F); \n\t\t\tMat rowsum(1, 4, CV_32F); \n\t\t\tfloat* dst = dim.ptr<float>(y); \n \n\t\t\tfor (int x = window_size + 1; x < width - (window_size + 1); x += 2) \n\t\t\t{ \n\t\t\t\tfloat sum = 0, ave = 0, var = 0; \n\t\t\t\tfloat nn4[4] = { dst[x - 1 - width], dst[x + 1 - width], dst[x - 1 + width], dst[x + 1 + width] }; \n \n\t\t\t\tfor (int i = 0; i < 4; i++) \n\t\t\t\t{ \n\t\t\t\t\tsum += nn4[i]; \n\t\t\t\t} \n \n\t\t\t\tave = sum * 0.25f; \n \n\t\t\t\tfor (int i = 0; i < 4; i++) \n\t\t\t\t{ \n\t\t\t\t\tvar += (ave - nn4[i]) * (ave - nn4[i]); \n\t\t\t\t} \n \n\t\t\t\tvar *= 0.25f; \n \n\t\t\t\tif (var >= threshold) \n\t\t\t\t{ \n\t\t\t\t\tfloat* matC = matrixC.ptr<float>(); \n\t\t\t\t\tfloat* vecY = vectorY.ptr<float>(); \n \n\t\t\t\t\tfloat sumy = 0.f; \n\t\t\t\t\tfor (int Y = 0; Y < window_size * 2; Y += 2) \n\t\t\t\t\t{ \n\t\t\t\t\t\tfloat* window = dim.ptr<float>(y - (window_size - 1) + Y, x - (window_size - 1)); \n \n\t\t\t\t\t\tfor (int X = 0; X < window_size * 2; X += 2) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tfloat v = window[X]; \n\t\t\t\t\t\t\tfloat r0 = window[X - 2 - width2]; \n\t\t\t\t\t\t\tfloat r1 = window[X + 2 - width2]; \n\t\t\t\t\t\t\tfloat r2 = window[X - 2 + width2]; \n\t\t\t\t\t\t\tfloat r3 = window[X + 2 + width2]; \n\t\t\t\t\t\t\tfloat ra = (r0 + r1 + r2 + r3) * 0.25f; \n \n\t\t\t\t\t\t\tmatC[0] = r0 - ra; \n\t\t\t\t\t\t\tmatC[1] = r1 - ra; \n\t\t\t\t\t\t\tmatC[2] = r2 - ra; \n\t\t\t\t\t\t\tmatC[3] = r3 - ra; \n \n\t\t\t\t\t\t\t*vecY++ = v; \n\t\t\t\t\t\t\tsumy += v; \n\t\t\t\t\t\t\tmatC += 4; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n\t\t\t\t\tvectorY -= sumy / window_area; \n \n\t\t\t\t\tmulTransposed(matrixC, CtC, true); \n\t\t\t\t\tCtC.at<float>(0, 0) += eps; \n\t\t\t\t\tCtC.at<float>(1, 1) += eps; \n\t\t\t\t\tCtC.at<float>(2, 2) += eps; \n\t\t\t\t\tCtC.at<float>(3, 3) += eps; \n\t\t\t\t\tgemm(matrixC, vectorY, 1.0, noArray(), 0.0, c, GEMM_1_T); \n \n\t\t\t\t\tsolve(CtC, c, alpha_coeff, DECOMP_LU); \n \n \n\t\t\t\t\tinvert(CtC, CInv, DECOMP_LU); \n\t\t\t\t\tMat onesVector = Mat::ones(4, 1, CV_32FC1); \n\t\t\t\t\tMat temp1 = (onesVector.t() * CInv * onesVector); \n\t\t\t\t\tMat temp2 = (onesVector.t() * CInv * c); \n\t\t\t\t\tMat offset = (CInv * onesVector) * (1.f - temp2.at<float>(0)) / (temp1.at<float>(0) + FLT_EPSILON); \n\t\t\t\t\tinvert(CtC, CInv, DECOMP_LU); \n\t\t\t\t\tfloat v1 = float(cv::sum(CInv).val[0] + FLT_EPSILON); \n \n\t\t\t\t\treduce(CInv, rowsum, 0, REDUCE_SUM, CV_32F); \n\t\t\t\t\tfloat v2 = Mat(rowsum * c).at<float>(0); \n \n\t\t\t\t\treduce(CInv, colsum, 1, REDUCE_SUM, CV_32F); \n \n\t\t\t\t\tmultiply(colsum, (1.f - v2) / (v1), offset); \n\t\t\t\t\talpha_coeff += offset; \n \n\t\t\t\t\tfloat* alpha = alpha_coeff.ptr<float>(0); \n\t\t\t\t\t \n \n\t\t\t\t\tif (alpha[0] == 0) \n\t\t\t\t\t{ \n\t\t\t\t\t\tdst[x] = (dst[x - 1 - width] + dst[x + 1 - width] + dst[x - 1 + width] + dst[x + 1 + width]) * 0.25f; \n\t\t\t\t\t} \n\t\t\t\t\telse \n\t\t\t\t\t{ \n\t\t\t\t\t\tdst[x] = alpha[0] * dst[x - 1 - width] + alpha[1] * dst[x + 1 - width] + alpha[2] * dst[x - 1 + width] + alpha[3] * dst[x + 1 + width]; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "10a8252502fd5ee51be8a98fcb1a2b5bedad33e6545a7f965e06bf2ddd6ff7b1"}
{"code": "for(int j=1; j<jx-1; ++j){ \n            for(int i=1; i<ix-1; ++i){ \n                const int id = MAT(i,j,ix); \n                for(int n=0; n<4; n++){ \n                    u_[id*4+n] += dt * dxi \n                        * ( qx[id-1] * ( u[(id-1)*4+n] - u[id*4+n] ) \n                            + qx[id] * ( u[(id+1)*4+n] - u[id*4+n] ) ); \n                    u_[id*4+n] += dt * dyi \n                        * ( qy[id-ix] * ( u[(id-ix)*4+n] - u[id*4+n] ) \n                            + qy[id] * ( u[(id+ix)*4+n] - u[id*4+n] ) ); \n                } \n                const float ro_ = u_[id*4]; \n                const float vx_ = u_[id*4+1]/ro_; \n                const float vy_ = u_[id*4+2]/ro_; \n                const float v2 = vx_*vx_ + vy_*vy_; \n                const float e_ = u_[id*4+3];  \n \n                ro[id] = ro_; \n                pr[id] = (gamma - 1.0) * (e_ - 0.5*v2*ro_); \n                vx[id] = vx_; \n                vy[id] = vy_; \n            } \n        }", "pragma": "for ", "hash": "39332267b5fbca0674bd346a7bf2df01c834529a461ee67b6cbe6a70f56a2bee"}
{"code": "for (int i = 0; i < lena; ++i) { \n    for (int j = 0; j < lenb; ++j) { \n      data[j + lenb * i] *= alpha[i] * beta[j]; \n    } \n  }", "pragma": "parallel for ", "hash": "ade011baa74f19ecbeff0beb93b59f7e0242f7030934ecd9dd13f21341633675"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp teams distribute  \n \n    for (int j = 0; j < 10; ++j) \n      ; \n  }", "pragma": "for ", "hash": "4d88a345535b72418ae4d71ab95e43d0053856f2847cb5735aaee2a54ba49228"}
{"code": "for (int idx = 0; idx < divNum * loop; idx++) \n\t\t{ \n\t\t\tfilter_impl(idx); \n\t\t}", "pragma": "parallel for ", "hash": "7da6041201dbee9a577ebbf675b82dc4cbe7d3c44e3f8a2a3cd8380f594c5142"}
{"code": "for (i = j; i >= k; i--) \n    baz (i);", "pragma": "for ", "hash": "098c09d4594dede5f6201af2f3f04d1dee6b32ba5aa9c678ac1ff631afa2d04c"}
{"code": "for (i=0; i<N; i++){  \n    for (j=N-1; j>i; j--){ \n      a[i][j] += cos(b[i][j]); \n    }  \n  }", "pragma": "parallel for private( i j)", "hash": "b7c82abd188177ec517fc5a733a1e4859e22067c06a4e3ebc64c33383b8cccfd"}
{"code": "for (i=0; i < 100; ++i) \n    for (j=0; j < 100; ++j) \n      { \n#pragma omp ordered depend(sink:i-2)  \n \n\tbark(); \n      }", "pragma": "parallel for ", "hash": "f312e0709502bafa060bb9b792f59329e75259e353da413a683663e874407d6d"}
{"code": "for(int count = 0; count < imSize; count++) \n        { \n        int row = count/shrinkedSize; \n        int col = count%shrinkedSize; \n        float embedRowPos = (float)(windowSize-1)/(float)(shrinkedSize+1)*(float)(row+1); \n        float embedColPos = (float)(windowSize-1)/(float)(shrinkedSize+1)*(float)(col+1); \n         \n \n        int lowRow = max((int)floor(embedRowPos), 0); \n        int upRow = min(lowRow+1, windowSize-1); \n        int lowCol = max((int)floor(embedColPos), 0); \n        int upCol = min(lowCol+1, windowSize-1); \n         \n \n        zoomed(row, col) = (image[0](lowRow, lowCol) + image[0](lowRow, upCol) + image[0](upRow, lowCol) + image[0](upRow, upCol))/4; \n        }", "pragma": "parallel for ", "hash": "cb91499962609a2eb11d3f302f2edc3f9668355fdc7a762f93271117a01fbafd"}
{"code": "for (int i = 0; i < numVecs; ++i) { \n            int block = i / 32; \n            int lane = i % 32; \n \n            int word = lane / 2; \n            int subWord = lane % 2; \n \n            for (int j = 0; j < dims; ++j) { \n                auto v = \n                        data[block * bytesPerBlock + j * bytesPerDimBlock + \n                             word]; \n \n                v = (subWord == 0) ? v & 0xf : v >> 4; \n                out[i * dims + j] = v; \n            } \n        }", "pragma": "parallel for ", "hash": "5dd362701e6dbf9952949e69634c3c2f9e1945630573a50a98cb8b53af31250d"}
{"code": "for (uint16_t i = 0; i <= UINT8_MAX; i++) { \n        for (uint16_t j = 0; j <= UINT8_MAX; j++) { \n            for (uint16_t k = 0; k <= UINT8_MAX; k++) { \n                union encoding enc = { .enc = { i, j, k } }; \n                uint8_t dec[3] = {}; \n                size_t len = 0; \n                len = get(val, enc.idx) ? 2 : SIZE_MAX; \n                if (jose_b64_dec_buf(enc.enc, 3, dec, sizeof(dec)) != len) { \n                    fprintf(stderr, \"{%hu,%hu,%hu}\\\"%c%c%c\\\" != %zu\\n\", \n                            i, j, k, enc.enc[0], enc.enc[1], enc.enc[2], len); \n                    assert(false); \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "840b88651f49011f0af958df71c69fd67ae0ddcbc0afb091ae98ab848464b07f"}
{"code": "for(index i = 0; i < size*bs; i++) \n\t\ttv[i] = vec[i];", "pragma": "parallel for simd ", "hash": "e756fe8ea27475d87c2b6cdc866438c2f2c1d3264daf069aae4056859f792617"}
{"code": "for (int y = 0; y < mHeight; ++y) \n        { \n                for (int x = 0; x < mWidth - 1; ++x) \n                { \n                        float wCur = mWater->getAt(x,y); \n                        float wNei = mWater->getAt(x+1,y); \n                        float diff = (wNei + heightAt(x+1,y)) - (wCur + heightAt(x,y)); \n                        float dW = CLAMP(diff/2.0, -wCur/2.0, wNei/2.0); \n                         \n                         \n                        mWater->setAt(x,  y, wCur + dW); \n                        mWater->setAt(x+1,y, wNei - dW); \n                } \n        }", "pragma": "parallel for ", "hash": "b3b733b28ebf196c96662ff59969af8aed031b4a75420aaab58fd431a176152b"}
{"code": "for( int i = 0 ; i < num ; i++ ) \n    { \n        depth_code_vec[i] = KNNEncoder(depth_fea.row(i), tree_depth_L0, depth_len, depthK); \n        color_code_vec[i] = KNNEncoder(color_fea.row(i), tree_color_L0, color_len, colorK); \n    }", "pragma": "parallel for ", "hash": "b1a93a343a8ff44c42356adee968bf2557871d7c371ec65fb08840a6579aa7e0"}
{"code": "for (int position = 0; position < npositions; position++) \n    { \n        float3 coords = positions[position]; \n \n        { \n            coords = make_float3(coords.x / spacing.x, coords.y / spacing.y, coords.z / spacing.z);   \n \n \n            float3 coord_grid = coords; \n            float3 index = make_float3(floor(coord_grid.x), floor(coord_grid.y), floor(coord_grid.z)); \n \n            float result = 0.0f; \n \n            int MinX = tmax(0, (int)index.x - 1), MaxX = tmin((int)index.x + 2, dimensions.x - 1); \n            int MinY = tmax(0, (int)index.y - 1), MaxY = tmin((int)index.y + 2, dimensions.y - 1); \n            int MinZ = tmax(0, (int)index.z - 1), MaxZ = tmin((int)index.z + 2, dimensions.z - 1); \n \n            int nz = MaxZ - MinZ + 1; \n            int ny = MaxY - MinY + 1; \n            int nx = MaxX - MinX + 1; \n \n            float InterpX[16]; \n            for (int z = MinZ; z <= MaxZ; z++) \n            { \n                for (int y = MinY; y <= MaxY; y++) \n                { \n                    float2 Points[4]; \n                    if (nx == 1) \n                        InterpX[(z - MinZ) * ny + y - MinY] = values[(z * dimensions.y + y) * 1]; \n                    else \n                    { \n                        for (int x = MinX; x <= MaxX; x++) \n                            Points[x - MinX] = make_float2(x, values[(z * dimensions.y + y) * dimensions.x + x]); \n \n                        InterpX[(z - MinZ) * ny + y - MinY] = CubicInterpShort(Points, coords.x, nx); \n                    } \n                } \n            } \n \n            float InterpXY[4]; \n            for (int z = MinZ; z <= MaxZ; z++) \n            { \n                float2 Points[4]; \n                if (ny == 1) \n                    InterpXY[z - MinZ] = InterpX[(z - MinZ) * ny]; \n                else \n                { \n                    for (int y = MinY; y <= MaxY; y++) \n                        Points[y - MinY] = make_float2(y, InterpX[(z - MinZ) * ny + y - MinY]); \n \n                    InterpXY[z - MinZ] = CubicInterpShort(Points, coords.y, ny); \n                } \n            } \n \n            { \n                float2 Points[4]; \n                if (nz == 1) \n                    result = InterpXY[0]; \n                else \n                { \n                    for (int z = MinZ; z <= MaxZ; z++) \n                        Points[z - MinZ] = make_float2(z, InterpXY[z - MinZ]); \n \n                    result = CubicInterpShort(Points, coords.z, nz); \n                } \n            } \n \n            output[position] = result; \n        } \n    }", "pragma": "parallel for ", "hash": "eef8c96728f5036247e9c78b5387c8a90cff2450fbeac01af4ef335f66b2fee8"}
{"code": "for(int j = 3; j < roi_out->height - 3; j++) \n  { \n    float *buf = out + (size_t)4 * roi_out->width * j + 4 * 3; \n    const float *buf_in = input + (size_t)roi_in->width * (j + roi_out->y) + 3 + roi_out->x; \n    for(int i = 3; i < roi_out->width - 3; i++) \n    { \n      const int c = FC(j, i, filters); \n      dt_aligned_pixel_t color; \n      const float pc = buf_in[0]; \n       \n \n      if(c == 0 || c == 2) \n      { \n        color[c] = pc; \n         \n \n        const float pym = buf_in[-roi_in->width * 1]; \n        const float pym2 = buf_in[-roi_in->width * 2]; \n        const float pym3 = buf_in[-roi_in->width * 3]; \n        const float pyM = buf_in[+roi_in->width * 1]; \n        const float pyM2 = buf_in[+roi_in->width * 2]; \n        const float pyM3 = buf_in[+roi_in->width * 3]; \n        const float pxm = buf_in[-1]; \n        const float pxm2 = buf_in[-2]; \n        const float pxm3 = buf_in[-3]; \n        const float pxM = buf_in[+1]; \n        const float pxM2 = buf_in[+2]; \n        const float pxM3 = buf_in[+3]; \n \n        const float guessx = (pxm + pc + pxM) * 2.0f - pxM2 - pxm2; \n        const float diffx = (fabsf(pxm2 - pc) + fabsf(pxM2 - pc) + fabsf(pxm - pxM)) * 3.0f \n                            + (fabsf(pxM3 - pxM) + fabsf(pxm3 - pxm)) * 2.0f; \n        const float guessy = (pym + pc + pyM) * 2.0f - pyM2 - pym2; \n        const float diffy = (fabsf(pym2 - pc) + fabsf(pyM2 - pc) + fabsf(pym - pyM)) * 3.0f \n                            + (fabsf(pyM3 - pyM) + fabsf(pym3 - pym)) * 2.0f; \n        if(diffx > diffy) \n        { \n           \n \n          const float m = fminf(pym, pyM); \n          const float M = fmaxf(pym, pyM); \n          color[1] = fmaxf(fminf(guessy * .25f, M), m); \n        } \n        else \n        { \n          const float m = fminf(pxm, pxM); \n          const float M = fmaxf(pxm, pxM); \n          color[1] = fmaxf(fminf(guessx * .25f, M), m); \n        } \n      } \n      else \n        color[1] = pc; \n \n      color[3] = 0.0f; \n       \n \n       \n \n      memcpy(buf, color, sizeof(float) * 4); \n      buf += 4; \n      buf_in++; \n    } \n  }", "pragma": "parallel for ", "hash": "986d52083dc36aeb510907b5bcec8590bc667f8ff6537f8866962ac08d4e2b2e"}
{"code": "for(int i = 0; i < trisCams->size(); ++i) \n    { \n        std::vector<std::pair<float, int>> commonCameraIDs; \n \n         \n \n        auto cameras = (*trisCams)[i]; \n        for(int c = 0; c < cameras->size(); ++c) \n        { \n            int cameraID = (*cameras)[c]; \n             \n \n            Mesh::triangle_proj tProj = _mesh.getTriangleProjection(i, &mp, cameraID, mp.getWidth(cameraID), mp.getHeight(cameraID)); \n            if(!mp.isPixelInImage(Pixel(tProj.tp2ds[0]), 10, cameraID) \n                    || !mp.isPixelInImage(Pixel(tProj.tp2ds[1]), 10, cameraID) \n                    || !mp.isPixelInImage(Pixel(tProj.tp2ds[2]), 10, cameraID)) \n                continue; \n \n            const float area = _mesh.computeTriangleProjectionArea(tProj); \n            commonCameraIDs.emplace_back(area, cameraID); \n        } \n         \n \n        std::sort(commonCameraIDs.begin(), commonCameraIDs.end(), std::greater<std::pair<int, int>>()); \n \n         \n \n        Chart& chart = charts[i]; \n        for (int c = 0; c < commonCameraIDs.size(); ++c) \n        { \n           \n \n          if (c > 0 && commonCameraIDs[c].first < 0.5 * commonCameraIDs[0].first) \n            break; \n          chart.commonCameraIDs.emplace_back(commonCameraIDs[c].second); \n        } \n         \n \n        std::sort(chart.commonCameraIDs.begin(), chart.commonCameraIDs.end()); \n \n         \n \n        _triangleCameraIDs[i] = chart.commonCameraIDs; \n \n         \n \n        chart.triangleIDs.emplace_back(i);  \n \n    }", "pragma": "parallel for ", "hash": "50904168b3f8a886f9d846a96a523a08b987906e121870f3673cca8f26d5172c"}
{"code": "for (int i=0; i<N; i++) { \n \n     \n \n    for (int k=0; k<ndim; k++) { \n \n       \n \n       \n \n      if (star[i]->r[k] < simbox.min[k]) { \n \n         \n \n        if (simbox.boundary_lhs[k] == periodicBoundary) { \n          star[i]->r[k]  += simbox.size[k]; \n          star[i]->r0[k] += simbox.size[k]; \n        } \n \n         \n \n        if (simbox.boundary_lhs[k] == mirrorBoundary || simbox.boundary_lhs[k] == wallBoundary) { \n          star[i]->r[k]  = (FLOAT) 2.0*simbox.min[k] - star[i]->r[k]; \n          star[i]->r0[k] = (FLOAT) 2.0*simbox.min[k] - star[i]->r0[k]; \n          star[i]->v[k]  = -star[i]->v[k]; \n          star[i]->v0[k] = -star[i]->v0[k]; \n          star[i]->a[k]  = -star[i]->a[k]; \n          star[i]->a0[k] = -star[i]->a0[k]; \n        } \n \n      } \n \n       \n \n       \n \n      if (star[i]->r[k] > simbox.max[k]) { \n \n         \n \n        if (simbox.boundary_rhs[k] == periodicBoundary) { \n          star[i]->r[k]  -= simbox.size[k]; \n          star[i]->r0[k] -= simbox.size[k]; \n        } \n \n         \n \n        if (simbox.boundary_rhs[k] == mirrorBoundary || simbox.boundary_rhs[k] == wallBoundary) { \n          star[i]->r[k]  = (FLOAT) 2.0*simbox.max[k] - star[i]->r[k]; \n          star[i]->r0[k] = (FLOAT) 2.0*simbox.max[k] - star[i]->r0[k]; \n          star[i]->v[k]  = -star[i]->v[k]; \n          star[i]->v0[k] = -star[i]->v0[k]; \n          star[i]->a[k]  = -star[i]->a[k]; \n          star[i]->a0[k] = -star[i]->a0[k]; \n        } \n \n      } \n \n \n    } \n     \n \n \n  }", "pragma": "parallel for ", "hash": "45aba9007971494f682fa983f97c1073e451c31960293405ba1825913a84d49a"}
{"code": "for (int i=0; i < a.n; i++)\r \n      bl = bl && (a.v[i] == b.v[i]);", "pragma": "parallel ", "hash": "e8daae1e97b554cf4208849a5b72c35b479135a5f3f3a02c856bb851077272a1"}
{"code": "for (k_L = 0; k_L < ths->N_total; k_L++) \n    { \n      INT k[ths->d], k_temp, t; \n \n      k_temp = k_L; \n \n      for (t = ths->d - 1; t >= 0; t--) \n      { \n        k[t] = k_temp % ths->N[t] - ths->N[t]/2; \n        k_temp /= ths->N[t]; \n      } \n \n      for (j = 0; j < ths->M_total; j++) \n      { \n        R omega = K(0.0); \n        for (t = 0; t < ths->d; t++) \n          omega += k[t] * K2PI * ths->x[j * ths->d + t]; \n        f_hat[k_L] += f[j] * BASE(II * omega); \n      } \n    }", "pragma": "parallel for private( j k_l)", "hash": "86155065bd309e1fc5d74e6b41ac3fd875b77f953d808210d7bfdfc45d66a36d"}
{"code": "for (i = 0; i < N; ++i) { \n            tmp += std::abs(beta(i)); \n        }", "pragma": "parallel for reduction(+:tmp) ", "hash": "a3696ac4e21c871eb381ced0410d1360d90df20dc70ce15b9c37aef35d77348e"}
{"code": "for (int i = 0 ; i < NumProcs () ;i++) {\r \n    std::vector <Transition>::reverse_iterator iter =\r \n      _tlist[i]->_tlist.rbegin();\r \n    std::vector <Transition>::reverse_iterator iter_end;\r \n    CB c(i,0);\r \n\r \n    iter_end = _tlist[i]->_tlist.rend();\r \n    int j = (int)_tlist[i]->_tlist.size()-1;\r \n    for (; iter != iter_end; iter++) {\r \n      c._index = j;\r \n\r \n      if( !itree->is_matched[i][j] ) {\r \n\tstd::vector<int> &ancestor_list(GetTransition(c)->get_ancestors());\r \n\tif ((iter->GetEnvelope ()->func_id != WAITANY &&\r \n\t     iter->GetEnvelope ()->func_id != TESTANY) &&\r \n\t    AllAncestorsMatched (c,ancestor_list)) {\r \n\t  l[i].push_back (j);\r \n\t} else if ((iter->GetEnvelope()->func_id == WAITANY ||\r \n\t\t    iter->GetEnvelope()->func_id == TESTANY) &&\r \n\t\t   AnyAncestorMatched (c,ancestor_list)) {\r \n\t  l[i].push_back (j);\r \n\r \n\t}\r \n      }\r \n      j--;\r \n      if (j <= itree->last_matched[i])\r \n\tbreak;\r \n            \r \n    }\r \n  }", "pragma": "parallel ", "hash": "9a16c97433ff4ca5a906bf6023a4fdb0b65f84f4887252c7eb6e7c868c478036"}
{"code": "for (int y = info.offy; y < info.offy + info.height; y++)\r \n\t{\r \n\t\tint offsetBuf = (y-info.offy)*info.width*4;\r \n\t\tfor (int x = info.offx; x < info.offx + info.width; x++)\r \n\t\t{\r \n\t\t\tint offset= y * mipMapSize[0].width() + x;\r \n\t\t\tif (f)\r \n\t\t\t{\r \n\t\t\t\t \n \n\t\t\t\tint value = getLightVectImagePixel(offset, x, y);\r \n\t\t\t\tmemcpy(&buffer[offsetBuf], &value, 4*sizeof(unsigned char));\r \n\t\t\t}\r \n\t\t\telse\r \n\t\t\t{\r \n\t\t\t\tfor(int i = 0; i < 3; i++)\r \n\t\t\t\t\tbuffer[offsetBuf + i] = detailsBuffer[offset*4 + i];\r \n\t\t\t\tbuffer[offsetBuf + 3] = 255;\r \n\t\t\t}\r \n\t\t\toffsetBuf += 4;\r \n\t\t}\r \n\t}", "pragma": "parallel for ", "hash": "72e836d7650748f844b5ebfef35ae565339a7d46549a00f266ccc68c539d499e"}
{"code": "for (int ic = 0; ic < (int)vconstraints.size(); ic++) { \n        if (vconstraints[ic]->IsActive()) { \n            mx(vconstraints[ic]->GetOffset() + n_q) = -vconstraints[ic]->Get_l_i(); \n        } \n    }", "pragma": "parallel for ", "hash": "655c6064cb6d517135a6e334c59fc6bdddc89a45e02b1d792500071c6e661ec0"}
{"code": "for(long k=0;k<nz;k++)\tfor(long i=0;i<nx;i++) \n\t\t\t\tb.a[i+nx*(j+ny*k)] = (v1 + (v2-v1)*(a[i+nx*(j+ny*k)]-m1)/(m2-m1))*e;", "pragma": "parallel for ", "hash": "b511a517ab89624ddc3778a6453eeddeae57c2e3b7fa0aa50c9d0ca9cc96f7b3"}
{"code": "for (ii = 0; ii < inum; ii ++) { \n    double fqi,fqij,fqji,fqjj,delr1[3]; \n    double sr1,sr2,sr3; \n    int mr1,mr2,mr3; \n \n    const int i = ilist[ii]; \n    const tagint itag = tag[i]; \n    int nj = 0; \n \n    if (mask[i] & groupbit) { \n      fqi = fqij = fqji = fqjj = 0.0;  \n \n      int itype = map[type[i]]; \n      const double xtmp = x[i][0]; \n      const double ytmp = x[i][1]; \n      const double ztmp = x[i][2]; \n      const double iq = q[i]; \n      const int iparam_i = elem3param[itype][itype][itype]; \n \n       \n \n \n      fqi = qfo_self(&params[iparam_i],iq,potal); \n \n       \n \n \n      const int * const jlist = firstneigh[i]; \n      const int jnum = numneigh[i]; \n \n      for (int jj = 0; jj < jnum; jj++) { \n        const int j = jlist[jj] & NEIGHMASK; \n        const tagint jtag = tag[j]; \n \n        if (itag > jtag) { \n          if ((itag+jtag) % 2 == 0) continue; \n        } else if (itag < jtag) { \n          if ((itag+jtag) % 2 == 1) continue; \n        } else { \n          if (x[j][2] < ytmp) continue; \n          if (x[j][2] == ztmp && x[j][1] < ytmp) continue; \n          if (x[j][2] == ztmp && x[j][1] == ytmp && x[j][0] < xtmp) continue; \n        } \n \n        const int jtype = map[type[j]]; \n        double jq = q[j]; \n \n        delr1[0] = x[j][0] - xtmp; \n        delr1[1] = x[j][1] - ytmp; \n        delr1[2] = x[j][2] - ztmp; \n        double rsq1 = dot3(delr1,delr1); \n \n        const int iparam_ij = elem3param[itype][jtype][jtype]; \n \n         \n \n \n        if (rsq1 > params[iparam_ij].lcutsq) continue; \n \n        const int inty = intype[itype][jtype]; \n \n         \n \n \n        tri_point(rsq1,mr1,mr2,mr3,sr1,sr2,sr3,itype); \n \n         \n \n \n        qfo_direct(inty,mr1,mr2,mr3,rsq1,sr1,sr2,sr3,fac11e,fqij); \n \n         \n \n \n        qfo_field(&params[iparam_ij],rsq1,iq,jq,fqji,fqjj); \n        fqi   += jq * fqij + fqji; \n#pragma omp atomic \n        qf[j] += (iq * fqij + fqjj); \n      } \n \n         \n \n \n      for (int jj = 0; jj < jnum; jj++) { \n        const int j = jlist[jj] & NEIGHMASK; \n        const int jtype = map[type[j]]; \n        const double jq = q[j]; \n \n        delr1[0] = x[j][0] - xtmp; \n        delr1[1] = x[j][1] - ytmp; \n        delr1[2] = x[j][2] - ztmp; \n        double rsq1 = dot3(delr1,delr1); \n \n        const int iparam_ij = elem3param[itype][jtype][jtype]; \n \n        if (rsq1 > params[iparam_ij].cutsq) continue; \n        nj ++; \n \n         \n \n \n        qfo_short(&params[iparam_ij],i,nj,rsq1,iq,jq,fqij,fqjj); \n        fqi += fqij; \n#pragma omp atomic \n        qf[j] += fqjj; \n      } \n \n#pragma omp atomic \n      qf[i] += fqi; \n    } \n  }", "pragma": "parallel for private(ii)", "hash": "2188731d02cb636b6732a11d667af2ac26598e7d67f933fed09367405423d962"}
{"code": "for (int i = 0; i < 1024; i++) \n    { \n      { r += a[i] + x + 12; if (i == 1023) x = 29; } \n      #pragma omp scan inclusive(r) \n      b[i] = r; \n    }", "pragma": "parallel for reduction( +:r inscan) private(x x)", "hash": "2589a417eec9c1867870efbd58a4892feffd329798d4521460f2c9970b228e22"}
{"code": "for (y=start; y <= stop; y++) \n  { \n    const int \n      id = GetOpenMPThreadId(); \n \n    double \n      fill_opacity, \n      stroke_opacity; \n \n    PixelPacket \n      fill_color, \n      stroke_color; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    ssize_t \n      start, \n      stop; \n \n    if (status == MagickFalse) \n      continue; \n    start=(ssize_t) ceil(bounds.x1-0.5); \n    stop=(ssize_t) floor(bounds.x2+0.5); \n    q=GetCacheViewAuthenticPixels(image_view,start,y,(size_t) (stop-start+1),1, \n      exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=start; x <= stop; x++) \n    { \n       \n \n      fill_opacity=GetOpacityPixel(polygon_info[id],mid,fill, \n        draw_info->fill_rule,x,y,&stroke_opacity); \n      if (draw_info->stroke_antialias == MagickFalse) \n        { \n          fill_opacity=fill_opacity > 0.25 ? 1.0 : 0.0; \n          stroke_opacity=stroke_opacity > 0.25 ? 1.0 : 0.0; \n        } \n      (void) GetFillColor(draw_info,x,y,&fill_color); \n      fill_opacity=(double) (QuantumRange-fill_opacity*(QuantumRange- \n        fill_color.opacity)); \n      MagickCompositeOver(&fill_color,(MagickRealType) fill_opacity,q, \n        (MagickRealType) q->opacity,q); \n      (void) GetStrokeColor(draw_info,x,y,&stroke_color); \n      stroke_opacity=(double) (QuantumRange-stroke_opacity*(QuantumRange- \n        stroke_color.opacity)); \n      MagickCompositeOver(&stroke_color,(MagickRealType) stroke_opacity,q, \n        (MagickRealType) q->opacity,q); \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n  }", "pragma": "parallel for ", "hash": "fd222200d6b83e042a1cbaa07ea586b37343352e60a0ddce02762f27a5efc976"}
{"code": "for (int j=0; j<N; j++) { \n                        inpoly[j]+=pnpoly(polypoints.size(), &px[0], &py[0], testpoints[j].x, testpoints[j].y); \n                }", "pragma": "parallel for ", "hash": "1673822b2e5b6a7e07ec4fad42e8c0a572bd0594984c9fe8deb216882f1701f3"}
{"code": "for (f = 0; f < effp->flows; ++f) { \n      size_t idonec = idone / effp->flows; \n      size_t odonec = obeg / effp->flows; \n      int eff_status_c = effp->handler.flow(&chain->effects[n][f], \n          effp1->obuf + f*flow_offs + effp1->obeg/effp->flows, \n          obuf + f*flow_offs + effp->oend/effp->flows, \n          &idonec, &odonec); \n      idone_min = min(idonec, idone_min); idone_max = max(idonec, idone_max); \n      odone_min = min(odonec, odone_min); odone_max = max(odonec, odone_max); \n \n      if (eff_status_c != SOX_SUCCESS) \n        effstatus = SOX_EOF; \n    }", "pragma": "parallel for private(idone_max idone_max idone_min idone_min odone_max odone_max odone_min odone_min)", "hash": "f9716579ce86fc0acf21a4870f0d8ef4366413099e1a991f7870a1b85dc7150f"}
{"code": "for (size_t i = 0; i < rv_partition.size(); i++) \n            { \n                box rv = rv_partition.at(i); \n                 \n \n                 \n \n                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"====================\"; \n                capd::interval p_box(1); \n                if (!dd.empty()) \n                { \n                    p_box *= measure::p_dd_measure(dd); \n                    CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"dd_box: \" << dd; \n                } \n                if (!rv.empty()) \n                { \n                    p_box *= measure::p_measure(rv, global_config.precision_prob); \n                    CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"rv_box: \" << rv; \n                } \n                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"p_box: \" << p_box; \n                 \n \n                std::vector<box> boxes{dd, rv}; \n                 \n \n                int undet_counter = 0; \n                 \n \n                int unsat_counter = 0; \n                 \n \n                bool sat_flag = false; \n                 \n \n                 \n \n                for (std::vector<pdrh::mode *> path : paths) { \n                    std::string solver_opt; \n                    std::stringstream p_stream; \n                    for (pdrh::mode *m : path) { \n                        p_stream << m->id << \" \"; \n                    } \n                     \n \n                    CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"Path: \" << p_stream.str().substr(0, \n                                                                                                           p_stream.str().find_last_of( \n                                                                                                                   \" \")); \n                    std::stringstream s; \n                     \n \n                    #pragma omp critical \n                    { \n                        solver_opt = global_config.solver_opt; \n                        s << solver_opt << \" --precision \" << \n                          measure::volume(rv).leftBound() * global_config.solver_precision_ratio; \n                        global_config.solver_opt = s.str(); \n                    } \n                    int res = decision_procedure::evaluate(path, boxes, global_config.solver_bin, s.str()); \n                     \n \n                    #pragma omp critical \n                    { \n                        global_config.solver_opt = solver_opt; \n                        switch (res) \n                        { \n                            case decision_procedure::SAT: \n                                if (p_box.leftBound() > 0) \n                                { \n                                    probability = capd::interval(probability.leftBound() + p_box.leftBound(), \n                                                                 probability.rightBound()); \n                                } \n                                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"SAT\"; \n                                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"P = \" << probability; \n                                 \n \n                                sat_flag = true; \n                                break; \n \n                            case decision_procedure::UNSAT: \n                                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"UNSAT\"; \n                                unsat_counter++; \n                                break; \n                            case decision_procedure::UNDET: \n                                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"UNDET\"; \n                                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"P = \" << probability; \n                                undet_counter++; \n                                break; \n                            case decision_procedure::ERROR: \n                                CLOG(ERROR, \"algorithm\") << \"Error occurred while calling the solver\"; \n                                exit(EXIT_FAILURE); \n \n                            default: \n                                break; \n                        } \n                    } \n                     \n \n                    if (sat_flag) break; \n                } \n                #pragma omp critical \n                { \n                     \n \n                    if (!sat_flag) \n                    { \n                         \n \n                        if (undet_counter > 0) \n                        { \n                            CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"Bisect \" << rv; \n                            std::vector<box> rv_bisect = box_factory::bisect(rv); \n                            rv_stack.insert(rv_stack.end(), rv_bisect.begin(), rv_bisect.end()); \n                        } \n                             \n \n                        else if (unsat_counter == paths.size()) \n                        { \n                            if (p_box.rightBound() > 0) \n                            { \n                                probability = capd::interval(probability.leftBound(), \n                                                             probability.rightBound() - p_box.leftBound()); \n                            } \n                            CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"P = \" << probability; \n                        } \n                    } \n                }; \n \n            }", "pragma": "parallel for ", "hash": "84410ac256b0b9de1b5bcd93e7fe8bb1ed13a85e728725ebed460d6cf8dea311"}
{"code": "for (i=0; i<nrows; i++) { \n          maxtf = fabs(rowval[rowptr[i]]); \n          for (j=rowptr[i]; j<rowptr[i+1]; j++)  \n            maxtf = (maxtf < fabs(rowval[j]) ? fabs(rowval[j]) : maxtf); \n   \n          for (j=rowptr[i]; j<rowptr[i+1]; j++) \n            rowval[j] = .5 + .5*rowval[j]/maxtf; \n        }", "pragma": "for private( j maxtf)", "hash": "20ad0e1ffd90deb81890022028bbacb9ff6d4b08e4fac809d1344ce073ccd6fb"}
{"code": "for (jj = 0; jj < nn; jj++) { \n        ii = ilist[jj]; \n        if (atom->mask[ii] & groupbit) { \n          x[ii] += alpha * d[ii]; \n          r[ii] -= alpha * q[ii]; \n\t \n           \n \n          p[ii] = r[ii] * Hdia_inv[ii]; \n          tmp1 += r[ii] * p[ii]; \n        } \n      }", "pragma": "for reduction(+:tmp1) private(ii)", "hash": "e1ffcb8fae041e455abb3bce88c18c5106705ad3e798c9c24b1eb0a6068eb9e7"}
{"code": "for(int i = 0; i < nY; i++) { \n            for(int j = 0; j < nX; j++) { \n                output[i][j] = values[i][j]; \n            } \n        }", "pragma": "parallel for ", "hash": "7f091ce791266e6affb2fd82f5333ec6b11730b879899643c9cc1e034f502cd5"}
{"code": "for( i=0; i<CYCLE; i++ ) {\r \n\t\tsource_count( self->source1 );\r \n\t\tsource_count( self->source2 );\r \n\t\tif( i % 7  == 0 )\r \n\t\t\tsignal_process_signals();\r \n\t\t}", "pragma": "parallel for private(i)", "hash": "1dcbb6bfbef83d5d7d769cf6d301ef23bc5135f5eaf5423ecd125f5f34edc610"}
{"code": "for (ix = 0; ix < nxb; ix++) { \n\tfor (iz=0; iz < nzb; iz++) { \n\t  i = iz+ix*nzb;   \n \n\t  j = iz+ix*nz2;  \n \n\t  c = sf_cmplx(0.,0.);  \n \n\t  for (im = 0; im < m2; im++) { \n\t    c += conjf(lt[im][i])*wave[im][j]; \n\t    c = sf_cadd(c,sf_cmul(conjf(lt[im][i]), wave[im][j])); \n\t  } \n\t  curr[j] = c; \n\t} \n      }", "pragma": "parallel for private(c i im ix iz j)", "hash": "5e49c11dca04d5d7d284c175eb14c4e53d98291adf2e259b88079e70f8bcd0ec"}
{"code": "for (i = 0; i<length; i++) \n    { \n        if(array[i] == 3) \n            privateCount++; \n    }", "pragma": "parallel for reduction(+:", "hash": "22d980e03527780ad645663e91172197b3f5c9c0082c0e9b6bf8fad1f3f514d3"}
{"code": "for(j = 0; j < Nparticles; j++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\t\ti = findIndex(CDF, Nparticles, u[j]);\r \n\t\t\tif(i == -1)\r \n\t\t\t\ti = Nparticles-1;\r \n\t\t\txj[j] = arrayX[i];\r \n\t\t\tyj[j] = arrayY[i];\r \n\t\t\t\r \n\t\t} ; }", "pragma": "parallel for private( i j)", "hash": "584a37caee80ebf8a4b15ffc56a88fa4e847b24ab630e948bb1ad537caed8283"}
{"code": "for (i = 1; i < N; i++) { \n      if (xd[i] < tmin) tmin = xd[i]; \n    }", "pragma": "for ", "hash": "8ef45c36d67dff77135cd1234cffd55040de3801075dd445cc185b1ff9a663a9"}
{"code": "for(z=1;z<splineControlPoint->nz-1;z++){ \n        for(y=1;y<splineControlPoint->ny-1;y++){ \n            derivativeValuesPtr = &derivativeValues[18*((z*splineControlPoint->ny+y)*splineControlPoint->nx+1)]; \n            for(x=1;x<splineControlPoint->nx-1;x++){ \n \n                get_GridValuesApprox<SplineTYPE>(x-1, \n                                                 y-1, \n                                                 z-1, \n                                                 splineControlPoint, \n                                                 controlPointPtrX, \n                                                 controlPointPtrY, \n                                                 controlPointPtrZ, \n                                                 xControlPointCoordinates, \n                                                 yControlPointCoordinates, \n                                                 zControlPointCoordinates, \n                                                 false); \n \n                XX_x=0.0, YY_x=0.0, ZZ_x=0.0; \n                XY_x=0.0, YZ_x=0.0, XZ_x=0.0; \n                XX_y=0.0, YY_y=0.0, ZZ_y=0.0; \n                XY_y=0.0, YZ_y=0.0, XZ_y=0.0; \n                XX_z=0.0, YY_z=0.0, ZZ_z=0.0; \n                XY_z=0.0, YZ_z=0.0, XZ_z=0.0; \n \n                for(a=0; a<27; a++){ \n                    XX_x += basisXX[a]*xControlPointCoordinates[a]; \n                    YY_x += basisYY[a]*xControlPointCoordinates[a]; \n                    ZZ_x += basisZZ[a]*xControlPointCoordinates[a]; \n                    XY_x += basisXY[a]*xControlPointCoordinates[a]; \n                    YZ_x += basisYZ[a]*xControlPointCoordinates[a]; \n                    XZ_x += basisXZ[a]*xControlPointCoordinates[a]; \n \n                    XX_y += basisXX[a]*yControlPointCoordinates[a]; \n                    YY_y += basisYY[a]*yControlPointCoordinates[a]; \n                    ZZ_y += basisZZ[a]*yControlPointCoordinates[a]; \n                    XY_y += basisXY[a]*yControlPointCoordinates[a]; \n                    YZ_y += basisYZ[a]*yControlPointCoordinates[a]; \n                    XZ_y += basisXZ[a]*yControlPointCoordinates[a]; \n \n                    XX_z += basisXX[a]*zControlPointCoordinates[a]; \n                    YY_z += basisYY[a]*zControlPointCoordinates[a]; \n                    ZZ_z += basisZZ[a]*zControlPointCoordinates[a]; \n                    XY_z += basisXY[a]*zControlPointCoordinates[a]; \n                    YZ_z += basisYZ[a]*zControlPointCoordinates[a]; \n                    XZ_z += basisXZ[a]*zControlPointCoordinates[a]; \n                } \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*XX_x); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*XX_y); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*XX_z); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*YY_x); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*YY_y); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*YY_z); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*ZZ_x); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*ZZ_y); \n                *derivativeValuesPtr++ = (SplineTYPE)(2.0*ZZ_z); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*XY_x); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*XY_y); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*XY_z); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*YZ_x); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*YZ_y); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*YZ_z); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*XZ_x); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*XZ_y); \n                *derivativeValuesPtr++ = (SplineTYPE)(4.0*XZ_z); \n            } \n        } \n    }", "pragma": "parallel for private(                                   a derivativevaluesptr x xcontrolpointcoordinates xx_x xx_y xx_z xy_x xy_y xy_z xz_x xz_y xz_z y ycontrolpointcoordinates yy_x yy_y yy_z yz_x yz_y yz_z z zcontrolpointcoordinates zz_x zz_y zz_z)", "hash": "ecec3b9d26e5b0cf163b368e4633f64f19192315dc401378367446d619720d79"}
{"code": "for (int y = info.offy; y < info.offy + info.height; y++)\r \n\t{\r \n\t\tint offset = y * width + info.offx;\r \n\t\tint offset2 = (y - info.offy)*info.width;\r \n\t\tfor (int x = info.offx; x < info.offx + info.width; x++)\r \n\t\t{\r \n\t\t\tmemcpy(&redC[offset2], &redPtr[offset], sizeof(PTMCoefficient));\r \n\t\t\tmemcpy(&greenC[offset2], &greenPtr[offset], sizeof(PTMCoefficient));\r \n\t\t\tmemcpy(&blueC[offset2], &bluePtr[offset], sizeof(PTMCoefficient));\r \n\t\t\toffset++;\r \n\t\t\toffset2++;\r \n\t\t}\r \n\t}", "pragma": "parallel for ", "hash": "0e0c88dc9ab12ab3b20df4916fb3dd3556dbfe9fec245e4e943cc5e9d6c8154a"}
{"code": "for (i = 0; i < min_dim; i++) { \n      for (j = 0; j < min_dim; j++) { \n         if (i == j) { \n            (*S)[i][j] = static_cast<T>(svd.singularValues()(i)); \n         } \n         else { \n            (*S)[i][j] = 0; \n         } \n      } \n   }", "pragma": "parallel for private( i j)", "hash": "1135c008cebc6f0d1b22509f3378393b11e0c3979736a79aa03b889e72ba4790"}
{"code": "for( i = 0 ; i < LCU ; i++ ) { \n      colormatrix_equiv_d2f( H[i+idx].D[0] , F -> S[i].D[0] ) ; \n      colormatrix_equiv_d2f( H[i+idx].D[1] , F -> S[i].D[1] ) ; \n      colormatrix_equiv_d2f( H[i+idx].D[2] , F -> S[i].D[2] ) ; \n      colormatrix_equiv_d2f( H[i+idx].D[3] , F -> S[i].D[3] ) ; \n    }", "pragma": "for private(i)", "hash": "fcf768318e1ea074f6fb12af3f5384322c4a9207c641f1837950275441fed4a9"}
{"code": "for(idx j = 0; j < total_points; ++j) \n\t\t\t\tmat[m->CellByLocalID(points_node[j])] = points_cluster[j];", "pragma": "parallel for ", "hash": "bf3731f260b6eec5d5b5de650550ff36cf811bd946d74bdc0249c3bf1597b92a"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\tif( (*this)[i] < (*right)[i]) (*res)[i] = (*right)[i]; else (*res)[i] = (*this)[i];", "pragma": "for ", "hash": "1665f7fb80a61d4924a221f5a59f3d0d256d9775909bb59640a09ebd12e8da71"}
{"code": "for (y=0; y<yres; y++) \n\t\t\t{ \n\t\t\t\tint xres1=y*xres*3; \n\t\t\t\tint xres2=xres1+2; \n\t\t\t\tint x; \n\t\t\t\tfor (x=0; x<xres; x++) \n\t\t\t\t{ \n\t\t\t\t\tint x2=x*3; \n\t\t\t\t\tmemcpy(output+x2+xres1,output+x*4+y*xres*4,3); \n\t\t\t\t\tSWAP(output[x2+xres1],output[x2+xres2]); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "dabbe2fcff377e11e74e4eb85e93dbf1729fa83eea7353118cb7523fc9ff29e6"}
{"code": "for (int k = 0; k < record_cnt; k++)\r \n\t{\r \n\t\tint prediction;\r \n\t\t\t \n \n\t\t\tprediction = cnn.predict_class(test_images[k].data());\r \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t \n \n\r \n\t\t\tif (prediction == test_labels[k]) correct_predictions++;\r \n\r \n\t\t\tif (k % 1000 == 0) progress.draw_progress(k);\r \n\t\t\r \n\t}", "pragma": "for reduction(+:correct_predictions) ", "hash": "d1515af3fcfeb0994d1a65d80e12c7d96df2a0b2a018e2f1f50f73d95ab16e87"}
{"code": "for (index i = 0; i < nodes.size(); ++i) { \n      std::vector<std::pair<node, node>> missingAtU = findFromNode(nodes[i], k); \n       \n \n      missingAtU.erase(std::remove_if(std::begin(missingAtU), std::end(missingAtU), \n          [&](std::pair<node, node> p) { return p.first >= p.second; }), std::end(missingAtU)); \n      missingLinksPrivate.insert(missingLinksPrivate.end(), missingAtU.begin(), missingAtU.end()); \n    }", "pragma": "for ", "hash": "5ba7c3a9c8ba218d0ac14242c9daae7c2e747bd2185150c83b6f06703bdbee05"}
{"code": "for(long i=1;i<n;i++)\r \n\t\t{\r \n\t\t\tmglPoint p(x->v(i,mx), y->v(i-1,my), zVal);\r \n\t\t\tdouble c = sh ? gr->NextColor(pal,i):gr->CDef;\r \n\t\t\tgr->AddPntQ(kq+2*i,p,c);\r \n\t\t\tp.y = y->v(i,my);\tgr->AddPntQ(kq+2*i+1,p,c);\r \n\t\t}", "pragma": "parallel ", "hash": "79ee5ca37d5cf9ef1948c639d879392d441643816d3faafe6583a59978c197ef"}
{"code": "for(size_t i=0;i<grid.size();i++) { \n     \n \n    double phi=atan2(grid[i].r.y,grid[i].r.x); \n    double cth=grid[i].r.z; \n \n     \n \n    for(int l=0;l<=lmax;l++) \n      for(int m=-l;m<=l;m++) \n\tYlm[i][lmind(l,m)]=solid_harmonics(l,m,cth,phi); \n  }", "pragma": "parallel for ", "hash": "b9cbf344bf15bb8baf0ddcfda4d9769f27908bd8743614730c3449873856dd66"}
{"code": "for (i = 0; i < params.size(); i++) \n    { \n        flag = paramCombi.getFlag(params.at(i)); \n \n        calculateIntrinsic(boardSize, imageSize, cameraMatTemp.at(i), distCoeffsTemp.at(i), imagePoints, rVecsTemp, \n                                                        tVecsTemp, reprojErrs, totalAvgErr, flag); \n \n        rVecsTemp.clear(); \n        tVecsTemp.clear(); \n \n        errors.at(i) = totalAvgErr; \n        totalAvgErr = 0; \n \n        #pragma omp critical \n        { \n            caliCount++; \n            cout << \"[findBestCalibParams] progress: \" << ((int)(((double)caliCount / params.size()) * 100)) << \"%\" << endl; \n        } \n    }", "pragma": "for ", "hash": "32d832039e9d1dcf8847a64b27c5e054736ed113a1383e381752bd2cffff58e3"}
{"code": "for (int ui = 0; ui < NewNIDV.Len(); ui++) { \n      int NewNID = NewNIDV[ui]; \n      if (NewNID < 0) { continue; } \n      F[NewNID] = NewF[ui]; \n    }", "pragma": "parallel for ", "hash": "072f770d016ea8950f96f07709d21a2991b0c88bbe0008092df12c6494c1577c"}
{"code": "for (size_t dx = 0; dx < spacex - 1; dx++){ \n        for (size_t dy = 0; dy < spacey; dy++){ \n            for (size_t dz = 0; dz < spacez - 1; dz++){ \n                EM.Hy(dx,dy,dz) = lass.HyH(dx,dy,dz) * EM.Hy(dx,dy,dz) \n                                - lass.HyE(dx,dy,dz) * ((EM.Ex(dx,dy,dz+1) \n                                                      - EM.Ex(dx,dy,dz)) \n                                                      - (EM.Ez(dx+1,dy,dz) \n                                                      - EM.Ez(dx,dy,dz))); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "08c758bc9500711ba1b77e0619c2f03a3d8bc7833d18f8a8babfc5b523dfe9bc"}
{"code": "for (i=0; i<pop->orig_size; i++) \n        { \n        adult = pop->adapt(pop, pop->entity_iarray[i]); \n        pop->entity_iarray[i]->fitness=adult->fitness; \n#pragma omp master \n        ga_entity_dereference(pop, adult); \n        }", "pragma": "parallel for private(adult i)", "hash": "c88bf5d337f3121344e7d25c815103704c5e5c28e13a11ee4cfa28462ad0082b"}
{"code": "for (int j = 0; j < nblock; ++j)  \n    { \n        for (int i = 0; i < nblock; ++i)  \n        { \n            int cpd_ij = cpd_new[j*nblock+i]; \n            for (int k = 0; k < nblock; ++k)  \n            { \n                 \n \n                int cpd_ik = row_T[i*nblock+k]; \n                 \n \n                int cpd_kj = col[j*nblock+k]; \n                if (cpd_ik + cpd_kj < cpd_ij)  \n                { \n                    cpd_ij = cpd_ik+cpd_kj; \n                    done = 0; \n                } \n            } \n            cpd_new[j*nblock+i] = cpd_ij; \n        } \n    }", "pragma": "parallel for reduction(&& : done) ", "hash": "c24fce584d79d431bf7d1a5d076a277f928bb8a37f44c3c3beb93d941a0769c2"}
{"code": "for(std::size_t i = 0; i < this->nChannels; i++){ \n      this->channelIndices[i] = i; \n      this->inverseChannelIndices[i] = i; \n      this->modChannelIndices[i] = i; \n      this->inverseModChannelIndices[i] = i; \n    }", "pragma": "for ", "hash": "52b65516d226850329c980627a480d4ae923cbe03b850ffb5012f030707e9f17"}
{"code": "for (size_t i = 0; i < chains.size(); i++) { \n            lambda(&chains[i]); \n        }", "pragma": "parallel for ", "hash": "e866eea68e7f6e9baaa485869e5b58f428737c662cf67c110ed22f5a2623c604"}
{"code": "for (int i=0;i<fit->ndet;i++) \n    for (int j=0;j<fit->ndata;j++) \n      fit->data[i][j] /=fit->median_scats[i];", "pragma": "parallel for ", "hash": "4b67cc1b095bd1340b9a39d9a59dd34b9adc70e35e140ed3a89c5b57cd83e4de"}
{"code": "for (int i = 0; i < 10; i++) { \n\t\t\t\tcapture_exceptions { \n\t\t\t\t\tif (i % 2 == 0) \n\t\t\t\t\t\tthrowf(Value, \"oops 8 in loop %d\", i); \n\t\t\t\t\tprintf(\"loop %d was OK\\n\", i); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "0218037404f79f6235ae23ec5785031711087ddc57cec1a27a071411eeab3ac8"}
{"code": "for(int n = 0; n < N_t; n++) {                                \n \n        int last_block = 0; \n        libxsmm_meltw_unary_param copy_params_1;            \n \n        libxsmm_meltw_unary_param copy_params_2; \n        libxsmm_meltw_unary_param trans_param_short; \n        libxsmm_meltw_unary_param trans_param_edge; \n \n        for(int wb = 0; wb < W_t - XS_TILE_FORWARD + 1; wb += XS_TILE_FORWARD) {     \n \n \n            copy_params_1.out.primary = &Y_a[n*F_t*W_t + wb];                  \n \n            copy_kernel_1(&copy_params_1); \n \n             \n \n            trans_param_short.in.primary  = &input_a[n*C_t*Win_t + 0*Win_t + wb]; \n            trans_param_short.out.primary = &input_a_shortvnni[n*C_t*short_width]; \n            trans_shortvnni_kernel( &trans_param_short ); \n \n             \n \n            bmmshortkernel(&input_a_shortvnni[n*C_t*short_width], &flip_weight_a[0], &Y_a[n*F_t*W_t + 0*W_t + wb], &l_br); \n \n            last_block = wb;         \n \n        } \n \n        if (W_t % XS_TILE_FORWARD != 0){                        \n \n \n            copy_params_2.out.primary = &Y_a[n*F_t*W_t + last_block + XS_TILE_FORWARD];                  \n \n            copy_kernel_2(&copy_params_2); \n \n             \n \n            trans_param_edge.in.primary  = &input_a[n*C_t*Win_t + 0*Win_t + (last_block + XS_TILE_FORWARD)]; \n            trans_param_edge.out.primary = &input_a_edgevnni[n*C_t*edge_width]; \n            trans_edgevnni_kernel( &trans_param_edge ); \n \n             \n \n            bmmedgekernel2(&input_a_edgevnni[n*C_t*edge_width], &flip_weight_a[0], &Y_a[n*F_t*W_t + 0*W_t + (last_block + XS_TILE_FORWARD)], &l_br); \n        } \n    }", "pragma": "parallel for ", "hash": "e6186ad33112449b2d43f0c6f81a5fbe1695429861b622cfd7dbb83d2e39eaea"}
{"code": "for (int val = 0; val < (currentLevelProperties.widthCheckerboardLevel_*currentLevelProperties.heightLevel_); val++)\r \n\tfor (unsigned int val = 0; val < (currentLevelProperties.widthCheckerboardLevel_*currentLevelProperties.heightLevel_); val++)\r \n \n\t{\r \n\t\tconst unsigned int yVal = val / currentLevelProperties.widthCheckerboardLevel_;\r \n\t\tconst unsigned int xVal = val % currentLevelProperties.widthCheckerboardLevel_;\r \n\r \n\t\tcopyPrevLevelToNextLevelBPCheckerboardStereoPixel<T, DISP_VALS>(xVal, yVal,\r \n\t\t\t\tcheckerboardPart, currentLevelProperties, nextLevelProperties,\r \n\t\t\t\tmessageUPrevStereoCheckerboard0, messageDPrevStereoCheckerboard0,\r \n\t\t\t\tmessageLPrevStereoCheckerboard0, messageRPrevStereoCheckerboard0,\r \n\t\t\t\tmessageUPrevStereoCheckerboard1, messageDPrevStereoCheckerboard1,\r \n\t\t\t\tmessageLPrevStereoCheckerboard1, messageRPrevStereoCheckerboard1,\r \n\t\t\t\tmessageUDeviceCurrentCheckerboard0, messageDDeviceCurrentCheckerboard0,\r \n\t\t\t\tmessageLDeviceCurrentCheckerboard0, messageRDeviceCurrentCheckerboard0,\r \n\t\t\t\tmessageUDeviceCurrentCheckerboard1, messageDDeviceCurrentCheckerboard1,\r \n\t\t\t\tmessageLDeviceCurrentCheckerboard1, messageRDeviceCurrentCheckerboard1,\r \n\t\t\t\tbpSettingsDispVals);\r \n\t}", "pragma": "parallel ", "hash": "4dab2c1ebad31673d038c0a7e48f2ed5ba8464faad221841f8f921f93abb3f73"}
{"code": "for(UINT64 i = 1; i <= dataSet->getNumberOfUniqueReads(); i++)  \n \n\t{ \n\t\tRead *read1 = dataSet->getReadFromID(i);  \n \n\t\tif(read1->superReadID==0)\t\t \n \n\t\t\tnonContainedReads++; \n\t}", "pragma": "parallel for reduction(+:noncontainedreads) ", "hash": "12a943afd0958b17db54ed1a20191884b7320b794f5efd7414df0235d43554cd"}
{"code": "for (long long k = 0; k < static_cast<long long>(eclipseCase->mainGrid()->cells().size()); k++) \n    { \n        values->at(k) = (k * 2) % eclipseCase->mainGrid()->cells().size(); \n    }", "pragma": "parallel for ", "hash": "821bb7b56805f1a42e573c5e53bd6f21fde9bbb90708917ab96d375f7f521f15"}
{"code": "for (j=0; j<ranSize; j++) { \n        ran[j] = HPCC_starts ((NUPDATE/ranSize) * j); \n    }", "pragma": "parallel for ", "hash": "d357720cfc431f1bb3f3ab617c3fdc492ad76fb01bc13cf33f2f93d81c3e22d5"}
{"code": "for (int s = 0; s <= setup.NS-1; s++)\tV[s]\t\t\t= Q[s];", "pragma": "parallel for ", "hash": "069c419194ff0aec2d19d63b2e5c6b1dc208eff1c7abf3583b0ea4d91a293603"}
{"code": "for ( int cellIdx = 0; cellIdx < static_cast<int>( cellVisibility->size() ); ++cellIdx ) \n        { \n            ( *cellVisibility )[cellIdx] = ( *wellFenceCells )[cellIdx] || ( *rangeVisibility )[cellIdx] || \n                                           ( *wellCellsOutsideRange )[cellIdx]; \n        }", "pragma": "parallel for ", "hash": "43499514d1e1d60b51f7c079c5fb5b188d6ce3db7b2dee2d6a29b0c33c105451"}
{"code": "for (j = 1; j <= lastcol-firstcol+1; j++) { \n            w[j] = 0.0; \n\t}", "pragma": "for ", "hash": "e21a72a90f6c38ef1d05c6d58f6ebd2a8a8d10c7bfd2f9c75a0e2d0a10b29644"}
{"code": "for(int v=0; v < i_RightVertexCount; v++) { \n \t\t\tint i_thread_num; \n\t\t\ti_thread_num = omp_get_thread_num(); \n\t\t\ti_thread_num = 0; \n\t\t\t \n \n\t\t\tB[ i_thread_num ][ d[v] ].push_back(v); \n\t\t\t \n\t\t\t \n \n\t\t\tVertexThreadGroup[v] = i_thread_num; \n \n\t\t}", "pragma": "parallel for ", "hash": "20ed60cdff6acae3bd142118b4d4e3b048c187fe148a5f0e3eaccb63fecc4d84"}
{"code": "for (int i = 0; i < resultLength; i++) { \n                    auto offset = tad.tadOffsets[i]; \n                    Nd4jLong shapeIter[MAX_RANK]; \n                    Nd4jLong coord[MAX_RANK]; \n                    int dim; \n                    int rankIter = rank; \n                    Nd4jLong xStridesIter[MAX_RANK]; \n                    T *xPointer = x + offset; \n                    SummaryStatsData<T> comp; \n                    comp.initWithValue(0.0); \n                    if (PrepareOneRawArrayIter<T>(rankIter, \n                                                  xShape, \n                                                  xPointer, \n                                                  xStride, \n                                                  &rankIter, \n                                                  shapeIter, \n                                                  &xPointer, \n                                                  xStridesIter) >= 0) { \n                        ND4J_RAW_ITER_START(dim, rank, coord, shapeIter); { \n                                 \n \n                                SummaryStatsData<T> comp2; \n                                comp2.initWithValue(xPointer[0]); \n                                comp = update(comp, comp2, extraParams); \n                            } ND4J_RAW_ITER_ONE_NEXT(dim, \n                                                     rank, \n                                                     coord, \n                                                     shapeIter, \n                                                     xPointer, \n                                                     xStridesIter); \n                    } \n                    else { \n                        printf(\"Unable to prepare array\\n\"); \n                    } \n \n                    result[i] = OpType::getValue(biasCorrected, comp); \n                }", "pragma": "parallel for ", "hash": "7788afb9f38494f159267600ba88959a624b8aa35e810c8622361cad405ee34f"}
{"code": "for (size_t dx = 0; dx < spacex; dx++){ \n        for (size_t dy = 0; dy < spacey - 1; dy++){ \n            for (size_t dz = 0; dz < spacez - 1; dz++){ \n                EM.Hx(dx,dy,dz) = lass.HxH(dx,dy,dz) * EM.Hx(dx,dy,dz) \n                                - lass.HxE(dx,dy,dz) * ((EM.Ez(dx,dy+1,dz) \n                                                         - EM.Ez(dx,dy,dz)) \n                                                         - (EM.Ey(dx,dy,dz+1) \n                                                         - EM.Ey(dx,dy,dz))); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "0ba82797d70c8df1a0b48222c52a5fca547384ccacb5210cf1df25c5c7b60cf9"}
{"code": "for( size_t i = 0; i < inNodes.size(); ++i ) \n            { \n                compactTract meanTract( getMeanTract( inNodes[i] ) ); \n \n                fullTractFM.writeFullNodeTract( inNodes[i], meanTract ); \n                std::string tractFilename( fullTractFM.getFullNodeTractFilename( inNodes[i] ) ); \n \n                if( reportProgress ) \n                { \n                    #pragma omp atomic \n                    ++progCount; \n \n                    #pragma omp single nowait  \n \n                    if( m_verbose ) \n                    { \n                        time_t currentTime( time( NULL ) ); \n                        if( currentTime - lastTime > 1 ) \n                        { \n                             \n \n                            lastTime = currentTime; \n                            size_t currentCount( progCount ); \n                            float progress = ( currentCount ) * 100. / (inNodes.size() ); \n                            size_t expected_remain( difftime( currentTime, startTime ) * ( ( 100. - progress ) / progress ) ); \n                            std::cout << \"\\r\" << ( int )progress << \" % Completed (\" << currentCount << \" node tracts)\" \n                                            << \". Expected remaining time: \"; \n                            std::cout << expected_remain / 3600 << \"h \" << ( expected_remain % 3600 ) / 60 << \"' \" << ( ( expected_remain \n                                            % 3600 ) % 60 ) << \"\\\"  \" << std::flush; \n                        } \n                    } \n                } \n                else \n                { \n                    if( m_verbose ) \n                        std::cout << \" Mean tract of node \" << inNodes[i] << \" (\" << m_tree.getNode( inNodes[i] ).getSize() \n                                        << \" tracts) written in \\\"\" << tractFilename << \"\\\"\" << std::endl; \n \n                    if( m_logfile != 0 ) \n                        ( *m_logfile ) << \"Mean tract for node \" << inNodes[i] << \" with \" << m_tree.getNode( inNodes[i] ).getSize() \n                                        << \" leaves written in \\\"\" << tractFilename << \"\\\"\" << std::endl; \n                } \n            }", "pragma": "parallel for ", "hash": "bbc9380c6ca52469cfa68c5c28fc782dcd43c3b89d9c16bcd7e73a8bb4d7f7a8"}
{"code": "for (ij = 0; ij < nish*njsh; ij++) { \n                ish = ij / njsh; \n                jsh = ij % njsh; \n                if (hermi != PLAIN && ish > jsh) { \n                        continue; \n                } \n \n                for (grid0 = 0; grid0 < ngrids; grid0 += BLKSIZE) { \n                        grid1 = MIN(grid0 + BLKSIZE, ngrids); \n                        ish += ish0; \n                        jsh += jsh0; \n                        shls[0] = ish; \n                        shls[1] = jsh; \n                        shls[2] = grid0; \n                        shls[3] = grid1; \n                        i0 = ao_loc[ish] - ao_loc[ish0]; \n                        j0 = ao_loc[jsh] - ao_loc[jsh0]; \n                        (*intor)(mat+ngrids*(j0*naoi+i0)+grid0, dims, shls, \n                                 atm, natm, bas, nbas, env, opt, cache); \n                } \n        }", "pragma": "for ", "hash": "4cef2cb2a98b0e2bd5e6850dcfc9caad9e160126b13b40944d745d02413d87f5"}
{"code": "for (i=0; i<nact; i++) { \n       \n \n      std::vector<float>         query(dim); \n      kdtree::KDTreeResultVector result; \n \n       \n \n      int32_t idx = active[i]; \n \n       \n \n      query[0] = (float)(r00*T[idx*3+0] + r01*T[idx*3+1] + r02*T[idx*3+2] + t0); \n      query[1] = (float)(r10*T[idx*3+0] + r11*T[idx*3+1] + r12*T[idx*3+2] + t1); \n      query[2] = (float)(r20*T[idx*3+0] + r21*T[idx*3+1] + r22*T[idx*3+2] + t2); \n \n       \n \n      M_tree->n_nearest(query,1,result); \n       \n \n \n       \n \n      double dx = M_tree->the_data[result[0].idx][0]; \n      double dy = M_tree->the_data[result[0].idx][1]; \n      double dz = M_tree->the_data[result[0].idx][2]; \n \n       \n \n      double nx = M_normal[result[0].idx*3+0]; \n      double ny = M_normal[result[0].idx*3+1]; \n      double nz = M_normal[result[0].idx*3+2]; \n \n       \n \n      double sx = query[0]; \n      double sy = query[1]; \n      double sz = query[2]; \n \n       \n \n      A.val[i][0] = nz*sy-ny*sz; \n      A.val[i][1] = nx*sz-nz*sx; \n      A.val[i][2] = ny*sx-nx*sy; \n      A.val[i][3] = nx; \n      A.val[i][4] = ny; \n      A.val[i][5] = nz; \n      b.val[i][0] = nx*(dx-sx) + ny*(dy-sy) + nz*(dz-sz);  \n \n    }", "pragma": "parallel for private(i)", "hash": "84a414f7b970575b4dd584858a76fa04e20548dc22f729bd9ebbbe45609ebe3a"}
{"code": "for (std::size_t vertex_idx = 0; vertex_idx < vertices.size(); ++vertex_idx) { \n        Vertex const & vertex = vertices[vertex_idx]; \n        energy += vertex.data_cost; \n    }", "pragma": "parallel for reduction(+:energy) ", "hash": "475f8d90a2964c021b26a41ce82366ffa9dc31008b657b9c5891532180acf741"}
{"code": "for (int i = 0; i < num_edges; ++ i) { \n            size_t src_offset = size_t(src[i]) * num_cols_local_; \n            size_t dst_offset = size_t(dst[i]) * num_cols_local_; \n            for (int j = 0; j < num_cols_local_; ++ j) { \n                DW_IN_[src_offset + j] += scale[i] * W_OUT_[dst_offset + j]; \n                DW_OUT_[dst_offset + j] += scale[i] * W_IN_[src_offset + j]; \n            } \n        }", "pragma": "parallel for ", "hash": "6ecf40cd0efadf68ea2996f76491d9a342ff55dabb409dc7c576fb56a83a863d"}
{"code": "for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] += crop_left; \n    points[i + 1] += crop_top; \n  }", "pragma": "parallel for simd ", "hash": "56e7d79418ee6b02f8091a8a036a32e8d6b597053c3afd64b424f440353291b1"}
{"code": "for ( i = 0; i < N; i++)\t \n\t{ \n\t\tdouble *ap = A + i*LDA; \n\t\tdouble *bp = B + i*LDB; \n \n\t\tdouble ar[8]; \n \n\t\tint j; \n\t \n\t\tfor ( j=0; j < m1 ; j++ ) \n\t\t{ \n \n\t\t\tar[0] = *(ap + 0); \n\t\t\tar[1] = *(ap + 1); \n\t\t\tar[2] = *(ap + 2); \n\t\t\tar[3] = *(ap + 3); \n\t\t\tar[4] = *(ap + 4); \n\t\t\tar[5] = *(ap + 5); \n\t\t\tar[6] = *(ap + 6); \n\t\t\tar[7] = *(ap + 7); \n \n\t\t\t*(bp + 0) = ar[0] + *(bp + 0) * beta; \n\t\t\t*(bp + 1) = ar[1] + *(bp + 1) * beta; \n\t\t\t*(bp + 2) = ar[2] + *(bp + 2) * beta; \n\t\t\t*(bp + 3) = ar[3] + *(bp + 3) * beta; \n\t\t\t*(bp + 4) = ar[4] + *(bp + 4) * beta; \n\t\t\t*(bp + 5) = ar[5] + *(bp + 5) * beta; \n\t\t\t*(bp + 6) = ar[6] + *(bp + 6) * beta; \n\t\t\t*(bp + 7) = ar[7] + *(bp + 7) * beta; \n \n\t\t\tap += 8; \n\t\t\tbp += 8; \n \n\t\t} \n \n\t\tfor ( j = 0; j < m2; j++ ) \n\t\t{ \n\t\t\t*(bp + j) = *(ap + j) + *(bp + j) * beta; \n\t\t} \n\t \n\t}", "pragma": "parallel for ", "hash": "20b0aa34643e8da9cb9d472d5a7779f7fb102b427dc5cfa3ce91771c152179bb"}
{"code": "for (i = 0; i < (int)n_rows_a; i += TILE_ORDER) {\r \n        for (j = 0; j < (int)n_cols_a; j += TILE_ORDER) {\r \n            for (it = i; it < MIN((int)n_rows_a, i + TILE_ORDER); it++) {\r \n                for (jt = j; jt < MIN((int)n_cols_a, j + TILE_ORDER); jt++) {\r \n                    a[it*n_cols_a + jt] = it*n_cols_a + jt;\r \n                }\r \n            }\r \n        }\r \n    }", "pragma": "parallel for private(   i it j jt)", "hash": "53510ee8ec7a62ffb8608f2f7a34a76a8a108e759245d9f81d5a60b0ab0ac474"}
{"code": "for (Code code = 0; code < mc.codeSize(); ++code) { \n            value[code] = 0; \n        }", "pragma": "parallel for ", "hash": "bf975094b15c45d195322678ece7521489e93413439dbf8f25fe4a0d487c8087"}
{"code": "for ( i = 0; i < n; ++i ) { \n \n        tt = ( phi[i] >= 0.0 ) ? phi[i] * TWOINVPI : phi[i] * TWOINVPI + 4.0; \n \n        if ( ::abs ( region[i] ) == 1) { \n \n            temp1 = halfnside_ + dnside_ * tt; \n            temp2 = tqnside_ * z[i]; \n \n            jp = static_cast < int64_t > ( temp1 - temp2 ); \n            jm = static_cast < int64_t > ( temp1 + temp2 ); \n \n            ir = nsideplusone_ + jp - jm; \n            kshift = 1 - ( ir & 1 ); \n \n            ip = ( jp + jm - nside_ + kshift + 1 ) >> 1; \n            ip = ip % fournside_; \n \n            pix[i] = ncap_ + ( ( ir - 1 ) * fournside_ + ip ); \n \n        } else { \n \n            tp = tt - floor( tt ); \n \n            temp1 = dnside_ * rtz[i]; \n \n            jp = static_cast < int64_t > ( tp * temp1 ); \n            jm = static_cast < int64_t > ( ( 1.0 - tp ) * temp1 ); \n            ir = jp + jm + 1; \n            ip = static_cast < int64_t > ( tt * (double)ir ); \n            longpart = static_cast < int64_t > ( ip / ( 4 * ir ) ); \n            ip -= longpart; \n \n            pix[i] = ( region[i] > 0 ) ? ( 2 * ir * ( ir - 1 ) + ip) : ( npix_ - 2 * ir * ( ir + 1 ) + ip ); \n \n        } \n    }", "pragma": "parallel for private(          i ip ir jm jp kshift longpart temp1 temp2 tp tt)", "hash": "ee6b5d63d9ec5cf50e7db8c0c174d08fa7ba618f503282362bbcde4aef64fde4"}
{"code": "for (int v=0; v<(int)cloud.height; v++)\r \n  {\r \n    for (int u=0; u<(int)cloud.width; u++)\r \n    {\r \n      const pcl::PointXYZRGB &pt = cloud(u,v);\r \n      cv::Vec3d &lab = im_lab(v,u);\r \n\r \n      R = pt.r*inv_255;\r \n      G = pt.g*inv_255;\r \n      B = pt.b*inv_255;\r \n\r \n      if(R <= 0.04045)  r = R*inv_12;\r \n      else        r = pow((R+0.055)*inv_1,2.4);\r \n      if(G <= 0.04045)  g = G*inv_12;\r \n      else        g = pow((G+0.055)*inv_1,2.4);\r \n      if(B <= 0.04045)  b = B*inv_12;\r \n      else        b = pow((B+0.055)*inv_1,2.4);\r \n\r \n      X = r*0.4124564 + g*0.3575761 + b*0.1804375;\r \n      Y = r*0.2126729 + g*0.7151522 + b*0.0721750;\r \n      Z = r*0.0193339 + g*0.1191920 + b*0.9503041;\r \n\r \n      xr = X*inv_Xr;\r \n      yr = Y; \n \n      zr = Z*inv_Zr;\r \n\r \n      if(xr > epsilon)  fx = pow(xr, inv_3);\r \n      else        fx = (kappa*xr + 16.0)*inv_116;\r \n      if(yr > epsilon)  fy = pow(yr, inv_3);\r \n      else        fy = (kappa*yr + 16.0)*inv_116;\r \n      if(zr > epsilon)  fz = pow(zr, inv_3);\r \n      else        fz = (kappa*zr + 16.0)*inv_116;\r \n\r \n      lab[0] = 116.0*fy-16.0;\r \n      lab[1] = 500.0*(fx-fy);\r \n      lab[2] = 200.0*(fy-fz);\r \n    }\r \n  }", "pragma": "parallel for private(b b fx fy fz g g r r x xr y yr z zr)", "hash": "e721f3f3479ca36a5fae3216ce6e59d954ac5dd739bf862d238bd464c9e66048"}
{"code": "for (long long y = 0; y < size_.get().y; y++) { \n        for (long long x = 0; x < size_.get().x; x++) { \n            float v = 0; \n            float X = x * repri; \n            float Y = y * repri; \n            for (auto &sampler : samplers) { \n                v += sampler.sample(X, Y); \n            } \n            v = (v + 1.0f) / 2.0f; \n            data[index(x, size_.get().y - 1 - y)] = glm::clamp(v, 0.0f, 1.0f); \n        } \n    }", "pragma": "parallel for ", "hash": "92da3c969ddef1c25803290af9e90c549d54a8d762110b338c8647acc24d1875"}
{"code": "for(long i=0;i<n;i++)\r \n\t\t{\txc[i]=xx[1]*(x->a[i]-xx[0]);\tyc[i]=xx[3]*(y->a[i]-xx[2]);\t}", "pragma": "parallel ", "hash": "13abd4800cbf14dd1bd01b1602af34c58bd12f7eb8134badd537656ffc4fae11"}
{"code": "for (ith=llim; ith<ulim; ++ith) \n    { \n    int ijob,i; \n    int dim2 = (ith-llim)*(mmax+1); \n    for (ijob=0; ijob<jobs->njobs; ++ijob) \n      { \n      X(job) *curjob = &jobs->job[ijob]; \n      if (curjob->type != MAP2ALM) \n        for (i=0; i<curjob->nmaps; ++i) \n          X(ringhelper_phase2pair)(&helper,mmax,&curjob->phas1[i][dim2], \n            &curjob->phas2[i][dim2],&ginfo->pair[ith],curjob->map[i]); \n      } \n    }", "pragma": "for ", "hash": "a8214d98d89bd76440424bd817fa07436e0d6dd1560d03f53ff7ee4b466f6060"}
{"code": "for (int i = totalCount - 1; i >= 0; --i) { \n        calcVector[i] /= calcNorm; \n    }", "pragma": "parallel for ", "hash": "53fdb98725b8290df0798e9800bc729246e2f0ff67dc4aa05026b7d68e7cd6d6"}
{"code": "for (ix=0; ix < Nx; ix++) { \n            ic = ix * Ncz; \n            ir = ix * Nrz; \n            fftwf_execute_dft_r2c(fwdz,&RZ[ir],(fftwf_complex *) &CZ[ic]); \n            for (iz=0; iz < Ncz; iz++) \n                CZ[ix*Ncz + iz] *= DZ[iz]; \n            fftwf_execute_dft_c2r(invz,(fftwf_complex *) &CZ[ic],&RZ[ir]); \n        }", "pragma": "parallel for private(ic ir ix iz)", "hash": "0a4ff0a57610209f93171520627f5431a6d35b5410e22d3c23efabab075ac8d4"}
{"code": "for (int32_t i = 0; i < m_num_bags; ++i) \n\t{ \n\t\tCMachine* c=dynamic_cast<CMachine*>(m_machine->clone()); \n\t\tASSERT(c != NULL); \n\t\tSGVector<index_t> idx(rnd_indicies.get_column_vector(i), m_bag_size, false); \n \n\t\tCFeatures* features; \n\t\tCLabels* labels; \n \n\t\tif (get_global_parallel()->get_num_threads()==1) \n\t\t{ \n\t\t\tfeatures = m_features; \n\t\t\tlabels = m_labels; \n\t\t} \n\t\telse \n\t\t{ \n\t\t\tfeatures = m_features->shallow_subset_copy(); \n\t\t\tlabels = m_labels->shallow_subset_copy(); \n\t\t} \n \n\t\tlabels->add_subset(idx); \n\t\t \n \n\t\tfeatures->add_subset(idx); \n\t\tset_machine_parameters(c,idx); \n\t\tc->set_labels(labels); \n\t\tc->train(features); \n\t\tfeatures->remove_subset(); \n\t\tlabels->remove_subset(); \n \n  #pragma omp critical \n\t\t{ \n\t\t \n \n\t\tCDynamicArray<index_t>* oob = get_oob_indices(idx); \n\t\tm_oob_indices->push_back(oob); \n \n\t\t \n \n\t\tm_bags->push_back(c); \n\t\t} \n \n\t\tif (get_global_parallel()->get_num_threads()!=1) \n\t\t{ \n\t\t\tSG_UNREF(features); \n\t\t\tSG_UNREF(labels); \n\t\t} \n \n\t\tSG_UNREF(c); \n\t\tpb.print_progress(); \n\t}", "pragma": "parallel for ", "hash": "86bc37bfd9e95b28c9dd4c6ec267a0ee9e89c325c7a9cd8ec6dbd2559cf37713"}
{"code": "for(int idx = 0; idx < n; ++idx) { \n    float val = grid->data[idx]; \n    grid->data[idx] = fabs(val); \n  }", "pragma": "parallel for ", "hash": "9dee889316085c2b811ba2c00cabc8fc5cec95a6644998f3eb68cd26f7333044"}
{"code": "for (auto xx = lowerBoundX; xx < upperBoundX; ++xx) \n      { \n         tls.init(waveTrackCache, scratchSize); \n         WaveTrackCache& cache = *tls.cache; \n         float* buffer = &tls.scratch[0]; \n         WaveTrackCache& cache = waveTrackCache; \n         float* buffer = &scratch[0]; \n         CalculateOneSpectrum( \n            settings, cache, xx, numSamples, \n            offset, rate, pixelsPerSecond, \n            lowerBoundX, upperBoundX, \n            gainFactors, buffer, &freq[0]); \n      }", "pragma": "parallel for private(tls)", "hash": "39136f4a04ff31856627bdbebac4407b95cc760f9e7f342f901086da4422eec4"}
{"code": "for (i=0; i<numel; i++) \n        tensor_data[i] = src_data[index_data[i]-1];", "pragma": "parallel for private(i)", "hash": "7cbafb3f8c06d31d5c87a16173a9991e5f24fac07b30a214c38c5c7b0242d113"}
{"code": "for (int j = 0; j < sumlengths.size(); j++) \n\t\t{ \n\t\t\tsumlengths[j] += Nlengths[i][j]; \n\t\t}", "pragma": "parallel for ", "hash": "0b4cf4b251bed013ab20fa3ca9afb387e35a5c8e11dc89b8d669ff5af0142eb4"}
{"code": "for (int i = 0; i < (int) n_macroparticles; i++) \n        id[i] = id[i] * index[i];", "pragma": "parallel for ", "hash": "3919b744d173b1e857f26db88a22849ec5ec3748eed8292753e6a861c277d825"}
{"code": "for (j=0; j<NN; j++) \n            c[j] = a[j];", "pragma": "parallel for ", "hash": "522212db4d69e254f3a9039746efd1f324090fd3c7578aab91ea971dfc9d5241"}
{"code": "for(long i=id;i<n;i+=mglNumThr)\r \n\t{\tunsigned char *b=GB+4*i, c[4]={b[0],b[1],b[2],b[3]}, *g=G+3*i;\r \n\t\tcombine(c,G4+4*i);\tg[0]=c[0];\tg[1]=c[1];\tg[2]=c[2];\t}", "pragma": "parallel ", "hash": "46c739623591bb5a5aac334e9a1ac04155f563d11546b08009e230ffac85305a"}
{"code": "for (int s = 0; s < numSamples; ++s) \n    y.row(s) -= rowsMax.at<real>(s);", "pragma": "parallel for ", "hash": "050183c6066cb31cd59527156a83852a8a6563d9a99eedf7fb466be071d59dda"}
{"code": "for(int n = 0; n < N; n++) \n  { \n    for(int fmOut = 0, outputIdx = 0; fmOut < fm; fmOut++) \n    { \n      for(int r = 0; r < rows; r++) \n      { \n        for(int c = 0; c < cols; c++, outputIdx++) \n        { \n          double denom = 0.0; \n          const int fmInMin = std::max(0, fmOut - n / 2); \n          const int fmInMax = std::min(fm - 1, fmOut + n / 2); \n          for(int fmIn = fmInMin; fmIn < fmInMax; fmIn++) \n          { \n            register double a = (*x)(n, fmIn * fmSize + r * cols + c); \n            denom += a * a; \n          } \n          denom = k + alpha * denom; \n          denoms(n, outputIdx) = denom; \n          this->y(n, outputIdx) = (*x)(n, outputIdx) * std::pow(denom, -beta); \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "7c8c065aed14dd1546ff512ee0d5c2f85b4a3e9698d431ac3e66eda928733c3e"}
{"code": "for (k = 0; k < NUM_LOOPS; k++) { \n\t\t \n \n\t\t \n \n\t\tfor (i = 0; i < rows; i++) { \n\t\t\tv[i] = 0.0f; \n\t\t\tfor (j = 0; j < columns; j++) \n\t\t\t\tv[i] = v[i] + A[i][j] * u[j]; \n\t\t} \n\t}", "pragma": "parallel for private(  i j k)", "hash": "b89c78d6c245e43572151f1b2e40018c44acae2ed0adebcbaa1378581be89c4c"}
{"code": "for(size_t y = 0; y < oheight; y++) \n      { \n        const size_t start = ((y + yoffs) * iwidth + xoffs) * DT_BLENDIF_LAB_CH; \n        _blendif_combine_channels(a + start, temp_mask + (y * owidth), owidth, blendif, parameters); \n      }", "pragma": "for ", "hash": "818dc4a632eb0a18255e5544d01c0b18c55c0575b8277ece89ef8e964ee46fd5"}
{"code": "for (k = 0; k < M; k++) \n    { \n      INT u, o, l; \n      R ip_y, ip_w; \n      INT ip_u; \n      R psij_const[m2p2]; \n      INT j = (ths->flags & NFFT_SORT_NODES) ? ths->index_x[2*k+1] : k; \n \n      uo(ths, (INT)j, &u, &o, (INT)0); \n \n      ip_y = FABS((R)(n) * ths->x[j] - (R)(u)) * ((R)ip_s); \n      ip_u = (INT)(LRINT(FLOOR(ip_y))); \n      ip_w = ip_y - (R)(ip_u); \n \n      for (l = 0; l < m2p2; l++) \n        psij_const[l] = ths->psi[ABS(ip_u-l*ip_s)] * (K(1.0) - ip_w) \n          + ths->psi[ABS(ip_u-l*ip_s+1)] * (ip_w); \n \n      nfft_trafo_1d_compute(&ths->f[j], g, psij_const, &ths->x[j], n, m); \n    }", "pragma": "parallel for private(k)", "hash": "0f6e01b61250758c56e58c72b5b9c4df1c8e84b55e32375934db2fd9cc39bf0b"}
{"code": "for (i=0; i<5; i++) \n        { \n            input[i] = i*i; \n        }", "pragma": "simd for ", "hash": "34a91e57a9b256b5c959f2af0d109640e26089be97cde8ad2e861d61c587f512"}
{"code": "for (int i = 0; i < h; ++i) { \n            int j = 0; \n            for (; j < w - 3; j += 4) { \n                const vfloat Vinv = LVFU((*array)(j, i)); \n                STVFU((*array)(j, i), vselfzero(vmaskf_gt(Vinv, ZEROV), pow_F(Vinv, exponentv))); \n            } \n            for (; j < w; ++j) { \n                if ((*array)(j, i) > 0.0f) { \n                    (*array)(j, i) = pow_F((*array)(j, i), exponent); \n                } else { \n                    (*array)(j, i) = 0.0f; \n                } \n            } \n        }", "pragma": "for ", "hash": "0be19af8433cf30764fd0d633ccef49e50b7536a2f26556575eacda5a8adcb0d"}
{"code": "for (size_t k = 0; k < it->second.size(); ++k) \n        { \n            std::vector<string> str; \n            boost::algorithm::split(str, it->second[k].second, \n                                    boost::is_any_of(\".\"), boost::token_compress_on); \n            double dist = 0; \n            if ( str.size() > 2 ) { \n                for (size_t j = 0; j < str.size() - 2; ++j) { \n                    size_t curr = atoi(str[j].c_str()); \n                    size_t next = atoi(str[j + 1].c_str()); \n                    dist += norm(emb_node(colon(), next) - emb_node(colon(), curr)); \n                } \n            } \n            coeff[k] = dist < 2 * __SIGMA ? exp(-0.5 * dist * dist / __SIGMA / __SIGMA) : 0; \n        }", "pragma": "parallel for ", "hash": "4e7e434769c92834c19067d420fd4376ea9335418cf2e3d5627572afdf23e0cf"}
{"code": "for ( int i = 0; i < int( m_frameData.m_currentNormal.size() ); ++i ) \n            { \n                Core::Math::getOrthogonalVectors( m_frameData.m_currentNormal[i], \n                                                  m_frameData.m_currentTangent[i], \n                                                  m_frameData.m_currentBitangent[i] ); \n            }", "pragma": "parallel for ", "hash": "dd7f709a82c33c0bfd2a809b398b73536109ac3124c0f33282e3b2de42fe952a"}
{"code": "for (int iframe = 0; iframe < n_frames; iframe++) \n\t\t\t{ \n\t\t\t\tRFLOAT pbuf[PBUF_SIZE]; \n \n \n\t\t\t\tint n_ok = 0; \n\t\t\t\tfor (int dy= -D_MAX; dy <= D_MAX; dy++) \n\t\t\t\t{ \n\t\t\t\t\tint y = i + dy; \n\t\t\t\t\tif (y < 0 || y >= ny) continue; \n\t\t\t\t\tfor (int dx = -D_MAX; dx <= D_MAX; dx++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tint x = j + dx; \n\t\t\t\t\t\tif (x < 0 || x >= nx) continue; \n \n \n\t\t\t\t\t\tif (DIRECT_A2D_ELEM(bBad, y, x)) continue; \n \n \n\t\t\t\t\t\tpbuf[n_ok] = DIRECT_A2D_ELEM(Iframes[iframe](), y, x); \n\t\t\t\t\t\tn_ok++; \n\t\t\t\t\t} \n \n \n\t\t\t\t} \n \n \n\t\t\t\tif (n_ok > NUM_MIN_OK) \n\t\t\t\t\tDIRECT_A2D_ELEM(Iframes[iframe](), i, j) = pbuf[rand() % n_ok]; \n\t\t\t\telse \n\t\t\t\t\tDIRECT_A2D_ELEM(Iframes[iframe](), i, j) = rnd_gaus(frame_mean, frame_std); \n \n \n\t\t\t}", "pragma": "parallel for ", "hash": "73b674c5998e75da54ef44061d8dc014dcff9bcb8bc054381eb9ae44beb38499"}
{"code": "for (int64_t i = 0; i < SIZE; i++) { \n    if (counts[i] > max_reads) { \n      num_truncated_bases++; \n      total_truncated_reads += counts[i] - max_reads; \n      counts[i] = max_reads; \n    } \n  }", "pragma": "parallel for reduction( +:num_truncated_bases total_truncated_reads) ", "hash": "ba6c8ac98d1fd814826c09561b7521f82bd2a35d4ef6af0a2ac8b94500c51c05"}
{"code": "for (uint64_t batch = range_start; batch < range_end; ++batch) { \n        uint8_t *priv_key = (uint8_t *) priv_key_shadow; \n         \n \n        uint64_t *counter = priv_key_shadow + 2; \n         \n \n        *counter += batch + range_offs; \n        uint8_t pub_key[KEY_LEN] = {0}; \n \n        crypto_scalarmult_curve25519_base(pub_key, priv_key); \n \n        const unsigned matching = (unsigned) match_hex_prefix(pub_key, hex_prefix, prefix_chars_len); \n \n         \n \n        uint32_t l_longest_match; \n        #pragma omp atomic read \n        l_longest_match = *longest_match; \n \n        if (matching > l_longest_match) { \n            #pragma omp atomic write \n            *longest_match = matching; \n \n            #pragma omp critical \n            { \n                printf(\"%u chars matching: \\n\", matching); \n                printf(\"Public key: \"); \n                print_key(pub_key); \n                printf(\"\\nSecret key: \"); \n                print_key(priv_key); \n                printf(\"\\n\"); \n            } \n        } \n    }", "pragma": "parallel for private(priv_key_shadow)", "hash": "bbbc95542ff45bb133a35fb3c5e6d5195aa4bcf78b2482a1185773f633af49f7"}
{"code": "for (i = 0; i < N; i++) \n    zd[i] = -xd[i];", "pragma": "parallel for private(i)", "hash": "60b6bba1d8f9a916aea7bade35e1f1c920285649eb4994682cd33378ff44b143"}
{"code": "for (ptrdiff_t i = i_start; i < i_end; ++i) { \n        pred_vtx[i - i_start] = get_pred_from_pred_entry(pred[i]); \n      }", "pragma": "parallel for ", "hash": "4b062070bbac1b50a9877c01efc39005fba7e88e8b1c92354712047b8426b1f7"}
{"code": "for (int i = 0; i < size; i++) { \n        float v = I(i); \n        maxI = std::max(maxI, v); \n        minI = std::min(minI, v); \n        J(i) = 0.0f;   \n \n    }", "pragma": "parallel for reduction(min:mini) reduction(max:maxi) ", "hash": "7dcc74ab47fabdadbabbd754de23fdda214d0205beff2bb5135849ab3072bd16"}
{"code": "for (uint64_t id = 0; id < dbg.size(); ++id) { \n    if (!ignored.at(id) && dbg.EdgeIndegreeZero(id)) { \n      uint64_t next = SDBG::kNullID; \n      uint64_t cur = id; \n      bool is_tip = false; \n      path.clear(); \n      path.push_back(id); \n \n      for (int i = 1; i < len; ++i) { \n        next = dbg.UniqueNextEdge(cur); \n        if (next == SDBG::kNullID) { \n          is_tip = dbg.EdgeOutdegreeZero(cur); \n          break; \n        } else if (dbg.UniquePrevEdge(next) == SDBG::kNullID) { \n          is_tip = true; \n          break; \n        } else { \n          path.push_back(next); \n          cur = next; \n        } \n      } \n      if (is_tip) { \n        for (unsigned long i : path) { \n          to_remove.set(i); \n        } \n        ++number_tips; \n        ignored.set(id); \n        ignored.set(path.back()); \n        if (next != SDBG::kNullID) { \n          ignored.unset(next); \n        } \n      } \n    } \n  }", "pragma": "parallel for reduction(+ : number_tips) private(path)", "hash": "9600d635676383af3dcf960891e0e9bdee3bfe5095f96b511bca291cde676cbf"}
{"code": "for(int out_grid_idx = 0; out_grid_idx < n_blocks; ++out_grid_idx) { \n    ot_tree_t* otree = octree_get_tree(out, out_grid_idx); \n     \n \n    ot_data_t* odata = octree_get_data(out, out_grid_idx); \n \n    int gn, ogd, ogh, ogw; \n    octree_split_grid_idx(out, out_grid_idx, &gn, &ogd, &ogh, &ogw);  \n     \n    int obit_idx_l1 = 1; \n    for(int dgd = 0; dgd < 2; ++dgd) { \n      for(int hgh = 0; hgh < 2; ++hgh) { \n        for(int wgw = 0; wgw < 2; ++wgw) { \n \n          int igd = 2*ogd + dgd; \n          int igh = 2*ogh + hgh; \n          int igw = 2*ogw + wgw; \n          int in_grid_idx = octree_grid_idx(in, gn, igd, igh, igw); \n          ot_tree_t* itree = octree_get_tree(in, in_grid_idx); \n           \n \n          ot_data_t* idata = octree_get_data(in, in_grid_idx); \n           \n          if(tree_isset_bit(itree, 0)) { \n            int obit_idx_l2 = tree_child_bit_idx(obit_idx_l1); \n            for(int ibit_idx_l1 = 1; ibit_idx_l1 < 9; ++ibit_idx_l1) { \n \n              if(tree_isset_bit(itree, ibit_idx_l1)) { \n \n                int obit_idx_l3 = tree_child_bit_idx(obit_idx_l2); \n                for(int idx = 0; idx < 8; ++idx) { \n \n                  int ibit_idx_l2 = tree_child_bit_idx(ibit_idx_l1) + idx; \n                  int out_data_idx = tree_data_idx(otree, obit_idx_l3, feature_size); \n                  if(tree_isset_bit(itree, ibit_idx_l2)) { \n                    int in_data_idx = tree_data_idx(itree, tree_child_bit_idx(ibit_idx_l2), feature_size); \n                    octree_pool2x2x2<pool_fcn>(idata + in_data_idx, feature_size, odata + out_data_idx); \n                  } \n                  else { \n                    int in_data_idx = tree_data_idx(itree, ibit_idx_l2, feature_size); \n                     \n \n                     \n \n                     \n \n                    octree_cpy_leaf(idata + in_data_idx, feature_size, odata + out_data_idx); \n                  } \n                  obit_idx_l3++; \n \n                } \n \n              } \n              else { \n                int out_data_idx = tree_data_idx(otree, obit_idx_l2, feature_size); \n                int in_data_idx = tree_data_idx(itree, ibit_idx_l1, feature_size); \n                 \n \n                 \n \n                 \n \n                octree_cpy_leaf(idata + in_data_idx, feature_size, odata + out_data_idx); \n              } \n              obit_idx_l2++; \n \n            } \n          } \n          else { \n            int out_data_idx = tree_data_idx(otree, obit_idx_l1, feature_size); \n             \n \n             \n \n             \n \n            octree_cpy_leaf(idata, feature_size, odata + out_data_idx); \n          } \n          obit_idx_l1++; \n \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "a765e8d6ab5ad95f5cd457fd9b0ca0a7d3f473955f623c187e574aea17edad83"}
{"code": "for (int i = 0; i < nrows; i++) { \n            uint64_t row = i * nrows; \n            MATRIX_TYPE *a_row = a + (row); \n            MATRIX_TYPE *c_row = c + (row); \n            for (int j = 0; j < ncols; j++) { \n                MATRIX_TYPE cval = 0; \n                for (int k = 0; k < nrows; k++) { \n                    cval += (a_row[k] * b[k * nrows + j]); \n                } \n \n                c_row[j] = cval; \n \n                if (i == j) { \n                    counter++; \n                } \n                sum += cval; \n            } \n        }", "pragma": "for ", "hash": "066a1f2051a79fe8155d595f855e0a10b12c419794e7e5bd0ba35949c88eb513"}
{"code": "for(i = 0; i < K*C*sizeF; i++) \n        filter[i] = (float)(i%mod);", "pragma": "parallel for private(i)", "hash": "a0227f957f26ddea69eb2febd0682196bfa4a66ab34ef5ac8c49efed74cc5a25"}
{"code": "for(int k=0; k<record_cnt; k++) \n\t{ \n\t\t \n \n\t\tconst int prediction=cnn.predict_class(test_images[k].data()); \n \n\t\t \n \n\t\tif(prediction ==test_labels[k]) correct_predictions+=1; \n\t\tif(k%1000==0) progress.draw_progress(k); \n\t}", "pragma": "for reduction(+:correct_predictions) ", "hash": "2dfecc613ed6c053d52458f095959f5cc867361544cc117f46dc3e8906ac33a1"}
{"code": "for (int i = 0; i < 10; ++i) { \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n    foo(); \n#pragma omp scan inclusive(a[:n], b) \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n    bar(); \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n \n     \n \n     \n \n     \n \n  }", "pragma": "parallel for simd reduction(  +:a[:n] b inscan) ", "hash": "7b4ead7208d7a7e146ac1dd67c0d4c2191a3f920afafb4243ef589e31e6904b7"}
{"code": "for(int i=0; i < totalSize; ++i) \n      data[i] = (i+1)%1000 - 500;", "pragma": "parallel for ", "hash": "d79ac4dca56f0ff959d75a2902c403b0c87eb613d99b2926f4c1d730e4dd5540"}
{"code": "for (si = 0; si < nseqs; si++) { \n     n = seqlen_array[si+1]; \n     for (i = 1, len1 = 0; i <= n; i++) { \n        char c = seq_array[si+1][i]; \n        if ((c != gap_pos1) && (c != gap_pos2)) len1++; \n     } \n     for (sj = si + 1; sj < nseqs; sj++)  \n     { \n        m = seqlen_array[sj+1]; \n        if ( n == 0 || m == 0 ) { \n           bench_output[si*nseqs+sj] = (int) 1.0; \n        } else { \n           #pragma omp task untied             private(i,gg,len2,mm_score) firstprivate(m,n,si,sj,len1)             shared(nseqs, bench_output,seqlen_array,seq_array,gap_pos1,gap_pos2,pw_ge_penalty,pw_go_penalty,mat_avscore) \n           { \n              int se1, se2, sb1, sb2, maxscore, seq1, seq2, g, gh; \n              int displ[2*MAX_ALN_LENGTH+1]; \n              int print_ptr, last_print; \n \n              for (i = 1, len2 = 0; i <= m; i++) { \n                 char c = seq_array[sj+1][i]; \n                 if ((c != gap_pos1) && (c != gap_pos2)) len2++; \n              } \n \n              if ( dnaFlag == TRUE ) { \n                 g  = (int) ( 2 * INT_SCALE * pw_go_penalty * gap_open_scale );  \n \n                 gh = (int) (INT_SCALE * pw_ge_penalty * gap_extend_scale);  \n \n              } else { \n                 gg = pw_go_penalty + log((double) MIN(n, m));  \n \n                 g  = (int) ((mat_avscore <= 0) ? (2 * INT_SCALE * gg) : (2 * mat_avscore * gg * gap_open_scale) );  \n \n                 gh = (int) (INT_SCALE * pw_ge_penalty);  \n \n              } \n \n              seq1 = si + 1; \n              seq2 = sj + 1; \n \n              forward_pass(&seq_array[seq1][0], &seq_array[seq2][0], n, m, &se1, &se2, &maxscore, g, gh); \n              reverse_pass(&seq_array[seq1][0], &seq_array[seq2][0], se1, se2, &sb1, &sb2, maxscore, g, gh); \n \n              print_ptr  = 1; \n              last_print = 0; \n \n              diff(sb1-1, sb2-1, se1-sb1+1, se2-sb2+1, 0, 0, &print_ptr, &last_print, displ, seq1, seq2, g, gh); \n              mm_score = tracepath(sb1, sb2, &print_ptr, displ, seq1, seq2); \n \n              if (len1 == 0 || len2 == 0) mm_score  = 0.0; \n              else                        mm_score /= (double) MIN(len1,len2); \n \n              bench_output[si*nseqs+sj] = (int) mm_score; \n           }  \n \n        }  \n \n     }  \n \n  }", "pragma": "parallel for private(i len1 m n si sj)", "hash": "acf7019c26498059d7396fa827b2fbe50402cecde093e3fbe9ed4bfcedbce88b"}
{"code": "for ( i=0; i < K ; i++ ) \n\t{ \n \n\t\t \n \n\t\tdouble *a_ptr = A + i * LDA*2; \n\t\tdouble *b_ptr = B + i * (M + pad_m)*2; \n\t\t \n\t\tdouble *ap = a_ptr; \n\t\tdouble *bp = b_ptr; \n\t\tint j; \n\t\tdouble ar[16]; \n \n\t\tfor ( j=0; j < m1 ; j++ ) \n\t\t{ \n \n\t\t\tar[0] = *(ap + 0); \n\t\t\tar[1] = *(ap + 1); \n\t\t\tar[2] = *(ap + 2); \n\t\t\tar[3] = *(ap + 3); \n\t\t\tar[4] = *(ap + 4); \n\t\t\tar[5] = *(ap + 5); \n\t\t\tar[6] = *(ap + 6); \n\t\t\tar[7] = *(ap + 7); \n\t\t\tar[8] = *(ap + 8); \n\t\t\tar[9] = *(ap + 9); \n\t\t\tar[10] = *(ap + 10); \n\t\t\tar[11] = *(ap + 11); \n\t\t\tar[12] = *(ap + 12); \n\t\t\tar[13] = *(ap + 13); \n\t\t\tar[14] = *(ap + 14); \n\t\t\tar[15] = *(ap + 15); \n \n\t\t\t*(bp + 0) = ar[0]; \n\t\t\t*(bp + 1) = ar[1]; \n\t\t\t*(bp + 2) = ar[2]; \n\t\t\t*(bp + 3) = ar[3]; \n\t\t\t*(bp + 4) = ar[4]; \n\t\t\t*(bp + 5) = ar[5]; \n\t\t\t*(bp + 6) = ar[6]; \n\t\t\t*(bp + 7) = ar[7]; \n\t\t\t*(bp + 8) = ar[8]; \n\t\t\t*(bp + 9) = ar[9]; \n\t\t\t*(bp + 10) = ar[10]; \n\t\t\t*(bp + 11) = ar[11]; \n\t\t\t*(bp + 12) = ar[12]; \n\t\t\t*(bp + 13) = ar[13]; \n\t\t\t*(bp + 14) = ar[14]; \n\t\t\t*(bp + 15) = ar[15]; \n \n\t\t\tap += 16; \n\t\t\tbp += 16; \n \n\t\t} \n \n\t\tfor (j=0 ; j < m2 ; j++ ) \n\t\t{ \n\t\t\tbp[0] = ap[0]; \n\t\t\tbp[1] = ap[1]; \n \n\t\t\tap += 2; \n\t\t\tbp += 2; \n\t\t} \n \n\t\tfor ( ; j < m2 + pad_m; j++ ) \n\t\t{ \n \n\t\t\tbp[0] = (double) 0.0; \n\t\t\tbp[1] = (double) 0.0; \n\t\t\tbp += 2; \n\t\t} \n\t\t \n\t}", "pragma": "parallel for ", "hash": "3f8a4a2ace2050368af8db42efd5c2d4a62f63a4a1239544db96c7950e8c86c3"}
{"code": "for (int i = start_number; i < max; i++) { \n        if (is_prime(i)) { \n            jj++; \n        } \n    }", "pragma": "parallel for reduction(+:jj) ", "hash": "142ef0fac76fd61e07a0a6a048019647a9a0ffcf5d3241401ecf680ebef3b6b7"}
{"code": "for(long i0=t->id;i0<t->n;i0+=mglNumThr)\r \n\t{\r \n\t\tregister long i=i0%nx, j=((i0/nx)%ny), k=i0/(nx*ny);\r \n\t\tb[i0] = dat->value(c[0]+i*c[1], c[2]+j*c[3], c[4]+k*c[5]);\r \n\t}", "pragma": "parallel ", "hash": "b7082bdf2f6a71dfd87d56411f483faa3ff018db4fe23e7fd6647844136652b8"}
{"code": "for (size_t i = 0; i < sz; ++i) { \n        AddToHashMapper_(mapper_, i, sparsity_); \n    }", "pragma": "parallel for ", "hash": "a49112b0261868e82b00f6bfef3942dc51f7104b06df03897e1753de7538ca45"}
{"code": "for (j = 0; j < size; j++) \n\tfor (i = 0; i < size; i++) \n\t\tcoeffs[j][i] = cst * exp(-(((i - size / 2)*(i - size / 2) + (j - size / 2)*(j - size / 2)) / (2 * sigma*sigma)));", "pragma": "parallel for ", "hash": "cb56df24b17106dd8332cd029de7deead110ae5ee3f6ee0559d1ce45ded3cd84"}
{"code": "for (int k = 0; k < n; k ++) { \n\t\tint tid = omp_get_thread_num(); \n\t\tint tid = 0; \n\t\tint y = lround(creal(data->reorder[k])); \n\t\tint z = lround(creal(data->reorder[k + n])); \n\t\tint t = -1; \n \n\t\tif (0 == flags[k]) { \n \n\t\t\tmd_clear(4, vec_dims, vec + (wx * nc * tf * tid), CFL_SIZE); \n \n\t\t\tfor (int i = k; i < n; i ++) { \n \n\t\t\t\tif ((y == lround(creal(data->reorder[i]))) && (z == lround(creal(data->reorder[i + n])))) { \n \n\t\t\t\t\tflags[i] = 1; \n\t\t\t\t\tt = lround(creal(data->reorder[i + 2 * n])); \n \n\t\t\t\t\tmd_copy(4, line_dims, (vec + (wx * nc * tf * tid) + t * wx * nc), (src + i * wx * nc), CFL_SIZE); \n\t\t\t\t} \n\t\t\t} \n \n\t\t\tmd_zfmacc2(4, fmac_dims, phi_out_str, perm + (y + z * sy) * (wx * nc * tk), vec_str, vec + (wx * nc * tf * tid), phi_mat_str, data->phi); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "0d03706e89f9fbf7eaa99944fe67094f4283f965d4041504564583632ae71dd1"}
{"code": "for(int i=0;i<nodes.size();i++){ \n\t            for(int j=0;j<nodes[i].neighbors().size();j++){ \n\t                Index nid = nodes[i].neighbors()[j].nodeId; \n\t                nodes[i].neighbors()[j].Ro.push_back(fabs(x_vec[i] - x_vec[nid])); \n\t            } \n\t        }", "pragma": "for ", "hash": "50786aa1303617ed9e4d057478c9c2926f8ea348dc412235c1dec6e012127c3f"}
{"code": "for (i = 1; i < n_beta; i++) { \n\t\tprintf(\"\\tChain %2d - \", i); \n\t\tfflush(stdout); \n\t\tchains[i]->additional_data \n\t\t\t\t= mem_malloc(sizeof(parallel_tempering_mcmc)); \n\t\tset_beta(chains[i], get_chain_beta(i, n_beta, beta_0)); \n\t\tgsl_vector_free(get_steps(chains[i])); \n\t\tchains[i]->params_step = dup_vector(get_steps(chains[0])); \n\t\tgsl_vector_scale(get_steps(chains[i]), pow(get_beta(chains[i]), -0.5)); \n\t\tgsl_vector_mul(get_steps(chains[i]), stepwidth_factors); \n\t\tset_params(chains[i], dup_vector(get_params_best(chains[0]))); \n\t\tcalc_model(chains[i], NULL); \n\t\tmcmc_check(chains[i]); \n\t\tprintf(\"beta = %f\\tsteps: \", get_beta(chains[i])); \n\t\tdump_vectorln(get_steps(chains[i])); \n\t\tfflush(stdout); \n\t\tmarkov_chain_calibrate(chains[i], burn_in_iterations, \n\t\t\t\tdesired_acceptance_rate, max_ar_deviation, iter_limit, mul, \n\t\t\t\tDEFAULT_ADJUST_STEP); \n\t\tburn_in(chains[i], burn_in_iterations); \n\t}", "pragma": "parallel for ", "hash": "9bc820c5f247d01377f67c3969faf1f6ea72f92ef69e020b2899be9c1d9b7856"}
{"code": "for(long i=0;i<n1*n2;i++)\tmemcpy(b+i*nx, d->a, nx*sizeof(mreal));", "pragma": "parallel for ", "hash": "2c6b496bf0db5bcc9a5e93fe1c82af6c82190e678436d347adb2e25eb3feb7a4"}
{"code": "for(long ii=t->id;ii<t->n;ii+=mglNumThr) \n\t\t{ \n\t\t\tregister long i = ii%mx, j = ii/mx, i0; \n\t\t\tfor(long k=0;k<2*dn;k++) \n\t\t\t{ \n\t\t\t\ti0 = k-dd+j*dn;\t\tff = 1; \n\t\t\t\tif(i0<0)\ti0=0;\telse if(i0>=ny)\ti0=ny-1; \n\t\t\t\tif(k<dd) \n\t\t\t\t{\tff = 0.5*(k-dd/2.)/dd;\t\tff=0.5+ff*(3-ff*ff);\t} \n\t\t\t\telse if(k>=dn+dd) \n\t\t\t\t{\tff = 0.5*(k-3.5*dd)/dd;\tff=0.5-ff*(3-ff*ff);\t} \n\t\t\t\ta[2*k] = re->v(i,i0)*ff;\ta[2*k+1] = im->v(i,i0)*ff; \n\t\t\t} \n\t\t\tmgl_fft(a, 1, 2*dn, t->v, w, false); \n\t\t\tfor(long k=0;k<dd;k++) \n\t\t\t{ \n\t\t\t\ti0 = i+mx*(j+mz*k); \n\t\t\t\td[i0+mx*mz*dd] = hypot(a[4*k],a[4*k+1])/dn; \n\t\t\t\td[i0] = hypot(a[4*k+2*dn],a[4*k+2*dn+1])/dn; \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "78dc1942a70892c6258874508208cdfb40fe065e40a6b0738d7c564a6a3ebd63"}
{"code": "for (int i = 0; i < num_iteration_for_pred_; ++i) { \n        t += models_[i * num_tree_per_iteration_ + k]->Predict(value); \n      }", "pragma": "parallel for reduction(+:t) ", "hash": "565895d7a7ea7a1a195f02ad3cbedd9e3d51cfc85772fe91bd98c89fb0727853"}
{"code": "for (uint64_t i = npGasOrDM; i < d->numParticles; i++) { \n\t\tif (d->mode->useLongIDs) { \n\t\t\t( (uint64_t *)(d->id) )[i] += npGasTotal; \n\t\t} else { \n\t\t\t( (uint32_t *)(d->id) )[i] += (uint32_t)npGasTotal; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "070e1a01442d04916d1f81f104dcc5698655a693ce1fe4973ffb7693791b8751"}
{"code": "for( size_t i = 0; i < newNbNodes.size(); ++i ) \n                { \n                    std::map< nodeID_t, dist_t >::iterator nbIter( newNbNodes.begin() ); \n                    for( int j = 0; j < i; ++j ) \n                        ++nbIter; \n \n                    bool nbIsNode( nbIter->first.first ); \n                    size_t nbId( nbIter->first.second ); \n                    dist_t newNbDist( 0 ); \n                    bool isNbActive( false ); \n \n                     \n \n \n \n                    if( nbIsNode ) \n                    {  \n \n                        if( protoNodes[nbId].isActive() ) \n                        { \n                            isNbActive = true; \n                        } \n \n                         \n \n                        newNbDist=( newTract->tractDistance( * static_cast< compactTract* >( nbTractVect[i] ) ) ); \n                    } \n                    else \n                    {  \n \n                        isNbActive = true; \n \n                         \n \n                        newNbDist=( newTract->tractDistance( * static_cast< compactTractChar* >( nbTractVect[i] ) ) ); \n                    } \n#pragma omp atomic \n                    m_numComps++; \n \n                    nbIter->second = newNbDist; \n#pragma omp critical \n                    if( isNbActive && newNbDist < newNearNb.second ) \n                    { \n                        newNearNb.second = newNbDist; \n                        newNearNb.first = nbIter->first; \n                    } \n \n                     \n \n                    protoNode* newProtoNb( fetchProtoNode( nbIter->first, &protoLeaves, &protoNodes ) ); \n \n                    bool nbhoodChanged( false ); \n                    nbhoodChanged = ( newProtoNb->updateActivhood( node2join1->getFullID(), node2join2->getFullID(), \n                                                                  std::make_pair( true, newID ),newNbDist, newIsActive, protoNodes  ) ); \n \n                    if( nbhoodChanged ) \n                    { \n                         \n \n#pragma omp critical( supernode ) \n                        { \n                            if ( !nbIsNode ) \n                            { \n                                priorityNodes.erase( priorityLeafIndex[nbId] ); \n                                priorityLeafIndex[nbId] = priorityNodes.insert( std::make_pair( newProtoNb->nearDist(), nbIter->first ) ); \n                            } \n                            else if( nodes[nbId].getSize() <= prioritySize ) \n                            { \n                                priorityNodes.erase( priorityNodeIndex[nbId] ); \n                                priorityNodeIndex[nbId] = priorityNodes.insert( std::make_pair( newProtoNb->nearDist(), nbIter->first ) ); \n                            } \n \n                        } \n                    } \n                }", "pragma": "parallel for ", "hash": "99010a540002d122b94023e50b099662e61cbbd2ed6890d1587f146fdce9556a"}
{"code": "for (i = 1; i < Noofintervals + 1; i = i+1) { \n\t\tx = h * (i + 0.5); \n                \n \n  #pragma omp critical \n\t\ttotalsum = totalsum + 4.0/(1.0 + x * x); \n\t}", "pragma": "parallel for private(x)", "hash": "c5228000fec885fef2cc0db59b61a77876e7feeddc1632714b5c746b41bbc003"}
{"code": "for( unsigned int fileIx = 0; fileIx<fileList.size(); fileIx++ ) \n    { \n        bool abortRequested = false; \n        emit checkAbort( &abortRequested ); \n \n        if( abortRequested ) \n        { \n            fileIx += 10000;  \n \n            continue; \n        } \n \n        Mat img = imread( fileList[ fileIx ].second.c_str(), 1 ); \n \n        cout << toGlobalPath( fileList[ fileIx ].second ) << endl << flush;  \n \n \n        vector< KeyPoint > keypoints; \n        detector->detect( img, keypoints ); \n \n        Mat descriptors; \n        extractor->compute( img, keypoints, descriptors ); \n \n        vector< float > histogram; \n        histogram = createHistogram( codebook, descriptors ); \n \n         \n \n        #pragma omp critical \n        { \n            labels.push_back( fileList[ fileIx ].first ); \n            histograms.push_back( histogram ); \n \n            totalFilesCount++; \n        } \n \n        emit updateProgressbar(); \n    }", "pragma": "parallel for ", "hash": "5dd11288d6f00a6cbc20d32c4fde965c88950fa857b21c5c9486a822fab29f8e"}
{"code": "for (int i = interval; i < nbLevels; ++i) \n\t\t\tscores[i].array() += bias_;", "pragma": "parallel for ", "hash": "b9863a01402847642b03b1f0e4f787bc65e37db79f9229d185024cf9e732c378"}
{"code": "for(i=0; i<size; i++){ \n    v[i] = UNI; \n  }", "pragma": "parallel for ", "hash": "4c9b6d59ec61be4571ccad4e7adc4fa36c7ad9e067076cb8004dc650c13d105a"}
{"code": "for (j = i + 1; \n\t\t    j < n; \n\t\t    j++) \n\t\t{ \n\t\t    for (k = 0; \n\t\t\tk < i; \n\t\t\tk++) \n\t\t    { \n\t\t\tB[i][j] += alpha * A[i][k] * B[j][k]; \n\t\t    } \n\t\t}", "pragma": "parallel for private(k)", "hash": "8d289db8b117e6bc54a2d784c3ce63ccc758e9c5e73ebc8e9ac1dde3a36fd4dd"}
{"code": "for(size_t k = 0; k < pixel_count; k += ch) \n  { \n    dt_aligned_pixel_t rgb = { in[k], in[k + 1], in[k + 2] }; \n \n    dt_aligned_pixel_t hsl_mix; \n    for(int i = 0, j = 0; i < 3; i++, j += 3) \n    { \n      hsl_mix[i] = clamp_simd(hsl_matrix[j + 0] * rgb[0] \n                               + hsl_matrix[j + 1] * rgb[1] \n                               + hsl_matrix[j + 2] * rgb[2]); \n    } \n \n     \n \n    if(hsl_mix[0] != 0.0 || hsl_mix[1] != 0.0 || hsl_mix[2] != 0.0) \n    { \n      dt_aligned_pixel_t hsl; \n       \n \n      for_each_channel(c) \n      { \n        rgb[c] = clamp_simd(rgb[c]); \n      } \n       \n \n      rgb2hsl(rgb, &hsl[0], &hsl[1], &hsl[2]); \n      for(int i = 0; i < 3; i++) \n      { \n        hsl[i] = (hsl_mix[i] != 0.0f) ? hsl_mix[i] : hsl[i]; \n      } \n      hsl2rgb(rgb, hsl[0], hsl[1], hsl[2]); \n    } \n \n     \n \n    for(int i = 0, j = 0; i < 3; i++, j += 3) \n    { \n      out[k + i] = fmaxf(rgb_matrix[j + 0] * rgb[0] \n                         + rgb_matrix[j + 1] * rgb[1] \n                         + rgb_matrix[j + 2] * rgb[2], 0.0f); \n    } \n  }", "pragma": "parallel for ", "hash": "4bd698f9dbcf44c4da6d7a2d2ad843644b90ae6f703dd8c2fc2de8f6600b2fad"}
{"code": "for (int y = 0; y < im.height; y += w) { \n                    vector<float> chunk(size*w, 0); \n \n                     \n \n                    for (int x = 0; x < im.width; x++) { \n                        for (int i = 0; i < w && y+i < im.height; i++) { \n                            chunk[x*w + i] = im(x, y+i, t, c); \n                        } \n                    } \n \n                     \n \n                    for (int i = 0; i < xIterations; i++) { \n                        blurChunk(&chunk[0], size, c0, c1, c2, c3); \n                        blurChunk(&chunk[0], size, c0, c1, c2, c3); \n                    } \n \n                     \n \n                    for (int x = 0; x < im.width; x++) { \n                        for (int i = 0; i < w && y+i < im.height; i++) { \n                            im(x, y+i, t, c) = chunk[x*w + i] * scale[x]; \n                        } \n                    } \n                }", "pragma": "parallel for ", "hash": "f4c4bd71622bb19c25af796bb2bc14afa5d5c089e813f7e6fb7dacf349b3359c"}
{"code": "for( int i=2; i<(l_msize[0]-2); i++){ \n    for( int j=2; j<(l_msize[1]-2); j++){ \n      for( int k=2; k<(l_msize[2]-2); k++){ \n\tint li = k + l_msize[2]*( j + l_msize[1]*i); \n\tassert( li >= 0); \n\tassert( li < ln_total); \n\tint lix2p = li + lnyz*2; \n\tint lix1p = li + lnyz; \n\tint lix2m = li - lnyz*2; \n\tint lix1m = li - lnyz; \n\tmesh_force_local[li][0] = fac1*DRHO(lix1p,lix1m) + fac2*DRHO(lix2p,lix2m); \n\tint liy2p = li + l_msize[2]*2; \n\tint liy1p = li + l_msize[2]; \n\tint liy2m = li - l_msize[2]*2; \n\tint liy1m = li - l_msize[2]; \n\tmesh_force_local[li][1] = fac1*DRHO(liy1p,liy1m) + fac2*DRHO(liy2p,liy2m); \n\tint liz2p = li + 2; \n\tint liz1p = li + 1; \n\tint liz2m = li - 2; \n\tint liz1m = li - 1; \n\tmesh_force_local[li][2] = fac1*DRHO(liz1p,liz1m) + fac2*DRHO(liz2p,liz2m); \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "bfdf5e0400e6a877e81f644a86ab3f9d02c20bb71a5578843557f5eaee46ee63"}
{"code": "for (int i = 0; i < n; i++) \n    data[i] = drand48();", "pragma": "parallel for ", "hash": "84dfa6a592b7805d0828c11d9f3b04f5ec2ea7e7169d86af9fdaa65d731847dd"}
{"code": "for(idx = 0; idx < count; ++idx) \n  { \n    dst[idx] = (short )(WLZ_CLAMP(src[idx], SHRT_MIN, SHRT_MAX)); \n  }", "pragma": "parallel for ", "hash": "cd55f522b9f164f8d23b0f19d5839346fddce8d58a69476ce6a7385da5c07cb4"}
{"code": "for (ompIndexType i = 0; i < static_cast<ompIndexType>(n); i++) { \n            double z1[2]; \n            double z3[2]; \n            z1[0] = a[2 * i]; \n            z1[1] = a[2 * i + 1]; \n            power_zi(z3, z1, b[0]); \n            c[2 * i] = static_cast<single>(z3[0]); \n            c[2 * i + 1] = static_cast<single>(z3[1]); \n        }", "pragma": "parallel for ", "hash": "e360c05caa282c6a4058ab0fb71f5d2dfb9dd4d0863a0ea324642108da0c83a3"}
{"code": "for (int i = 0; i < ids.size(); i++){\r \n\t\t \n \n\t\tvector<int> counts;\r \n\t\tfor (int i = 0; i < ppls.size(); i++){\r \n\t\t\tcounts.push_back(0);\r \n\t\t}\t\t\r \n\t\tvector<int> imgmatch;\r \n\t\tvector<int> imgcounts;\r \n\t\tfor (int j = 0; j < features.size(); j++){\r \n\t\t\t\r \n\t\t\tvector<float> code;\r \n\t\t\tfor (int k = 0; k < descriptorSize[j]; k++){\r \n\t\t\t\tcode.push_back(features[j][i*descriptorSize[j] + k]);\r \n\t\t\t}\r \n\t\t\t \n \n\t\t\tcvflann::Matrix<float> query(code.data(), 1, descriptorSize[j]);\r \n\t\t\tcvflann::Matrix<int> indices(indices_array, 1, nn);\r \n\t\t\tcvflann::Matrix<float> dists(dists_array, 1, nn);\r \n\t\t\tindex[j]->knnSearch(query, indices, dists, nn, cvflann::SearchParams(128));\r \n\t\t\t\t \n \n\t\t\tcounts[ids[indices[0][1]]]++;\r \n\t\t\t \n \n\t \n\t\t\r \n\t\t\tbool added = false;\r \n\t\t\tfor (int k = 0; k < imgmatch.size(); k++){\r \n\t\t\t\tif ( indices[0][1] == imgmatch[k]){\r \n\t\t\t\t\timgcounts[k]++;\r \n\t\t\t\t\tadded = true;\r \n\t\t\t\t\tbreak;\r \n\t\t\t\t}\r \n\t\t\t}\r \n\t\t\tif (!added){\r \n\t\t\t\timgmatch.push_back(indices[0][1]);\r \n\t\t\t\timgcounts.push_back(1);\r \n\t\t\t}\t\t\t\r \n\t\t}\r \n\t\tint maxCount = -1;\r \n\t\tint maxId = -1;\r \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tfor (int j = 0; j < counts.size(); j++){\r \n\t\t\tif (counts[j] >= maxCount){\r \n\t\t\t\tmaxCount = counts[j];\r \n\t\t\t\tmaxId = j;\r \n\t\t\t}\r \n\t\t}\r \n\t\tcout<<ids[i]<<\" \"<<maxId<<\" \"<<maxCount<<endl;\r \n\t\t\r \n\t\tomp_set_lock(&writelock);\r \n\t\tif (maxId == ids[i]){\r \n\t\t\tcorrect++;\r \n\t\t\tsuccess_num.push_back(maxCount);\r \n\t\t}\r \n\t\telse{\r \n\t\t\tfail_num.push_back(maxCount);\r \n\t\t}\r \n\t\tomp_unset_lock(&writelock);\r \n\t}", "pragma": "parallel ", "hash": "87d500e45d9ebf2517ca3ada4fee8756f48fdf690e24c23da657eb854b3222fd"}
{"code": "for(size_type thread = 0; thread < threads; thread++) \n  { \n    for(range_type range = firstRange(paths, labels, bounds[thread]); range.first <= bounds[thread].second; \n      range = nextRange(range, paths, labels, bounds[thread])) \n    { \n      if(sameFrom(range, paths)) \n      { \n        range_type range_lcp = extendRange(range, paths, labels, lcp, bounds[thread]); \n        mergePathNodes(paths, labels, range, range_lcp, lcp); \n        paths[tail[thread]] = paths[range.first]; \n        tail[thread]++; unique[thread]++; \n      } \n      else \n      { \n        for(size_type i = range.first; i <= range.second; i++) \n        { \n          if(paths[i].sorted()) { nondeterministic[thread]++; } \n          else { unsorted[thread]++; } \n          paths[tail[thread]] = paths[i]; \n          tail[thread]++; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "b38c2a320e171d6cf1b4fb21f9647b5eea80f8ccb62d1075dd706e1fc2909d53"}
{"code": "for(i = 0; i < ninpoin; i++) \n\t{ \n\t\tdouble* sum = new double[ndim];\t\t \n \n\t\tdouble* psum = new double[ndim];\t \n \n \n\t\tint j; \n\t\tfor(j = 0; j < ndim; j++) \n\t\t{ \n\t\t\tsum[j] = 0; \n\t\t\tpsum[j] = 1.0; \n\t\t} \n \n\t\t \n \n\t\tfor(j = 0; j < nbpoin; j++) \n\t\t{ \n\t\t\tdouble dist = 0; \n\t\t\tfor(int idim = 0; idim < ndim; idim++) \n\t\t\t\tdist += (ip->get(i,idim)-bp->get(j,idim))*(ip->get(i,idim)-bp->get(j,idim)); \n\t\t\tdist = sqrt(dist); \n \n\t\t\tif(dist < srad)\t \n\t\t\t\tfor(int idim = 0; idim < ndim; idim++) \n\t\t\t\t\tsum[idim] += co[idim].get(j) * (this->*rbfunc)(dist); \n\t\t} \n \n\t\t \n \n\t\t \n \n \n\t\tfor(int idim = 0; idim < ndim; idim++) \n\t\t{ \n\t\t\t(*ip)(i,idim) += sum[idim]; \n\t\t} \n \n\t\tdelete [] sum; \n\t\tdelete [] psum; \n\t}", "pragma": "parallel for private(i)", "hash": "73a67616cde080fe186c8a67d9388b6f5bf408020d8783c193b8809d0a99627a"}
{"code": "for (lp=0; lp<iter; lp = lp + (2*incr - decr)) { \n    buf[lp] += omp_get_thread_num (); \n  }", "pragma": "for ", "hash": "7c72c8f8e7d23ec5576cb47338e4249080fda76f21cfa8d5e6afcb6885e70e04"}
{"code": "for ( int y = 0; y < static_cast<int>( p_header->height ); y++ ) { \n            uint32 curPixel = ( y * p_header->width ); \n \n            for ( uint x = 0; x < p_header->width; x++ ) { \n                po_colors[curPixel].r = ( pixelData[curPixel] & p_header->pixelFormat.rBitMask ) >> shift.r; \n                po_colors[curPixel].g = ( pixelData[curPixel] & p_header->pixelFormat.gBitMask ) >> shift.g; \n                po_colors[curPixel].b = ( pixelData[curPixel] & p_header->pixelFormat.bBitMask ) >> shift.b; \n \n                if ( hasAlpha ) { \n                    po_alphas[curPixel] = ( pixelData[curPixel] & p_header->pixelFormat.aBitMask ) >> shift.a; \n                } \n \n                curPixel++; \n            } \n        }", "pragma": "parallel for ", "hash": "e3a4e327e80dd0bbeced3dc914d4af642fd6e765f2f06813897d07f9363f378d"}
{"code": "for (int f1 = 0; f1 < nfeat; f1++) { \n     \n \n    for (int i = A.Mt.row_ptr[f1], end = A.Mt.row_ptr[f1 + 1]; i < end; i++) { \n      int Mrow     = A.Mt.cols[i];  \n \n      double val1  = A.Mt.vals[i];  \n \n \n      for (int j = A.M.row_ptr[Mrow], end2 = A.M.row_ptr[Mrow + 1]; j < end2; j++) { \n        int f2 = A.M.cols[j]; \n        if (f1 <= f2) { \n          out(f2, f1) += A.M.vals[j] * val1; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "c95e5f8c01c6704fcf303860e25d92b456e56cbe982d4b6515c8b4d9f4f72393"}
{"code": "for(k = 0; k < size; k++) \n            current_product += x_ptr[k] * hypre_conj(y_ptr[k]);", "pragma": "parallel for reduction(+:current_product) private(k)", "hash": "42641571d1d4eb56f6b24cf9a153e31eb2db0f4f5763fd299a1391f10533762e"}
{"code": "for (size_t i = 0;i < vectorSize;i++) \n\t\t{ \n\t\t\tif (symbol == alphabet[i]) \n\t\t\t{ \n\t\t\t\tfound = true; \n\t\t\t\tbreak; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "e4f4c8db2b1f4dc583e3fe0944ce6d080d1398e19cb8c605447d400ec4257ebf"}
{"code": "for (unsigned int i=0; i < vertices.size(); ++i) \n\t{ \n\t\tCTimer timer; \n\t\tdouble tim; \n\t\ttimer.tic(); \n\t\tint best = 0; \n\t\tfl_double_t maximum = -FL_DBL_MAX; \n \n\t\tfor (unsigned int j=0; j < q[i].size(); ++j) \n\t\t{ \n\t\t\t \n \n\t\t\tstd::string appearance_type = vertices[i].appearances[j]->getType(); \n\t\t\tEAppearanceModelType type = SPARSE_LBP; \n \n\t\t\tif (appearance_type.compare(\"SPARSE_LBP\")==0) \n\t\t\t{ \n\t\t\t\ttype = SPARSE_LBP; \n\t\t\t} \n \n\t\t\tswitch (type) \n\t\t\t{ \n\t\t\t\tcase SPARSE_LBP: \n\t\t\t\t\tvertices[i].appearances[j]->update_optimized( \n\t\t\t\t\t\t\t\tNFfeaturesPool->getFeaturesFromPool(0), \n\t\t\t\t\t\t\t\tw[i][j], q[i][j], &groundTruthPositionsNF[INDEX(0, i, 2)]); \n\t\t\t\tbreak; \n\t\t\t\tcase EXTENDED_SPARSE_LBP: \n\t\t\t\t\t \n \n\t\t\t\tbreak; \n\t\t\t\tcase HOG: \n\t\t\t\t\t \n \n\t\t\t\tbreak; \n\t\t\t} \n \n\t\t\tfl_double_t sum = 0.0; \n\t\t\t \n \n\t\t\tfor (int k=0; k < vertices[i].appearances[j]->getLength(); ++k) \n\t\t\t\tsum += q[i][j][k]; \n \n\t\t\tif (sum > maximum) \n\t\t\t{ \n\t\t\t\tmaximum = sum; \n\t\t\t\tbest = j; \n\t\t\t} \n\t\t} \n \n\t\tvertices[i].best = best; \n\t\ttim = timer.toc(); \n\t\tstd::cout << \"GetQG: Node \" << i << \" took \" << tim << \" ms\" << std::endl; \n\t}", "pragma": "parallel for ", "hash": "248aab20c7091ffac331a29cd1a8091597b2b8a2fdef5fd5ebd57243759412af"}
{"code": "for (int i = 0; i < n; i++) { \n                msk.run(dis_tables + i * pq.ksub * pq.M, \n                        pq.ksub, \n                        distances + i * k, \n                        labels + i * k); \n            }", "pragma": "for ", "hash": "1139397f7edb53e8c1d0e88d0e87a0a56e9c3de23790280868dd4ff7b1eea5e9"}
{"code": "for    (ix=0; ix<fdm->nxpad; ix++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tup[ix][iz] = 2*uo[ix][iz]  \n\t\t    -          um[ix][iz]  \n\t\t    +          ua[ix][iz] * vt[ix][iz]; \n\t\tum[ix][iz] = ua[ix][iz]*dv[ix][iz]; \n\t    } \n\t}", "pragma": "parallel for private(ix iz)", "hash": "98ba4a3dd8463902ef45e8484663bbfddb432c0b249fecc3bfd6b1bb7620cee5"}
{"code": "for (int i = 0; \n             i < end_int; \n             ++i) { \n            this->cells[i]->computeFintGaussPoints(); \n        }", "pragma": "parallel for ", "hash": "2f35371e9e90cf0e238efc231e54c71c9defc34a2c0134b000750cb212ff64fb"}
{"code": "for (i=1; i<n; i++) \n  { \n    if (fabs(x[i]) < min) \n    { \n      min = x[i]; \n      ret = i; \n    } \n  }", "pragma": "parallel for simd ", "hash": "9b3d3b157200b4423239a8eacf5b9ac354391ce91ff8aaf333d6e6ba749d0ef6"}
{"code": "for(size_t i=0; i<np; i++) { \n    Float x= p[i].x[0]*dx_inv; \n    Float y= p[i].x[1]*dx_inv; \n    Float z= p[i].x[2]*dx_inv; \n \n    assert(0 <= x && x <= nc && \n\t   0 <= y && y < nc && \n\t   0 <= z && z < nc); \n \n \n    int ix0= (int) x; \n    int iy0= (int) y; \n    int iz0= (int) z; \n     \n    Float wx1= x - ix0; \n    Float wy1= y - iy0; \n    Float wz1= z - iz0; \n \n    Float wx0= 1 - wx1; \n    Float wy0= 1 - wy1; \n    Float wz0= 1 - wz1; \n \n    if(ix0 >= nci) ix0= 0; \n    if(iy0 >= nci) iy0= 0; \n    if(iz0 >= nci) iz0= 0; \n \n    assert(0 <= ix0 && ix0 < nci && \n\t   0 <= iy0 && iy0 < nci && \n\t   0 <= iz0 && iz0 < nci); \n \n             \n    int ix1= ix0 + 1; if(ix1 >= nci) ix1 -= nci; \n    int iy1= iy0 + 1; if(iy1 >= nci) iy1 -= nci; \n    int iz1= iz0 + 1; if(iz1 >= nci) iz1 -= nci; \n \n    assert(0 <= ix1 && ix1 < nci && \n\t   0 <= iy1 && iy1 < nci && \n\t   0 <= iz1 && iz1 < nci); \n \n    ix0 -= local_ix0; \n    ix1 -= local_ix0; \n \n    f[i][axis]= 0; \n \n    if(0 <= ix0 && ix0 < static_cast<int>(local_nx)) { \n      f[i][axis] +=  \n\tgrid_val(fx, ix0, iy0, iz0)*wx0*wy0*wz0 + \n\tgrid_val(fx, ix0, iy0, iz1)*wx0*wy0*wz1 + \n\tgrid_val(fx, ix0, iy1, iz0)*wx0*wy1*wz0 + \n\tgrid_val(fx, ix0, iy1, iz1)*wx0*wy1*wz1; \n    } \n    if(0 <= ix1 && ix1 < static_cast<int>(local_nx)) { \n      f[i][axis] +=  \n\tgrid_val(fx, ix1, iy0, iz0)*wx1*wy0*wz0 + \n\tgrid_val(fx, ix1, iy0, iz1)*wx1*wy0*wz1 + \n\tgrid_val(fx, ix1, iy1, iz0)*wx1*wy1*wz0 + \n\tgrid_val(fx, ix1, iy1, iz1)*wx1*wy1*wz1; \n    } \n  }", "pragma": "parallel for ", "hash": "e16dfaf49692cc328c19439fb335462edc577d8c622d31d665afdc958a8f26ab"}
{"code": "for(int i = 0; i < nLat; i++) { \n         for(int j = 0; j < nLon; j++) { \n            int Icenter = nearestI[i][j]; \n            int Jcenter = nearestJ[i][j]; \n            assert(Icenter < ielevs.size()); \n            assert(Jcenter < ielevs[Icenter].size()); \n            for(int e = 0; e < nEns; e++) { \n               float currElev = oelevs[i][j]; \n               float nearestElev = ielevs[Icenter][Jcenter]; \n               if(!Util::isValid(currElev) || !Util::isValid(nearestElev)) { \n                   \n \n                  ofield(i,j,e) = ifield(Icenter,Jcenter,e); \n               } \n               else { \n                  float nearestPressure = ifield(Icenter,Jcenter,e); \n                  float currPressure = calcPressure(nearestElev, nearestPressure, currElev); \n                  ofield(i,j,e) = currPressure; \n               } \n            } \n         } \n      }", "pragma": "parallel for ", "hash": "d4ab56b525b38b748c2fc994af5517814ca16930e5c1cfe9ef3277126ebf11cf"}
{"code": "for (int i = 0; i < m_threadedNodes[0].size(); i++) { \n                auto& node = m_threadedNodes[0][i]; \n                if (node.isLeaf()) { \n                    node.triid += m_offsetTriIdx; \n                } \n            }", "pragma": "parallel for ", "hash": "2c1205c7c9fef1aefc2c219ed98fecebf5695620714211f942d126c528b9e5c1"}
{"code": "for(i=0; i<size; i++){ \n    v1[i] = VNI; \n    v2[i] = VNI; \n  }", "pragma": "parallel for ", "hash": "c53eab863a95f8a8ce81d90a6bf781ccaaa2c859f28af7222950406dc5049717"}
{"code": "for( i = 0 ; i < count ; i++ ) { \n      triple[i] = (int*)malloc( 3 *  sizeof (int ) ) ; \n    }", "pragma": "parallel for private(i)", "hash": "20308cd364b0d3063156befd7edd7a1738d803860d370f2a5bb34372f783dde8"}
{"code": "for(int i = 0; i < n_samples; ++i) \n    { \n         \n \n        int64_t source_pair_idx = rand() % total_pairs; \n        std::string r1 = BWTAlgorithms::extractString(index_set.pBWT, source_pair_idx * 2); \n        std::string r2 = BWTAlgorithms::extractString(index_set.pBWT, source_pair_idx * 2 + 1); \n \n         \n \n         \n \n        std::string k1 = \"$\" + r1.substr(0, k); \n        std::string k2 = \"$\" + r2.substr(0, k); \n \n        BWTInterval i1 = BWTAlgorithms::findInterval(index_set.pBWT, k1); \n        BWTInterval i2 = BWTAlgorithms::findInterval(index_set.pBWT, k2); \n \n        std::vector<int64_t> pair_ids; \n        for(int64_t j = i1.lower; j <= i1.upper; ++j) \n        { \n            int64_t read_id = index_set.pSSA->lookupLexoRank(j); \n            if(read_id % 2 == 1) \n                continue; \n             \n            int64_t pair_id = read_id % 2 == 0 ? read_id / 2 : (read_id - 1) / 2; \n            if(pair_id != source_pair_idx) \n                pair_ids.push_back(pair_id); \n        } \n \n        for(int64_t j = i2.lower; j <= i2.upper; ++j) \n        { \n            int64_t read_id = index_set.pSSA->lookupLexoRank(j); \n            if(read_id % 2 == 0) \n                continue; \n            int64_t pair_id = read_id % 2 == 0 ? read_id / 2 : (read_id - 1) / 2; \n            if(pair_id != source_pair_idx) \n                pair_ids.push_back(pair_id); \n        } \n \n        std::sort(pair_ids.begin(), pair_ids.end()); \n        std::vector<int64_t>::iterator iter =  \n            std::adjacent_find(pair_ids.begin(), pair_ids.end()); \n                                            \n        bool has_duplicate = iter != pair_ids.end(); \n        #pragma omp critical \n        { \n            num_pairs_checked += 1; \n            num_duplicates += has_duplicate; \n        } \n    }", "pragma": "parallel for ", "hash": "f19c8a2e2c02eb9bf63503aac140c1a586a174eb81797880464ec1ca14457495"}
{"code": "for (i = 0; i < nlocal; i++) \n    if (mask[i] & groupbit) { \n      const double dtfm = dtf / rmass[i]; \n      v[i][0] += dtfm * f[i][0]; \n      v[i][1] += dtfm * f[i][1]; \n      v[i][2] += dtfm * f[i][2]; \n \n      const double dtirotate = dtfrotate / (radius[i]*radius[i]*rmass[i]); \n      omega[i][0] += dtirotate * torque[i][0]; \n      omega[i][1] += dtirotate * torque[i][1]; \n      omega[i][2] += dtirotate * torque[i][2]; \n    }", "pragma": "parallel for private(i)", "hash": "8b21f6622e4c8c0347b2625adf31dca9ee85995a529966584abf3678ad35fea0"}
{"code": "for (size_t c = summary::offset::nongrid; \n                c < summary::nscalars::total; \n                ++c) { \n \n                INFO0(who, \"Processing component \" << summary::name[c]); \n \n                 \n \n                data.setConstant(final.y().size(), t.size(), \n                                 numeric_limits<real_t>::quiet_NaN()); \n                size_t off = 0; \n                for (summary_pool_type::const_iterator i = pool.begin(); \n                    i != pool.end(); ++i) { \n                    data.col(off++) = i->second->storage.col(c); \n                } \n \n                 \n \n                dtstats = arsel(final.y().size(), t, data.data(), \n                                final.y().size(), arspec, \n                                eff_N, eff_var, mu, mu_sigma, p, T); \n \n                 \n \n                 \n \n                assert(final.storage.col(c).innerStride() == 1); \n                std::copy(mu.begin(), mu.end(), final.storage.col(c).data()); \n \n                 \n \n                 \n \n                 \n \n                #pragma omp critical \n                { \n                    const char * const name = summary::name[c]; \n                    std::ostringstream comment; \n                    comment << \"Instantaneous planar averages of \" \n                            << summary::description[c] \n                            << \" versus /y and /t.\" \n                               \"  Attributes 'mu' and 'mu_sigma' are\" \n                               \" the ensemble mean and its estimated\" \n                               \" standard error versus /y.\" \n                               \"  Other attributes capture outputs from\" \n                               \" the autoregressive sampling uncertainty\" \n                               \" estimator (doi:10.1063/1.4866813)\" \n                               \" versus /y and require care to interpret.\"; \n                    esio_plane_write(h.get(), name, data.data(), \n                                     data.outerStride(), \n                                     data.innerStride(), \n                                     comment.str().c_str()); \n                    esio_attribute_writev(h.get(), name, \"eff_N\", \n                            eff_N.data(), eff_N.size()); \n                    esio_attribute_writev(h.get(), name, \"eff_var\", \n                            eff_var.data(), eff_var.size()); \n                    esio_attribute_writev(h.get(), name, \"mu\", \n                            mu.data(), mu.size()); \n                    esio_attribute_writev(h.get(), name, \"mu_sigma\", \n                            mu_sigma.data(), mu_sigma.size()); \n                    esio_attribute_writev(h.get(), name, \"p\", \n                            p.data(), p.size()); \n                    esio_attribute_writev(h.get(), name, \"T\", \n                            T.data(), T.size()); \n                } \n            }", "pragma": "for private(dtstats)", "hash": "edd691002dcb32ec3beaa3eecbfcb250fe84f1bc3b141a4a8f3f11371092223a"}
{"code": "for (p = s; p != r; p -= 1) \n    bar (p);", "pragma": "for ", "hash": "a699687ed13ee78c6269661bb1b21f05c089bb341a910698c35f0fec352f6d22"}
{"code": "for(ix = 0; ix < (VOLUME); ix++){ \n    rr = (*(l + ix)); \n     \n \n \n     \n \n    _vector_minus_assign(rr.s2, rr.s2); \n    _vector_minus_assign(rr.s3, rr.s3); \n \n     \n \n \n    iy=g_iup[ix][0]; \n \n    sp = k + iy; \n    up=&hf->gaugefield[ix][0]; \n       \n    _vector_add(psia,(*sp).s0,(*sp).s2); \n    _vector_add(psib,(*sp).s1,(*sp).s3); \n       \n    _vector_add(phia,rr.s0,rr.s2); \n    _vector_add(phib,rr.s1,rr.s3); \n \n    _vector_tensor_vector_add(v1, phia, psia, phib, psib); \n    _su3_times_su3d(v2,*up,v1); \n    _complex_times_su3(v1,ka0,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[ix][0], 2.*factor, v1); \n \n     \n \n \n    iy=g_idn[ix][0]; \n \n    sm = k + iy; \n    um=&hf->gaugefield[iy][0]; \n       \n    _vector_sub(psia,(*sm).s0,(*sm).s2); \n    _vector_sub(psib,(*sm).s1,(*sm).s3); \n \n    _vector_sub(phia,rr.s0,rr.s2); \n    _vector_sub(phib,rr.s1,rr.s3); \n \n    _vector_tensor_vector_add(v1, psia, phia, psib, phib); \n    _su3_times_su3d(v2,*um,v1); \n    _complex_times_su3(v1,ka0,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[iy][0], 2.*factor, v1); \n \n     \n \n \n    iy=g_iup[ix][1]; \n \n    sp = k + iy; \n    up=&hf->gaugefield[ix][1];       \n \n    _vector_i_add(psia,(*sp).s0,(*sp).s3); \n    _vector_i_add(psib,(*sp).s1,(*sp).s2); \n \n    _vector_i_add(phia,rr.s0,rr.s3); \n    _vector_i_add(phib,rr.s1,rr.s2); \n \n    _vector_tensor_vector_add(v1, phia, psia, phib, psib); \n    _su3_times_su3d(v2,*up,v1); \n    _complex_times_su3(v1,ka1,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[ix][1], 2.*factor, v1); \n \n     \n \n \n    iy=g_idn[ix][1]; \n \n    sm = k + iy; \n    um=&hf->gaugefield[iy][1]; \n       \n    _vector_i_sub(psia,(*sm).s0,(*sm).s3); \n    _vector_i_sub(psib,(*sm).s1,(*sm).s2); \n \n    _vector_i_sub(phia,rr.s0,rr.s3); \n    _vector_i_sub(phib,rr.s1,rr.s2); \n \n    _vector_tensor_vector_add(v1, psia, phia, psib, phib); \n    _su3_times_su3d(v2,*um,v1); \n    _complex_times_su3(v1,ka1,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[iy][1], 2.*factor, v1); \n \n     \n \n \n    iy=g_iup[ix][2]; \n \n    sp = k + iy; \n    up=&hf->gaugefield[ix][2]; \n       \n    _vector_add(psia,(*sp).s0,(*sp).s3); \n    _vector_sub(psib,(*sp).s1,(*sp).s2); \n       \n    _vector_add(phia,rr.s0,rr.s3); \n    _vector_sub(phib,rr.s1,rr.s2); \n \n    _vector_tensor_vector_add(v1, phia, psia, phib, psib); \n    _su3_times_su3d(v2,*up,v1); \n    _complex_times_su3(v1,ka2,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[ix][2], 2.*factor, v1); \n \n     \n \n \n    iy=g_idn[ix][2]; \n \n    sm = k + iy; \n    um=&hf->gaugefield[iy][2]; \n       \n    _vector_sub(psia,(*sm).s0,(*sm).s3); \n    _vector_add(psib,(*sm).s1,(*sm).s2); \n \n    _vector_sub(phia,rr.s0,rr.s3); \n    _vector_add(phib,rr.s1,rr.s2); \n \n    _vector_tensor_vector_add(v1, psia, phia, psib, phib); \n    _su3_times_su3d(v2,*um,v1); \n    _complex_times_su3(v1,ka2,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[iy][2], 2.*factor, v1); \n \n     \n \n \n    iy=g_iup[ix][3]; \n \n    sp = k + iy; \n    up=&hf->gaugefield[ix][3]; \n       \n    _vector_i_add(psia,(*sp).s0,(*sp).s2); \n    _vector_i_sub(psib,(*sp).s1,(*sp).s3); \n \n    _vector_i_add(phia,rr.s0,rr.s2); \n    _vector_i_sub(phib,rr.s1,rr.s3); \n \n    _vector_tensor_vector_add(v1, phia, psia, phib, psib); \n    _su3_times_su3d(v2,*up,v1); \n    _complex_times_su3(v1,ka3,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[ix][3], 2.*factor, v1); \n \n     \n \n \n    iy=g_idn[ix][3]; \n \n    sm = k + iy; \n    um=&hf->gaugefield[iy][3]; \n       \n    _vector_i_sub(psia,(*sm).s0,(*sm).s2); \n    _vector_i_add(psib,(*sm).s1,(*sm).s3); \n \n    _vector_i_sub(phia,rr.s0,rr.s2); \n    _vector_i_add(phib,rr.s1,rr.s3); \n \n    _vector_tensor_vector_add(v1, psia, phia, psib, phib); \n    _su3_times_su3d(v2,*um,v1); \n    _complex_times_su3(v1,ka3,v2); \n    _trace_lambda_mul_add_assign_nonlocal(hf->derivative[iy][3], 2.*factor, v1); \n      \n     \n \n  }", "pragma": "for ", "hash": "fd123b0b722bc14fb864acaf71016529f8eaaa70ea35fbf3ffe3c3a847322b85"}
{"code": "for (p = q; p != r; p = 4 + p)\t \n \n    bar (p);", "pragma": "for ", "hash": "636b24ecf183d37b5b7623cf9bc9bf7bdeb76afe0c04bc7e217118844501e3b8"}
{"code": "for (unsigned x=0; x<w; x++) { \n\t\t\tfor (unsigned y=0; y<h; y++) { \n\t\t\t\tunsigned pos = x + y*w; \n\t\t\t\timage[pos].g -= subtract; if (clampblack & image[pos].g < 0.0) image[pos].g = 0.0; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "f5607f38ea9313f90c4d73ba7cb446932e9d52755125ad029acb16ba9eaef56b"}
{"code": "for (i = 0; i < (int)n_int; i++) \n\t\t\t\ttmp += func(a + float(i * h));", "pragma": "for private(i)", "hash": "35b1807d0e0bfcdfba3abda0c99eacc0a3c4a1312a85b0539e19d81a518fb286"}
{"code": "for (int y = 0; y<h; y++) \n\t{ \n\t\tfor (int x = 0; x<w; x++) \n\t\t{ \n\t\t\tint index = mem_index(x, y, el); \n \n\t\t\tdata[el].vx[index] = X(y*w + x, 0); \n\t\t\tdata[el].vy[index] = Y(y*w + x, 0); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "3b054f69b3e42e6c527c5602c2140303a438d07f97183c7b86640d925ba96441"}
{"code": "for (i = 0; i < LOOPCOUNT; ++i) \n            { \n                 <ompts:check>#pragma omp atomic</ompts:check> \n                 exclusiv_bit_or ^= logics[i]; \n            }", "pragma": "for ", "hash": "05fa9c2b8e093821af29968de33ecba47f3910405f310ca61509e16054791983"}
{"code": "for (int i1=0; i1 < read->shape()[1]; ++i1) { \n                float sum = 0.0; \n            #pragma omp parallel for reduction(+ : sum) \n            for (int i0=0; i0 < read->shape()[0]; ++i0) {  \n                float x = write->at<float>(0,i1); \n                float y = read->at<float>(i0,i1) ; \n                 \n \n                 sum += y ;  \n \n            } \n              write->at<float>(0,i1) = sum ; \n              }", "pragma": "parallel for ", "hash": "366caa937b8dd23efb920acbca5a4e7ff19026a667b7f18fdcae266957124dd4"}
{"code": "for (ij = 0; ij < nbas*nbas; ij++) { \n                i = ij / nbas; \n                j = ij - nbas*i; \n                di = CINTcgto_spheric(i, bas); \n                dj = CINTcgto_spheric(j, bas); \n                for (kl = 0; kl < nbas*(nbas+1)/2; kl++) { \n                        k = ishls[kl]; \n                        l = jshls[kl]; \n                        dk = CINTcgto_spheric(k, bas); \n                        dl = CINTcgto_spheric(l, bas); \n                        shls[0] = i; \n                        shls[1] = j; \n                        shls[2] = k; \n                        shls[3] = l; \n                        buf = malloc(sizeof(double) * di*dj*dk*dl*3); \n                        cint2e_ip1_sph(buf, shls, atm, natm, bas, nbas, env, opt_for_ip1); \n                        free(buf); \n                } \n                count += nbas*(nbas+1)/2; \n                if (100*count/((long)nbas*nbas*nbas*(nbas+1)/2) > pct) { \n                        pct++; \n                        time1 = omp_get_wtime(); \n                        printf(\"\\t%d%%, CPU time = %8.2f\\r\", pct, \n                               time1-time0); \n                        fflush(stdout); \n                } \n        }", "pragma": "for ", "hash": "c0b51cad2da78cb12d65d7797370e0eabf5123e0c3a5ac227db0b9f082a74653"}
{"code": "for(i=0; i<m->num_faces; ++i) \n        { \n            if((m2->ffaces[i].faces = (INTDATA *)malloc(sizeof(INTDATA)*(m->ffaces[i].num_faces)))==NULL) mesh_error(MESH_ERR_MALLOC); \n            memcpy(m2->ffaces[i].faces, m->ffaces[i].faces, sizeof(INTDATA)*(m->ffaces[i].num_faces)); \n            m2->ffaces[i].num_faces = m->ffaces[i].num_faces; \n        }", "pragma": "parallel for ", "hash": "8760c07a595752c312b3c1530690e15472c5175efd02ea629d3aa2560eb14a58"}
{"code": "for (int i=0; i<(int)nViews; ++i) { \n\t\t\tconst Views::value_type& view = views[i]; \n   #pragma omp critical \n\t\t\tmap_view[view.first] = scene.images.GetSize(); \n\t\t#else \n\t\tfor (const auto& view : sfm_data.GetViews()) { \n\t\t\tmap_view[view.first] = scene.images.GetSize(); \n\t\t#endif \n\t\t\tMVS::Image& image = scene.images.AddEmpty(); \n\t\t\timage.name = view.second->s_Img_path; \n\t\t\tUtil::ensureUnifySlash(image.name); \n\t\t\tUtil::strTrim(image.name, PATH_SEPARATOR_STR); \n\t\t\tString pathRoot(sfm_data.s_root_path); Util::ensureDirectorySlash(pathRoot); \n\t\t\tconst String srcImage(MAKE_PATH_FULL(WORKING_FOLDER_FULL, pathRoot+image.name)); \n\t\t\timage.name = MAKE_PATH_FULL(WORKING_FOLDER_FULL, OPT::strOutputImageFolder+image.name); \n\t\t\tUtil::ensureDirectory(image.name); \n\t\t\timage.ID = static_cast<MVS::IIndex>(view.first); \n\t\t\timage.platformID = map_intrinsic.at(view.second->id_intrinsic); \n\t\t\tMVS::Platform& platform = scene.platforms[image.platformID]; \n\t\t\timage.cameraID = 0; \n\t\t\tif (sfm_data.IsPoseAndIntrinsicDefined(view.second.get()) && \n\t\t\t\tFile::access(srcImage)) { \n\t\t\t\tMVS::Platform::Pose* pPose; \n\t\t\t\t#ifdef _USE_OPENMP \n    #pragma omp critical \n\t\t\t\t#endif \n\t\t\t\t{ \n\t\t\t\timage.poseID = platform.poses.GetSize(); \n\t\t\t\tpPose = &platform.poses.AddEmpty(); \n\t\t\t\t++scene.nCalibratedImages; \n\t\t\t\t} \n\t\t\t\tconst openMVG::geometry::Pose3 poseMVG(sfm_data.GetPoseOrDie(view.second.get())); \n\t\t\t\tpPose->R = poseMVG.rotation(); \n\t\t\t\tpPose->C = poseMVG.center(); \n\t\t\t\t \n \n\t\t\t\tconst openMVG::cameras::IntrinsicBase * cam = sfm_data.GetIntrinsics().at(view.second->id_intrinsic).get(); \n\t\t\t\tif (cam->have_disto())  { \n\t\t\t\t\t \n \n\t\t\t\t\topenMVG::image::Image<openMVG::image::RGBColor> imageRGB, imageRGB_ud; \n\t\t\t\t\topenMVG::image::ReadImage(srcImage, &imageRGB); \n\t\t\t\t\topenMVG::cameras::UndistortImage(imageRGB, cam, imageRGB_ud, openMVG::image::BLACK); \n\t\t\t\t\topenMVG::image::WriteImage(image.name, imageRGB_ud); \n\t\t\t\t} else  { \n\t\t\t\t\t \n \n\t\t\t\t\tFile::copyFile(srcImage, image.name); \n\t\t\t\t} \n\t\t\t\t++nPoses; \n\t\t\t} else { \n\t\t\t\t \n \n\t\t\t\timage.poseID = NO_ID; \n\t\t\t\t \n \n\t\t\t\tFile::copyFile(srcImage, image.name); \n\t\t\t\tDEBUG_EXTRA(\"warning: uncalibrated image '%s'\", view.second->s_Img_path.c_str()); \n\t\t\t} \n\t\t\t++progress; \n\t\t}", "pragma": "parallel for ", "hash": "10daa0a699e72f5832025a3fa87084f9db67c04002e63f6ce651c43395a236ff"}
{"code": "for (unsigned int i = 0; i < surfaces.size(); i++) \n    { \n      if((!(surfaces.at(i)->isNew)) || (!(surfaces.at(i)->selected)) || (!(surfaces.at(i)->valid)) || (surfaces.at(i)->type != pcl::SACMODEL_PLANE)) \n \n        continue; \n       \n      replacePlaneWithBetterNurbs(surfaces.at(i)); \n    }", "pragma": "parallel for ", "hash": "850b43d4fafc0f303046512d098f624783acf4e1835c6cdcb9fddfe8ea2dac98"}
{"code": "for ( n = 0; n < grid_size; ++n ) \n    { \n      grad_lat[n] = ZERO; \n      grad_lon[n] = ZERO; \n      grad_latlon[n] = ZERO; \n \n      if ( grid.mask[n] ) \n\t{ \n\t  delew = HALF; \n\t  delns = HALF; \n \n\t  j = n/nx + 1; \n\t  i = n - (j-1)*nx + 1; \n \n\t  ip1 = i + 1; \n\t  im1 = i - 1; \n\t  jp1 = j + 1; \n\t  jm1 = j - 1; \n \n\t  if ( ip1 > nx ) ip1 = ip1 - nx; \n\t  if ( im1 <  1 ) im1 = nx; \n\t  if ( jp1 > ny ) \n\t    { \n              jp1 = j; \n              delns = ONE; \n            } \n\t  if ( jm1 < 1 ) \n\t    { \n              jm1 = j; \n              delns = ONE; \n            } \n \n\t  in  = (jp1-1)*nx + i - 1; \n\t  is  = (jm1-1)*nx + i - 1; \n\t  ie  = (j  -1)*nx + ip1 - 1; \n\t  iw  = (j  -1)*nx + im1 - 1; \n \n\t  ine = (jp1-1)*nx + ip1 - 1; \n\t  inw = (jp1-1)*nx + im1 - 1; \n\t  ise = (jm1-1)*nx + ip1 - 1; \n\t  isw = (jm1-1)*nx + im1 - 1; \n \n\t   \n \n \n\t  if ( ! grid.mask[ie] ) \n\t    { \n              ie = n; \n              delew = ONE; \n            } \n\t  if ( ! grid.mask[iw] ) \n\t    { \n              iw = n; \n              delew = ONE; \n            } \n  \n\t  grad_lat[n] = delew*(array[ie] - array[iw]); \n \n\t   \n \n \n\t  if ( ! grid.mask[in] ) \n\t    { \n              in = n; \n              delns = ONE; \n            } \n\t  if ( ! grid.mask[is] ) \n\t    { \n              is = n; \n              delns = ONE; \n            } \n  \n\t  grad_lon[n] = delns*(array[in] - array[is]); \n \n\t   \n \n \n\t  delew = HALF; \n\t  if ( jp1 == j || jm1 == j ) \n\t    delns = ONE; \n\t  else  \n\t    delns = HALF; \n \n\t  if ( ! grid.mask[ine] ) \n\t    { \n              if ( in != n ) \n\t\t{ \n\t\t  ine = in; \n\t\t  delew = ONE; \n\t\t} \n              else if ( ie != n ) \n\t\t{ \n\t\t  ine = ie; \n\t\t  inw = iw; \n\t\t  if ( inw == n ) delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n              else \n\t\t{ \n\t\t  ine = n; \n\t\t  inw = iw; \n\t\t  delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n\t    } \n \n\t  if ( ! grid.mask[inw] ) \n\t    { \n              if ( in != n ) \n\t\t{ \n\t\t  inw = in; \n\t\t  delew = ONE; \n\t\t} \n              else if ( iw != n ) \n\t\t{ \n\t\t  inw = iw; \n\t\t  ine = ie; \n\t\t  if ( ie == n ) delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n              else \n\t\t{ \n\t\t  inw = n; \n\t\t  ine = ie; \n\t\t  delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n\t    } \n \n\t  grad_lat_zero = delew*(array[ine] - array[inw]); \n \n\t  if ( ! grid.mask[ise] ) \n\t    { \n              if ( is != n ) \n\t\t{ \n\t\t  ise = is; \n\t\t  delew = ONE; \n\t\t} \n              else if ( ie != n ) \n\t\t{ \n\t\t  ise = ie; \n\t\t  isw = iw; \n\t\t  if ( isw == n ) delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n              else \n\t\t{ \n\t\t  ise = n; \n\t\t  isw = iw; \n\t\t  delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n\t    } \n \n\t  if ( ! grid.mask[isw] ) \n\t    { \n              if ( is != n ) \n\t\t{ \n\t\t  isw = is; \n\t\t  delew = ONE; \n\t\t} \n              else if ( iw != n ) \n\t\t{ \n\t\t  isw = iw; \n\t\t  ise = ie; \n\t\t  if ( ie == n ) delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n              else \n\t\t{ \n\t\t  isw = n; \n\t\t  ise = ie; \n\t\t  delew = ONE; \n\t\t  delns = ONE; \n\t\t} \n\t    } \n \n\t  grad_lon_zero = delew*(array[ise] - array[isw]); \n \n\t  grad_latlon[n] = delns*(grad_lat_zero - grad_lon_zero); \n\t} \n    }", "pragma": "parallel for private(                  delew delns grad_lat_zero grad_lon_zero i ie im1 in ine inw ip1 is ise isw iw j jm1 jp1 n)", "hash": "1d94b0db8445cb36d1d9ab1c31310fd6b977175fa2f6bb53d7b7f455abd1767b"}
{"code": "for (uint i = 0; i < imageSizeRef[box]; i++) { \n    for(uint s = 0; s < lambdaSize; s++) { \n       \n \n      double coefDiff = sqrt(lambda_Coul[s]) - sqrt(lambda_Coul[iState]); \n      energyRecip[s] += prefactRef[box][i] * \n                        ((sumRref[box][i] + coefDiff * cosMolRef[molIndex][i]) * \n                         (sumRref[box][i] + coefDiff * cosMolRef[molIndex][i]) + \n                         (sumIref[box][i] + coefDiff * sinMolRef[molIndex][i]) * \n                         (sumIref[box][i] + coefDiff * sinMolRef[molIndex][i])); \n    } \n  }", "pragma": "parallel for reduction(+:energyrecip[:lambdasize]) ", "hash": "8e40635c541cb4c4bb772cb15dd46b6218cd0a21ae56884e5ff004d35cea61b1"}
{"code": "for( int i=0; i<tensorRules[t].getNumPoints(); i++ ){ \n                                weights[ points->getSlot( tensorRules[t].getPoint(i) ) ] += ((double) tensor_weights[t]) * w[i]; \n                        }", "pragma": "parallel for ", "hash": "e926622520bc243d6ec62123df80e3aec9881e23423dfc39d11c48c896622613"}
{"code": "for (int j = top + 1; j < border[0].rows - bottom; j++) \n\t\t{ \n\t\t\tfloat* s = src.ptr<float>(j - top); \n\t\t\tfloat* b = border[0].ptr<float>(j); \n\t\t\tfloat* g = border[1].ptr<float>(j); \n\t\t\tfloat* r = border[2].ptr<float>(j); \n \n\t\t\tfor (int i = 0; i < LEFT; i += 8) \n\t\t\t{ \n\t\t\t\t_mm256_storeu_ps(b + i, _mm256_set1_ps(s[0])); \n\t\t\t\t_mm256_storeu_ps(g + i, _mm256_set1_ps(s[1])); \n\t\t\t\t_mm256_storeu_ps(r + i, _mm256_set1_ps(s[2])); \n\t\t\t} \n\t\t\tfor (int i = END; i < END + RIGHT; i += 8) \n\t\t\t{ \n\t\t\t\t_mm256_storeu_ps(b + i, _mm256_set1_ps(s[3 * (src.cols - 1) + 0])); \n\t\t\t\t_mm256_storeu_ps(g + i, _mm256_set1_ps(s[3 * (src.cols - 1) + 1])); \n\t\t\t\t_mm256_storeu_ps(r + i, _mm256_set1_ps(s[3 * (src.cols - 1) + 2])); \n\t\t\t} \n \n\t\t\tfor (int i = 0; i < SIMDW; i += 8) \n\t\t\t{ \n\t\t\t\t__m256 mb, mg, mr; \n\t\t\t\t_mm256_load_cvtps_bgr2planar_ps(s + 3 * i, mb, mg, mr); \n\t\t\t\t_mm256_storeu_ps(b + i + left, mb); \n\t\t\t\t_mm256_storeu_ps(g + i + left, mg); \n\t\t\t\t_mm256_storeu_ps(r + i + left, mr); \n\t\t\t} \n\t\t\tfor (int i = SIMDW; i < src.cols; i++) \n\t\t\t{ \n\t\t\t\tb[i + left] = s[3 * i + 0]; \n\t\t\t\tg[i + left] = s[3 * i + 1]; \n\t\t\t\tr[i + left] = s[3 * i + 2]; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "bc7c7291ce699da5b8c3f315e761bb5cd3527146a1b9eb4d865466bc08629003"}
{"code": "for (k=0; k<N; k++) \n          zd_dev[k] *= c[0];", "pragma": "parallel for ", "hash": "cc1ce20ab483e90134112e9f119667815f8e494b52fdede3188e29ee176d3ea6"}
{"code": "for (int p = 0; p < particle_count; p++) \n\t\t\t{ \n\t\t\t\tconst int global_class_id = particles.getIntMinusOne(EMDL_PARTICLE_CLASS, p); \n\t\t\t\tconst int selected_class_id = class_to_subset[global_class_id]; \n \n\t\t\t\tif (selected_class_id >= 0) \n\t\t\t\t{ \n\t\t\t\t\tconst double dx_A = particles.getDouble(EMDL_ORIENT_ORIGIN_X_ANGSTROM, p); \n\t\t\t\t\tconst double dy_A = particles.getDouble(EMDL_ORIENT_ORIGIN_Y_ANGSTROM, p); \n \n\t\t\t\t\tstd::vector<double> raw_blob_parameters = all_optimal_parameters[selected_class_id]; \n\t\t\t\t\traw_blob_parameters[0] += dx_A / pixel_size; \n\t\t\t\t\traw_blob_parameters[1] += dy_A / pixel_size; \n \n\t\t\t\t\tconst d2Vector raw_blob_centre(raw_blob_parameters[0], raw_blob_parameters[1]); \n\t\t\t\t\tconst d2Vector image_centre((double)(box_size/2), (double)(box_size/2)); \n\t\t\t\t\tconst double max_dist = (image_centre - raw_blob_centre).length() + box_size / sqrt(2.0) + 1; \n \n\t\t\t\t\tconst double phi = DEG2RAD(particles.getDouble(EMDL_ORIENT_PSI, p)); \n \n\t\t\t\t\tconst double centre = box_size / 2; \n\t\t\t\t\tconst d2Vector axis(centre,centre); \n \n\t\t\t\t\tstd::vector<double> rotated_blob_parameters = Blob2D::rotate(raw_blob_parameters, phi, axis); \n\t\t\t\t\tBlob2D blob(rotated_blob_parameters, max_dist); \n \n\t\t\t\t\tBufferedImage<float> weight(box_size,box_size); \n\t\t\t\t\tweight.fill(1.f); \n \n \n\t\t\t\t\tstd::string img_fn = particles.getString(EMDL_IMAGE_NAME, p); \n\t\t\t\t\tBufferedImage<float> particle_image; \n\t\t\t\t\tparticle_image.read(img_fn); \n \n\t\t\t\t\tstd::vector<double> rad_average = blob.radialAverage(particle_image, weight); \n\t\t\t\t\tBufferedImage<float> projection = blob.radialAverageProjection(particle_image, rad_average); \n \n\t\t\t\t\tparticle_image -= projection; \n \n\t\t\t\t\tconst int index = compressed_particle_indices[p]; \n\t\t\t\t\tall_particle_images.copySliceFrom(index, particle_image); \n\t\t\t\t\tall_blob_images.copySliceFrom(index, projection); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "c8ba7232b553adda3d6a0f954e5597e3f335524a95ad207c00025bc156e4aab3"}
{"code": "for (uint32_t ind = 0; ind < cands.size(); ind++) { \n\t\t\tif (used[ind]) continue; \n\t\t\tprintf(\"%ld %d\\r\", re.size(), done); \n\t\t\tdone++; \n\t\t\tfflush(stdout); \n\t\t\tmodel cand(cur); \n\t\t\tcand.add(*p.patterns.front()); \n\t\t\tcand.add(candvector[ind]); \n\t\t\tcand.train(); \n \n\t\t\tmodel base(cur); \n\t\t\tbase.add(candvector[ind]); \n\t\t\tbase.train(); \n \n\t\t\tdists[ind] = (cand.kl(base) + cand.kl(target)) / cand.kl(back); \n \n\t\t\t \n \n\t\t\t\t \n \n\t\t\t \n \n \n\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t \n \n\t\t}", "pragma": "parallel for ", "hash": "75e3047ce8db4c9069747d0d66b6a8880505ef42d4c9b7e260b12adfe8a0b59e"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t    (*res)[i] = ((*right)[i] >= (*this)[i]);", "pragma": "for ", "hash": "67e89fb661edcddd3443ea92f3735a240a243293f8b96f4b89ac271dce85cead"}
{"code": "for (i = 0; i < size; i++) { \n    dst[i] = 1 - (src[i] * src[i]); \n  }", "pragma": "parallel for private(i)", "hash": "55f6e285de6ecd058714a602d6223a6be09c3d168b780cae8106fa22c90c4bb9"}
{"code": "for (iyq=0; iyq<nyq; iyq++) \n            { \n                for (ixq=0; ixq<nxq; ixq++) \n                { \n                    ix = (int) cellx[ixq] - 1; \n                    iy = (int) celly[iyq] - 1; \n                    indx = iyq*nxq + ixq; \n                    vq[indx] = evalBilinear(ix, iy, \n                                            ixq, iyq, \n                                            nx,  \n \n                                            x, y, \n                                            xquse, yquse, \n                                            v); \n                }  \n \n            }", "pragma": "parallel for private(    indx ix ixq iy iyq)", "hash": "6c82f1b3e922ebea8222a8991d6f58068d806f019211b77b0502037190d66992"}
{"code": "for (p = 0; p < nbatch; p++) \n    { \n      nn_(SpatialMaxPooling_updateOutput_frame)(input_data+p*nslices*iwidth*iheight, output_data+p*nslices*owidth*oheight, \n                                                indices_data+p*nslices*owidth*oheight, \n                                                nslices, \n                                                iwidth, iheight, \n                                                owidth, oheight, \n                                                kW, kH, dW, dH, \n                                                padW, padH); \n    }", "pragma": "parallel for private(p)", "hash": "113c68d348caa09b1f4bbb9ff07cabe0f7e2b6e2abcfaf9596a86d95f3a5cb92"}
{"code": "for (int32 h = 0; h < height; h++) \n\t\t{ \n\t\t\tfor (uint32 w = 0; w < width; w++) \n\t\t\t{ \n\t\t\t\tuint32 loc = h*width + w; \n\t\t\t\tuint8* to_loc_px = to_px + loc * 4; \n\t\t\t\tuint8* fr_loc_px = fr_px + loc * 3; \n\t\t\t\t*to_loc_px = *fr_loc_px; \n\t\t\t\t*(to_loc_px + 1) = *(fr_loc_px + 1); \n\t\t\t\t*(to_loc_px + 2) = *(fr_loc_px + 2); \n\t\t\t\t*(to_loc_px + 3) = alpha; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "bcfc3b5998fb382487ac46a0e4b3c97ed6fc5fc347fbf94999adf0d4cd5c5011"}
{"code": "for(int i = 0; i < 3; i ++){ \n\t\tZ_update_tmp[i] = K[i] - D1[i]; \n\t\tZ_update_tmp[i].noalias() += C * H[i]; \n\t}", "pragma": "for ", "hash": "3ed624688c27b0be5d7b21c52a45b616f01959849b1fe786a5c4e99a3401f2b3"}
{"code": "for (ompIndexType k = 0; k < (ompIndexType)n; k++) { \n                indexType idxOb = 2 * (i * planesize * n + j + k * planesize); \n                indexType idxBuffer = 2 * k; \n                ob[idxOb] = buffer[idxBuffer]; \n                ob[idxOb + 1] = buffer[idxBuffer + 1]; \n            }", "pragma": "parallel for ", "hash": "a5a39fcb0b3c09bd2b2a4fc6236e1c28d968ac2e8986fc450191fb2f1628083e"}
{"code": "for (unsigned int i = 0; i < nodes.size(); i++){ \n        visited[i] = 0; \n    }", "pragma": "parallel for ", "hash": "fa138cae6f136a0acca6d1fa631b4af0ebd6f24d01649dd7b8f8dc50b85885d0"}
{"code": "for (int i=0;i<tod->ndet;i++)  \n      { \n\tif ((!mbCutsIsAlwaysCut(tod->cuts,tod->rows[i],tod->cols[i])))   {  \n \n\t  get_radec_from_altaz_fit_1det_coarse(tod,i,scratch); \n\t  for (int j=0;j<tod->ndata;j++) { \n\t    actData dx=(ra-scratch->ra[j])*mycos; \n\t    actData dy=dec-scratch->dec[j]; \n\t    actData dd=dx*dx+dy*dy; \n\t    if (dd<mindist) \n\t      mindist=dd; \n\t  } \n\t} \n      }", "pragma": "for ", "hash": "53877cf608c147d6c82493c4ab07b7cd95bc6b3cf02f445f1ba03a5b0a75e67b"}
{"code": "for (i = 0; i < 10; i++) \n    for (int j = n; j < 8; j++) \n      for (long k = -10; k < 10; k++) \n\t{ \n\t  b[i][j][k] += 16; \n\t  noreturn (); \n\t  b[i][j][k] -= 32; \n\t}", "pragma": "parallel for simd ", "hash": "1b80757b9213373a83d55cb18274cb0868031782c742ad0f2013fee0ec00258b"}
{"code": "for (k = 0; k < kcount; k++) \n\teng_tmp += ug[k] * (sfacrl_all[k]*sfacrl_all[k] +  \n\t\t\t    sfacim_all[k]*sfacim_all[k]);", "pragma": "for private(k)", "hash": "79c2443b13523a9d70af17ebbed8bae9449f042f3de51d2c7a286256115e5ffb"}
{"code": "for (int i = 0; i < a; i++) \n    thrower();", "pragma": "for ", "hash": "526c17c479014a240e269871251c9c62d85347062937a8ee20664ac519536bc9"}
{"code": "for (ompIndexType k = 0; k < (ompIndexType)nbElements; ++k) { \n                mat[k] = (int32)1; \n            }", "pragma": "parallel for ", "hash": "6d31443cf26d3e6a231ccefeeca95acceded1f048d475eb43990d5404c5a6efe"}
{"code": "for(i=0; i<communitySize; i++) \n                { \n                    eigenVectorNew[i]=0.0; \n                    degree_u = G->numEdges[vertex[i]+1] - G->numEdges[vertex[i]]; \n                    for(j=G->numEdges[vertex[i]]; j<G->numEdges[vertex[i]+1]; j++) \n                    { \n                        if(v2C[G->endV[j]] == currCommunity) \n                        { \n                            eigenVectorNew[i] += G->dbl_weight_e[j] * eigenVectorOld[v2pos[G->endV[j]]]; \n                        } \n                    } \n                    eigenVectorNew[i] -= (((double)degree[vertex[i]]) - (double)(degree_u * degreeSum)/(double)(2.0*G->m))* eigenVectorOld[i]; \n                    ktx += (double) degree_u * eigenVectorOld[i]; \n                }", "pragma": "for reduction(+:ktx) private(degree_u j)", "hash": "6930c80bd404039d4c9d43842559de84e0541c04f45c9b1cfbc5db9b0128895e"}
{"code": "for (int i = 0; i <= LIM; i++) { \n    for (int j = 0; j <= LIM; j++) { \n      vec2i one = {j, i}; \n      if (i != 0 || j != 0) \n        for (int k = i; k <= LIM; k++) { \n          for (int l = 0; l <= LIM; l++) { \n            vec2i two = {l, k}; \n            if (l <= j && k <= i) continue; \n            if (isGood(one, two, 0.000001)) { \n               \n \n              ans++; \n            } \n          } \n        } \n    } \n  }", "pragma": "parallel for reduction(+ : ans) ", "hash": "00a4848f8398d439608d9685151afc9b116849526b537d87af38285585b9a8df"}
{"code": "for (k = 1; k <= np; k++) { \n\tkk = k_offset + k; \n\tt1 = S; \n\tt2 = an; \n \n \n \n \n\tfor (i = 1; i <= 100; i++) { \n            ik = kk / 2; \n            if (2 * ik != kk) t3 = randlc(&t1, t2); \n            if (ik == 0) break; \n            t3 = randlc(&t2, t2); \n            kk = ik; \n\t} \n \n \n \n \n\tif (TIMERS_ENABLED == TRUE) timer_start(3); \n\tvranlc(2*NK, &t1, A, x-1); \n\tif (TIMERS_ENABLED == TRUE) timer_stop(3); \n \n \n \n\tif (TIMERS_ENABLED == TRUE) timer_start(2); \n \n\tfor ( i = 0; i < NK; i++) { \n            x1 = 2.0 * x[2*i] - 1.0; \n            x2 = 2.0 * x[2*i+1] - 1.0; \n            t1 = pow2(x1) + pow2(x2); \n            if (t1 <= 1.0) { \n\t\tt2 = sqrt(-2.0 * log(t1) / t1); \n\t\tt3 = (x1 * t2);\t\t\t\t \n \n\t\tt4 = (x2 * t2);\t\t\t\t \n \n\t\tl = max(fabs(t3), fabs(t4)); \n\t\tqq[l] += 1.0;\t\t\t\t \n \n\t\tsx = sx + t3;\t\t\t\t \n \n\t\tsy = sy + t4;\t\t\t\t \n \n            } \n\t} \n\tif (TIMERS_ENABLED == TRUE) timer_stop(2); \n    }", "pragma": "for reduction(+:sx sy) ", "hash": "fdb3a499284d6a0984b607a1e89987f877e527a829ba832831ad45ae837300ca"}
{"code": "for (long K = coloradj1; K<coloradj2; K++) { \n\t\t\t\tlong i = colorIndex[K]; \n\t\t\t\tlong localTarget = -1; \n\t\t\t\tlong adj1 = vtxPtr[i]; \n\t\t\t\tlong adj2 = vtxPtr[i+1]; \n\t\t\t\tlong selfLoop = 0; \n\t\t\t\t \n \n\t\t\t\tmap<long, long> clusterLocalMap;  \n \n\t\t\t\tmap<long, long>::iterator storedAlready; \n\t\t\t\tvector<double> Counter;  \n \n\t\t\t\t \n\t\t\t\tif(adj1 != adj2) { \n\t\t\t\t\t \n \n\t\t\t\t\tclusterLocalMap[currCommAss[i]] = 0; \n\t\t\t\t\tCounter.push_back(0);  \n \n\t\t\t\t\t \n \n\t\t\t\t\tselfLoop = buildLocalMapCounter(adj1, adj2, clusterLocalMap, Counter, vtxInd, currCommAss, i); \n\t\t\t\t\t \n \n\t\t\t\t\tlocalTarget = max(clusterLocalMap, Counter, selfLoop, cInfo, vDegree[i], currCommAss[i], constantForSecondTerm); \n\t\t\t\t} else { \n\t\t\t\t\tlocalTarget = -1; \n\t\t\t\t}\t\t\t\t\t \n\t\t\t\t \n \n\t\t\t\tif(localTarget != currCommAss[i] && localTarget != -1) { \n\t\t\t\t\t__sync_fetch_and_add(&cUpdate[localTarget].degree, vDegree[i]); \n\t         \t\t\t__sync_fetch_and_add(&cUpdate[localTarget].size, 1); \n\t\t\t\t\t__sync_fetch_and_sub(&cUpdate[currCommAss[i]].degree, vDegree[i]); \n\t\t\t\t\t__sync_fetch_and_sub(&cUpdate[currCommAss[i]].size, 1); \n\t\t\t\t} \n \n\t\t\t\tcurrCommAss[i] = localTarget;       \n\t\t\t\tclusterLocalMap.clear();       \n\t\t\t}", "pragma": "parallel for ", "hash": "286c677f3995a50c5f0b8f4fa30080b2aba438bf86067a02c80e95b074da68e8"}
{"code": "for(unsigned i=0; i<n; i++){ \n        for(unsigned j=i; j<n; j++){ \n            typename GaussianProcess<TScalarType>::VectorType v; \n            v = m_Kernel->GetDerivative(samples[i], samples[j]); \n \n            if(v.rows() != num_params) throw std::string(\"GaussianProcess::ComputeDerivativeKernelMatrixInternal: dimension missmatch in derivative.\"); \n            for(unsigned p=0; p<num_params; p++){ \n \n                 \n \n \n                M(i + p*n, j) = v[p]; \n                M(j + p*n, i) = v[p]; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "701ec8587c4e77988ae7983ea4c51fc0e1e251cf50242e72afbd056f7381d153"}
{"code": "for (local_int_t i=0; i< nrow; i++)  { \n    double sum = 0.0; \n    const double * const cur_vals = A.matrixValues[i]; \n    const local_int_t * const cur_inds = A.mtxIndL[i]; \n    const int cur_nnz = A.nonzerosInRow[i]; \n#pragma sst replace cur_nnz 27 \n    for (int j=0; j< cur_nnz; j++) \n      sum += cur_vals[j]*xv[cur_inds[j]]; \n    yv[i] = sum; \n  }", "pragma": "parallel for ", "hash": "f946e03f70b49ec480489a789299429c5a8607fc5d5bb82492396a63ec85c583"}
{"code": "for ( int i = 0; i < int( mesh.n_halfedges() ); ++i ) \n    { \n        auto h = mesh.halfedge_handle( i ); \n         \n \n        auto vh = mesh.property( m_hV, h ); \n        if ( vh.idx() != -1 )  \n \n        { \n            auto idx = mesh.property( inTriIndexProp, h ); \n            mesh.set_point( vh, newCoarseVertices[idx] ); \n            mesh.property( hNormalProp, h ) = newCoarseNormals[idx]; \n        } \n    }", "pragma": "parallel for ", "hash": "0a38e11848fad7257f7011e674b0845670414392c9ff577a50d250ef7475fcbb"}
{"code": "for(int c=1; c < weightColumns; c++){ \n\t\t\t\t \n \n\t\t\t\tif(c < itemWeight){ \n\t\t\t\t\ttable[i][c] = table[i-1][c]; \n \n\t\t\t\t \n \n\t\t\t\t}else{ \n\t\t\t\t\tint worthOfNotUsingItem = table[i-1][c]; \n\t\t\t\t\tint worthOfUsingItem = itemWorth + table[i-1][c-itemWeight]; \n\t\t\t\t\ttable[i][c] = worthOfNotUsingItem < worthOfUsingItem ? worthOfUsingItem : worthOfNotUsingItem; \n\t\t\t\t} \n\t\t\t}", "pragma": "for ", "hash": "9c61316f8e2e431ff9f322aedcf8e39615be95457e3d50a65fab0aaf275b721e"}
{"code": "for(int i = 0; i < nLat; i++) { \n         for(int j = 0; j < nLon; j++) { \n            int Icenter = nearestI[i][j]; \n            int Jcenter = nearestJ[i][j]; \n            assert(Icenter < ielevs.size()); \n            assert(Jcenter < ielevs[Icenter].size()); \n            for(int e = 0; e < nEns; e++) { \n               float currLaf = Util::MV; \n               if(mLafRadius == 0) { \n                  currLaf = olafs[i][j]; \n               } \n               else { \n                   \n \n                  int count = 0; \n                  float total = 0; \n                  for(int ii = std::max(0, i-mLafRadius); ii <= std::min(nLat-1, i+mLafRadius); ii++) { \n                     for(int jj = std::max(0, j-mLafRadius); jj <= std::min(nLon-1, j+mLafRadius); jj++) { \n                        if(Util::isValid(olafs[ii][jj])) { \n                           total += olafs[ii][jj]; \n                           count++; \n                        } \n                     } \n                  } \n                  if(count > 0) \n                     currLaf = total / count; \n               } \n \n                \n \n                \n \n                \n \n                \n \n                \n \n               float baseValue = ofield(i, j, e); \n \n                \n \n               if(!Util::isValid(baseValue)) { \n                  continue; \n               } \n \n                \n \n                \n \n                \n \n \n               float elevGradient = calcElevGradient(i, j, e, Icenter, Jcenter, ifield, gfield, ielevs, ilafs); \n               float lafGradient = Util::MV; \n               if(mLafSearchRadii.size() > 0) \n                  lafGradient = calcLafGradient(i, j, e, Icenter, Jcenter, ifield, ilafs, ielevs, elevGradient); \n \n               if(mSaveGradient == \"elev\") { \n                  ofield(i, j, e) = elevGradient; \n               } \n               else if(mSaveGradient == \"laf\") { \n                  ofield(i, j, e) = lafGradient; \n               } \n               else { \n                   \n \n                  float baseElev = elevsInterp[i][j]; \n                  float baseLaf = lafsInterp[i][j]; \n                  float value = baseValue; \n                  float currElev = oelevs[i][j]; \n                  if(Util::isValid(currElev) && Util::isValid(baseElev)) { \n                     float dElev = currElev - baseElev; \n                     value += dElev * elevGradient; \n                  } \n                  if(Util::isValid(currLaf) && Util::isValid(baseLaf) && Util::isValid(lafGradient)) { \n                     float dLaf = currLaf - baseLaf; \n                     value += dLaf * lafGradient; \n                  } \n \n                  if((Util::isValid(minAllowed) && value < minAllowed) || (Util::isValid(maxAllowed) && value > maxAllowed)) { \n                     value = baseValue; \n                  } \n \n                   \n \n                  if(mLimit) { \n                     float min = Util::MV; \n                     float max = Util::MV; \n                     for(int ii = std::max(0, Icenter-mElevRadius); ii <= std::min(ifield.getNumY()-1, Icenter+mElevRadius); ii++) { \n                        for(int jj = std::max(0, Jcenter-mElevRadius); jj <= std::min(ifield.getNumX()-1, Jcenter+mElevRadius); jj++) { \n                           float curr = ifield(ii, jj, e); \n                           if(Util::isValid(curr)) { \n                              if(!Util::isValid(min) || curr < min) \n                                 min = curr; \n                              else if(!Util::isValid(max) || curr > max) \n                                 max = curr; \n                           } \n                        } \n                     } \n                     if(value > max) \n                        value = max; \n                     if(value < min) \n                        value = min; \n                  } \n                  ofield(i,j,e)  = value; \n               } \n            } \n         } \n      }", "pragma": "parallel for ", "hash": "e553be9eb68174ccb3a31690a85133c1e3cccd5fa114d399640dc6e4561475a2"}
{"code": "for (int y = 0; y < blockSize.m_y; y++)\r \n\t\t{\r \n\t\t\tfor (int x = 0; x < blockSize.m_x; x++)\r \n\t\t\t{\r \n\t\t\t\tint threadNo = ::omp_get_thread_num();\r \n\r \n\t\t\t\tCTPeriod validPeriod[NB_OUTPUT_REGRESSION];\r \n\t\t\t\tif (beginDS.IsOpen() && endDS.IsOpen())\r \n\t\t\t\t{\r \n\t\t\t\t\tCGeoPoint pt = extents.XYPosToCoord(CGeoPointIndex(x, y));\r \n#pragma omp critical(BlockIO)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tCGeoPointIndex xy;\r \n\t\t\t\t\t\txy = beginDS.GetExtents().CoordToXYPos(pt);\r \n\t\t\t\t\t\tint b = (int)beginDS.ReadPixel(0, xy);\r \n\t\t\t\t\t\txy = endDS.GetExtents().CoordToXYPos(pt);\r \n\t\t\t\t\t\tint e = (int)endDS.ReadPixel(0, xy);\r \n\r \n\t\t\t\t\t\tif (b != noData && e != noData)\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\tvalidPeriod[O_FIVE].Begin() = m_options.GetTRef(b);\r \n\t\t\t\t\t\t\tvalidPeriod[O_FIVE].End() = CTRef(validPeriod[O_FIVE].Begin().GetYear() + 4, LAST_MONTH, LAST_DAY);\r \n\r \n\t\t\t\t\t\t\tvalidPeriod[O_BEGIN_END].Begin() = m_options.GetTRef(b);\r \n\t\t\t\t\t\t\tvalidPeriod[O_BEGIN_END].End() = m_options.GetTRef(e);\r \n\t\t\t\t\t\t}\r \n\r \n\t\t\t\t\t\tvalidPeriod[O_ALL] = m_options.m_period;\r \n\t\t\t\t\t}\r \n\t\t\t\t}\r \n\r \n\t\t\t\tCStatisticXY statXY[NB_OUTPUT_REGRESSION];\r \n\r \n\t\t\t\tfor (size_t s = 0; s < window.GetNbScenes() - 1; s++)\r \n\t\t\t\t{\r \n\t\t\t\t\tCLandsatPixel pixel = window.GetPixel(s, x, y);\r \n\r \n\t\t\t\t\tif (pixel.IsValid())\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tdouble date = pixel.GetTRef().GetYear() + (double)pixel.GetTRef().GetJDay() / pixel.GetTRef().GetNbDaysPerYear();\r \n\r \n\t\t\t\t\t\tfor (size_t i = 0; i < NB_OUTPUT_REGRESSION; i++)\r \n\t\t\t\t\t\t\tif (validPeriod[i].IsInit() && validPeriod[i].IsInside(pixel.GetTRef()))\r \n\t\t\t\t\t\t\t\tstatXY[i].Add(date, pixel.NBR()*m_options.m_RFactor);\r \n\r \n\t\t\t\t\t} \n \n\t\t\t\t} \n \n\r \n\t\t\t\tfor (size_t i = 0; i < NB_OUTPUT_REGRESSION; i++)\r \n\t\t\t\t{\r \n\t\t\t\t\tif (statXY[i][NB_VALUE] >= 3)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tfor (size_t s = 0; s < NB_REGRESSION_STATS; s++)\r \n\t\t\t\t\t\t\tdata[i][s][y*blockSize.m_x + x] = (float)statXY[i][REG_STATS[s]];\r \n\t\t\t\t\t}\r \n\t\t\t\t}\r \n\r \n#pragma omp atomic \r \n\t\t\t\tm_options.m_xx++;\r \n\t\t\t} \n \n\r \n\r \n\t\t\tm_options.UpdateBar();\r \n\t\t}", "pragma": "parallel for ", "hash": "fddc2bb7afb98c0d931c03a4aecc740b4285d2c9a44bababd78c3d6bee05e67f"}
{"code": "for(int i=0; i<logregprob->ny; i++) { \n        double Ax=0; \n        sparse_array &row = logregprob->A_rows[i]; \n        for(int j=0; j<row.length(); j++) { \n            Ax += logregprob->x[row.idxs[j]]*row.values[j]; \n        } \n        logregprob->expAx[i] = exp(Ax); \n    }", "pragma": "parallel for ", "hash": "472a0df5cc77aff1015d375f4479065421cd13890b462040fa834cc8c80c0f31"}
{"code": "for (size_t j = 0; j < n; j++) { \n          for (size_t i = 0; i < m; i++) { \n            register double complex temp = alpha * B[j * ldb + i]; \n            if (transA == CBlasTrans) { \n              for (size_t k = 0; k < i; k++) \n                temp -= A[i * lda + k] * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= A[i * lda + i]; \n            } \n            else { \n              for (size_t k = 0; k < i; k++) \n                temp -= conj(A[i * lda + k]) * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= conj(A[i * lda + i]); \n            } \n            B[j * ldb + i] = temp; \n          } \n        }", "pragma": "parallel for ", "hash": "8c991da41b44b8d4f751bae8b5d080125b03a9993150fc39f73e5f763658fe73"}
{"code": "for( i = 0 ; i < LCU ; i++ ) { \n \n    zero_halfspinor( &der2[i] ) ; \n \n    double complex A[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n    double complex B[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n \n    const size_t Uidx = i + t*LCU ; \n \n    size_t mu , d ; \n    for( mu = 0 ; mu < ND-1 ; mu++ ) { \n      const size_t Sfwd = lat[ i ].neighbor[mu] ; \n      const size_t Sbck = lat[ i ].back[mu] ; \n      const size_t Ubck = lat[ Uidx ].back[mu] ; \n       \n      for( d = 0 ; d < NS ; d++ ) { \n\t \n \n\tmultab( (void*)A , \n\t\t(void*)lat[ Uidx ].O[mu] , \n\t\t(void*)S[ Sfwd ].D[d] ) ; \n\t \n \n\tmultabdag( (void*)B , \n\t\t   (void*)lat[ Ubck ].O[mu] , \n\t\t   (void*)S[ Sbck ].D[d] ) ; \n\t \n \n\tadd_mat( (void*)A , (void*)B ) ; \n\t \n \n\tcolormatrix_Saxpy( A , S[i].D[d], -2. ) ; \n\t \n \n\tadd_mat( (void*)der2[i].D[d] , (void*)A ) ; \n      } \n    } \n  }", "pragma": "for private(i)", "hash": "de0503a84a264c757bfa6f2a889e14668eecbdef13eb77f78b58a75f6acc37ec"}
{"code": "for (int frame = 0; frame < remainder; frame++) { \n    for (int ref_frame = 0; ref_frame < ref_index.size(); ref_frame++) \n      fits[frame].data[ref_frame] = \n\t::distance(ref_size[ref_frame],ref_index[ref_frame],ref_data[ref_frame], \n\t\t   fit_size[frame],fit_index[frame],fit_data[frame]); \n    if (sort) \n      fits[frame].sort(k1); \n  }", "pragma": "parallel for ", "hash": "2501d0106f7d09fe4cef9337060a89c68b570d0466d956e59280af15589f8006"}
{"code": "for(i=1;i<nX-1;i++) { \n            for(j=1;j<nY-1;j++) { \n \n                u[i][j] = ((dy*dy)*(u_old[i-1][j] + u_old[i+1][j]) +  \n                             (dx*dx)*(u_old[i][j-1] + u_old[i][j+1]) -  \n                             (dx*dx)*(dy*dy)*f[i][j])/(2.0*((dx*dx) + (dy*dy)) ); \n            } \n        }", "pragma": "for ", "hash": "37b291421210ff1e5a164807f7c0f4928b5eb191ff0969b62e3eaf9b3c3cdc02"}
{"code": "for (int i = 0; i < N; i++) \n            for (int j = 0; j < N; j++)  \n                if (D[i][k] < INT_MAX && D[k][j] < INT_MAX) { \n                    int d = D[i][k] + D[k][j]; \n                    if (d < D[i][j]) { \n                         D[i][j] = d; \n                         P[i][j] = P[k][j]; \n                    } \n                }", "pragma": "parallel for ", "hash": "793394050dca8e274b27c74aa68a7d60e6c8008952728126900fedec3a7d74cc"}
{"code": "for(int i=myInBegin2D[TYPE_B][TYPE_A]; i<myInEnd2D[TYPE_B][TYPE_A]; i++) {  \n \n                    for(int j=myOutBegin2D[TYPE_B][TYPE_A]; j<myOutEnd2D[TYPE_B][TYPE_A]; j++) { \n                        if(mutual[TYPE_BA][In[TYPE_B][i]][Out[TYPE_A][j]]>highestMutualThread) { \n                            highestMutualThread=mutual[TYPE_BA][In[TYPE_B][i]][Out[TYPE_A][j]]; \n                            highestType1Thread=b; \n                            highestType2Thread=a; \n                            highestIndex1Thread=i; \n                            highestIndex2Thread=j; \n                        } \n                    } \n                }", "pragma": "for ", "hash": "4fd72b37001cce5b66cf576d9f52dc4b9660e2f2f0d415934c3a45c2112730d4"}
{"code": "for (i=0; i<nvox; i+=step) { \n    if (i%1000 == 0) fprintf(stderr,\" %ld000\\r\",(long)progress++); \n    int bi = (int)VPixel(map,0,0,i,VShort); \n    int ri = (int)VPixel(map,0,1,i,VShort); \n    int ci = (int)VPixel(map,0,2,i,VShort); \n    int nadjx = VNumNeigbours(i,map,mapimage,adjdef); \n    if (nadjx < minadj) continue; \n \n    int roiflagi = 0; \n    if (roi != NULL) { \n      if (VGetPixel(roi,bi,ri,ci) > 0.5) roiflagi = 1; \n    } \n \n    gsl_histogram *tmphist = gsl_histogram_alloc (nbins); \n    gsl_histogram_set_ranges_uniform (tmphist,hmin,hmax); \n    gsl_histogram_reset(tmphist); \n     \n    const float *datax1 = gsl_matrix_float_const_ptr(SNR1,i,0); \n    const float *datax2 = gsl_matrix_float_const_ptr(SNR2,i,0); \n \n \n    size_t j=0; \n    for (j=0; j<i; j+=step) { \n      int bj = (int)VPixel(map,0,0,j,VShort); \n      int rj = (int)VPixel(map,0,1,j,VShort); \n      int cj = (int)VPixel(map,0,2,j,VShort); \n      int d = SQR(bi-bj) + SQR(ri-rj) + SQR(ci-cj); \n      if (d < rad2) continue; \n      int nadjy = VNumNeigbours(j,map,mapimage,adjdef); \n      if (nadjy < minadj) continue; \n \n      int roiflagj = 0; \n      if (roi != NULL) { \n\tif (VGetPixel(roi,bj,rj,cj) > 0.5) roiflagj = 1; \n\tif (roiflagi + roiflagj != 1) continue;  \n      } \n      const float *datay1 = gsl_matrix_float_const_ptr(SNR1,j,0); \n      const float *datay2 = gsl_matrix_float_const_ptr(SNR2,j,0); \n \n       \n \n      double z1 = EdgeCorr(datax1,datay1,nt,metric); \n      double z2 = EdgeCorr(datax2,datay2,nt,metric); \n      double z = (z1-z2); \n      if (z < zmin) zmin = z; \n      if (z > zmax) zmax = z; \n \n      if (z < hmin) z = hmin; \n      if (z > hmax-tiny) z = hmax-tiny; \n      gsl_histogram_increment (tmphist,z); \n    } \n \n \n#pragma omp critical  \n    { \n      gsl_histogram_add (histogram,tmphist); \n    } \n    gsl_histogram_free (tmphist); \n  }", "pragma": "parallel for private(snr1 snr2)", "hash": "26dcef51508d25769e394dd02027d1953e08db2dd260805969bf33f8c88e11dd"}
{"code": "for (int y = info.offy; y < info.offy + info.height; y++)\r \n\t\t\t{\r \n\t\t\t\tint offsetBuf = (y - info.offy) * info.width << 2;\r \n\t\t\t\tint offset2 =(y - info.offy) * info.width;\r \n\t\t\t\tfor (int x = info.offx; x < info.offx + info.width; x++)\r \n\t\t\t\t{\r \n\t\t\t\t\tfor (int i = 0; i < 3; i++)\r \n\t\t\t\t\t\tbuffer[offsetBuf + i] = tobyte(lumMap[offset2] * 255.0);\r \n\t\t\t\t\tbuffer[offsetBuf + 3] = 255;\r \n\t\t\t\t\toffsetBuf += 4;\r \n\t\t\t\t\toffset2++;\r \n\t\t\t\t}\r \n\t\t\t}", "pragma": "parallel for ", "hash": "a3fd342707eb3040ac8c0d6033b74224be00c68056b511eb147471a6cac67d47"}
{"code": "for (int i = 0; i < num_rows; ++i)\r \n    {     \n \n        const size_t branch (i + m_min_points);           \n \n        const size_t rowSize (num_columns - i * 2);       \n \n        const size_t rowOffset ((num_columns - (i - 1)) * i);   \n \n        for (int j = 0; j < rowSize; ++j)\r \n        {     \n \n            const size_t offset (rowOffset + j);\r \n            size_t marker (branch);\r \n            for (size_t k = 0; k < marker; ++k)\r \n                wavelet[offset] -= y[j + k];\r \n            marker += branch;\r \n            for (size_t k = marker - branch; k < marker; ++k)\r \n                wavelet[offset] += y[j + k];\r \n            wavelet[offset] /= marker;\r \n\r \n            if (minZ.get ()[omp_get_thread_num ()] > wavelet[offset])\r \n                minZ.get ()[omp_get_thread_num ()] = wavelet[offset];\r \n\r \n            if (maxZ.get ()[omp_get_thread_num ()] < wavelet[offset])\r \n                maxZ.get ()[omp_get_thread_num ()] = wavelet[offset];\r \n        }\r \n    }", "pragma": "parallel for ", "hash": "10aa415b6d7308fba9a7b3e5776fc913186a162443d222a4afd9f3e138842a59"}
{"code": "for(i=0;i<linen;i++) { \n\t\tfor(j=0;j<classn;j++) { \n\t\t\tarray_test_class_probability[i*classn+j] = log( array_class_probability[j] ); \n\t\t} \n\t\tfor(j=0;j<propertyn;j++) { \n\t\t\tfor(k=0;k<classn;k++) { \n\t\t\t\tarray_test_class_probability[i*classn+k] += log( array_probability[ array_probability_index[j] + array_test[i*propertyn+j]*classn + k] ); \n\t\t\t\t \n \n\t\t\t} \n\t\t} \n\t\t \n \n\t\tmax=0; \n\t\tfor(j=0;j<classn;j++) { \n\t\t\tif(array_test_class_probability[i*classn+j]-array_test_class_probability[i*classn+max]>EPSILON) { \n\t\t\t\tmax=j; \n\t\t\t} \n\t\t} \n\t\tarray_test_class[i]=max; \n\t}", "pragma": "parallel for ", "hash": "222d0893f69a471d7003de58e4123fa3ba8fd009b1ba7f73ade179ef98fb8a6e"}
{"code": "for (n = 0; n < LOOPCOUNT; n++) { \n        if (LOOPCOUNT == n + 1 ) \n          my_sleep(SLEEPTIME); \n \n        tids[n] = omp_get_thread_num(); \n      }", "pragma": "for ", "hash": "27bc945b85e7eca72497180222b63c950dd5ac7b527081e8b21781476738f1bd"}
{"code": "for (i=1;i<=LOOPCOUNT;i++) { \n    sum=sum+i; \n  }", "pragma": "parallel for reduction(+:sum) private(i)", "hash": "a44e07061dfaa4a81856a2c450e91c27dba1ef641afdd7c67ea34a8792a7c19f"}
{"code": "for (int iii = 0; iii < src.rows; iii++) { \n\t\tfor (int jjj = 0; jjj < src.cols; jjj++) { \n \n\t\t\t \n \n\t\t\t \n\t\t\tdst.at<cv::Vec3b>(iii,jjj)[1] = src.at<unsigned short>(iii,jjj) % 256; \n\t\t\tdst.at<cv::Vec3b>(iii,jjj)[0] = (src.at<unsigned short>(iii,jjj) - (src.at<unsigned short>(iii,jjj) % 256) ) / 256; \n\t\t\t \n\t\t\t \n\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\t \n\t\t\tdst.at<cv::Vec3b>(iii,jjj)[2] = (unsigned char) (255.0 * conf.at<double>(iii,jjj)); \n \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "5b74591b0a821d4004a3d47d749ea9e98267231dd964788cfe2a06199fe7286d"}
{"code": "for (long i=0; i<size; i++){ \n\t\t\tCellHandle& cell = Tes.cellHandles[i]; \n\t\t\tcell->info().Reynolds=uniformReynolds; \n\t\t\tcell->info().NutimesFluidK = NussfluidK; \n\t\t}", "pragma": "parallel for ", "hash": "2769db1b332dfeaca531e3cfa00c2bdb3f55d4f1e2454b89cce34dbe6cf0b704"}
{"code": "for (uint64_t vert_index = 0; vert_index < g->n_local; ++vert_index) \n  { \n    int32_t part = pulp->local_parts[vert_index]; \n \n    for (int32_t p = 0; p < pulp->num_parts; ++p) \n      tp.part_counts[p] = 0.0; \n \n    uint64_t out_degree = out_degree(g, vert_index); \n    uint64_t* outs = out_vertices(g, vert_index); \n    for (uint64_t j = 0; j < out_degree; ++j) \n    { \n      uint64_t out_index = outs[j]; \n      int32_t part_out = pulp->local_parts[out_index]; \n      tp.part_counts[part_out] += 1.0; \n    } \n \n    int32_t max_part = part; \n    double max_val = -1.0; \n    uint64_t num_max = 0; \n    for (int32_t p = 0; p < pulp->num_parts; ++p) \n    { \n      if (tp.part_counts[p] == max_val) \n      { \n        tp.part_counts[num_max++] = (double)p; \n      } \n      else if (tp.part_counts[p] > max_val) \n      { \n        max_val = tp.part_counts[p]; \n        max_part = p; \n        num_max = 0; \n        tp.part_counts[num_max++] = (double)p; \n      } \n    }       \n \n    if (num_max > 1) \n      max_part =  \n        (int32_t)tp.part_counts[(xs1024star_next(&xs) % num_max)]; \n \n    if (max_part != part) \n    { \n      int64_t new_size = (int64_t)pulp->avg_sizes[0]; \n \n      pulp->part_size_changes[0][part] - 1 > 0 ? \n        new_size = pulp->part_sizes[0][part] + pulp->part_size_changes[0][part] - 1 : \n        new_size = (int64_t)((double)pulp->part_sizes[0][part] + multiplier * pulp->part_size_changes[0][part] - 1); \n \n      if (new_size > (int64_t)min_size) \n      { \n    #pragma omp atomic \n        --pulp->part_size_changes[0][part]; \n    #pragma omp atomic \n        ++pulp->part_size_changes[0][max_part]; \n \n        pulp->local_parts[vert_index] = max_part; \n        add_vid_to_send(&tq, q, vert_index); \n      } \n    } \n  }", "pragma": "for ", "hash": "1575248d2d8188e6a3eeceea9d6592b4d0650c380daaea135a7e1ad85e88d059"}
{"code": "for (int feature_index = 0; feature_index < this->num_features_; ++feature_index) { \n    OMP_LOOP_EX_BEGIN(); \n    const int tid = omp_get_thread_num(); \n    if (smaller_is_feature_aggregated_[feature_index]) { \n      SplitInfo smaller_split; \n       \n \n      smaller_leaf_histogram_array_global_[feature_index].FromMemory( \n        output_buffer_.data() + smaller_buffer_read_start_pos_[feature_index]); \n \n      this->train_data_->FixHistogram(feature_index, \n        smaller_leaf_splits_global_->sum_gradients(), smaller_leaf_splits_global_->sum_hessians(), \n        GetGlobalDataCountInLeaf(smaller_leaf_splits_global_->LeafIndex()), \n        smaller_leaf_histogram_array_global_[feature_index].RawData()); \n \n       \n \n      smaller_leaf_histogram_array_global_[feature_index].FindBestThreshold( \n        smaller_leaf_splits_global_->sum_gradients(), \n        smaller_leaf_splits_global_->sum_hessians(), \n        GetGlobalDataCountInLeaf(smaller_leaf_splits_global_->LeafIndex()), \n        &smaller_split); \n      if (smaller_split.gain > smaller_best[tid].gain) { \n        smaller_best[tid] = smaller_split; \n        smaller_best[tid].feature = this->train_data_->RealFeatureIndex(feature_index); \n      } \n    } \n \n    if (larger_is_feature_aggregated_[feature_index]) { \n      SplitInfo larger_split; \n       \n \n      larger_leaf_histogram_array_global_[feature_index].FromMemory(output_buffer_.data() + larger_buffer_read_start_pos_[feature_index]); \n \n      this->train_data_->FixHistogram(feature_index, \n        larger_leaf_splits_global_->sum_gradients(), larger_leaf_splits_global_->sum_hessians(), \n        GetGlobalDataCountInLeaf(larger_leaf_splits_global_->LeafIndex()), \n        larger_leaf_histogram_array_global_[feature_index].RawData()); \n \n       \n \n      larger_leaf_histogram_array_global_[feature_index].FindBestThreshold( \n        larger_leaf_splits_global_->sum_gradients(), \n        larger_leaf_splits_global_->sum_hessians(), \n        GetGlobalDataCountInLeaf(larger_leaf_splits_global_->LeafIndex()), \n        &larger_split); \n      if (larger_split.gain > larger_best[tid].gain) { \n        larger_best[tid] = larger_split; \n        larger_best[tid].feature = this->train_data_->RealFeatureIndex(feature_index); \n      } \n    } \n    OMP_LOOP_EX_END(); \n  }", "pragma": "parallel for ", "hash": "99466a59e8656434d3420ee8c4bbc6876a0212c2a2ad9b959d46dc7540d55054"}
{"code": "for (int i = 0; i < nvalues  ; i++) \n\t{ \n \n\t\t \n \n\t\tif (stop < my_time) \n\t\t{ \n \n\t\t\t \n \n                        j = sub_rand_nums[i]; \n \n\t\t\t \n \n\t\t\tgc = read_neigbourhood(j, maxi, coloured_graph_); \n                         \n \n \n\t\t\t \n \n\t\t\tif (branching.size() >= 2 && all_elem_key.size() >= ((kamer * 2) + 2) && branching.size() <= maxbranch)  \n \n\t\t\t{ \n    #pragma omp parallel for schedule (static) \n\t\t\t\tfor (int i = 0; i < branching.size(); i++) \n\t\t\t\t{ \n\t\t\t\t\t \n\t\t\t\t\tvector<u64>::iterator ist = find(demi_cyc.begin(), demi_cyc.end(), branching[i]); \n\t\t\t\t\tif(ist == demi_cyc.end()) \n\t\t\t\t\t{ \n                        #pragma omp parallel for schedule (static) \n\t\t\t\t\t\tfor (int k = 0; k < kamer; k++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tint nps_cycle = (((kamer + k) * 2) + 2); \n\t\t\t\t\t\t\tsearch_snps(branching[i], 0, nps_cycle, P); \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tvisited.clear(); \n      \t\t\t\t\t\t\tfor (int i = 0; i < all_elem_key.size(); i++) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tvisited.insert(pair<u64, bool>(all_elem_key[i], 0)); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n\t\t\t\t} \n \n \n\t\t\t} \n \n \n\t\t\t \n \n\t\t\tnp = omp_get_num_threads(); \n\t\t\ttid = omp_get_thread_num(); \n\t\t\tpip = omp_get_max_threads(); \n                        gc_vec.push_back(gc); \n \n\t\t\tif (((cycles_.size() > cyclesize) && tid == 0) || (i == nvalues - 1))  \n                        { \n \n \n\t\t\t\ttotalsnps = totalsnps + (cycles_.size() - cyclesize); \n\t\t\t\t \n \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tout << all_elem_key.size() << ' '; \n\t\t\t\tout << cycles_.size() << ' ';   \n \n\t\t\t\tout << cycles_.size() - cyclesize << ' '; \n\t\t\t\t \n \n\t\t\t\tout << nvalues  - call << ' '; \n\t\t\t\tout << *std::max_element(begin(gc_vec), end(gc_vec)) << ' '; \n  \n\t\t\t\t \n \n\t\t\t\t \n \n \n\t\t\t\tstd::clock_t c_end = std::clock(); \n \n\t\t\t\tout << std::fixed << std::setprecision(2)  \n \n\t\t\t\t\t<< ((c_end - c_start) / (double)CLOCKS_PER_SEC) << ' '; \n \n\t\t\t\tdouble end = omp_get_wtime(); \n \n\t\t\t\tdif = end - start;  \n \n\t\t\t\tout << dif << endl; \n \n\t\t\t\tcyclesize = cycles_.size(); \n \n\t\t\t\tstep++; \n                                 \n                                gc_vec.clear(); \n \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif (tid == 0) { \n \n\t\t\t\tauto t_end = std::chrono::high_resolution_clock::now(); \n \n\t\t\t\tstop = std::chrono::duration<double, std::ratio<60>>(t_end - t_start).count(); \n\t\t\t} \n \n \n\t\t\t \n \n\t\t\tbranching.clear(); \n\t\t\tall_elem_key.clear(); \n\t\t\tm.clear(); \n\t\t\tcall++;  \n \n\t\t\t \n \n\t\t\t \n \n\t\t} \n \n \n\t}", "pragma": "parallel for private(gc j)", "hash": "64d02bd3ae0715ce11f5c80d382b3384ef485e731441fbb86904fb665d6a6627"}
{"code": "for(size_t pattern = 0; pattern < nr_initial_mers; pattern++) { \n    float joint_prob = 1.0; \n    for(int k_prime = 0; k_prime <= k; k_prime++) { \n      joint_prob *= model->getV()[k_prime][get_bg_id(pattern, k_prime+1, k_prime)]; \n    } \n    int remaining_shifts = pattern_length - k - 1; \n    if(remaining_shifts > 0)  { \n      calculate_bg_probability(background_model, alphabet_size, k, remaining_shifts, pattern, joint_prob, \n                               pattern_bg_probs, pattern_length); \n    } else { \n      pattern_bg_probs[pattern] = joint_prob; \n    } \n  }", "pragma": "parallel for ", "hash": "7e906bcc5a5bc792ed6060b04000e2ccc5de45232f61a37909058c79ec2e679c"}
{"code": "for (int i = 0; i < numQuads; i++) \n    {         \n        int idx = 8*i; \n        indices->set(idx + 0, i*4 + 0); \n        indices->set(idx + 1, i*4 + 1); \n        indices->set(idx + 2, i*4 + 1); \n        indices->set(idx + 3, i*4 + 2); \n        indices->set(idx + 4, i*4 + 2); \n        indices->set(idx + 5, i*4 + 3); \n        indices->set(idx + 6, i*4 + 3); \n        indices->set(idx + 7, i*4 + 0); \n    }", "pragma": "parallel for ", "hash": "4c47fb9952d4a95550aa0a71f71675068022bb1b65d9634c27aef505bd472abd"}
{"code": "for(int i=0; i<size; i++) \n    delinp[i] = 0.0;", "pragma": "parallel for ", "hash": "829988e239631ddf8e28118d01f3b3c77e558a5908612793f845d1946e1d08a4"}
{"code": "for (int i = 0; i < EdgePartitions.Len(); i++) { \n      TInt CurrStart = EdgePartitions[i].GetVal1(); \n      TInt CurrEnd = EdgePartitions[i].GetVal2(); \n      for (int e_i = CurrStart; e_i < CurrEnd ; e_i++) { \n        curr_eid = offset + factor*e_i; \n        if (CrossNet.IsEdge(e_i)) { \n          int new_eid = curr_eid; \n          TIntPr EdgeKey(CrossNetId, e_i); \n          TCrossNet::TCrossEdgeI edge = CrossNet.GetEdgeI(e_i); \n          int srcNode = edge.GetSrcNId(); \n          int dstNode = edge.GetDstNId(); \n          TIntPr NodeKeySrc(Mode1, srcNode); \n          TIntPr NodeKeyDst(Mode2, dstNode); \n          int newSrc = NodeMap.GetDat(NodeKeySrc); \n          int newDst = NodeMap.GetDat(NodeKeyDst); \n          NewNet->AddEdgeUnchecked(curr_eid, newSrc, newDst); \n          curr_eid++; \n          int otherEId = -1; \n          if (!CrossNet.IsDirected()) { \n            otherEId = curr_eid; \n            NewNet->AddEdgeUnchecked(otherEId, newDst, newSrc); \n          } \n          EdgeMap.AddDat(EdgeKey, TIntPr(new_eid, otherEId)); \n        } \n      } \n    }", "pragma": "parallel for private(curr_eid)", "hash": "b97945d87e465f04e332bc5ada09d5a82056f8fa815e4b89ee869d4ce84e8247"}
{"code": "for(i=0;i<*neq;i++){ \n\t    ad[i]=ad1[i]; \n\t    for(j=1;j<num_cpus;j++){ \n\t\tad[i]+=ad1[i+j**neq]; \n\t    } \n\t}", "pragma": "for ", "hash": "6c67cdbc6b25fe6cf0b381d7cdaada3c982bdea3659eb18ad5ecb3d8d0c58bce"}
{"code": "for (indx=0; indx < m_Height*m_Width; indx++) { \n    m_Image[indx][0] = CLIP((int32_t)(m_Image3[indx][0] / 3.0f - m_Image3[indx][2] / 6.0f + m_Image3[indx][1] / 3.464101615)); \n    m_Image[indx][1] = CLIP((int32_t)(m_Image3[indx][0] / 3.0f - m_Image3[indx][2] / 6.0f - m_Image3[indx][1] / 3.464101615)); \n    m_Image[indx][2] = CLIP((int32_t)(m_Image3[indx][0] / 3.0f + m_Image3[indx][2] / 3.0f)); \n  }", "pragma": "parallel for private(indx)", "hash": "6997aa641ecc266745d3a21d08270bfd4b064fc60d4b116c5a9203a438ccf492"}
{"code": "for (int n\t= 0; n <= N_IC-1; n++) \n\t{ \n\t\tfor (int s = 0; s <= variable_setup.NS-1; s++)\tV[n][s]\t\t\t\t\t\t= rho_s[n][s]; \n\t\tfor (int k = 0; k <= variable_setup.ND-1; k++)\tV[n][variable_setup.NS+k]\t= u[n][k]; \n \n\t\tV[n][ne]\t= T[n]; \n\t\tswitch (variable_setup.energy_flag) \n\t\t{ \n\t\tcase 0: \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 0, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n \n\t\tcase 1: \n\t\t\tV[n][ne+1]\t= Te[n]; \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 0, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n \n\t\tcase 2: \n\t\t\tV[n][ne+1]\t= Tv[n]; \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 0, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n \n\t\tcase 3: \n\t\t\tV[n][ne+1]\t= Tv[n]; \n\t\t\tV[n][ne+2]\t= Te[n]; \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 0, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n \n\t\tcase 4: \n\t\t\tV[n][ne+1]\t= Tr[n]; \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 1, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n \n\t\tcase 5: \n\t\t\tV[n][ne+1]\t= Tr[n]; \n\t\t\tV[n][ne+2]\t= Te[n]; \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 1, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n \n\t\tcase 6: \n\t\t\tV[n][ne+1]\t= Tr[n]; \n\t\t\tV[n][ne+2]\t= Tv[n]; \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 1, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n \n\t\tcase 7: \n\t\t\tV[n][ne+1]\t= Tr[n]; \n\t\t\tV[n][ne+2]\t= Tv[n]; \n\t\t\tV[n][ne+3]\t= Te[n]; \n\t\t\tvariable_data[n].calculate_data(variable_setup.NS, 1, V[n], species.Cv_t, species.Cv_r, species.R, species.M); \n\t\t\tbreak; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "8833a46f32a83174c30e83ef67c45e1b1910e09f51d1a6f6e674e91c48673e1b"}
{"code": "for( OMPInt i=0; i<nEl; ++i) \n\t    { \n\t      (*res)[ i] = static_cast<DLong>( round((*p0C)[ i]));  \n\t    }", "pragma": "for ", "hash": "1ade25439d1803b914cc8216c06bd0ebd26a3162210c9c6233c00f8670dac5d9"}
{"code": "for (i = 0; i < nx; i++) \n\t\tdata1D[i] = cte;", "pragma": "parallel for private(i)", "hash": "625df91055d76f932dc0174fab0f78d91fdd40cf7c7caf3d0fb6c86d76bc0bd4"}
{"code": "for (i = 0; i < num; i++) { \n    x[i][0] = h[0]*x[i][0] + h[5]*x[i][1] + h[4]*x[i][2] + boxlo[0]; \n    x[i][1] = h[1]*x[i][1] + h[3]*x[i][2] + boxlo[1]; \n    x[i][2] = h[2]*x[i][2] + boxlo[2]; \n  }", "pragma": "parallel for private(i)", "hash": "e2fbc31f70fe4c2b523252b0cb794ede6130de110a819d7d87a6af26cc2c67a4"}
{"code": "for(j=0; j < J; j++){ \n \n\t\tbeta = 0.0; \n \n\t\tfor(i = 0; i < N; i++){ \n \n\t\t\t \n \n\t\t\t \n \n \n\t  \t\tbeta += Ezzstar(i,j) + Ett(j,0); \n \n \n \n \n\t  \t\tbeta += Exx(i,0) * Ebb(j,0) - 2*Ezstar(i,j)*Etau(j,0); \n\t  \t\tbeta = beta - 2*Ezstar(i,j)*Ex(i,0)*Eb(j,0) + 2*Etau(j,0)*Ex(i,0)*Eb(j,0); \n \n\t\t} \n \n\t\tbeta = beta/2; \n\t\talpha = 1 + N/2; \n\t\tEdd(j,0) = alpha/beta; \n\t \n\t}", "pragma": "parallel for private(beta i j)", "hash": "735d8356f95c3909e1e6cb4a62ac4fd877216707caa097f4be49a19289cb1264"}
{"code": "for(ix=0; ix<rnx; ix++){ \n                curr[(ix+nb)*fnz+gpz]+=dd[ix][it]; \n            }", "pragma": "parallel for private(ix)", "hash": "deb5f868ee4a8c09eefa8ff100f1b8510a45a4505450f2f57b26a881e9539fe1"}
{"code": "for (j = 0; j < system->N; ++j) { \n        start_j = Start_Index(j, bonds); \n        end_j = End_Index(j, bonds); \n \n        for (pk = start_j; pk < end_j; ++pk) { \n          bo_jk = &(bonds->select.bond_list[pk].bo_data); \n          for (k = 0; k < nthreads; ++k) \n            bo_jk->Cdbo += bo_jk->CdboReduction[k]; \n        } \n      }", "pragma": "for ", "hash": "2234ae558db9c45d65a054aa44e189e1478adebce0d2f96b3cb2e924818fbe4e"}
{"code": "for(int i = 0; i < arraySize; ++i)\r \n            outArray[i] = arrayPointer[i];", "pragma": "parallel for ", "hash": "9abd6e21e20769fd49b8a95349203a6211cce8e730b92f4761adc9c5d416fc2a"}
{"code": "for (j=0; j<NX; j++) \n      for (i=0;i<NX;i++) \n      cc[j][i] = aa[j][i]+bb[j][i];", "pragma": "parallel for ", "hash": "f7adbdd3a7fbe4602cb75578d2b7ee13b240def5561e0fee4a477f0bcdb26338"}
{"code": "for(int iPoint=0; iPoint<nPoints; iPoint+=nSkip) \n\t{ \n\t\tint\tjPoint\t= m_Selection.Get_Size() > 0 ? *((int *)m_Selection.Get_Entry(iPoint)) : iPoint; \n \n\t\tTSG_Point_Z\tp\t= m_pPoints->Get_Point(jPoint); \n \n\t\tm_Projector.Get_Projection(p); \n \n\t\tDraw_Point(p.x, p.y, p.z, \n\t\t\tGet_Color(m_pPoints->Get_Value(jPoint, cField), p.z), \n\t\t\tSize + (dSize <= 0.0 ? 0 : (int)(20.0 * exp(-dSize * p.z))) \n\t\t); \n\t}", "pragma": "parallel for ", "hash": "00f9cfa7e9aba8c5aa8668c7f09f6e89e7910b93464b9cd7ec3f70b4e9e90c40"}
{"code": "for (n=0; n<N; n++) \n    { \n        for (k=0; k<rsctrellis.numStates; k++) \n        { \n            A0[k+n*rsctrellis.numStates] = -INFINITY; \n            A1[k+n*rsctrellis.numStates] = -INFINITY; \n            B0[k+n*rsctrellis.numStates] = buffer; \n            B1[k+n*rsctrellis.numStates] = buffer; \n        } \n        A_mid[n] = 0; \n    }", "pragma": "parallel for private(k n)", "hash": "af995fb9c03df39e859ff6faa2e4cb8d63e91d80c37e2f6a5c2cdcbd2fa3ddb3"}
{"code": "for (int k = 0; k < nSide; k++) \n      for (int j = 0; j < nSide; j++) \n        for (int i = 0; i < nSide; i++) \n          out_shape[ijk2gmsh[i+nSide*(j+nSide*k)]] = lag_i[i] * lag_j[j] * lag_k[k];", "pragma": "parallel for ", "hash": "18d5b096ee62b37811112a5cb2a8cbe18ff160ac04317ac3fe507333249ebb04"}
{"code": "for (size_t i = 0;i < zeroBufferSize;i++) \n\t\t\tzeroBuff[i] = (BYTE)0;", "pragma": "parallel for ", "hash": "bbbe262992cdad2ad9f97075ee267475116f50fdb02c681ba89dea640cae0702"}
{"code": "for(i=0; i<(size_t)omp_get_max_threads(); i++)", "pragma": "parallel for ", "hash": "dad3adeab8981814e1912c893418883563ffc96b0531b5096b38f67c0a1ca82a"}
{"code": "for (int i = 0; i < querySetSize; i++){ \n                    int id = querySeqs[i]; \n \n                    int thread_idx = 0; \n                    thread_idx = omp_get_thread_num(); \n                    char* seqData = tdbr->getData(id); \n                    seqs[thread_idx]->mapSequence(id, tdbr->getDbKey(id), seqData); \n \n                    matchers[thread_idx]->matchQuery(seqs[thread_idx], UINT_MAX); \n \n                    kmersPerPos += seqs[thread_idx]->stats->kmersPerPos; \n                    dbMatchesSum += seqs[thread_idx]->stats->dbMatches; \n                }", "pragma": "parallel for reduction( +: dbmatchessum kmersperpos) ", "hash": "4f169f60de11b76199ac34ba28da8a54ab99ae2b7fbfe3800db577e14c99d984"}
{"code": "for(i=0;i<l;i++) \n\t{ \n\t\tz[i] = y[i]*z[i]; \n\t\tdouble d = 1-z[i]; \n\t\tif (d > 0) \n\t\t\tf += C[i]*d*d; \n\t}", "pragma": "parallel for reduction(+:f) private(i)", "hash": "33cdd20d8fe3bac8101b3e8cfe92d617a49ae879db1be9e1b1533f6f244a0f48"}
{"code": "for (int ir = 0; ir < num_points; ir++) { \n            vsigma_[0]->f_rg(ir) = vsigma_tmp[ir]; \n            vsigma.f_rg(ir) = vsigma_tmp[ir]; \n        }", "pragma": "parallel for ", "hash": "232dee6b0ce4c8eee0432317030466c6dac2ecb4376bb2b6aa112f541ced4fd9"}
{"code": "for(size_t i=0;i<grids.size();i++) { \n       \n \n      wrk[ith].set_grid(grids[i]); \n      wrk[ith].form_hirshfeld_grid(hirsh); \n       \n \n      wrk[ith].eval_overlap(Swrk); \n       \n \n      wrk[ith].free(); \n \n       \n \n#pragma omp critical \n      Sat[grids[i].atind]+=Swrk; \n    }", "pragma": "for ", "hash": "a93e6855b7eb9e080ee39c65f679f57228ab1a56993ddd579a0f8b670e2db52b"}
{"code": "for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w2 = j * 2;", "pragma": "parallel for private(conditional: w2)", "hash": "c61728d84448452dd4d797297e1981535d920b71a56298628c4651b8712d580c"}
{"code": "for(long j=0;j<2*ny;j++)\tfor(long i=0;i<2*nx;i++)\t \n \n\t{ \n\t\tregister long i0 = i+2*nx*j; \n\t\tif(i<nx/2)\t\tdmp[i0] += GAMMA*mgl_ipow((nx/2-i)/(nx/2.),2); \n\t\tif(i>3*nx/2)\tdmp[i0] += GAMMA*mgl_ipow((i-3*nx/2-1)/(nx/2.),2); \n\t\tif(j<ny/2)\t\tdmp[i0] += GAMMA*mgl_ipow((ny/2-j)/(ny/2.),2); \n\t\tif(j>3*ny/2)\tdmp[i0] += GAMMA*mgl_ipow((j-3*ny/2-1)/(ny/2.),2); \n\t}", "pragma": "parallel for ", "hash": "383d2e264af8674d2fa19e5dcf19ae9d7384cb59fde953c8f6e0198f19d60907"}
{"code": "for (int i = 0; i < PARTICLESIZE; i++) { \n    vec3 newVelo(0, 0, 0); \n    for (int j = 0; j < PARTICLESIZE; j++) { \n      vec3 r = bodies[j].pos - bodies[i].pos; \n      float distSqr = dot(r, r) + SOFTENING; \n      if (distSqr > 0.1f) { \n        float invDist = 1.0f / sqrtf(distSqr); \n        float invDist3 = invDist * invDist * invDist; \n \n        newVelo += r * invDist3; \n      } \n    } \n \n    bodies[i].speed += delta * newVelo * FRICITON; \n    bodies[i].speed -= 0.000001f * bodies[i].pos; \n    bodies[i].pos += bodies[i].speed; \n \n    bodies[i].pos.x = clamp(bodies[i].pos.x, -1000.0f, 1000.0f); \n    bodies[i].pos.y = clamp(bodies[i].pos.y, -1000.0f, 1000.0f); \n    bodies[i].pos.z = clamp(bodies[i].pos.z, -1000.0f, 1000.0f); \n  }", "pragma": "parallel for ", "hash": "c54adae77eb51d5e4ae961733d23bf3b14eb23fe213b10ddae9371e055e41049"}
{"code": "for (i = 0;i < n;i++){ \n      trash = quatVector( &(q[i*qstep]), &(v[i*vstep]), &(vout[i*voutstep]), p ); \n    }", "pragma": "for ", "hash": "a3ebf97932ce687fe2532e4910782a0d41cd4df5d4f1aac0adfa773256fe9757"}
{"code": "for (i = 0; i < n; i++) { \n            for (j = 0; j < n; j++) { \n                sum = 0; \n                for (k = 0; k < n; k++) { \n                    sum += a[i][k] * b[k][j]; \n                } \n                c[i][j] = sum; \n            } \n        }", "pragma": "for ", "hash": "c8128eb28b503c8e700d5922df47edccb381caa879643871705f05aca10028d2"}
{"code": "for (int i = 0; i < clusterAmount; ++i) { \n\t\tthis->clusterList[i].id = i; \n\t\tthis->previousClusterList[i].id = i; \n \n\t\t \n \n\t\tuint64_t maxParticles = (particleAmount - numberOfParticlesInCluster) / clusterAmount; \n\t\tstd::random_device rd; \n\t\tstd::mt19937_64 mt(rd()); \n\t\tstd::uniform_int_distribution<uint64_t> distribution(1, maxParticles); \n\t\tthis->clusterList[i].numberOfParticles = distribution(mt); \n\t\tnumberOfParticlesInCluster += this->clusterList[i].numberOfParticles; \n \n\t\tuint64_t streuung = this->clusterList[i].numberOfParticles / 10; \n\t\tstd::uniform_int_distribution<uint64_t> distribution2(this->clusterList[i].numberOfParticles - streuung, this->clusterList[i].numberOfParticles + streuung); \n\t\tthis->previousClusterList[i].numberOfParticles = distribution2(mt); \n \n\t\t \n \n\t\tstd::uniform_int_distribution<uint64_t> distRoot(0, particleAmount - 1); \n\t\tthis->previousClusterList[i].rootParticleID = distRoot(mt); \n\t\tthis->clusterList[i].rootParticleID = distRoot(mt); \n\t}", "pragma": "parallel for ", "hash": "d1a4229a97ea3bbc893306b5b5246ee0905fbcc458d912ee556c3974949207f3"}
{"code": "for (ompIndexType k = 0; k < elementCount; k++) { \n            char** value = (char**)(data + offset + (sizeType * k)); \n            ptrArrayOf[k] = ArrayOf::characterArrayConstructor(std::string(value[0])); \n        }", "pragma": "parallel for ", "hash": "24ae9788c5ae1778aa575301581c7be8184406a419d180ae2e373a7910b295f8"}
{"code": "for (int i=0; i<total; i++)\r \n\t\t{\r \n\t\t\t*(outPtr+i+total)=*(outPtr+i+total)+move_y;\r \n\t\t}", "pragma": "parallel for ", "hash": "3d4d0b91ad9e4827ef63c0e7d903464e414b0e9d8c17c9e3081d8731516bb544"}
{"code": "for(fint ied = m->gSubDomFaceStart(); ied < m->gSubDomFaceEnd(); ied++) \n\t\t{ \n\t\t\tconst fint ielem = m->gintfac(ied,0); \n\t\t\tconst fint jelem = m->gintfac(ied,1); \n \n\t\t\tfor(int i = 0; i < nvars; i++) \n\t\t\t{ \n\t\t\t\tufl(ied,i) = linearExtrapolate(u(ielem,i), grads[ielem], i, 1.0, \n\t\t\t\t                               &gr(ied,0), ri+ielem*NDIM); \n\t\t\t\tufr(ied,i) = linearExtrapolate(u(jelem,i), grads[jelem], i, 1.0, \n\t\t\t\t                               &gr(ied,0), ri+jelem*NDIM); \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "c03139dc817bc322d2db16dc08d30ca873fc09290f9d348b31b5fff220a83869"}
{"code": "for (size_t i = 0; i < n; i++) \n      idxs[i] = i;", "pragma": "parallel for ", "hash": "dd1cb848d8346eeba51996b3ef814ad5db33104047248b2191e09e916470323d"}
{"code": "for(int y = 0; y < nY ; y++){\r \n        for(int x = 0; x < nX; x++){\r \n             \n \n            float laf_correction = 0;\r \n            if(dlaf_gradient.size() > 0) {\r \n                float olaf = olafs[y][x];\r \n                float ilaf = dlafs[y][x];\r \n                if(gridpp::is_valid(olaf) && gridpp::is_valid(ilaf)) {\r \n                    float laf_diff = olaf - ilaf;\r \n                    laf_correction = dlaf_gradient[y][x]*laf_diff;\r \n                }\r \n            }\r \n\r \n            float elev_correction = 0;\r \n            if(delev_gradient.size() > 0) {\r \n                float oelev = oelevs[y][x];\r \n                float ielev = delevs[y][x];\r \n                if(gridpp::is_valid(oelev) && gridpp::is_valid(ielev)) {\r \n                    float elev_diff = oelev - ielev;\r \n                    elev_correction = delev_gradient[y][x]*elev_diff;\r \n                }\r \n            }\r \n\r \n            output[y][x] += laf_correction + elev_correction;\r \n        }\r \n    }", "pragma": "parallel for ", "hash": "05746f4785f8bd63a1a5222a67a8a15f38e0d265181d581c61c53cc3ccacf932"}
{"code": "for (int batch=0; batch<nBatch; batch++) { \n        const int *restrict      my_starts = starts + batch*256; \n        const uint16_t *restrict my_counts = counts + batch*256; \n        const uint8_t *restrict  ksub = key[radix+1+r] + from + batch*batchSize;   \n \n        const uint8_t *restrict  byte = ugrps + batch*256;                         \n \n        const int                my_ngrp = ngrps[batch]; \n        for (int i=0; i<my_ngrp; i++, byte++) { \n          const uint16_t len = my_counts[*byte]; \n          memcpy((uint8_t *)TMP + my_starts[*byte], ksub, len); \n          ksub += len; \n        } \n      }", "pragma": "parallel for ", "hash": "a98c73e418afa18951d06cd28b3d2dca6e1a3bc69d805c749da6240ee3ccbc21"}
{"code": "for (ix=nx+ibnd-ntaper; ix<nx+ibnd; ix++) { \n#pragma ivdep \n\t\t\tfor (iz=ibnd; iz<nz+ibnd; iz++) { \n\t\t\t\tvx[ix*n1+iz] *= bnd.tapx[ix-ib]; \n\t\t\t\tvz[ix*n1+iz] *= bnd.tapz[ix-ib]; \n\t\t\t} \n\t\t}", "pragma": "for private(ix iz)", "hash": "1252643349c2e21d2fd99b5a0989a77efe6a5a11e72e5488b4fc16384cc04829"}
{"code": "for (i = 0; i < total_device_number; i++) { \n \n\t\t\t\ttmp_cal_arg = &mic_args[i]; \n \n\t\t\t\tint k = 0; \n\t\t\t\tmic_read_index = 0; \n\t\t\t\tfor (k = 0; k < i; k++) { \n\t\t\t\t\tmic_read_index += device_read_counts[k]; \n\t\t\t\t} \n \n\t\t\t\ttmp_cal_arg->mic_ref_start = ref_start; \n\t\t\t\ttmp_cal_arg->mic_ref_end = ref_end; \n\t\t\t\ttmp_cal_arg->read_ptr = &read_ptr[mic_read_index * CHAR_NUM * word_num]; \n\t\t\t\ttmp_cal_arg->result_ptr = &result_ptr[mic_read_index * (ref_end - ref_start)]; \n\t\t\t\ttmp_cal_arg->read_count = device_read_counts[i]; \n\t\t\t\tsingle_read_count = device_read_counts[i]; \n\t\t\t\tsingle_read_size = single_read_count * word_num * CHAR_NUM; \n\t\t\t\ttmp_cal_arg->read_size = single_read_size; \n\t\t\t\tsingle_result_size = (ref_end - ref_start) * single_read_count; \n\t\t\t\ttmp_cal_arg->result_size = single_result_size; \n\t\t\t\tif (cal_output_info.buffer_flag) { \n\t\t\t\t\ttmp_cal_arg->async_flag = 0; \n\t\t\t\t} else { \n\t\t\t\t\ttmp_cal_arg->async_flag = 1; \n\t\t\t\t} \n \n\t\t\t\tmic_cal(tmp_cal_arg); \n\t\t\t}", "pragma": "parallel for private(     i mic_read_index single_read_count single_read_size single_result_size tmp_cal_arg)", "hash": "e854bb1106146081189307e34283eaa7c9c953e627ee07d5400f8c890ad0aada"}
{"code": "for (int y = 0; y < h; ++y) { \n\t\t\tprocessLine(y); \n\t\t}", "pragma": "parallel for ", "hash": "8dd8b93577334ec0d8bc92e6f3a2067ba560830a4d88809091a843d5502db1cd"}
{"code": "for(size_t j = 0; j < input.size(); ++j) { \n            double score = profile_hmm_score(current_haplotype.get_sequence(), input[j], alignment_flags); \n \n            #pragma omp atomic \n            haplotype_score += score; \n        }", "pragma": "parallel for ", "hash": "b779b54e57dcd5f932ddce7b22249d197ba9d5f7cd9938198d79422e0d5a0634"}
{"code": "for ( int64_t i = 1; i < int64_t( porePressures.size() - 1 ); ++i ) \n    { \n        bool validPP_im1 = porePressures[i - 1] >= 0.0 && porePressures[i - 1] != std::numeric_limits<double>::infinity(); \n        bool validPP_i   = porePressures[i] >= 0.0 && porePressures[i] != std::numeric_limits<double>::infinity(); \n        bool validPP_ip1 = porePressures[i + 1] >= 0.0 && porePressures[i + 1] != std::numeric_limits<double>::infinity(); \n        bool anyValidPP           = validPP_im1 || validPP_i || validPP_ip1; \n        smoothOrFilterSegments[i] = !anyValidPP; \n    }", "pragma": "parallel for ", "hash": "14e80096904468772e0071609e0973f1f97c1d928055649b0128f9c865ccc59a"}
{"code": "for(long i=0;i<vx;i++)\tb[k+i] = v->vthr(i);", "pragma": "parallel for ", "hash": "6e914b242f56fccb83dea4d9e8246c43227a5d080d24990d230bfaf909d1bb7c"}
{"code": "for (OMPInt i = 0; i < nEl; ++i) \n        StrPut((*dest)[i], source, pos);", "pragma": "for ", "hash": "a56b265511a4a3a1cd4ac95c522314dff544e2e21433a988f624c3ba0f10802c"}
{"code": "for(T i = clen+2; i < 20; ++i) { \n \n \n      v[i] = v[v-clen] + 1; \n \n \n    }", "pragma": "for simd ", "hash": "7ff953a8835352fb37b38e2d1f00f88598746b99ca263ddf50ab747cbde4b7b2"}
{"code": "for (int i=0;i<tod->ndet;i++) {  \n      if ((!mbCutsIsAlwaysCut(tod->cuts,tod->rows[i],tod->cols[i]))&&(is_det_listed(tod,params,i))) { \n\t \n \n\tget_pointing_vec_new(tod,map,i,ind,scratch); \n\t \n \n\tif (tod->kept_data) { \n\t  int row=tod->rows[i]; \n\t  int col=tod->cols[i]; \n\t  mbUncut *uncut=tod->kept_data[row][col]; \n\t  for (int region=0;region<uncut->nregions;region++)  \n\t    for (int j=uncut->indexFirst[region];j<uncut->indexLast[region];j++) \n\t      mymap->map[ind[j]]+=tod->data[i][j];\t   \n\t} \n\telse { \n\t  if (tod->uncuts) { \n\t     \n \n\t    int row=tod->rows[i]; \n\t    int col=tod->cols[i]; \n\t    mbUncut *uncut=tod->uncuts[row][col]; \n\t    for (int region=0;region<uncut->nregions;region++)  \n\t      for (int j=uncut->indexFirst[region];j<uncut->indexLast[region];j++) \n\t\tmymap->map[ind[j]]+=tod->data[i][j]; \n\t  } \n\t  else  \n\t    for (int j=0;j<tod->ndata;j++)  \n\t      mymap->map[ind[j]]+=tod->data[i][j]; \n\t} \n      } \n    }", "pragma": "for ", "hash": "5e196cf37816722ef2407ecb7c4d85b84e190db066b18e4b8e3392819d2b0a8b"}
{"code": "for(int i = 0; i<m_size ; i++) \n\t\t{ \n\t\t\tthis->m_growCode[i] = 1; \n\t\t\tthis->m_cht[i] = 1.5f; \n\t\t\tthis->m_lai[i] = 0.95f; \n\t\t\tm_pet[i] = 0.f; \n\t\t}", "pragma": "parallel for ", "hash": "47669879b990d848ab6af02b5355cd120eb105776dba2934fd5421e40029750a"}
{"code": "for(int i = 0; i < nPoints; i++) { \n         \n \n         \n \n        float lat = iOutputLats[i]; \n        float lon = iOutputLons[i]; \n        output[i] = ::calc(igrid, iInputLats, iInputLons, ivalues, lat, lon); \n    }", "pragma": "parallel for ", "hash": "8d0614a87a446b8ab7bed31690bcd2fb140702153b563d706052f82920301f33"}
{"code": "for( int i = 0; i < blockssize; ++i ) { \n      SetupBlock* const block = blocks[ uint_c(i)  ]; \n \n      std::vector< real_t >      neighborhoodSectionBlockCenters; \n      std::vector< SetupBlock* > neighborhoodSectionBlocks; \n \n      for( uint_t n = 0; n != 26; ++n ) { \n \n         constructNeighborhoodSectionBlockCenters( n, block->getAABB(), neighborhoodSectionBlockCenters ); \n \n         WALBERLA_ASSERT_EQUAL( neighborhoodSectionBlockCenters.size() % 3, 0 ); \n \n         for( uint_t p = 0; p != neighborhoodSectionBlockCenters.size(); p += 3 ) { \n \n            real_t x = neighborhoodSectionBlockCenters[p]; \n            real_t y = neighborhoodSectionBlockCenters[p+1]; \n            real_t z = neighborhoodSectionBlockCenters[p+2]; \n \n             \n \n            if( x <  domain_.xMin() && periodic_[0] ) x = domain_.xMax() - domain_.xMin() + x; \n            if( x >= domain_.xMax() && periodic_[0] ) x = domain_.xMin() - domain_.xMax() + x; \n            if( y <  domain_.yMin() && periodic_[1] ) y = domain_.yMax() - domain_.yMin() + y; \n            if( y >= domain_.yMax() && periodic_[1] ) y = domain_.yMin() - domain_.yMax() + y; \n            if( z <  domain_.zMin() && periodic_[2] ) z = domain_.zMax() - domain_.zMin() + z; \n            if( z >= domain_.zMax() && periodic_[2] ) z = domain_.zMin() - domain_.zMax() + z; \n \n            SetupBlock* neighbor = getBlock( x, y, z ); \n \n            if( neighborhoodSectionBlocks.empty() || neighborhoodSectionBlocks.back() != neighbor ) \n               neighborhoodSectionBlocks.push_back( neighbor ); \n         } \n \n         for( uint_t v = 0; v != neighborhoodSectionBlocks.size(); ++v ) \n            for( uint_t w = v+1; w != neighborhoodSectionBlocks.size(); ++w ) \n               WALBERLA_ASSERT_UNEQUAL( neighborhoodSectionBlocks[v], neighborhoodSectionBlocks[w] ); \n         WALBERLA_ASSERT( !neighborhoodSectionBlocks.empty() ); \n \n         block->clearNeighborhoodSection(n); \n         if( neighborhoodSectionBlocks.back() != nullptr ) { \n \n            if( neighborhoodSectionBlocks.back()->getLevel() > block->getLevel() ) \n            { \n               WALBERLA_ASSERT_EQUAL( neighborhoodSectionBlocks.size(), getBlockMaxNeighborhoodSectionSize(n) ); \n            } \n            else \n            { \n               WALBERLA_ASSERT_EQUAL( neighborhoodSectionBlocks.size(), 1 ); \n            } \n            for( uint_t j = 0; j != neighborhoodSectionBlocks.size(); ++j ) \n               block->addNeighbor( n, neighborhoodSectionBlocks[j] ); \n         } \n \n         neighborhoodSectionBlocks.clear(); \n         neighborhoodSectionBlockCenters.clear(); \n      } \n      block->assembleNeighborhood(); \n   }", "pragma": "parallel for ", "hash": "cc70fd9f5bf209521809453214c672869bbe4e4859fe83bdff204e7aab5225e6"}
{"code": "for(j=0; j<dim1_size; j+=nblk){ \n               for(i=0; i<dim0_size; i+=nblk){ \n                  for(int ii=i; ii<i+nblk && ii<dim0_size; ii++){ \n                     for(int jj=j; jj<j+nblk && jj<dim1_size; jj++){ \n                        buf_p[src_w*ii+jj] = base_p[jj*alloc_size+ii]; \n                     } \n                  } \n               } \n            }", "pragma": "parallel for private(i j)", "hash": "b2d8461c543ebb9206973b7190f9f4d0ce316af85d2387742d6c8ad68ceb90be"}
{"code": "for (int feature_index = 0; feature_index < num_features_; ++feature_index) { \n    if (!col_sampler_.is_feature_used_bytree()[feature_index] && (force_features == nullptr || force_features->find(feature_index) == force_features->end())) continue; \n    if (parent_leaf_histogram_array_ != nullptr \n        && !parent_leaf_histogram_array_[feature_index].is_splittable()) { \n      smaller_leaf_histogram_array_[feature_index].set_is_splittable(false); \n      continue; \n    } \n    is_feature_used[feature_index] = 1; \n  }", "pragma": "parallel for ", "hash": "50aefac481d6db24f899ed6aae80932619e7a4acfbccc7531b399a09ac78b7bb"}
{"code": "for (int i = 2; i <= LIM - 1; i++) { \n    if (DIVS[i] == DIVS[i + 1]) { \n      ans++; \n    } \n  }", "pragma": "parallel for reduction(+ : ans) ", "hash": "e3ab6a44f34a92b2bc03524719933dc7cbdb6510da6d91b037a682a1051b0588"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tlong k = i*nx;\t\t\tb[k] = b[k+nx-1] = 0;\r \n\t\tfor(long j=1;j<nx-1;j++)\tb[j+k] = (a[j+k+1]+a[j+k-1]-2*a[j+k])*dd;\r \n\t}", "pragma": "parallel ", "hash": "38eb46a242f0da28b07583f63142c6c79fed164aba6f55ba0b85c96d56a1cb3d"}
{"code": "for(int s=disp; s < disp+nsends; ++s) { \n        idx_t const row = local2nbr_inds[s]; \n        for(idx_t f=0; f < nfactors; ++f) { \n          local2nbr_buf[f + (s*nfactors)] = matv[f + (row*nfactors)]; \n        } \n      }", "pragma": "for ", "hash": "388b2abe92b97b4e6b4ba0b543c3c8ced76dc74a50d4945baae50a36ed849e3c"}
{"code": "for (int j = 0; j < nCols; ++j) \n        { \n            int y = double(j)/nCols*imgbak.cols; \n            cv::Vec3f sum = cv::Vec3f(); \n            double sumt = 0.0; \n            for (int k=-1; k<=2;k++) \n                for (int l=-1; l<=2; l++) \n                { \n                    cv::Vec3f t; \n                    if(y+l < 0) t = p[k][0]; \n                    else if(y+l >= imgbak.cols) t = p[k][imgbak.cols]; \n                    else t = p[k][y+l]; \n                    double w = cubicW(fabs(double(j)/nCols*imgbak.cols-(y+l)))*cubicW(fabs(double(i)/nRows*imgbak.rows-(x+k))); \n                    sum = sum + w * t; \n                    sumt += w; \n                } \n            n[j] = sum/sumt; \n        }", "pragma": "parallel for ", "hash": "d5db2c25851cc2e41c2535c51a31fcbd282bab9b20b33a6b7c63e4d0f49245ba"}
{"code": "for (k = 0; k < xro->nz; k++) { \n\txro->data[k * xro->nx * xro->ny + j * xro->nx + i] =  \n\t  xr->data[(k+trim[2]) * xr->nx * xr->ny + (j+trim[1]) * xr->nx + (i+trim[0])]; \n      }", "pragma": "parallel for private(k)", "hash": "7a328cbfd81dc9f13db24c1b4a4d4da90c73f6e93e4f4d9bc189880ac6aff86f"}
{"code": "for (unsigned n = 0; n < _nb_threads; n++) \n            { \n                bm3d_1st_step(sigma, sub_noisy[n], sub_basic[n], w_table[n], \n                              h_table[n], chnls, nHard, kHard, NHard, pHard, useSD_h, \n                              color_space, tau_2D_hard, &plan_2d_for_1[n], \n                              &plan_2d_for_2[n], &plan_2d_inv[n]); \n            }", "pragma": "for ", "hash": "a4083f10c4cc4ee6d15cd2df95f755ab0efe0ad281da3f5923da60385349bc50"}
{"code": "for (int n = 0; n < ntotal; n++) { \n        graph[n].join([&](int i, int j) { \n            if (i != j) { \n                float dist = qdis.symmetric_dis(i, j); \n                graph[i].insert(j, dist); \n                graph[j].insert(i, dist); \n            } \n        }); \n    }", "pragma": "parallel for ", "hash": "b024676a4e756b32ce11b7b9e59161a09ba124fc9584cefcfb55f515c02dcb81"}
{"code": "for (int iBox=0; iBox<s->boxes->nLocalBoxes; ++iBox) \n   { \n      for (int iOff=MAXATOMS*iBox, ii=0; ii<s->boxes->nAtoms[iBox]; ++ii, ++iOff) \n      { \n         v0 += s->atoms->p[iOff][0]; \n         v1 += s->atoms->p[iOff][1]; \n         v2 += s->atoms->p[iOff][2]; \n \n         int iSpecies = s->atoms->iSpecies[iOff]; \n         v3 += s->species[iSpecies].mass; \n      } \n   }", "pragma": "parallel for reduction(+:v0) reduction(+:v1) reduction(+:v2) reduction(+:v3) ", "hash": "7fd6de382baac70688c9575f91255b5478dc38b96eae740bc4e84e1cbbaa6b71"}
{"code": "for (int i = 0; i < (int)tumframes.size(); ++i) \n    { \n        TumFrame d = tumframes[i]; \n         \n \n \n \n        Image cimg(datasetDir + \"/\" + d.rgb.img); \n        rgbo.h = cimg.h; \n        rgbo.w = cimg.w; \n \n \n        Image dimg(datasetDir + \"/\" + d.depth.img); \n \n        bool downScale = (dmpp && dmpp->params.apply_downscale) ? true : false; \n        int targetW    = downScale ? dimg.w / 2 : dimg.w; \n        int targetH    = downScale ? dimg.h / 2 : dimg.h; \n \n        deptho.w = targetW; \n        deptho.h = targetH; \n \n        auto f = makeFrameData(); \n \n \n        if (cimg.type == UC3) \n        { \n             \n \n            ImageTransformation::addAlphaChannel(cimg.getImageView<ucvec3>(), f->colorImg); \n        } \n        else if (cimg.type == UC4) \n        { \n            cimg.getImageView<ucvec4>().copyTo(f->colorImg.getImageView()); \n        } \n        else \n        { \n            SAIGA_ASSERT(0); \n        } \n \n        DepthImageType tmp; \n        tmp.create(dimg.h, dimg.w); \n \n        if (dimg.type == US1) \n        { \n            dimg.getImageView<unsigned short>().copyTo(tmp.getImageView(), depthFactor); \n        } \n        else \n        { \n            SAIGA_ASSERT(0); \n        } \n \n        if (dmpp) \n        { \n            (*dmpp)(tmp, f->depthImg.getImageView()); \n        } \n        else \n        { \n            tmp.getImageView().copyTo(f->depthImg.getImageView()); \n        } \n \n \n        frames[i] = f; \n    }", "pragma": "parallel for ", "hash": "11bf1e9756ae9b4339ba5eec5d9f2c52285dd9a9b4ff26c0fa8a38ce39a8fc87"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t(*res)[i] = (*this)[i] | (*right)[i];", "pragma": "for ", "hash": "7715c1166dfe9e6e3fb32889b0f373b3d99ae62a08acec161ade841ad9a02dc2"}
{"code": "for (int objIndex = 0; objIndex < (int) numObjects; objIndex++) \n\t\t{ \n\t\t\tElasticObject* obj = m_objects[objIndex]; \n\t\t\tauto& RHS_perm = obj->m_RHS_perm; \n\t\t\tauto& matL = obj->m_factorization->m_matL; \n\t\t\tauto& matLT = obj->m_factorization->m_matLT; \n \n\t\t\tfor (int k = 0; k < matL.outerSize(); ++k) \n\t\t\t\tfor (Eigen::SparseMatrix<Real, Eigen::ColMajor>::InnerIterator it(matL, k); it; ++it) \n\t\t\t\t\tif (it.row() == it.col()) \n\t\t\t\t\t\tRHS_perm[it.row()] /= it.value(); \n\t\t\t\t\telse \n\t\t\t\t\t\tRHS_perm[it.row()] -= it.value() * RHS_perm[it.col()]; \n \n\t\t\t \n \n\t\t\tfor (int k = (int) matLT.outerSize() - 1; k >= 0; --k) \n\t\t\t\tfor (Eigen::SparseMatrix<Real, Eigen::ColMajor>::ReverseInnerIterator it(matLT, k); it; --it) \n\t\t\t\t\tif (it.row() == it.col()) \n\t\t\t\t\t\tRHS_perm[it.row()] /= it.value(); \n\t\t\t\t\telse \n\t\t\t\t\t\tRHS_perm[it.row()] -= it.value() * RHS_perm[it.col()]; \n\t\t}", "pragma": "for ", "hash": "7dd187380204a40328fd52969150d317fbc29657d1ac1db7c93d2b23f8ed7b61"}
{"code": "for (int e = 0; e < indices.size(); e++) \n            tads->at(e)->assign(_chunks[indices[e]]);", "pragma": "parallel for ", "hash": "0682df97dc7439beb9292456f3a34102cd29d1c3400b786e258f693d3a495a39"}
{"code": "for ( size_t i = 0; i < n; ++i ) { \n        double mean ( 0. ), variance ( 0. ); \n        lsba_low->Predict ( ( *u_h ) [i], ( *v_h ) [i], mean, variance ); \n        ( *var_low ) [i] = variance; \n      }", "pragma": "parallel for ", "hash": "8d0bfc804d586b270be4577d5420a1d4a27c5cd8401a3011e192a1f5933c1265"}
{"code": "for (i=1; i<imax+1; i++){ \n\t\tfor (j=1;j< jmax+1; j++){ \n\t\t\tH[i][j][0]    = W[i][j][0]; \n\t\t\tH[i][j][kmax] = W[i][j][kmax]; \n\t\t} \n\t}", "pragma": "parallel for private(j)", "hash": "1ad9c7ab4684928f093713e9632e438b4858afd2260397391c67c135611aeff3"}
{"code": "for(unsigned o = 0; o < objList.size(); o++) \n    { \n      jp::id_t objID = objList[o]; \n      if(hypMap[objID].size() > 1) \n      { \n\tstd::sort(hypMap[objID].begin(), hypMap[objID].end()); \n\thypMap[objID].erase(hypMap[objID].begin() + hypMap[objID].size() / 2, hypMap[objID].end()); \n      } \n    }", "pragma": "parallel for ", "hash": "896b71f0b72717e96d4a0c2d126417d4925acd7130b58c78ffa6790ca10dbadf"}
{"code": "for(ix=0; ix<sx*sy; ix++){ img_in[0][ix] = bufferf1[ix]; }", "pragma": "parallel for ", "hash": "2859b7f8ec7b065cc373e6d8e298195709e98a5641dc383b3f7ab1a2b7e11737"}
{"code": "for(int t=0;t<cnet.size();t++){ \n\t\t\t\tcnet[t]->forward(v4); \n\t\t\t\tint tpd= cnet[t]->getPrediction(); \n\t\t\t\tFP tpb = cnet[t]->getProb(); \n\t\t\t\t \n\t\t\t\tvote[tpd]++; \n\t\t\t\tvotepb[tpd]+=tpb; \n\t\t\t}", "pragma": "parallel for ", "hash": "5927f921768c091667a431f1ebbbd857ce2ca124a046aa8b322ad7f39a890e81"}
{"code": "for (int i = 0; i < 16; i++) \n    for (int j = 0; j < 16; j += i) \n      ;", "pragma": "for ", "hash": "9c1aa1825004de76754bb72021f3634d77de96a61e036c269e12df2f9ac22c8e"}
{"code": "for (size_t tRow_J = tRow + 1; tRow_J < m_uiN - 1; tRow_J++) \n\t\t{ \n\t\t\tif (lpdValues[tRow_J * m_uiN + tRow] != 0.0) \n\t\t\t{ \n\t\t\t\tlong double dRow_J_Scalar = lpdValues[tRow_J * m_uiN + tRow] * dRow_Scalar; \n\t\t\t\tfor (size_t tCol = tRow + 1; tCol < m_uiN; tCol++) \n\t\t\t\t{ \n\t\t\t\t\t \n \n\t\t\t\t\tlpdValues[tRow_J * m_uiN + tCol] += dRow_J_Scalar * lpdValues[tRow * m_uiN + tCol]; \n\t\t\t\t\t \n \n\t\t\t\t} \n\t\t\t\tlpdValues[tRow_J * m_uiN + tRow] = 0.0; \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "fd586926371ccdf20d58fae2520fe79163997426bf621ef73d5af1244a82b43f"}
{"code": "for (int c = 1; c <= grid.NCM; c++) \n\t\t{ \n\t\t\tint c_ptr\t= grid.cells.whereis[c]; \n\t\t\tint cl, cr; \n\t\t\tint f; \n \n\t\t\tfor (int k = 0; k <= grid.cells.data_ptr[c_ptr]->NF-1; k++) \n\t\t\t{ \n\t\t\t\tf \t= grid.faces.whereis[grid.cells.data_ptr[c_ptr]->face[k]]; \n\t\t\t\tcl\t= grid.faces.data_ptr[f]->cl[0]; \n\t\t\t\tcr\t= grid.faces.data_ptr[f]->cr[0]; \n\t\t\t\tint c_ptr2; \n \n\t\t\t\tif (cl == c) \n\t\t\t\t{ \n\t\t\t\t\tif (cr > 0) \n\t\t\t\t\t{ \n\t\t\t\t\t\tc_ptr2\t= grid.cells.whereis[cr]; \n\t\t\t\t\t\tfor (int j = 0; j <= NVAR-1; j++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tdouble aux = 0.0; \n\t\t\t\t\t\t\tfor (int l = 0; l <= NVAR-1; l++) \n\t\t\t\t\t\t\t\taux +=\tSolution.Jacobian_inviscid_minus[f][j][l] * Solution.dQ[c_ptr2][l]; \n \n\t\t\t\t\t\t\tR[c_ptr](j+1, 1)\t-= aux; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n \n\t\t\t\tif (cr == c) \n\t\t\t\t{ \n\t\t\t\t\tif (cl > 0) \n\t\t\t\t\t{ \n\t\t\t\t\t\tc_ptr2\t= grid.cells.whereis[cl]; \n\t\t\t\t\t\tfor (int j = 0; j <= NVAR-1; j++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tdouble aux = 0.0; \n\t\t\t\t\t\t\tfor (int l = 0; l <= NVAR-1; l++) \n\t\t\t\t\t\t\t\taux +=\tSolution.Jacobian_inviscid_plus[f][j][l] * Solution.dQ[c_ptr2][l]; \n \n\t\t\t\t\t\t\tR[c_ptr](j+1, 1)\t+= aux; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "5c12313b8181481f3c50a0ff00e58c3e528f93eb2bb8860bd6af4eeacab1cbc6"}
{"code": "for (int y = 0; y < size.height; y++) { \n      Vec4T const* src = args.get(i).ptr<Vec4T const>(y); \n      cv::Vec4f* dst = local_view.ptr<cv::Vec4f>(y); \n \n      for (int x = 0; x < size.width; x++) { \n         \n \n        cv::Vec3f const bgr(std::pow(src[x][0] * alpha_scale, gamma),    \n \n                            std::pow(src[x][1] * alpha_scale, gamma),    \n \n                            std::pow(src[x][2] * alpha_scale, gamma));   \n \n \n         \n \n        cv::Vec3f const xyz = tnzu::to_xyz(bgr); \n \n        dst[x][0] *= xyz[0]; \n        dst[x][1] *= xyz[1]; \n        dst[x][2] *= xyz[2]; \n      } \n    }", "pragma": "parallel for ", "hash": "d540cfc72177b3cddcad42a2dd86c96928a5530acf1700f9b229db84ee0b5b97"}
{"code": "for(i=0;i<n;i=i+1){ \n\t\tcont = 0; \n\t\tfor(j=0;j<n;j=j+1){ \n\t\t\tif(vector[i] > vector[j]){ \n\t\t\t\tcont = cont + 1; \n\t\t\t} \n\t\t\telse if ( (vector[i] == vector[j]) && (i > j) ){ \n\t\t\t\tcont = cont + 1; \n\t\t\t} \n\t\t} \n\t\tresult[cont] = vector[i]; \n\t}", "pragma": "parallel for private(cont j)", "hash": "819d27220e821b9ddc2d77116640fdb460c0c2896b581a0e7db4ba67fb5fc5e2"}
{"code": "for (int i = 0; i < 2; ++i) { \n     \n \n \n \n \n \n    g = 1; \n    g1 = 2; \n    sivar = 3; \n \n    [&]() { \n      g = 4; \n      g1 = 5; \n      sivar = 6; \n \n    }(); \n  }", "pragma": "for private(  g g1 sivar)", "hash": "56f7b7f4d923f984b2b6ba9efabacbda061cae427b6ced34f07a65e0d8d80b1f"}
{"code": "for (SizeT i = 0; i < sz; ++i) {  \n        Ty cdata=data[i]-meanl; \n          T2 cdatar=cdata.real(); \n          T2 cdatai=cdata.imag(); \n          if (finite(cdatar)) kurtr += (cdatar*cdatar*cdatar*cdatar-6.0*cdatar*cdatar*cdatai*cdatai+cdatai* \n            cdatai*cdatai*cdatai)*(varr*varr-vari*vari)/(pow(varr*varr-vari*vari,2.0)+ \n            4.0*varr*varr*vari*vari)+2.0*(4.0*cdatar*cdatar*cdatar*cdatai- \n            4.0*cdatar*cdatai*cdatai*cdatai)*varr*vari/ \n            (pow(varr*varr-vari*vari,2.0)+ \n            4.0*varr*varr*vari*vari); \n          if (finite(cdatai)) kurti += (4.0*cdatar*cdatar*cdatar*cdatai-4.0*cdatar*cdatai*cdatai*cdatai)* \n            (varr*varr-vari*vari)/(pow(varr*varr-vari*vari,2.0)+4.0*varr*varr*vari*vari)- \n            2.0*(cdatar*cdatar*cdatar*cdatar- \n            6.0*cdatar*cdatar*cdatai*cdatai+cdatai*cdatai*cdatai*cdatai)*varr*vari/ \n            (pow(varr*varr-vari*vari,2.0)+ \n            4.0*varr*varr*vari*vari); \n        }", "pragma": "for reduction(+:kurtr kurti) ", "hash": "efae2b38f260ea308b1669cf6626f05c0f58ea10a0b139e6ca4c01ec8c1244a8"}
{"code": "for (a = 0; a < nmatrices; ++a)\r \n        expm_srt_3d(&out[out_stride*a], &r[nparams*a], &t[t_stride*a], s[s_stride*a]);", "pragma": "parallel for private(a)", "hash": "3a72c4a6ec1b4b1aea8bf5137ce4811e74db71132d677cd059614200175e3b1e"}
{"code": "for (i = 0; i < 8; ++i) \n    f0 ();", "pragma": "for ", "hash": "8994c9788ded9ac82fdc6dad578cbe7059fccad4075789795ee3f490b5c57fc3"}
{"code": "for (int i = 0; i < nFrame; ++i) { \n        const thpp::Tensor<T>& input_i = input[i]; \n        const int* targetData_i = targets[i].data(); \n        const int targetLength = zeroPadArrayLength(targetData_i, maxTargetlength); \n        const int nSegment = 2 * targetLength + 1; \n \n         \n \n        thpp::Tensor<T> fvars({inputLength, nSegment}); \n        fvars.fill(LogMath<T>::logZero); \n        fvars.at({0, 0}) = input_i.at({0, 0}); \n        if (nSegment > 1) { \n            fvars.at({0, 1}) = input_i.at({0, targetData_i[0]}); \n        } \n        for (int t = 1; t < inputLength; ++t) { \n            const thpp::Tensor<T>& currLogActs = input_i[t]; \n            const thpp::Tensor<T>& prefFvars = fvars[t-1]; \n            int sBegin = std::max(0, nSegment - (2 * (inputLength - t))); \n            int sEnd = std::min(nSegment, 2 * (t + 1)); \n            for (int s = sBegin; s < sEnd; ++s) {  \n \n                T fv; \n                if (s % 2 == 1) {  \n \n                    int labelIndex = s/2; \n                    int label = targetData_i[labelIndex]; \n                    fv = LogMath<T>::logAdd(prefFvars.at(s), prefFvars.at(s-1)); \n                    if (s > 1 && label != targetData_i[labelIndex-1]) { \n                        fv = LogMath<T>::logAdd(fv, prefFvars.at(s-2)); \n                    } \n                    fv = LogMath<T>::logMul(fv, currLogActs.at(label)); \n                } else {  \n \n                    fv = prefFvars.at(s); \n                    if (s > 0) { \n                        fv = LogMath<T>::logAdd(fv, prefFvars.at(s-1)); \n                    } \n                    fv = LogMath<T>::logMul(fv, currLogActs.at(0));  \n \n                } \n                fvars.at({t,s}) = fv; \n            } \n        } \n \n         \n \n        T logProb = fvars.at({inputLength-1, nSegment-1}); \n        if (nSegment > 1) { \n            logProb = LogMath<T>::logAdd(logProb, fvars.at({inputLength-1, nSegment-2})); \n        } \n        losses.at(i) = (-logProb); \n \n        if (!forwardOnly) { \n             \n \n            thpp::Tensor<T> bvars({inputLength, nSegment}); \n            bvars.fill(LogMath<T>::logZero); \n            bvars.at({inputLength-1, nSegment-1}) = LogMath<T>::logOne; \n            if (nSegment > 1) { \n                bvars.at({inputLength-1, nSegment-2}) = LogMath<T>::logOne; \n            } \n            for (int t = inputLength-2; t >= 0; --t) { \n                const thpp::Tensor<T>& prevLogActs = input_i[t+1]; \n                const thpp::Tensor<T>& prevBvars = bvars[t+1]; \n                int sBegin = std::max(0, nSegment - (2 * (inputLength - t))); \n                int sEnd = std::min(nSegment, 2 * (t + 1)); \n                for (int s = sBegin; s < sEnd; ++s) { \n                    T bv; \n                    if (s % 2 == 1) { \n                        const int labelIndex = s/2; \n                        int label = targetData_i[labelIndex]; \n                        bv = LogMath<T>::logAdd( \n                            LogMath<T>::logMul(prevBvars.at(s), prevLogActs.at(label)), \n                            LogMath<T>::logMul(prevBvars.at(s+1), prevLogActs.at(blankLabel))); \n                        if (s < nSegment-2) { \n                            const int prevLabel = targetData_i[labelIndex+1]; \n                            if (label != prevLabel) { \n                                bv = LogMath<T>::logAdd(bv, \n                                    LogMath<T>::logMul(prevBvars.at(s+2), prevLogActs.at(prevLabel))); \n                            } \n                        } \n                    } else { \n                        int labelIndex = s/2; \n                        int label = targetData_i[labelIndex]; \n                        bv = LogMath<T>::logMul(prevBvars.at(s), prevLogActs.at(blankLabel)); \n                        if (s < nSegment-1) { \n                            bv = LogMath<T>::logAdd(bv, \n                                LogMath<T>::logMul(prevBvars.at(s+1), prevLogActs.at(label))); \n                        } \n                    } \n                    bvars.at({t,s}) = bv; \n                } \n            } \n \n             \n \n            for (int t = 0; t < inputLength; ++t) { \n                const thpp::Tensor<T>& currLogFv = fvars[t]; \n                const thpp::Tensor<T>& currLogBv = bvars[t]; \n                std::vector<T> logDeDy(nClasses, LogMath<T>::logZero); \n                for (int s = 0; s < nSegment; ++s) { \n                    int k = (s%2==1) ? targetData_i[s/2] : blankLabel; \n                    logDeDy[k] = LogMath<T>::logAdd(logDeDy[k], \n                        LogMath<T>::logMul(currLogFv.at(s), currLogBv.at(s))); \n                } \n                for (int k = 0; k < nClasses; ++k) { \n                    gradInput.at({i,t,k}) = -LogMath<T>::safeExp( \n                        LogMath<T>::logDiv(logDeDy[k], logProb)); \n                } \n            } \n        }  \n \n    }", "pragma": "parallel for ", "hash": "20b529c767c257c496fc206c4cddac55e611d50c2c931496cd92b67fbf742838"}
{"code": "for (int tile_block = 0; tile_block < jcp.tile_block; tile_block++) { \n        int ithr = mkldnn_get_thread_num(); \n \n        for (int ifm1 = 0; ifm1 < jcp.nb_ic; ++ifm1) { \n            for (int ifm2 = 0; ifm2 < jcp.ic_block; ++ifm2) { \n                diff_src_transform_bwd_weights_ver_tile(tile_block, jcp, \n                        &(diff_src(0, ifm1 * jcp.ic_block + ifm2, \n                                0, 0, 0)), \n                        &(V(ithr, ifm1, 0, 0, ifm2, 0, 0, 0)), \n                        kernel_->transpose_4fma_ker); \n            } \n        } \n \n        for (int ofm1 = 0; ofm1 < jcp.nb_oc; ofm1++) { \n            for (int ofm2 = 0; ofm2 < jcp.oc_block; ofm2++) { \n                float *dbias = jcp.with_bias \n                    ? &(diff_bias_prv(ithr, \n                                simd_w * (ofm1 * jcp.oc_block + ofm2))) \n                    : NULL; \n                diff_dst_transform_bwd_weights_ver(tile_block, jcp, \n                        &(diff_dst(0, ofm1 * jcp.oc_block + ofm2, \n                                0, 0, 0)), \n                        &(M(ithr, ofm1, 0, 0, ofm2, 0, 0, 0)), \n                        dbias); \n            } \n        } \n \n        for (int ofm1 = 0; ofm1 < jcp.nb_oc; ofm1++) { \n            for (int oj = 0; oj < alpha; oj++) { \n                for (int oi = 0; oi < alpha; oi++) { \n                    for (int ifm1 = 0; ifm1 < jcp.nb_ic; ifm1++) { \n                        if (th_counter == 0) \n                            kernel_->gemm_loop_ker_first_iter( \n                                    &(Us(ithr, ofm1, ifm1, oj, oi, 0, 0, 0, 0)), \n                                    &(M(ithr, ofm1, oj, oi, 0, 0, 0, 0)), \n                                    &(V(ithr, ifm1, oj, oi, 0, 0, 0, 0))); \n                        else \n                            kernel_->gemm_loop_ker( \n                                    &(Us(ithr, ofm1, ifm1, oj, oi, 0, 0, 0, 0)), \n                                    &(M(ithr, ofm1, oj, oi, 0, 0, 0, 0)), \n                                    &(V(ithr, ifm1, oj, oi, 0, 0, 0, 0))); \n                    } \n                } \n            } \n        } \n        th_counter++; \n    }", "pragma": "for ", "hash": "47e4f662511775e40f45ffb8ca32d166ca1ca4228d5176c73be7159131989ff4"}
{"code": "for (size_t n = 0; n < batch_sz; ++n) { \n    const float *bottom_data = in_buf + n * in_width * in_height * chan; \n    float *top_data = out_buf + n * out_width * out_height * chan; \n    for (size_t c = 0; c < chan; ++c) { \n      for (size_t ph = 0; ph < out_height; ++ph) { \n        for (size_t pw = 0; pw < out_width; ++pw) { \n          size_t hstart = ph * stride_h_ - pad_h_; \n          size_t wstart = pw * stride_w_ - pad_w_; \n          size_t hend = min(hstart + kernel_h_, in_height + pad_h_); \n          size_t wend = min(wstart + kernel_w_, in_width + pad_w_); \n          size_t pool_size = (hend - hstart) * (wend - wstart); \n          hstart = max(hstart, 0); \n          wstart = max(wstart, 0); \n          hend = min(hend, in_height); \n          wend = min(wend, in_width); \n          for (size_t h = hstart; h < hend; ++h) { \n            for (size_t w = wstart; w < wend; ++w) { \n              top_data[ph * out_width + pw] += \n                  bottom_data[h * in_width + w]; \n            } \n          } \n          top_data[ph * out_width + pw] /= ((float)pool_size); \n        } \n      } \n      bottom_data += in_width * in_height; \n      top_data += out_width * out_height; \n    } \n  }", "pragma": "parallel for ", "hash": "d113e85c5b3236020e1bc04dcde67dbf9b8868b822898ebc9c8eeda71348096d"}
{"code": "for (int i = 0; i < np; i++) \n  { \n    const auto &vtx = vtxArray[i]; \n    const float4 pos0 = make_float4(vtx.pos.x,vtx.pos.y,vtx.pos.z,1.0f); \n    const float4 posO = modelView(pos0); \n    const float4 posP = projection(posO); \n \n    const float  wclip = -1.0f/posO.z; \n    float4 posV = make_float4(posP.x*wclip, posP.y*wclip, posP.z*wclip, -1.0f); \n    float3 col = make_float3(-1.0f); \n \n    const float depth = posV.z; \n    if (depth >= depthMin && depth <= depthMax) \n    { \n \n      posV.x = (posV.x + 1.0f) * 0.5f * width; \n      posV.y = (1.0f - posV.y) * 0.5f * height; \n      posV.x = (posV.x + 1.0f)*0.5f*width; \n      posV.y = (posV.y + 1.0f)*0.5f*height; \n      using std::abs; \n      posV.w = vtx.pos.h * 0.5f * width *abs(wclip); \n      assert(posV.w > 0.0f); \n \n      using std::sqrt; \n      using std::min; \n      posV.w = sqrt(posV.w*posV.w + minHpix*minHpix); \n      posV.w = min(posV.w, maxHpix); \n      assert(posV.w > 0.0f); \n \n      if (   posV.x - posV.w <= width \n          && posV.x + posV.w >= 0 \n          && posV.y - posV.w <= height \n          && posV.y + posV.w >= 0) \n      { \n        const float s = vtx.attr.vel; \n        const float t = vtx.attr.rho; \n        assert(s>=0.0f && s<=1.0f); \n        assert(t>=0.0f && t<=1.0f); \n        const auto &tex = colorMapTex(s,t); \n        col = make_float3(tex[0],tex[1],tex[2]); \n      } \n      else \n        posV.w = -1.0; \n    } \n \n    depthArray  [i] = depth; \n    vtxArrayView[i] =  \n    { \n      pos2d_t(posV.x, posV.y, posV.w), \n      make_float4(col, 1.0f), \n      vtx.attr \n    }; \n \n    nVisible += vtxArrayView[i].isVisible(); \n  }", "pragma": "parallel for reduction(+:nvisible) ", "hash": "ed7e62a86f08682a7e4f51bbb0ed90f621aaa605db67a8a732f9c18f79cb466c"}
{"code": "for(int i = 0; i < size; i += ch) \n  { \n    float XYZ[3] = { 0 }; \n \n    dt_RGB_to_XYZ(img_src + i, XYZ); \n    dt_XYZ_to_Lab(XYZ, img_src + i); \n \n    for(int c = 0; c < 1; c++) \n    { \n      const float L_in = img_src[i + c] / 100.0f; \n \n      if(L_in <= left) \n      { \n        img_src[i + c] = 0.f; \n      } \n      else \n      { \n        const float percentage = (L_in - left) / (right - left); \n        img_src[i + c] = 100.0f * powf(percentage, in_inv_gamma); \n      } \n    } \n \n    dt_Lab_to_XYZ(img_src + i, XYZ); \n    dt_XYZ_to_RGB(XYZ, img_src + i); \n  }", "pragma": "parallel for ", "hash": "4b4a1b61b32a74f00621b8d581c58abd6b8f274595a2dbb33968437ddd9b8366"}
{"code": "for (int boxNr = 0; boxNr < numBoxes; boxNr++) {\t\t \n\t\t \n\t\tLogManager *log = LogManager::getSingletonPtr(); \n\t\tBVH *tree;\t\t\t\t \n\t\tVoxelHashTableIterator it;\t\t \n\t\t \n \n\t\tstdext::hash_map<unsigned int, Vertex> vertexMap; \n\t\tTriangle *triangleCache; \n\t\tunsigned int *triangleIndexCache; \n\t\tFILE *triangleFile, *triangleIdxFile; \n\t\tchar output[500]; \n \n\t\t \n \n\t\tit = voxelHashTable->find(boxNr); \n\t\tif (it == voxelHashTable->end()) \n\t\t\tcontinue; \n \n#pragma omp critical \n\t\t{ \n\t\t\tboxesBuilt++; \n\t\t}\t\t \n\t\tboxesBuilt++; \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tCashedBoxSingleFile<Vertex> *pVertexCache = new CashedBoxSingleFile<Vertex>(getVertexFileName(), grid.getSize(), 10, false); \n\t\tCashedBoxSingleFile<Vertex> &vertexCache = *pVertexCache; \n \n\t\tunsigned int numTris = it->second;\t\t \n\t\t \n\t\tsprintf(output, \" - Processor %d voxel %d / %d (%u tris)\", omp_get_thread_num(), boxesBuilt, numUsedVoxels, numTris); \n\t\tlog->logMessage(LOG_INFO, output);\t\t \n \n\t\t \n \n\t\tFILE *test = fopen(getBVHFileName(boxNr).c_str(), \"rb\"); \n\t\tif (test != 0) { \n\t\t\tcout << \"   skipping, already built.\" << endl; \n\t\t\tfclose(test); \n\t\t\tcontinue; \n\t\t} \n \n\t\t \n \n\t\t \n \n\t\tif ((triangleFile = fopen(getVTriangleFileName(boxNr).c_str(), \"rb\")) == NULL) { \n\t\t\tcout << \"ERROR: could not open file \" << getVTriangleFileName(boxNr) << \" !\" << endl; \n\t\t\tcontinue; \n\t\t} \n \n\t\tif ((triangleIdxFile = fopen(getTriangleIdxFileName(boxNr).c_str(), \"rb\")) == NULL) { \n\t\t\tcout << \"ERROR: could not open file \" << getTriangleIdxFileName(boxNr) << \" !\" << endl; \n\t\t\tcontinue; \n\t\t}\t\t \n \n\t\ttriangleCache = new Triangle[numTris]; \n\t\ttriangleIndexCache = new unsigned int[numTris]; \n\t\tsize_t ret = fread(triangleCache, sizeof(Triangle), numTris, triangleFile); \n\t\tif (ret != numTris) { \n\t\t\tcout << \"ERROR: could only read \" << ret << \" of \" << numTris << \" triangles from file \" << getVTriangleFileName(boxNr) << \" !\" << endl;\t\t\t \n\t\t\tcontinue; \n\t\t} \n\t\tret = fread(triangleIndexCache, sizeof(unsigned int), numTris, triangleIdxFile); \n\t\tif (ret != numTris) { \n\t\t\tcout << \"ERROR: could only read \" << ret << \" of \" << numTris << \" triangles from file \" << getVTriangleFileName(boxNr) << \" !\" << endl;\t\t\t \n\t\t\tcontinue; \n\t\t} \n \n\t\tfclose(triangleIdxFile); \n\t\tfclose(triangleFile); \n \n\t\tVector3 bb_min, bb_max; \n\t\tbb_min.e[0] = FLT_MAX; \n\t\tbb_min.e[1] = FLT_MAX; \n\t\tbb_min.e[2] = FLT_MAX; \n\t\tbb_max.e[0] = -FLT_MAX; \n\t\tbb_max.e[1] = -FLT_MAX; \n\t\tbb_max.e[2] = -FLT_MAX; \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tfor (unsigned int i = 0; i < numTris; i++) {\t\t\t \n\t\t\tvertexMap[triangleCache[i].p[0]] = vertexCache[triangleCache[i].p[0]]; \n\t\t\tvertexMap[triangleCache[i].p[1]] = vertexCache[triangleCache[i].p[1]]; \n\t\t\tvertexMap[triangleCache[i].p[2]] = vertexCache[triangleCache[i].p[2]]; \n\t\t\tupdateBB(bb_min, bb_max, vertexCache[triangleCache[i].p[0]].v); \n\t\t\tupdateBB(bb_min, bb_max, vertexCache[triangleCache[i].p[1]].v); \n\t\t\tupdateBB(bb_min, bb_max, vertexCache[triangleCache[i].p[2]].v); \n\t\t} \n \n\t\tvoxelMinsTemp[boxNr] = bb_min; \n\t\tvoxelMaxsTemp[boxNr] = bb_max; \n \n\t\t \n \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n \n\t\ttree = new BVH(triangleCache, triangleIndexCache, numTris, &vertexMap, bb_min, bb_max, boxNr, getBVHTestFileName(boxNr).c_str()); \n\t\ttree->buildTreeSAH();\t\t \n\t\ttree->saveToFile(getBVHFileName(boxNr).c_str()); \n\t\ttree->printTree(false); \n\t\t \n\t\tdelete pVertexCache; \n\t\tdelete triangleCache; \n\t\tdelete triangleIndexCache; \n\t\tdelete tree; \n\t}", "pragma": "parallel for ", "hash": "e62a5c96ec8c7a884f6fa4d5610c8b0eb0334cf255a6bb2907b5f78d4b587e3d"}
{"code": "for (size_t i = 0; i < entries; ++i) { \n            progress.updateProgress(); \n            unsigned int key = reader.getDbKey(i); \n            std::string name = par.db2; \n            if (name.back() != '/') { \n                name.append(1, '/'); \n            } \n            if (par.unpackNameMode == Parameters::UNPACK_NAME_ACCESSION) { \n                size_t lookupId = reader.getLookupIdByKey(key); \n                name.append(FileUtil::sanitizeFilename(reader.getLookupEntryName(lookupId))); \n            } else { \n                name.append(SSTR(key)); \n            } \n            name.append(par.unpackSuffix); \n            FILE* handle = FileUtil::openAndDelete(name.c_str(), \"w\"); \n            fwrite(reader.getData(i, thread_idx), sizeof(char), reader.getEntryLen(i) - 1, handle); \n            fclose(handle); \n        }", "pragma": "for ", "hash": "7b9f1749ff92fa63e1d3b99308f0c8629481aa797fb763c916dc3283fd58bfda"}
{"code": "for (size_t id = 0; id < indexSizeNew; ++id) { \n            if (par.useSequenceId) { \n                keysNew[id] = std::make_pair( \n                        Util::parseFastaHeader(newReader.getData(id,thread_idx)), \n                        newReader.getDbKey(id)); \n            } else { \n                keysNew[id] = std::make_pair( \n                        Util::removeWhiteSpace(newReader.getData(id, thread_idx)), \n                        newReader.getDbKey(id)); \n            } \n        }", "pragma": "for ", "hash": "66b0ce73287297077cd18364c620a79b14550a477e8c4926bb836ccb55a1e4e8"}
{"code": "for ( int i = 0; i < matrix.rows(); ++i ) \n        { \n            Sparse row      = matrix.row( i ); \n            const int check = ( row.nonZeros() > 0 ) ? 1 : 0; \n#pragma omp atomic \n            status &= check; \n        }", "pragma": "parallel for ", "hash": "b0956c73829031655911c74c8d81e1c0befd45c4bb54787c40e8c343840c80ab"}
{"code": "for (int i = 0; i < (int)scene.images.size(); ++i) \n    { \n        auto& img   = scene.images[i]; \n        auto extr   = img.se3; \n        auto camera = scene.intrinsics[img.intr]; \n        StereoCamera4 scam(camera, scene.bf); \n \n        for (auto& ip : img.stereoPoints) \n        { \n            if (!ip) continue; \n             \n \n            auto i  = ip.wp; \n            auto wp = x_v[i]; \n            auto w  = ip.weight * scene.scale(); \n \n \n \n            if (ip.IsStereoOrDepth()) \n            { \n                auto stereo_point = ip.GetStereoPoint(scene.bf); \n                auto [res, depth] = \n                    BundleAdjustmentStereo(scam, ip.point, stereo_point, extr, wp, w, w * scene.stereo_weight); \n \n \n \n                auto c = res.squaredNorm(); \n                chi2_per_point_new[i] += c; \n                chi2_sum += c; \n            } \n            else \n            { \n                auto [res, depth] = BundleAdjustment(scam, ip.point, extr, wp, w); \n \n                auto c = res.squaredNorm(); \n                chi2_per_point_new[i] += c; \n                chi2_sum += c; \n            } \n        } \n    }", "pragma": "for ", "hash": "9b6289c3650bb06bff6fff2e04268d9ce32f386f99dec64c229112b2a72ad919"}
{"code": "for (n=0; n<nMIC0; n++) { \n         AC.x[n] = 0; \n         AC.y[n] = 0; \n         AC.z[n] = 0; \n    }", "pragma": "parallel for ", "hash": "1681f8ffb80b5ed73f2e116e07defaa0eb8217587dc407f093985dbb7b827d1e"}
{"code": "for (i = 0; i < npixels; i++) { \n\t\tj1[i] = Dxx[i] * ud[i]; \n\t\tj2[i] = Dxy[i] * ud[i]; \n\t\tj3[i] = Dxz[i] * ud[i]; \n\t}", "pragma": "parallel for ", "hash": "d325a97070799275093578bff072eea1521a207e75009a6c21ae0c999e3ecf20"}
{"code": "for(int i0 = 0; i0 < mean.width; i0++) \n  { \n    float *buf = img_bak + dt_get_thread_num() * size; \n    for(int i1 = 0; i1 < mean.height; i1++) \n      SIMD_FOR (int k = 0; k < 4; k++) \n        buf[4*i1+k] = mean.data[4*(i0 + (size_t)i1 * mean.width)+k]; \n    box_mean_1d_4ch(mean.height, buf, mean.data + 4*i0, 4 * mean.width, w); \n    for(int i1 = 0; i1 < var.height; i1++) \n      SIMD_FOR (int k = 0; k < 9; k++) \n        buf[9*i1+k] = var.data[9*(i0 + (size_t)i1 * var.width)+k]; \n    box_mean_1d_9ch(var.height, buf, var.data + 9*i0, 9 * var.width, w); \n  }", "pragma": "parallel for ", "hash": "26d8066c579c73966289ebf53681a5c2e6d1e83eef86f2ca64b4f63108ffdc2b"}
{"code": "for(int grid_idx = 0; grid_idx < n_blocks; ++grid_idx) { \n    const ot_tree_t* itree = octree_get_tree(in, grid_idx); \n    ot_tree_t* otree = octree_get_tree(out, grid_idx); \n \n     \n \n    const ot_data_t* prob_data = octree_get_data(prob, grid_idx);  \n \n    if(!tree_isset_bit(itree, 0)) { \n      int data_idx = tree_data_idx(itree, 0, 1); \n      if(prob_data[data_idx] >= thr) { \n        tree_set_bit(otree, 0); \n      } \n    } \n    else { \n \n      tree_set_bit(otree, 0); \n      for(int bit_idx_l1 = 1; bit_idx_l1 < 9; ++bit_idx_l1) { \n        if(!tree_isset_bit(itree, bit_idx_l1)) { \n          int data_idx = tree_data_idx(itree, bit_idx_l1, 1); \n          if(prob_data[data_idx] >= thr) { \n            tree_set_bit(otree, bit_idx_l1); \n          } \n        } \n        else { \n \n          tree_set_bit(otree, bit_idx_l1); \n          for(int add_bit_idx_l2 = 0; add_bit_idx_l2 < 8; ++add_bit_idx_l2) { \n            int bit_idx_l2 = tree_child_bit_idx(bit_idx_l1) + add_bit_idx_l2; \n            if(!tree_isset_bit(itree, bit_idx_l2)) { \n              int data_idx = tree_data_idx(itree, bit_idx_l2, 1); \n              if(prob_data[data_idx] >= thr) { \n                tree_set_bit(otree, bit_idx_l2); \n              } \n            } \n            else { \n              tree_set_bit(otree, bit_idx_l2); \n            } \n          } \n \n        } \n      } \n \n    } \n  }", "pragma": "parallel for ", "hash": "e1f04e7e1b917fc721ef82363eacceb94dc48b8aca1d9207d46749cd085b0029"}
{"code": "for(k=0;k<nypad;k++) \n\tfor(i=0;i<nxpad;i++) \n\t    for(j=0;j<nzpad;j++) \n\t\tfor(l=-_mix;l<=_mix;l++) \n\t\t{ \n\t\t    if(i+l>=0&&i+l<nxpad){ \n\t\t\tpx_tmp[k][i][j]+=coeff_1dx[l+_mix]*p2[k][i+l][j]/2.0/dx; \n\t\t\tqx_tmp[k][i][j]+=coeff_1dx[l+_mix]*q2[k][i+l][j]/2.0/dx; \n\t\t\trx_tmp[k][i][j]+=coeff_1dx[l+_mix]*r2[k][i+l][j]/2.0/dx; \n\t\t    } \n\t\t    if(j+l>=0&&j+l<nzpad){ \n\t\t\tpz_tmp[k][i][j]+=coeff_1dz[l+_mix]*p2[k][i][j+l]/2.0/dz; \n\t\t\tqz_tmp[k][i][j]+=coeff_1dz[l+_mix]*q2[k][i][j+l]/2.0/dz; \n\t\t\trz_tmp[k][i][j]+=coeff_1dz[l+_mix]*r2[k][i][j+l]/2.0/dz; \n\t\t    } \n\t\t}", "pragma": "parallel for private(i j k l)", "hash": "1a36e68b0aa961e6bb2d005d3f30fc3a85ffa7ec34da1fb16b2e11dcb9097a0a"}
{"code": "for (i = 0; i < Nspec; ++i) { \n        for (j = 0; j < Nch; j = j + Nav) { \n            buf = 0; \n             \n \n            for (k = j; k < j + Nav && k < Nch; ++k) { \n                buf += cin[i * Nch + k]; \n            } \n             \n \n            cout[j / Nav + i * nout[1]] = buf / (float) (k - j); \n        } \n    }", "pragma": "parallel for private(   buf i j k)", "hash": "405b7007117ed2aacef50810e51efab72d62e3d8509b496cc85c39300fac6b19"}
{"code": "for ( i = 0 ; i < 4 ; i++ ) \n    { \n      for ( j = 0 ; j < Ntot ; j++ ) \n\t{ \n\t   \n \n\t  double som = 0.0 ;  \n\t  for ( k = 0 ; k < n ; k++ ) \n\t    { \n\t       \n \n\t      som += M[i][k] ;  \n\t    } \n\t  s[i] = som ;  \n\t} \n    }", "pragma": "parallel for private(i j k)", "hash": "38601933eeed937bd9d0e83a5f12aa12a1fb673b0f8c76aae9e1ce44eaf01078"}
{"code": "for ( int k = 0; k < sChunk; k++ ) \n      { \n \n        if ( ( i + k ) >= TrainPairs.rows ) \n          continue; \n \n        Mat Patch1( Patches.size[1], Patches.size[2], \n                    CV_8U, &Patches.at<uchar>( \n                    TrainPairs.at<int32_t>( i + k, 0 ), 0, 0) ); \n \n        Mat Patch2( Patches.size[1], Patches.size[2], \n                    CV_8U, &Patches.at<uchar>( \n                    TrainPairs.at<int32_t>( i + k, 2 ), 0, 0) ); \n \n         \n \n        Mat PatchTrans1 = get_desc( Patch1, nAngleBins, InitSigma, bNorm ); \n        Mat PatchTrans2 = get_desc( Patch2, nAngleBins, InitSigma, bNorm ); \n \n        Mat Desc1 = sPRFilters * PatchTrans1; \n        Mat Desc2 = sPRFilters * PatchTrans2; \n \n         \n \n        min( Desc1, 1.0f, Desc1 ); \n        min( Desc2, 1.0f, Desc2 ); \n \n        Mat Dist = Desc1 - Desc2; \n \n        memcpy( &Dists.at<float>( k, 0 ), \n                 Dist.data, Dist.total() * Dist.elemSize() ); \n        { \n          #pragma omp atomic \n          chunk++; \n        } \n      }", "pragma": "parallel for ", "hash": "2aed4db31c3225b77677b415c0b5c442852065256a1c716cac652631111fc7c0"}
{"code": "for(fint iel = 0; iel < m->gnelem(); iel++) \n\t\t\t{ \n\t\t\t\tfor(int i = 0; i < nvars; i++) \n\t\t\t\t{ \n\t\t\t\t\tustage(iel,i) = tvdcoeffs(istage,0)*u(iel,i) \n\t\t\t\t\t\t          + tvdcoeffs(istage,1)*ustage(iel,i) \n\t\t\t\t\t\t          - tvdcoeffs(istage,2) * dtmin*cfl/m->garea(iel)*residual(iel,i); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for simd ", "hash": "e6ea5fbcba8ba1267964aa27d2758fb935c4f5dd99beb28dfa00a149bb79473b"}
{"code": "for (size_t uiI = 0; uiI < m_uiN; uiI++) \n\t{ \n\t\tvRet.m_lpdValues[uiI] = m_lpdValues[uiI] * i_dRHO; \n\t}", "pragma": "for ", "hash": "962d6ce4309dd98a8e248e963358b80a7643d57bf69d9e95684216db0ce97e57"}
{"code": "for (b=0; b<direct_order; b++) if (hash[b]) { \n\t\tneu2[a].ac+=syn_d[hash[b]]; \n\t\thash[b]++; \n\t\thash[b]=hash[b]%direct_size; \n\t    } else break;", "pragma": "parallel for ", "hash": "21ff3b943f3ecbd2915c7707fc67f9df58963ce3eb2bf12c34953c6999e0f695"}
{"code": "for (size_t i = 0; i < par.filenames.size(); ++i) { \n            progress.updateProgress(); \n            MemoryMapped file(par.filenames[i], MemoryMapped::WholeFile, MemoryMapped::SequentialScan); \n            if (!file.isValid()) { \n                Debug(Debug::ERROR) << \"Could not open GFF file \" << par.filenames[i] << \"\\n\"; \n                EXIT(EXIT_FAILURE); \n            } \n            char *data = (char *) file.getData(); \n            char* end = data + file.mappedSize(); \n            size_t idx = 0; \n            while (data < end && *data != '\\0') { \n                 \n \n                if (*data == '#' || *data == '\\n') { \n                    data = Util::skipLine(data); \n                    continue; \n                } \n \n                const size_t columns = Util::getFieldsOfLine(data, fields, 255); \n                data = Util::skipLine(data); \n                if (columns < 9) { \n                    Debug(Debug::WARNING) << \"Not enough columns in GFF file\\n\"; \n                    continue; \n                } \n \n                if (features.empty() == false) { \n                    bool shouldSkip = true; \n                    std::string type(fields[2], fields[3] - fields[2] - 1); \n                    for (size_t i = 0; i < features.size(); ++i) { \n                        if (type.compare(features[i]) == 0) { \n                            localFeatureCount[i]++; \n                            shouldSkip = false; \n                            break; \n                        } \n                    } \n                    if (shouldSkip) { \n                        continue; \n                    } \n                } \n                size_t start = Util::fast_atoi<size_t>(fields[3]); \n                size_t end = Util::fast_atoi<size_t>(fields[4]); \n                if (start == end) { \n                    Debug(Debug::WARNING) << \"Invalid sequence length in line \" << idx << \"\\n\"; \n                    continue; \n                } \n                std::string strand(fields[6], fields[7] - fields[6] - 1); \n                std::string name(fields[0], fields[1] - fields[0] - 1); \n                size_t lookupId = reader.getLookupIdByAccession(name); \n                if (lookupId == SIZE_MAX) { \n                    Debug(Debug::ERROR) << \"GFF entry not found in database lookup: \" << name << \"\\n\"; \n                    EXIT(EXIT_FAILURE); \n                } \n                unsigned int lookupKey = reader.getLookupKey(lookupId); \n                size_t seqId = reader.getId(lookupKey); \n                if (seqId == UINT_MAX) { \n                    Debug(Debug::ERROR) << \"GFF entry not found in sequence database: \" << name << \"\\n\"; \n                    EXIT(EXIT_FAILURE); \n                } \n \n                unsigned int key = __sync_fetch_and_add(&(entries_num), 1); \n                size_t bufferLen; \n                if (strand == \"+\") { \n                    bufferLen = Orf::writeOrfHeader(buffer, lookupKey, start, end, 0, 0); \n                } else { \n                    bufferLen = Orf::writeOrfHeader(buffer, lookupKey, end, start, 0, 0); \n                } \n                headerWriter.writeData(buffer, bufferLen, key, thread_idx); \n \n                char *seq = reader.getData(seqId, thread_idx); \n                 \n \n                ssize_t length = end - start + 1; \n                writer.writeStart(thread_idx); \n                if (strand == \"+\") { \n                    size_t len = snprintf(buffer, sizeof(buffer), \"%u\\t%s_%zu_%zu_%zu\\t%zu\\n\", key, name.c_str(), idx, start, end, i); \n                    lookupWriter.writeData(buffer, len, thread_idx, false, false); \n                    writer.writeAdd(seq + start - 1 , length, thread_idx); \n                } else { \n                    size_t len = snprintf(buffer, sizeof(buffer), \"%u\\t%s_%zu_%zu_%zu\\t%zu\\n\", key, name.c_str(), idx, end, start, i); \n                    lookupWriter.writeData(buffer, len, thread_idx, false, false); \n                    for (size_t i = end - 1 ; i >= end - length; i--) { \n                        revStr.append(1, Orf::complement(seq[i])); \n                    } \n                    writer.writeAdd(revStr.c_str(), revStr.size(), thread_idx); \n                    revStr.clear(); \n                } \n                writer.writeAdd(\"\\n\", 1, thread_idx); \n                writer.writeEnd(key, thread_idx); \n                idx++; \n            } \n            file.close(); \n        }", "pragma": "for ", "hash": "629ae3289247c0916e62410ee236dcb2b435d4714b5e8b3ae9bfa99c3a2db716"}
{"code": "for (int i = 0; i < (int) imageSizeRef[box]; i++) { \n        cosMolRef[*thisMol][i] = 0.0; \n        sinMolRef[*thisMol][i] = 0.0; \n \n        for (uint j = 0; j < thisKind.NumAtoms(); j++) { \n          if(particleHasNoCharge[startAtom + j]) { \n            continue; \n          } \n          double dotProduct = Dot(mols.MolStart(*thisMol) + j, kxRef[box][i], \n                                  kyRef[box][i], kzRef[box][i], molCoords); \n           \n \n          cosMolRef[*thisMol][i] += (thisKind.AtomCharge(j) * \n                                     cos(dotProduct)); \n          sinMolRef[*thisMol][i] += (thisKind.AtomCharge(j) * \n                                     sin(dotProduct)); \n        } \n         \n \n        sumRnew[box][i] += (lambdaCoef * cosMolRef[*thisMol][i]); \n        sumInew[box][i] += (lambdaCoef * sinMolRef[*thisMol][i]); \n      }", "pragma": "parallel for ", "hash": "547b3394bf597dc1b13ace5f6e5f7e989b6ed61a20e1d5ef372d4f469522dfc1"}
{"code": "for(long k=0;k<l;k++)\tfor(long j=0;j<m;j++)\tfor(long i=0;i<n;i++)\r \n\t\t\tr->a[i+n*(j+m*k)] = dd->a[xx+dx*i + nx*(yy+dy*j + ny*(zz+dz*k))];", "pragma": "parallel for ", "hash": "97661946836dfd78b622bc7d69e40a388188694b01d647e437a6eefa4e753a7c"}
{"code": "for (i = 0; i < (int)n_a; i++) {\r \n            result[i] = a[i] > b[i];\r \n        }", "pragma": "parallel for private(i)", "hash": "bdd18a8a764df945210160678a08ded9a4d091349822d00e95f075fe1a661d15"}
{"code": "for(int i = 0; i < parent->getNumThreads() * numNeurons; i++){ \n            int ti = i/numNeurons; \n            int ni = i % numNeurons; \n            thread_gSyn[ti][ni] = resetVal; \n         }", "pragma": "parallel for ", "hash": "515357f83bccf0700ab05a1b3fda2a2f9b300c98ec46822fda62eeaba7359a26"}
{"code": "for(i = 0; i < 2; ++i) \n\t{ \n\t\tSHA512_CTX ctx; \n\t\tSHA512_Init(&ctx); \n\t\tSHA512_Update(&ctx, pos[i], len[i]); \n\t\tSHA512_Final(cksum[i], &ctx); \n\t}", "pragma": "parallel for ", "hash": "70611d66b8b8ef2ae9941615ee9887ddf19f8e38375a01e0e7cf72646170bfb4"}
{"code": "for (int i=1; i<=NP; i++){ \n\t\tif (all6==0){ \n\t\t\tallvalues[i][1]=values[i]; \n\t\t\tallvalues[i][2]=values[i]; \n\t\t} \n\t\tfor (int v=1; v<=6; v++){ \n\t\t\tif (nn[i][v]==0) continue; \n\t\t\telse { \n\t\t\t\tif (all6==0){ \n\t\t\t\t\tallvalues[i][1]=fmin(allvalues[i][1],0.5*(values[nn[i][v]]+values[i])); \n\t\t\t\t\tallvalues[i][2]=fmax(allvalues[i][2],0.5*(values[nn[i][v]]+values[i])); \n\t\t\t\t} \n\t\t\t\telse allvalues[i][v]=0.5*(values[nn[i][v]]+values[i]); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "1de989390938d8320f6c2306a339bc3f10ff6a375155df3d2c95e172e3271ba2"}
{"code": "for (y=0; y < (long) image->rows; y++) \n  { \n    const IndexPacket \n      *indexes; \n \n    IndexPacket \n      *convolve_indexes; \n \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],-((long) width/2L),y-(long) \n      (width/2L),image->columns+width,width,exception); \n    q=GetCacheViewPixels(convolve_view[id],0,y,convolve_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=AcquireCacheViewIndexes(image_view[id]); \n    convolve_indexes=GetCacheViewIndexes(convolve_view[id]); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      long \n        j, \n        v; \n \n      MagickRealType \n        alpha, \n        gamma; \n \n      MagickPixelPacket \n        pixel; \n \n      register const double \n        *k; \n \n      register long \n        u; \n \n      GetMagickPixelPacket(image,&pixel); \n      gamma=0.0; \n      k=kernel; \n      j=0; \n      for (v=0; v < (long) width; v++) \n      { \n        for (u=0; u < (long) width; u++) \n        { \n          alpha=1.0; \n          if (((channel & OpacityChannel) != 0) && \n              (image->matte != MagickFalse)) \n            alpha=(MagickRealType) (QuantumScale*(QuantumRange- \n              (p+u+j)->opacity)); \n          if ((channel & RedChannel) != 0) \n            pixel.red+=(*k)*alpha*(p+u+j)->red; \n          if ((channel & GreenChannel) != 0) \n            pixel.green+=(*k)*alpha*(p+u+j)->green; \n          if ((channel & BlueChannel) != 0) \n            pixel.blue+=(*k)*alpha*(p+u+j)->blue; \n          if ((channel & OpacityChannel) != 0) \n            pixel.opacity+=(*k)*(p+u+j)->opacity; \n          if (((channel & IndexChannel) != 0) && \n              (image->colorspace == CMYKColorspace)) \n            pixel.index+=(*k)*alpha*indexes[x+u+j]; \n          gamma+=(*k)*alpha; \n          k++; \n        } \n        j+=image->columns+width; \n      } \n      gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma); \n      if ((channel & RedChannel) != 0) \n        q->red=RoundToQuantum(gamma*pixel.red+image->bias); \n      if ((channel & GreenChannel) != 0) \n        q->green=RoundToQuantum(gamma*pixel.green+image->bias); \n      if ((channel & BlueChannel) != 0) \n        q->blue=RoundToQuantum(gamma*pixel.blue+image->bias); \n      if ((channel & OpacityChannel) != 0) \n        q->opacity=RoundToQuantum(pixel.opacity+image->bias); \n      if (((channel & IndexChannel) != 0) && \n          (image->colorspace == CMYKColorspace)) \n        convolve_indexes[x]=RoundToQuantum(gamma*pixel.index+image->bias); \n      p++; \n      q++; \n    } \n    if (SyncCacheView(convolve_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,ConvolveImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  }", "pragma": "parallel for ", "hash": "e0b28bdc40ccddb666f5eba057e14828fc2374a080c5fa3429a3a462194ced62"}
{"code": "for (int i=0; i<ev_raw.size(); i++) \n\t\ty_binned[ev_to_channel(ev_raw[i])] += y_raw[i];", "pragma": "parallel for ", "hash": "783eb74c722c50d3432490aeda337d4d1753ad722dbc53d382ac0c89073afda8"}
{"code": "for(ik = 0; ik < nn; ik++) { \n\t\ti = ik / n; \n\t\tk = ik % n; \n\t\tif(k <= i) { \n\t\t\ti = n - i - 2; \n\t\t\tk = n - k - 1; \n\t\t} \n\t\tmi = m[i]; \n\t\tmk = m[k]; \n\t\tsi = s[i]; \n\t\tsk = s[k]; \n\t\tsum = 0; \n#pragma omp parallel for reduction(+:sum) \n\t\tfor(o = 0; o < l; o++) \n\t\t\tsum += (d[i*l + o] - mi) * (d[k*l + o] - mk) / si / sk; \n \n\t\tc[nn-(n-i)*((n-i)-1)/2+k-i-1] = sum / (l - 1); \n\t}", "pragma": "parallel for private(       i ik k mi mk o si sk)", "hash": "d218f103509caacbc4e7ea6487e42912e3f6a4b15bcb2fb4d8a5ce987c24490e"}
{"code": "for (i = 0; i < img_w; i++) \n\t\t\timageNG_16[j][i] = imageNG[j][i];", "pragma": "parallel for ", "hash": "e2e82ba61014f1bc8b9dd755d6411c1f0606a915a7f1062ee1249f33932f1de3"}
{"code": "for(int i = 0;i < blocks.size();++i) \n      blocks[i]->symmetrize();", "pragma": "parallel for ", "hash": "5920cebe6d41ffb81c618c2609dd6f07465eb9d375e8d42b8e1e32d4169ea0c3"}
{"code": "for (ii = 0; ii<10; jj> kk + 2) \n    c[ii] = a[ii];", "pragma": "parallel for simd ", "hash": "7233f25c6d50bdd7b9632c0f6f783b31e454750bd871d972179c682ed2291ff2"}
{"code": "for (int i = 0; i < contoursSize; ++i) { \n\t\t\tdouble contourAspectRatio = ImageUtils::computeContourAspectRatio(contours[i]); \n\t\t\tdouble contourCircularity = ImageUtils::computeContourCircularity(contours[i]); \n \n   #pragma omp critical \n\t\t\tif (_contourAspectRatioRange[0] == -1 || contourAspectRatio < _contourAspectRatioRange[0]) {\t\t\t\t \n\t\t\t\t_contourAspectRatioRange[0] = contourAspectRatio; \n\t\t\t} \n \n   #pragma omp critical \n\t\t\tif (_contourAspectRatioRange[1] == -1 || contourAspectRatio > _contourAspectRatioRange[1]) {\t\t\t\t \n\t\t\t\t_contourAspectRatioRange[1] = contourAspectRatio; \n\t\t\t} \n \n   #pragma omp critical \n\t\t\tif (_contourCircularityRange[0] == -1 || contourCircularity < _contourCircularityRange[0]) {\t\t\t\t \n\t\t\t\t_contourCircularityRange[0] = contourCircularity; \n\t\t\t} \n \n   #pragma omp critical \n\t\t\tif (_contourCircularityRange[1] == -1 || contourCircularity > _contourCircularityRange[1]) {\t\t\t\t \n\t\t\t\t_contourCircularityRange[1] = contourCircularity; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "fe0a79201c65d1a8325070c90ff0d82c9c5db02f9260ca30eafde34332021d5d"}
{"code": "for(long i=0;i<nx;i++)\ta[i+xx] = vv;", "pragma": "parallel for ", "hash": "abadad9350a0bfc9163432e47f26a951a9263ee6f849aeaeae66adfac785ad10"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      c[9] += i; \n      c[10] += 2 * i; \n      c[11] += 3 * i; \n      c[12] += 4 * i; \n    }", "pragma": "for reduction(+:c[x:4]) ", "hash": "6844e129d3f3c3e55d70916aa2e309eb65a7fd7b03de371c0b0322257eeedf30"}
{"code": "for (long i = 0; i < N; i++) \n\t\tptr[i] = alpha - beta * cosf(2. * M_PI * i / (N - 1));", "pragma": "parallel for ", "hash": "6dfcab29dec7ab71655520443fbb9cf332e4775313ad2ff6556802f39eb32ca6"}
{"code": "for(int x=0; x<Get_NX(); x++) \n\t\t{ \n\t\t\tif( m_pDEM->is_NoData(x, y) ) \n\t\t\t{ \n\t\t\t\tNoise.Set_NoData(x, y); \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tNoise.Set_Value(x, y, Get_Noise(x, y, Epsilon)); \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "e2e000bccf57c67c08850a07fc7dfbfae7cebf78517900c32bc87bc0713e2ab1"}
{"code": "for(long j=0;j<n;j++)\trk.dd->a[j] = rk.din.a[j] + (rk.d1.a[j]+rk.d2.a[j]+2*(rk.d3.a[j]+rk.d4.a[j]))*(dt/6);", "pragma": "parallel for ", "hash": "07b5c0f6e6276759ccb70c8c115518a637f47ab607f7e88567c6f52d0ccfd64b"}
{"code": "for(long i=0;i<long(ex_bi.size());i++)\tif(ex_bi[i].ln[3]<0) \n\t{ \n\t\tmglGlyphDescr &g = ex_bi[i]; \n\t\tg.ln[0] = g.ln[1] = g.ln[2] = g.ln[3] = cur-1-g.ln[3]; \n\t\tg.tr[0] = g.tr[1] = g.tr[2] = g.tr[3] = cur-1-g.tr[3]; \n\t}", "pragma": "parallel for ", "hash": "31d47afc64efd2e91be428c0366111ee4da9dabbbbe502c91a566e6b88b2dd9b"}
{"code": "for(long j=0;j<n2;j++)\tfor(long i=0;i<n1;i++)\r \n\t\t\tr->a[i+n1*j] = c1->a[i]*c2->a[j];", "pragma": "parallel for ", "hash": "0d2d36311bc897875581e4a1427ee06c08f53702fa048913898bd9d761807827"}
{"code": "for (int i = 0; i < n_control_points_; i++) \n\t{ \n\t\tGrad_.col(i) = G_ * Z_.col(i) + E_.col(i); \n\t}", "pragma": "for ", "hash": "7a81c9cebab64b142067b104c7e590bfa571cc440bba5ec129ae81bcd01a85bf"}
{"code": "for( size_t y = 0; y < ysz; ++y ) { \n            QRgb *scanLine = ( QRgb* ) res.scanLine( y ); \n            for( size_t x = 0; x < xsz; ++x ) { \n                Bial::Point3D pos = transf( x, y, guiImage->currentSlice( axis ) ); \n                char pixel = seeds( pos.x, pos.y, pos.z ); \n                if( pixel == 1 ) { \n                    scanLine[ x ] = qRgb( 0, 255, 0 ); \n                } \n                else if( pixel == 2 ) { \n                    scanLine[ x ] = qRgb( 0, 0, 255 ); \n                } \n                else { \n                    scanLine[ x ] = qRgba( 0, 0, 0, 0 ); \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "18ae7d5e0064d64a88fc0931100d0feffb528e1f55ffda3d2bd8e3d37d7e81a8"}
{"code": "for (long i = 1; i < nx - 1; ++i) {\r \n\t\t\tg(i, 0) = v(i, 0);\r \n\t\t\tg(i, ny) = v(i, ny);\r \n\t\t}", "pragma": "parallel ", "hash": "8afda3b5dcbc7dfd630ce2eb38f33edfa0b8b28734eaa1a98e2cb8214f076aec"}
{"code": "for (i = 0; i < size; i++) \n        { \n          fimg[hpass + i] -= fimg[lpass + i]; \n          if (fimg[hpass + i] < -thold) \n            fimg[hpass + i] += thold; \n          else if (fimg[hpass + i] > thold) \n            fimg[hpass + i] -= thold; \n          else \n            fimg[hpass + i] = 0; \n          if (hpass) \n            fimg[i] += fimg[hpass + i]; \n        }", "pragma": "for ", "hash": "fb4ba13e6d2c33ea0f0454f225a7425feee0bf0465fb75c9558a8e94b4867fc7"}
{"code": "for (int i = 0; i < nlocal; i++) { \n      if (mask[i] & groupbit) { \n        v[i].x *= factor_eta; \n        v[i].y *= factor_eta; \n        v[i].z *= factor_eta; \n        angmom[i].x *= factor_eta; \n        angmom[i].y *= factor_eta; \n        angmom[i].z *= factor_eta; \n      } \n    }", "pragma": "parallel for ", "hash": "acb35491d95f913b8142b3f1e06f1e4643f3abdc73b7a5724259b0c49e78d6c9"}
{"code": "for (int row=0; row<rows; row++){ \n        for (int col=0; col<cols; col++){ \n            returnMat(row,col) = m_ampClass->T3_elements_A[m_ampClass->T3_T5c_indices[index](row, col) ] \n                                *(double)m_ampClass->T3_T5c_indices_signs[index](row, col);; \n        } \n    }", "pragma": "parallel for private( cols rows)", "hash": "581034a03354f4bd510a674a9f819e4879b7f1ed6bad6226eab7978d75771405"}
{"code": "for( OMPInt i=0; i<nEl; ++i) \n\t      { \n\t\t(*res)[ i] = tanh((*res)[ i]);  \n\t      }", "pragma": "for ", "hash": "adb8b4b366f2fde73ca91921e40210059575b61404ea9e6641f3e5fe0748c912"}
{"code": "for (size_t j=0;j<SEQ_DIM_BITS_SIZE;j++){ \n         \n \n         \n \n        uint64_t mask = 1; \n \n        if (data[i].z & (mask << j)){ \n          tmp_centroid[j]++; \n        } \n        if (data[i].y & (mask << j)){ \n          tmp_centroid[SEQ_DIM_BITS_SIZE + j]++; \n        } \n        if (data[i].x & (mask << j)){ \n          tmp_centroid[(2 *SEQ_DIM_BITS_SIZE) + j]++; \n        } \n      }", "pragma": "parallel for ", "hash": "3289afcaa02b761c08c8b442ce13d6bed3a88d5d1a60251be154c776d8d0602f"}
{"code": "for (size_t j = 0; j < n; j++) { \n          if (alpha != one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          size_t k = m - 1; \n          do { \n            if (B[j * ldb + k] != zero) { \n              if (diag == CBlasNonUnit) B[j * ldb + k] /= A[k * lda + k]; \n              register double complex temp = B[j * ldb + k]; \n              for (size_t i = 0; i < k; i++) \n                B[j * ldb + i] -= temp * A[k * lda + i]; \n            } \n          } while (k-- > 0); \n        }", "pragma": "parallel for ", "hash": "875f07c6bb09eab07eab088b33575ad2948f5254402c55cde893e67ec7c95d44"}
{"code": "for(i = 0; i < iterations; i++){ \n    my_rank = omp_get_thread_num(); \n    assignments[i] = my_rank; \n  }", "pragma": "parallel for ", "hash": "68e9ccc00f27a16fd443df46f3ca5e1583c989687c409694d27dd2b3384c84e6"}
{"code": "for (int tid=0; tid<th2data.nthreads; tid++) { \n      mapper(tid); \n    }", "pragma": "parallel for ", "hash": "36cccf21923d8a2810dc6e6569db2c2ff6339c733fd0d431360cc035d899ffc1"}
{"code": "for (uint i = 0; i < nMeshes; ++i) { \n  \n \n      Eigen::Transform<Real, 3, Eigen::Affine> backwardTransform = forwardTransforms[i].inverse(); \n       \n \n      computeIntersections1st(intersections[i * Intersections::N_INTERSECTIONS + Intersections::Z], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::Z_DI], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::Z_DJ], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::Z_DK], \n                              backwardTransform,  \n                              velocityMeshes[i], \n                              2); \n      computeIntersections2nd(intersections[i * Intersections::N_INTERSECTIONS + Intersections::X], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::X_DI], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::X_DJ], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::X_DK], \n                              backwardTransform,  \n                              velocityMeshes[i], \n                              0); \n      computeIntersections3rd(intersections[i * Intersections::N_INTERSECTIONS + Intersections::Y], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::Y_DI], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::Y_DJ], \n                              intersections[i * Intersections::N_INTERSECTIONS + Intersections::Y_DK], \n                              backwardTransform,  \n                              velocityMeshes[i], \n                              1);     \n   }", "pragma": "parallel for ", "hash": "4132a398eed6c986567c4df75b284c9587efbb2825261d1ba80a058f272dd641"}
{"code": "for (int j = 0; j < int_len; ++j) { \n    tgrad[j] = static_cast<float>(R_REAL_PTR(grad)[j]); \n    thess[j] = static_cast<float>(R_REAL_PTR(hess)[j]); \n  }", "pragma": "parallel for ", "hash": "1e2af0f9671349207ec593a097fa3bc892efa124db4600e210d96b0a972cde39"}
{"code": "for (int i = 0; i < sim_data.get_N(); ++i) { \n\t\t\ttheta = (this->non_linear[i] + this->harmonic_trap[i]) * 0.5 * sim_data.get_dt();\t \n\t\t\tthis->pos_time_evolution[i].real = exp(-1.0 * theta); \n\t\t\tthis->pos_time_evolution[i].imag = 0;\t \n\t\t}", "pragma": "parallel for private(theta)", "hash": "99569d86fb5d2da0c03540f7fd90e0d4c96f21b35441f7206c5d2b15d668c78d"}
{"code": "for (index = 0; index < count; index++) \n\t{ \n\t\t \n \n\t\tint res; \n\t\tint ks = keySize(cur_salt->cipher_algorithm); \n\t\t \n \n\t\tunsigned char keydata[64 * ((32 + 64 - 1) / 64)]; \n \n\t\tcur_salt->s2kfun(saved_key[index], keydata, ks); \n\t\tres = check(keydata, ks); \n\t\tif (res) { \n\t\t\tcracked[index] = 1; \n#pragma omp atomic \n\t\t\tany_cracked |= 1; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "8fb71729ed353366c91de6e4625eb1991a32ccc8fb508cb1ba77331cd8ec1dd4"}
{"code": "for (y=0; y < (long) blur_image->rows; y++) \n    { \n      MagickPixelPacket \n        pixel; \n \n      MagickRealType \n        alpha, \n        gamma; \n \n      register const double \n        *k; \n \n      register long \n        i; \n \n      GetMagickPixelPacket(image,&pixel); \n      gamma=0.0; \n      k=kernel; \n      for (i=0; i < (long) width; i++) \n      { \n        alpha=1.0; \n        if (((channel & OpacityChannel) != 0) && \n            (image->matte != MagickFalse)) \n          alpha=(MagickRealType) (QuantumScale*(QuantumRange-(p+y+i)->opacity)); \n        if ((channel & RedChannel) != 0) \n          pixel.red+=(*k)*alpha*(p+y+i)->red; \n        if ((channel & GreenChannel) != 0) \n          pixel.green+=(*k)*alpha*(p+y+i)->green; \n        if ((channel & BlueChannel) != 0) \n          pixel.blue+=(*k)*alpha*(p+y+i)->blue; \n        if ((channel & OpacityChannel) != 0) \n          pixel.opacity+=(*k)*(p+y+i)->opacity; \n        if (((channel & IndexChannel) != 0) && \n            (image->colorspace == CMYKColorspace)) \n          pixel.index+=(*k)*alpha*indexes[y+i]; \n        gamma+=(*k)*alpha; \n        k++; \n      } \n      gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma); \n      if ((channel & RedChannel) != 0) \n        (q+y)->red=RoundToQuantum(gamma*pixel.red+image->bias); \n      if ((channel & GreenChannel) != 0) \n        (q+y)->green=RoundToQuantum(gamma*pixel.green+image->bias); \n      if ((channel & BlueChannel) != 0) \n        (q+y)->blue=RoundToQuantum(gamma*pixel.blue+image->bias); \n      if ((channel & OpacityChannel) != 0) \n        (q+y)->opacity=RoundToQuantum(pixel.opacity+image->bias); \n      if (((channel & IndexChannel) != 0) && \n          (blur_image->colorspace == CMYKColorspace)) \n        blur_indexes[y]=RoundToQuantum(gamma*pixel.index+image->bias); \n    }", "pragma": "parallel for ", "hash": "7081449aee02d9a7451735d68741dc08d0c79872d94dcd75eb8b9375e0fce28d"}
{"code": "for( r = 0 ; r < rep ; r++ ){ \n \n        conds[r] = new pcaCond(kDim, mDim); \n        conds[r]->minIteration = minIteration; \n        conds[r]->maxIteration = maxIteration; \n        conds[r]->lbPosTh = lbPosTh; \n        conds[r]->lbNegTh = -0.1 * lbPosTh; \n \n         \n \n        if( annealSteps > 0 ){ \n            conds[r]->lbNegTh = -0.01 * lbPosTh; \n            conds[r]->minIteration = annealSteps; \n            conds[r]->annealSteps = annealSteps; \n \n             \n \n \n \n \n \n \n \n \n \n \n \n \n \n             \n \n \n            conds[r]->maxTFlucAmp = maxTFlucAmp; \n            conds[r]->minTFlucAmp = minTFlucAmp; \n        } \n         \n \n \n        if( r < (rep/4) ){ \n            conds[r]->initType = initType_whiteNoise; \n        } else if( r < (rep/2) ){ \n            conds[r]->initType = initType_randomCluster; \n        } else{ \n            conds[r]->initType = initType_kMeans; \n        } \n         \n        results[r] = new pcaResult(nDim, lDim, kDim, mDim); \n        results[r]->iterCnt = r; \n        temps[r] = new pcaTemp(nDim, lDim, kDim, mDim); \n \n \n \n \n        bayesClusterPCA_core(conds[r], data, results[r], temps[r]); \n \n \n \n \n        results[r]->outputToFile(in_name, conds[r], data, r); \n        scores.p[r] = results[r]->lowerBounds->p[results[r]->lowerBounds->d1-1]; \n        scores.outputFineToFile(out_name); \n \n \n \n \n        delete conds[r]; \n        delete results[r]; \n        delete temps[r]; \n    }", "pragma": "parallel for ", "hash": "334bb38da37610e18930303d5b688375c67bd73a6a9e06dfdfe28dd68132683d"}
{"code": "for (n=0; n<N; n++)\r \n        {\r \n            extrinsic_data(k,n) = -2*itpp::elem_div(ch, Vr.mid(n,L+1)-sqr(ch)*Vx(k,n))*(Er.mid(n,L+1)+ch*Ex(k,n)); \n \n        }", "pragma": "parallel for private(n)", "hash": "2ec8b81beb86f5fa25e1df2d0b23ea750ba828f032b1daae7b0770ce5d00282e"}
{"code": "for (count i = 0; i < getDimension(); i++) { \n\t\tvalues[i] -= other[i]; \n\t}", "pragma": "parallel for ", "hash": "b9b8270d0ecdede09e9b59fda0c9ef7ed53adef5ddfbcf6967f58ba012482fc0"}
{"code": "for (int i = 0; i < num_iteration_for_pred_; ++i) { \n        t += models_[i * num_tree_per_iteration_ + k]->Predict(features); \n      }", "pragma": "parallel for reduction(+:t) ", "hash": "8c92e950dd1f4da8ad6d514583b47ef9ec3b64d989fcab84e8f4717c46d83879"}
{"code": "for (iy = fy; iy <= ly; iy++) { \n                y = oy + iy*dy; \n                sf_esc_tracer3_set_ymin (esc_tracers[iy - fy], y - md); \n                sf_esc_tracer3_set_ymax (esc_tracers[iy - fy], y + md); \n                for (ix = 0; ix < nx; ix++) { \n                    x = ox + ix*dx; \n                    sf_esc_tracer3_set_xmin (esc_tracers[iy - fy], x - md); \n                    sf_esc_tracer3_set_xmax (esc_tracers[iy - fy], x + md); \n                    for (iz = 0; iz < nz; iz++) { \n                        z = oz + iz*dz; \n                        sf_esc_tracer3_set_zmin (esc_tracers[iy - fy], z - md); \n                        sf_esc_tracer3_set_zmax (esc_tracers[iy - fy], z + md); \n                        sf_esc_tracer3_compute (esc_tracers[iy - fy], z, x, y, b, a, \n                                                0.0, 0.0, esc_points[iy - fy], \n                                                &ae[iy - fy], &be[iy - fy]); \n                         \n \n                        for (i = 0; i < ESC3_NUM; i++) \n                            e[i][iy][ix][iz] = sf_esc_point3_get_esc_var (esc_points[iy - fy], i); \n                        e[ESC3_Z][iy][ix][iz] -= z; \n                        e[ESC3_X][iy][ix][iz] -= x; \n                        e[ESC3_Y][iy][ix][iz] -= y; \n                         \n \n                        vt[iy - fy][0] = cosf (be[iy - fy]); \n                        vt[iy - fy][1] = sinf (be[iy - fy])*cosf (ae[iy - fy]); \n                        vt[iy - fy][2] = sinf (be[iy - fy])*sinf (ae[iy - fy]); \n                         \n \n                        sf_quat_vecrot (vf, vt[iy - fy], q[iy - fy]); \n                        e[ESC3_NUM][iy][ix][iz] = q[iy - fy][0]; \n                        e[ESC3_NUM + 1][iy][ix][iz] = q[iy - fy][1]; \n                        e[ESC3_NUM + 2][iy][ix][iz] = q[iy - fy][2]; \n                        e[ESC3_NUM + 3][iy][ix][iz] = q[iy - fy][3]; \n                    }  \n \n                }  \n \n            }", "pragma": "parallel for private(i ix iy iz x y z)", "hash": "670306c7ce8851bff51697a4d1a7c2d53915ab6c0fa6cf419bdf95434a3035c6"}
{"code": "for(long j=0;j<n;j++)\trk.cc->a[j] = rk.cin.a[j] + dt*rk.c3.a[j];", "pragma": "parallel for ", "hash": "46bcb250ec13cf48ae2080eddcd6dd5702dc0608a1ae2bb379fb9fe3bc2eddaa"}
{"code": "for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n        int state2 = tlk->sp->patterns[idx2][k]; \n         \n        int w = l * tlk->matrix_size; \n         \n        double *pPartials = partials + (l*tlk->pattern_count + k)*4; \n         \n        if (state1 < 4 && state2 < 4) { \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += 4; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += 4; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += 4; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += 4; \n             \n        } \n        else if (state1 < 4 ) { \n             \n \n            *pPartials++ = matrices1[w + state1]; w += 4; \n            *pPartials++ = matrices1[w + state1]; w += 4; \n            *pPartials++ = matrices1[w + state1]; w += 4; \n            *pPartials++ = matrices1[w + state1]; w += 4; \n        } \n        else if (state2 < 4 ) { \n             \n \n            *pPartials++ = matrices2[w + state2]; w += 4; \n            *pPartials++ = matrices2[w + state2]; w += 4; \n            *pPartials++ = matrices2[w + state2]; w += 4; \n            *pPartials++ = matrices2[w + state2]; w += 4; \n             \n        } \n        else { \n             \n \n            *pPartials++ = 1.0; \n            *pPartials++ = 1.0; \n            *pPartials++ = 1.0; \n            *pPartials++ = 1.0; \n        } \n    }", "pragma": "parallel for ", "hash": "f24c5b03eb6b27a6a88d1d10b3e091a0648d0df7c37053a61938bdc28f841369"}
{"code": "for (int k = 0; k < omega.beta.size(); k++) \n\t\t{ \n\t\t\tbeta = omega.beta[k]; \n\t\t\t_y_mat[j*omega.beta.size()+k] = c.dmac_compton_pol(ev0, theta, beta)*omega.domega(theta)*n_photons; \n\t\t}", "pragma": "parallel for ", "hash": "bf74b811a85d53e08a79a6fda6c1d641020620ea03893c99161426bb2b5f425c"}
{"code": "for (index_mu=0;index_mu<num_mu;index_mu++) { \n    dlm1=1.0/sqrt(2.);  \n \n    d00[index_mu][0]=dlm1*sqrt(2.); \n    dl=mu[index_mu] * sqrt(3./2.);  \n \n    d00[index_mu][1]=dl*sqrt(2./3.); \n    for(l=1;l<lmax;l++){ \n      ll=(double) l; \n       \n \n      dlp1 = fac1[l]*mu[index_mu]*dl - fac2[l]*dlm1; \n      d00[index_mu][l+1] = dlp1 * fac3[l]; \n      dlm1 = dl; \n      dl = dlp1; \n    } \n  }", "pragma": "parallel for private(dl dlm1 dlp1 index_mu l ll)", "hash": "7121229b674d142211e13105f2a5fddff43c582c6336833554606e2aad72bd0b"}
{"code": "for(size_t y = 0; y < this->getHeight(); y++) { \n        for(size_t x = 0; x < this->getWidth(); x++) { \n            const double inverted = 1.0 - this->map.at(y).at(x); \n            this->map.at(y).at(x) = inverted; \n        } \n    }", "pragma": "parallel for ", "hash": "b9093276e9ff7d0593f26c4c52faad7b8f802dfa2bb133bc07a1826a52cc3089"}
{"code": "for (unsigned c=0; c < colors; c++) {\t\t\t \n \n\t\tint lev, hpass, lpass; \n\t\t \n \n\t\tfloat *fimg = 0; \n\t\tfimg = new float[(size*3 + height + width) ]; \n\t\tfloat *temp = fimg + size*3; \n \n\t\tfor (unsigned i=0; i < size; i++) \n\t\t\t \n \n\t\t\tfimg[i] = img[i][c]; \n \n\t\tfor (hpass=lev=0; lev < 5; lev++) { \n\t\t\tlpass = size*((lev & 1)+1); \n\t\t\tfor (unsigned row=0; row < height; row++) { \n\t\t\t\t \n \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\t{ \n\t\t\t\t\tfloat *base = fimg+hpass+row*width;  \n\t\t\t\t\tint st=1; \n\t\t\t\t\tint size=width;  \n\t\t\t\t\tint sc=1 << lev; \n\t\t\t\t\tint i; \n\t\t\t\t\tfor (i=0; i < sc; i++) \n\t\t\t\t\t\ttemp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)]; \n\t\t\t\t\tfor (; i+sc < size; i++) \n\t\t\t\t\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)]; \n\t\t\t\t\tfor (; i < size; i++) \n\t\t\t\t\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))]; \n\t\t\t\t} \n\t\t\t\t \n\t\t\t\tfor (unsigned col=0; col < width; col++) \n\t\t\t\t\tfimg[lpass + row*width + col] = temp[col] * 0.25; \n\t\t\t} \n\t\t\tfor (unsigned col=0; col < width; col++) { \n\t\t\t\t \n \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\t{ \n\t\t\t\t\tfloat *base = fimg+lpass+col;  \n\t\t\t\t\tint st=width; \n\t\t\t\t\tint size=height;  \n\t\t\t\t\tint sc=1 << lev; \n\t\t\t\t\tint i; \n\t\t\t\t\tfor (i=0; i < sc; i++) \n\t\t\t\t\t\ttemp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)]; \n\t\t\t\t\tfor (; i+sc < size; i++) \n\t\t\t\t\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)]; \n\t\t\t\t\tfor (; i < size; i++) \n\t\t\t\t\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))]; \n\t\t\t\t} \n\t\t\t\t \n\t\t\t\tfor (unsigned row=0; row < height; row++) \n\t\t\t\t\tfimg[lpass + row*width + col] = temp[row] * 0.25; \n\t\t\t} \n\t\t\t \n\t\t\tthold = threshold * noise[lev]; \n\t\t\tfor (unsigned i=0; i < size; i++) { \n\t\t\t\tfimg[hpass+i] -= fimg[lpass+i]; \n\t\t\t\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold; \n\t\t\t\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold; \n\t\t\t\telse\t fimg[hpass+i] = 0; \n\t\t\t\tif (hpass) fimg[i] += fimg[hpass+i]; \n\t\t\t} \n\t\t\thpass = lpass; \n\t\t} \n \n\t\tfor (unsigned i=0; i < size; i++) \n\t\t\t \n \n\t\t\timg[i][c] = fimg[i]+fimg[lpass+i]; \n\t\t \n\t\t \n \n\t\tdelete [] fimg; \n\t}", "pragma": "parallel for ", "hash": "f9099aab4ef4427f6bbbada95ddcd4e2e2492714fe39172e57144f3c43a435eb"}
{"code": "for (int i=0;i<tod->ndet;i++) { \n      if (!mbCutsIsAlwaysCut(tod->cuts,tod->rows[i],tod->cols[i])) { \n\tunsigned idum=tod->seed+i+1; \n\tfor (int j=0;j<tod->ndata;j++) { \n\t  tod->data[i][j]=mygasdev(&idum); \n\t}   \n      } \n    }", "pragma": "for ", "hash": "864f246f47557c6a3d52270b7cebb80357c77be4e0f3457b5e266bd6e601443e"}
{"code": "for (i = 0; i < M; i++) \n\t\tfor (j = 0; j < M; j++) { \n\t\t\tp = 0.0; \n\t\t\tfor (a = 0; a < nelec/2; a++) \n\t\t\t\tp += C[a*M+i] * C[a*M+j]; \n\t\t\tP[i*M+j] = p * 2.0; \n\t\t}", "pragma": "parallel for private(a j p)", "hash": "93a807a646e30bce84186295d6aad79f01bd58eca40aedf67f9f982b0a4b00cc"}
{"code": "for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i) {\r \n\t\trefine_ihv_dirs(i);\r \n\t}", "pragma": "parallel for ", "hash": "a36fafba2ab044940481086c3b38bd82b34a72ee667c0f27ba21a9b2654f934d"}
{"code": "for(int x=0; x<Get_NX(); x++) \n\t\t{ \n\t\t\tif( pDistance->is_NoData(x, y) || pTWI->is_NoData(x, y) ) \n\t\t\t{ \n\t\t\t\tpTCI_Low->Set_NoData(x, y); \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tdouble\td\t= (dMax - pDistance->asDouble(x, y)) / dRange;\t\t\t \n \n\t\t\t\tdouble\tw\t= log(1.0 + (pTWI->asDouble(x, y) - wMin)) / wRange;\t \n \n \n\t\t\t\tpTCI_Low->Set_Value(x, y, (2.0 * d + w) / 3.0); \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "7744aef2cbc20902570a391ab8d3f201fae2ba139c77204027d19101dcf7e144"}
{"code": "for (int i = 0; i < m_nCells; i++) \n    { \n        if (m_date >= startDate && m_date <= endDate) \n        { \n            m_frPHU[i] += doHeatUnitAccumulation(m_PHU, m_tMin[i], m_tMax[i], m_tBase[i]); \n \n            if (m_frLAI1 != NULL && m_frLAI2 != NULL && m_frPHU1 != NULL && m_frPHU2 != NULL) \n            { \n                getScurveShapeParameter(m_frLAI1[i], m_frLAI2[i], m_frPHU1[i], m_frPHU2[i], \n                                        &(m_LAIShapeCoefficient1[i]), &(m_LAIShapeCoefficient2[i])); \n            } \n \n             \n \n            m_frLAImx[i] = \n                    m_frPHU[i] / (m_frPHU[i] + exp(m_LAIShapeCoefficient1[i] - m_LAIShapeCoefficient2[i] * m_frPHU[i])); \n            if (m_frPHU[i] <= m_frDPHU[i]) \n \n            { \n \n                if (m_preLAI[i] > m_maxLAI[i]) \n                { \n                    m_preLAI[i] = m_maxLAI[i]; \n                } \n \n                m_LAIdelta[i] = (m_frLAImx[i] - m_prefrLAImx[i]) * m_maxLAI[i] * \n                                (1.0f - exp(5.0f * (m_preLAI[i] - m_maxLAI[i]))); \n \n                m_prefrLAImx[i] = m_frLAImx[i]; \n            } \n \n             \n \n             \n \n            m_activeRadiation[i] = 0.5f * m_SR[i] * (1.0f - exp(-m_lightextinctioncoefficient[i] * (m_LAI[i] + 0.05f))); \n             \n \n            m_rue[i] = 0.f; \n \n            if (m_rueAmb != NULL && m_rueHi != NULL && m_co2 != 0 && m_co2Hi != NULL) \n            { \n                if (m_co2Hi[i] == 330.0f) \n                { \n                    m_co2Hi[i] = 660.f; \n                } \n \n                getScurveShapeParameter(m_rueAmb[i] * 0.01f, m_rueHi[i] * 0.01f, m_co2, m_co2Hi[i], \n                                        &(m_CO2ShapeCoefficient1[i]), &(m_CO2ShapeCoefficient2[i])); \n            } \n            if (m_co2 < 330.0f) \n            { \n                m_rue[i] = m_rueAmb[i]; \n            } \n            if (m_co2 = 330) \n            { \n                m_rue[i] = \n                        100.0f * m_co2 / (m_co2 + exp(m_CO2ShapeCoefficient1[i] - m_CO2ShapeCoefficient2[i] * m_co2)); \n            } \n             \n \n             \n \n            m_ee[i] = 0.0f; \n            m_tMean[i] = (m_tMin[i] + m_tMax[i]) / 2; \n            if (abs(m_tMean[i] + 237.3f) >= 1.0e-6f) \n                m_ee[i] = exp((16.78f * m_tMean[i] - 116.9f) / (m_tMean[i] + 237.3f)); \n            float rm = 0.4f; \n            if (m_RM != NULL) \n                rm = m_RM[i]; \n            m_VPD[i] = m_ee[i] * (1.0f - rm); \n             \n \n            if (m_VPD[i] > 1) \n            { \n                 \n \n                m_rue[i] -= RadiationUseEfficiencyAdjustByVPD(m_VPD[i], m_rueDcl[i]); \n                 \n \n                m_rue[i] = max(m_rue[i], \n                               0.27f * m_rueAmb[i]);       \n \n            } \n            m_biomassDelta[i] = max(0.0f, m_rue[i] * m_activeRadiation[i]); \n \n             \n \n            if (m_frN1 != NULL && m_frN2 != NULL && m_frN3 != NULL && m_frP1 != NULL && m_frP2 != NULL && \n                m_frP3 != NULL) \n            { \n                m_frN[i] = NPBiomassFraction(m_frN1[i], m_frN2[i], m_frN3[i], m_frPHU[i]); \n                m_frP[i] = NPBiomassFraction(m_frP1[i], m_frP2[i], m_frP3[i], m_frPHU[i]); \n            } \n \n             \n \n            m_biomassNOpt[i] = m_frN[i] * m_biomass[i]; \n            m_biomassPOpt[i] = m_frP[i] * m_biomass[i]; \n             \n \n \n            m_frRoot[i] = 0.4f - 0.2f * m_frPHU[i]; \n        } \n \n    }", "pragma": "parallel for ", "hash": "f42d91c8c04531d15f3376d7bd75ed3cc0fa7ff5897cf98bce1919b1928c0990"}
{"code": "for (i = 0; i < 10; i++) \n    { \n      #pragma omp ordered   \n \n\t; \n    }", "pragma": "for ", "hash": "6b2a3535412f5e4b842d6c4c7bd8b81cd68edb1ee2d7fe7d361d67b9fea22bca"}
{"code": "for(rotangle=0;rotangle<360;rotangle+=rotstep){ \n                     \n \n                    CvMat* rot = NULL; \n                    rot=cvCreateMat(2,3, CV_32FC1); \n                    IplImage* prpatch = NULL; \n                    prpatch=cvCreateImage(cvSize((w*2),(h*2)), IPL_DEPTH_8U, 1); \n                    IplImage* testfit = NULL; \n                    testfit=cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 1); \n                    placed|=search(rotangle, posstep, w, h, firstpassed, acorigin->count, &minxpos, &minypos, &minrotangle, &mincentricords,center, itmp, prpatch, rpatch, img,testfit,rot); \n                    cvReleaseImage(&testfit); \n                    cvReleaseImage(&prpatch); \n                    cvReleaseMat(&rot); \n                }", "pragma": "parallel for ", "hash": "ca5a4f9f69f39b4613a4a896de8f5fa5947d1c4bdd498fa6d771755ff9fac873"}
{"code": "for(int i = 0; i < height; i++) { \n        for(int j = 0; j < width; j++) { \n            double val = 0.0; \n \n            for(int iy = i - radius; iy < i + radius + 1; iy++) { \n                const int y = handleEdges(iy, height, tileable); \n                val += input.at(j, y); \n            } \n \n            result.setValue(j, i, val / (radius + radius + 1)); \n        } \n    }", "pragma": "parallel for ", "hash": "e205798e1957c7e4763a604ff047aca7473272f8c852eabee78b0bb27b91b664"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr) \n\t{ \n\t\tregister long k = i*nx;\t\t\tb[k] = b[k+nx-1] = 0; \n\t\tfor(long j=1;j<nx-1;j++)\tb[j+k] = (a[j+k+1]+a[j+k-1]-mgl2*a[j+k])*dd; \n\t}", "pragma": "parallel for ", "hash": "4ba9f39638c17328dd04aa7a96fc650c961dcba86460286a408a8b9cdf049a6e"}
{"code": "for(long f = 0; f < (long)m_nTriangles; f++) \n\t\t\t{ \n\t\t\t\tVec3<Real> seedPoint((m_points[i] + m_points[j] + m_points[k]) / 3.0); \n\t\t\t\tVec3<Real> hitPoint; \n\t\t\t\tVec3<Real> hitNormal; \n\t\t\t\tnormal = -normal; \n                size_t faceIndex = m_nTriangles; \n \n\t\t\t\tFloat dist; \n\t\t\t\tlong hitTriangle; \n\t\t\t\tif (rm.Raycast(seedPoint,normal,hitTriangle,dist, hitPoint, hitNormal)) \n\t\t\t\t{ \n\t\t\t\t\tfaceIndex = hitTriangle; \n\t\t\t\t} \n \n                if (faceIndex < m_nTriangles ) \n                { \n\t\t\t\t\tm_extraDistPoints[f] = hitPoint; \n\t\t\t\t\tm_extraDistNormals[f] = hitNormal; \n\t\t\t\t\tm_graph.m_vertices[f].m_distPoints.PushBack(DPoint(m_nPoints+f, 0, false, true)); \n\t\t\t\t} \n \n\t\t\t\t \n \n\t\t\t\t#ifdef THREAD_DIST_POINTS \n    #pragma omp critical \n\t\t\t\t#endif \n\t\t\t\t{ \n\t\t\t\t\tcompleted++; \n\t\t\t\t \n\t\t\t\t\tprogress = completed * 100.0 / m_nTriangles; \n\t\t\t\t\tif (fabs(progress-progressOld) > ptgStep && m_callBack) \n\t\t\t\t\t{ \n\t\t\t\t\t\tsprintf(msg, \"%3.2f %% \\t \\t \\r\", progress); \n\t\t\t\t\t\t(*m_callBack)(msg, progress, 0.0,  m_nTriangles); \n\t\t\t\t\t\tprogressOld = progress; \n\t\t\t\t\t} \n\t\t\t\t}         \n\t\t\t}", "pragma": "parallel for ", "hash": "8d0dffe7cefd7d6fcac089b548c6ce34aa8901fac744d8e5c1107cc36c69d20a"}
{"code": "for(int frame=0; frame<NUMFRM; frame++) { \n#   pragma omp critical \n    std::cout << \"frame \" << (frame+1) << \" of \" << NUMFRM << std::endl; \n    rcT theRamCanvas(IMGSIZ, IMGSIZ, XCENTR-RELSIZ, XCENTR+RELSIZ, YCENTR-RELSIZ, YCENTR+RELSIZ); \n    double angle = 2.0*std::numbers::pi/6.0/NUMFRM*frame; \n    std::complex<double> a(std::cos(angle), std::sin(angle)); \n    double b = 1e-2; \n    for(int y=0;y<theRamCanvas.getNumPixY();y++) { \n      for(int x=0;x<theRamCanvas.getNumPixX();x++) { \n        std::complex<double> z  = theRamCanvas.int2real(x, y); \n        std::complex<double> zL = z + 100.0; \n        for(int count=0; count<MAXITR; count++) { \n          if(std::abs(z-zL) <= ZROEPS) { \n            theRamCanvas.drawPoint(x, y, rcT::colorType::csCCu0R::c(count*CCLMAG)); break; \n          } else if(std::abs(z) <= ZROEPS) { \n            break; \n          } else if(std::abs(z) > ZMAGMX) { \n            theRamCanvas.drawPoint(x, y, rcT::colorType::csCCu0W::c(count*DCLMAG)); break; \n            break; \n          } \n          zL = z; \n          if (b<1e11) \n            z = (-pow(a, 6.0) * pow(z, 12.0) + (7.0 * pow(a, 6.0) + (5.0 * b)) * pow(z, 6.0) + b) /  \n                pow(z, 5.0) / (pow(a, 6.0) + b) / 6.0; \n          else \n            z = (5.0 * pow(z, 6.0) + 1.0) / pow(z, 5.0) / 6.0; \n        } \n      } \n    } \n    theRamCanvas.writeTIFFfile(\"newton_roter_\" + mjr::fmtInt(frame, 3, '0') + \".tiff\"); \n  }", "pragma": "parallel for ", "hash": "7f412c8db97e64f94ca0acb1e83b5ae54a91b9b0bdfc2a6bf18a1d877ca7a775"}
{"code": "for (int i=_N_start; i<_N_active; i++){ \n\t\t\tfor (int j=i+1; j<_N_active; j++){ \n\t\t\t\tif (_gravity_ignore_10 && j==1 && i==0 ) continue; \n\t\t\t\tconst double dx = particles[i].x - particles[j].x; \n\t\t\t\tconst double dy = particles[i].y - particles[j].y; \n\t\t\t\tconst double dz = particles[i].z - particles[j].z; \n\t\t\t\tconst double r2 = dx*dx + dy*dy + dz*dz + softening2; \n\t\t\t\tconst double r = sqrt(r2); \n\t\t\t\tconst double prefact  = G/(r2*r); \n\t\t\t\tconst double prefacti = prefact*particles[i].m; \n\t\t\t\tconst double prefactj = -prefact*particles[j].m; \n\t\t\t\t \n\t\t\t\t{ \n\t\t\t\tdouble ix = prefactj*dx; \n\t\t\t\tdouble yx = ix - cs[i].x; \n\t\t\t\tdouble tx = particles[i].ax + yx; \n\t\t\t\tcs[i].x = (tx - particles[i].ax) - yx; \n\t\t\t\tparticles[i].ax = tx; \n \n\t\t\t\tdouble iy = prefactj*dy; \n\t\t\t\tdouble yy = iy- cs[i].y; \n\t\t\t\tdouble ty = particles[i].ay + yy; \n\t\t\t\tcs[i].y = (ty - particles[i].ay) - yy; \n\t\t\t\tparticles[i].ay = ty; \n\t\t\t\t \n\t\t\t\tdouble iz = prefactj*dz; \n\t\t\t\tdouble yz = iz - cs[i].z; \n\t\t\t\tdouble tz = particles[i].az + yz; \n\t\t\t\tcs[i].z = (tz - particles[i].az) - yz; \n\t\t\t\tparticles[i].az = tz; \n\t\t\t\t} \n\t\t\t\t \n\t\t\t\t{ \n\t\t\t\tdouble ix = prefacti*dx; \n\t\t\t\tdouble yx = ix - cs[j].x; \n\t\t\t\tdouble tx = particles[j].ax + yx; \n\t\t\t\tcs[j].x = (tx - particles[j].ax) - yx; \n\t\t\t\tparticles[j].ax = tx; \n \n\t\t\t\tdouble iy = prefacti*dy; \n\t\t\t\tdouble yy = iy - cs[j].y; \n\t\t\t\tdouble ty = particles[j].ay + yy; \n\t\t\t\tcs[j].y = (ty - particles[j].ay) - yy; \n\t\t\t\tparticles[j].ay = ty; \n\t\t\t\t \n\t\t\t\tdouble iz = prefacti*dz; \n\t\t\t\tdouble yz = iz - cs[j].z; \n\t\t\t\tdouble tz = particles[j].az + yz; \n\t\t\t\tcs[j].z = (tz - particles[j].az) - yz; \n\t\t\t\tparticles[j].az = tz; \n\t\t\t\t} \n\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "0377a968cf1c15ebfa8251bb8d145db36e348163619c7e55434216ca3c4c24c6"}
{"code": "for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i) {\r \n\t\tfor (int j = 0; j < iwidth; ++j) {\r \n\t\t\tint x = j + nr_leftmargin;\r \n\t\t\tint y = i + nr_topmargin;\r \n\t\t\tif (ndir[nr_offset(y, x)] & HOT) {\r \n\t\t\t\tint l = libraw.COLOR(i, j);\r \n\t\t\t\tnraw[nr_offset(i + nr_topmargin, j + nr_leftmargin)][l] = libraw.imgdata.image[i\r \n\t\t\t\t\t\t* iwidth + j][l];\r \n\t\t\t}\r \n\t\t}\r \n\t}", "pragma": "parallel for private(iwidth)", "hash": "b1363906f939b0fb3f9fb6ce77c65a7786fa0d98d1cbd97eee447892f15c91f1"}
{"code": "for (i = 0; i < population->size - threshold; i++) { \n         \n \n        parent1 = \n            &population->individual[rand_num(random_seed)%threshold]; \n        parent2 = \n            &population->individual[rand_num(random_seed)%threshold]; \n \n         \n \n        child = &population->individual[threshold + i]; \n        gprcm_mate(parent1, parent2, \n                   population->rows, population->columns, \n                   population->sensors, population->actuators, \n                   population->connections_per_gene, \n                   population->min_value, population->max_value, \n                   population->integers_only, \n                   mutation_prob, use_crossover, \n                   population->chromosomes, \n                   instruction_set, no_of_instructions, \n                   0, population->ADF_modules, child); \n \n         \n \n        population->fitness[threshold + i] = 0; \n \n         \n \n        (&child->program)->age = 0; \n    }", "pragma": "parallel for ", "hash": "9d441f3430b7968a6c27e3d006fa3a3fdf0bb74fd6c681221f88e955afd7fc4d"}
{"code": "for(int splitId = 0; splitId < splits.size(); ++splitId) \n\t\t{ \n\t\t\tQVector<uint> leftSeqCounts, rightSeqCounts; \n\t\t\tbool bOutgroupSeqOnLeft, bOutgroupSeqOnRight; \n\t\t\tif(CalculateSeqsInSample(splits.at(splitId), leftSeqCounts, rightSeqCounts, bOutgroupSeqOnLeft, bOutgroupSeqOnRight)) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tfor(uint i = 0; i < numActiveSamples; ++i) \n\t\t\t\t{ \n\t\t\t\t\tuint iIndex = activeSamples.at(i); \n \n\t\t\t\t\tfor(uint j = i+1; j < numActiveSamples; ++j) \n\t\t\t\t\t{\t\t \n\t\t\t\t\t\tuint jIndex = activeSamples.at(j); \n \n\t\t\t\t\t\tdouble normSeqCountI, normSeqCountJ; \n \n\t\t\t\t\t\tif(bOutgroupSeqOnLeft) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tnormSeqCountI = double(rightSeqCounts.at(iIndex)) / m_splitSystem->GetSamples()->GetSequences()->GetNumSequencesInSample(iIndex); \n\t\t\t\t\t\t\tnormSeqCountJ = double(rightSeqCounts.at(jIndex)) / m_splitSystem->GetSamples()->GetSequences()->GetNumSequencesInSample(jIndex); \n\t\t\t\t\t\t} \n\t\t\t\t\t\telse \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tnormSeqCountI = double(leftSeqCounts.at(iIndex)) / m_splitSystem->GetSamples()->GetSequences()->GetNumSequencesInSample(iIndex);\t \n\t\t\t\t\t\t\tnormSeqCountJ = double(leftSeqCounts.at(jIndex)) / m_splitSystem->GetSamples()->GetSequences()->GetNumSequencesInSample(jIndex); \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\ttempMatrix[i][j].uniqueEvolution += splits.at(splitId).GetWeight()*fabs(normSeqCountI - normSeqCountJ); \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tif(GetSplitsToConsider() == COMMON_SPLIT_SET) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tdouble shared = std::min(normSeqCountI, normSeqCountJ); \n\t\t\t\t\t\t\ttempMatrix[i][j].normFactor += splits.at(splitId).GetWeight()*std::min(shared, 1 - shared);  \n\t\t\t\t\t\t\ttempMatrix[i][j].normFactor += splits.at(splitId).GetWeight()*fabs(normSeqCountI - normSeqCountJ); \n\t\t\t\t\t\t} \n\t\t\t\t\t\telse if(GetSplitsToConsider() == COMPLETE_LINEAGE) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\ttempMatrix[i][j].normFactor += splits.at(splitId).GetWeight()*(normSeqCountI + normSeqCountJ); \n\t\t\t\t\t\t\ttempMatrix[i][j].normFactor += splits.at(splitId).GetWeight()*fabs(normSeqCountI - normSeqCountJ); \n\t\t\t\t\t\t} \n\t\t\t\t\t\telse if(GetSplitsToConsider() == NORMALIZED_WEIGHTED_UNIFRAC) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\ttempMatrix[i][j].normFactor += splits.at(splitId).GetWeight()*(normSeqCountI + normSeqCountJ); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "840837f172437160132b9201f7ac307ac756ce7989a41e3b685054dcc9497a6d"}
{"code": "for(pairI = 0; pairI < pairMax; pairI++)\r \n\t\t{\r \n\t\t\tint tI = omp_get_thread_num();\r \n\t\t\tassert(omp_get_num_threads() == outerThreads);\r \n\t\t\tassert((tI >= 0) && (tI < outerThreads));\r \n\r \n\t\t\tassert((pairI >= 0) && (pairI < readPairs.size()));\r \n\t\t\toneReadPair rP = readPairs.at(pairI);\r \n\r \n\t\t\tassert((tI >= 0) && (tI < graphAligners.size()));\r \n\r \n\t\t\tstd::map<int, double> _IS_ignore;\r \n\t\t\tstd::vector<std::pair<seedAndExtend_return_local, seedAndExtend_return_local>> alignment_pairs = graphAligners.at(tI)->seedAndExtend_short_allAlignments(rP, insertSize_mean, insertSize_sd, true, debug, MiSeq250bp);\r \n\r \n\t\t\tif(alignment_pairs.size() > 1)\r \n\t\t\t{\r \n\t\t\t\tassert(alignment_pairs.at(0).first.mapQ_genomic >= alignment_pairs.at(1).first.mapQ_genomic);\r \n\t\t\t\tassert(alignment_pairs.at(0).first.mapQ >= alignment_pairs.at(1).first.mapQ);\r \n\t\t\t}\r \n\t\t\t\r \n\t\t\tstd::vector<std::pair<seedAndExtend_return_local, seedAndExtend_return_local>> alignment_pairs_forPrint;\r \n\t\t\tunsigned int max_print_index = (alignment_pairs.size() > print_max_alignments) ? print_max_alignments : alignment_pairs.size();\r \n\t\t\tdouble accumulated_LL = 0;\r \n\t\t\tdouble accumulated_genomic_LL = 0;\r \n\t\t\tfor(unsigned int i = 0; i < max_print_index; i++)\r \n\t\t\t{\r \n\t\t\t\talignment_pairs_forPrint.push_back(alignment_pairs.at(i));\r \n\t\t\t\taccumulated_LL += alignment_pairs.at(i).first.mapQ;\r \n\t\t\t\taccumulated_genomic_LL += alignment_pairs.at(i).first.mapQ_genomic;\r \n\t\t\t}\r \n\r \n\t\t\tif(printedAlignments_perRead_perThread.at(tI).count(max_print_index) == 0)\r \n\t\t\t{\r \n\t\t\t\tprintedAlignments_perRead_perThread.at(tI)[max_print_index] = 0;\r \n\t\t\t}\r \n\t\t\tprintedAlignments_perRead_perThread.at(tI).at(max_print_index)++;\r \n\r \n\t\t\tint accumulated_LL_asInt = int(accumulated_LL * 10.0);\r \n\t\t\tif(printedAlignments_perRead_combinedLL_perThread.at(tI).count(accumulated_LL_asInt) == 0)\r \n\t\t\t{\r \n\t\t\t\tprintedAlignments_perRead_combinedLL_perThread.at(tI)[accumulated_LL_asInt] = 0;\r \n\t\t\t}\r \n\t\t\tprintedAlignments_perRead_combinedLL_perThread.at(tI).at(accumulated_LL_asInt)++;\r \n\t\t\t\r \n\t\t\tint accumulated_genomic_LL_asInt = int(accumulated_genomic_LL * 10.0);\r \n\t\t\tif(printedAlignments_perRead_combinedGenomicLL_perThread.at(tI).count(accumulated_genomic_LL_asInt) == 0)\r \n\t\t\t{\r \n\t\t\t\tprintedAlignments_perRead_combinedGenomicLL_perThread.at(tI)[accumulated_genomic_LL_asInt] = 0;\r \n\t\t\t}\r \n\t\t\tprintedAlignments_perRead_combinedGenomicLL_perThread.at(tI).at(accumulated_genomic_LL_asInt)++;\r \n\r \n\r \n\t\t\talignments_perThread.at(tI).push_back(alignment_pairs_forPrint);\r \n\t\t\talignments_readPairI_perThread.at(tI).push_back(pairI);\r \n\r \n\t\t\tif(tI == 0)\r \n\t\t\t{\r \n\t\t\t\tstd::cout  << Utilities::timestamp() << \"\\t\\t\" << \"Thread \" << tI << \": align pair \" << pairI << \"\\n\" << std::flush;\r \n\t\t\t}\r \n\t\t}", "pragma": "parallel for ", "hash": "86268fea9bff6e62e734625e737e4071f67e9ac26159f2df99f50d6dddd992d2"}
{"code": "for( size_t i = 0; i < tree.edge_count(); ++i ) { \n        tree.edge_at(i).data<MassTreeEdgeData>().masses.clear(); \n    }", "pragma": "parallel for ", "hash": "e12214c72cb956bac365b11cae87a6609d876be5a08a6728c1ca557fa5826175"}
{"code": "for(long i=0;i<nx*ny*vz;i++)\tb[k+i] = v->vthr(i);", "pragma": "parallel for ", "hash": "2f3670d039b8146b132e573026c71c2a5964f24fdd0e9c7965c85d1bc29afb5c"}
{"code": "for (int ip = 0; ip < otherphysicslist.size(); ++ip)   \n \n        { \n            ChPhysicsItem* PHpointer = otherphysicslist[ip]; \n            PHpointer->VariablesQbSetSpeed(step); \n            PHpointer->Update(this->ChTime); \n        }", "pragma": "parallel for ", "hash": "f544ac2132326721edc85fa8e12f63d5a69c3191330b55e7ff781fbc4321502c"}
{"code": "for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n     \n \n    mask[k / 4] = (input[k] > threshold || input[k + 1] > threshold || input[k + 2] > threshold); \n  }", "pragma": "parallel for simd ", "hash": "31a2185c8fd580563232b212aac400fc1f0cf5e5c19b822a8eaa9880033013ee"}
{"code": "for (int i = 0; i < N; i++) { \n        d[i].real(WR[i]); \n        d[i].imag(WI[i]); \n    }", "pragma": "parallel for ", "hash": "67a25fd37d3d0ffa69cf0deeec907dba8941b78890e4f3c0070a1bdcf6dac89b"}
{"code": "for(rocsparse_int row = 0; row < mb; ++row) \n    { \n        rocsparse_int row_begin = bsr_row_ptr[row] - base; \n        rocsparse_int row_end   = bsr_row_ptr[row + 1] - base; \n \n        if(row_block_dim == 2) \n        { \n            std::vector<T> sum0(WFSIZE, static_cast<T>(0)); \n            std::vector<T> sum1(WFSIZE, static_cast<T>(0)); \n \n            for(rocsparse_int j = row_begin; j < row_end; j += WFSIZE) \n            { \n                for(rocsparse_int k = 0; k < WFSIZE; ++k) \n                { \n                    if(j + k < row_end) \n                    { \n                        rocsparse_int col = bsr_col_ind[j + k] - base; \n \n                        for(rocsparse_int l = 0; l < col_block_dim; l++) \n                        { \n                            if(dir == rocsparse_direction_column) \n                            { \n                                sum0[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l], \n                                                   x[col * col_block_dim + l], \n                                                   sum0[k]); \n                                sum1[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l + 1], \n                                                   x[col * col_block_dim + l], \n                                                   sum1[k]); \n                            } \n                            else \n                            { \n                                sum0[k] \n                                    = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) + l], \n                                               x[col * col_block_dim + l], \n                                               sum0[k]); \n                                sum1[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + col_block_dim + l], \n                                                   x[col * col_block_dim + l], \n                                                   sum1[k]); \n                            } \n                        } \n                    } \n                } \n            } \n \n            for(unsigned int j = 1; j < WFSIZE; j <<= 1) \n            { \n                for(unsigned int k = 0; k < WFSIZE - j; ++k) \n                { \n                    sum0[k] += sum0[k + j]; \n                    sum1[k] += sum1[k + j]; \n                } \n            } \n \n            if(beta != static_cast<T>(0)) \n            { \n                y[row * row_block_dim + 0] \n                    = std::fma(beta, y[row * row_block_dim + 0], alpha * sum0[0]); \n                y[row * row_block_dim + 1] \n                    = std::fma(beta, y[row * row_block_dim + 1], alpha * sum1[0]); \n            } \n            else \n            { \n                y[row * row_block_dim + 0] = alpha * sum0[0]; \n                y[row * row_block_dim + 1] = alpha * sum1[0]; \n            } \n        } \n        else if(row_block_dim == 3) \n        { \n            std::vector<T> sum0(WFSIZE, static_cast<T>(0)); \n            std::vector<T> sum1(WFSIZE, static_cast<T>(0)); \n            std::vector<T> sum2(WFSIZE, static_cast<T>(0)); \n \n            for(rocsparse_int j = row_begin; j < row_end; j += WFSIZE) \n            { \n                for(rocsparse_int k = 0; k < WFSIZE; ++k) \n                { \n                    if(j + k < row_end) \n                    { \n                        rocsparse_int col = bsr_col_ind[j + k] - base; \n \n                        for(rocsparse_int l = 0; l < col_block_dim; l++) \n                        { \n                            if(dir == rocsparse_direction_column) \n                            { \n                                sum0[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l], \n                                                   x[col * col_block_dim + l], \n                                                   sum0[k]); \n                                sum1[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l + 1], \n                                                   x[col * col_block_dim + l], \n                                                   sum1[k]); \n                                sum2[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l + 2], \n                                                   x[col * col_block_dim + l], \n                                                   sum2[k]); \n                            } \n                            else \n                            { \n                                sum0[k] \n                                    = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) + l], \n                                               x[col * col_block_dim + l], \n                                               sum0[k]); \n                                sum1[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + col_block_dim + l], \n                                                   x[col * col_block_dim + l], \n                                                   sum1[k]); \n                                sum2[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + 2 * col_block_dim + l], \n                                                   x[col * col_block_dim + l], \n                                                   sum2[k]); \n                            } \n                        } \n                    } \n                } \n            } \n \n            for(unsigned int j = 1; j < WFSIZE; j <<= 1) \n            { \n                for(unsigned int k = 0; k < WFSIZE - j; ++k) \n                { \n                    sum0[k] += sum0[k + j]; \n                    sum1[k] += sum1[k + j]; \n                    sum2[k] += sum2[k + j]; \n                } \n            } \n \n            if(beta != static_cast<T>(0)) \n            { \n                y[row * row_block_dim + 0] \n                    = std::fma(beta, y[row * row_block_dim + 0], alpha * sum0[0]); \n                y[row * row_block_dim + 1] \n                    = std::fma(beta, y[row * row_block_dim + 1], alpha * sum1[0]); \n                y[row * row_block_dim + 2] \n                    = std::fma(beta, y[row * row_block_dim + 2], alpha * sum2[0]); \n            } \n            else \n            { \n                y[row * row_block_dim + 0] = alpha * sum0[0]; \n                y[row * row_block_dim + 1] = alpha * sum1[0]; \n                y[row * row_block_dim + 2] = alpha * sum2[0]; \n            } \n        } \n        else if(row_block_dim == 4) \n        { \n            std::vector<T> sum0(WFSIZE, static_cast<T>(0)); \n            std::vector<T> sum1(WFSIZE, static_cast<T>(0)); \n            std::vector<T> sum2(WFSIZE, static_cast<T>(0)); \n            std::vector<T> sum3(WFSIZE, static_cast<T>(0)); \n \n            for(rocsparse_int j = row_begin; j < row_end; j += WFSIZE) \n            { \n                for(rocsparse_int k = 0; k < WFSIZE; ++k) \n                { \n                    if(j + k < row_end) \n                    { \n                        rocsparse_int col = bsr_col_ind[j + k] - base; \n \n                        for(rocsparse_int l = 0; l < col_block_dim; l++) \n                        { \n                            if(dir == rocsparse_direction_column) \n                            { \n                                sum0[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l], \n                                                   x[col * col_block_dim + l], \n                                                   sum0[k]); \n                                sum1[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l + 1], \n                                                   x[col * col_block_dim + l], \n                                                   sum1[k]); \n                                sum2[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l + 2], \n                                                   x[col * col_block_dim + l], \n                                                   sum2[k]); \n                                sum3[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + row_block_dim * l + 3], \n                                                   x[col * col_block_dim + l], \n                                                   sum3[k]); \n                            } \n                            else \n                            { \n                                sum0[k] \n                                    = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) + l], \n                                               x[col * col_block_dim + l], \n                                               sum0[k]); \n                                sum1[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + col_block_dim + l], \n                                                   x[col * col_block_dim + l], \n                                                   sum1[k]); \n                                sum2[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + 2 * col_block_dim + l], \n                                                   x[col * col_block_dim + l], \n                                                   sum2[k]); \n                                sum3[k] = std::fma(bsr_val[row_block_dim * col_block_dim * (j + k) \n                                                           + 3 * col_block_dim + l], \n                                                   x[col * col_block_dim + l], \n                                                   sum3[k]); \n                            } \n                        } \n                    } \n                } \n            } \n \n            for(unsigned int j = 1; j < WFSIZE; j <<= 1) \n            { \n                for(unsigned int k = 0; k < WFSIZE - j; ++k) \n                { \n                    sum0[k] += sum0[k + j]; \n                    sum1[k] += sum1[k + j]; \n                    sum2[k] += sum2[k + j]; \n                    sum3[k] += sum3[k + j]; \n                } \n            } \n \n            if(beta != static_cast<T>(0)) \n            { \n                y[row * row_block_dim + 0] \n                    = std::fma(beta, y[row * row_block_dim + 0], alpha * sum0[0]); \n                y[row * row_block_dim + 1] \n                    = std::fma(beta, y[row * row_block_dim + 1], alpha * sum1[0]); \n                y[row * row_block_dim + 2] \n                    = std::fma(beta, y[row * row_block_dim + 2], alpha * sum2[0]); \n                y[row * row_block_dim + 3] \n                    = std::fma(beta, y[row * row_block_dim + 3], alpha * sum3[0]); \n            } \n            else \n            { \n                y[row * row_block_dim + 0] = alpha * sum0[0]; \n                y[row * row_block_dim + 1] = alpha * sum1[0]; \n                y[row * row_block_dim + 2] = alpha * sum2[0]; \n                y[row * row_block_dim + 3] = alpha * sum3[0]; \n            } \n        } \n        else \n        { \n            for(rocsparse_int bi = 0; bi < row_block_dim; ++bi) \n            { \n                std::vector<T> sum(WFSIZE, static_cast<T>(0)); \n \n                for(rocsparse_int j = row_begin; j < row_end; ++j) \n                { \n                    rocsparse_int col = bsr_col_ind[j] - base; \n \n                    for(rocsparse_int bj = 0; bj < col_block_dim; bj += WFSIZE) \n                    { \n                        for(unsigned int k = 0; k < WFSIZE; ++k) \n                        { \n                            if(bj + k < col_block_dim) \n                            { \n                                if(dir == rocsparse_direction_column) \n                                { \n                                    sum[k] = std::fma(bsr_val[row_block_dim * col_block_dim * j \n                                                              + row_block_dim * (bj + k) + bi], \n                                                      x[col_block_dim * col + (bj + k)], \n                                                      sum[k]); \n                                } \n                                else \n                                { \n                                    sum[k] = std::fma(bsr_val[row_block_dim * col_block_dim * j \n                                                              + col_block_dim * bi + (bj + k)], \n                                                      x[col_block_dim * col + (bj + k)], \n                                                      sum[k]); \n                                } \n                            } \n                        } \n                    } \n                } \n \n                for(unsigned int j = 1; j < WFSIZE; j <<= 1) \n                { \n                    for(unsigned int k = 0; k < WFSIZE - j; ++k) \n                    { \n                        sum[k] += sum[k + j]; \n                    } \n                } \n \n                if(beta != static_cast<T>(0)) \n                { \n                    y[row * row_block_dim + bi] \n                        = std::fma(beta, y[row * row_block_dim + bi], alpha * sum[0]); \n                } \n                else \n                { \n                    y[row * row_block_dim + bi] = alpha * sum[0]; \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "ffde4b03d028597f7eb2117df405d5a28b9ff03f64f67dd7f716b52f40507fe6"}
{"code": "for (size_t view_index = 0; view_index < views_->size(); ++view_index) { \n    LOG(INFO) << \"Computing descriptors for image index \" << view_index; \n \n    cv::Mat &image = (*views_)[view_index].GetImage(); \n    std::vector<cv::KeyPoint> &keypoints = keypoints_[view_index]; \n    cv::Mat descriptors; \n    switch (options_.detector_type) { \n      case DetectorType::AKAZE: { \n          cv::Ptr<cv::Feature2D> akaze = cv::AKAZE::create(); \n          akaze->compute(image, keypoints, descriptors); \n          break; \n        } \n      default: { \n          cv::Ptr<cv::Feature2D> fast = cv::ORB::create(); \n          fast->compute(image, keypoints, descriptors); \n        } \n    } \n \n#pragma omp critical \n    { \n       \n \n      descriptors_[view_index] = descriptors; \n    } \n  }", "pragma": "parallel for ", "hash": "7cc4ebe85d339638debb32e3f8bb61b89d34f3a39a58136f22774634cbaf9981"}
{"code": "for (i = 0; i <= n - 1; i += 1) { \n     \n#pragma omp parallel for private (xx,yy,temp,j) reduction (+:error) firstprivate (dx,dy) \n    for (j = 0; j <= m - 1; j += 1) { \n      xx = - 1.0 + dx * (i - 1); \n      yy = - 1.0 + dy * (j - 1); \n      temp = u[i][j] - (1.0 - xx * xx) * (1.0 - yy * yy); \n      error = error + temp * temp; \n    } \n  }", "pragma": "parallel for reduction(+:error) private(i j temp xx yy)", "hash": "00842036895669a1f01da64b570c167d6584a61fddb694d8458f4184e6f89222"}
{"code": "for (int g = 0; g < group_; ++g) { \n    caffe_cpu_gemm<Dtype>(CblasNoTrans, CblasTrans, conv_out_channels_ / group_, \n        kernel_dim_ / group_, conv_out_spatial_dim_, \n        (Dtype)1., output + output_offset_ * g, col_buff + col_offset_ * g, \n        (Dtype)1., weights + weight_offset_ * 0); \n  }", "pragma": "parallel for ", "hash": "de4bfd7bf2c572a5ad6cf9e5f3faee517b7f50b1502caaf4f4e66325fcec364c"}
{"code": "for (i = 0; i < r; i++) { \n        b[i] *= TWO_PI; \n    }", "pragma": "parallel for private(i)", "hash": "c2d647f7f57bf015bb695091c5e86692d468b3b046fc2cb602cb11805d1dab10"}
{"code": "for (int i = 0; i < numEntries; i++) { \n        smartSubtractionCAPS(C + i, A + i, B + i); \n    }", "pragma": "parallel for ", "hash": "26d6d19128b587b4480537285615499227826a4af2fb89770d679d03471416ca"}
{"code": "for (int i = 0; i < n; ++i) { \n      w[i] = alpha*x[i] + y[i]; \n    }", "pragma": "parallel for ", "hash": "9a0b631fcbcddb20282f60d066fce54fcea5d384505f1af08e7ba9f5aea4e240"}
{"code": "for(INMOST_DATA_INTEGER_TYPE k = wbeg; k < static_cast<INMOST_DATA_INTEGER_TYPE>(wend); ++k) \n\t\t{ \n\t\t\tint thr = Thread(); \n\t\t\tout_pG_Address[k].thr = thr; \n\t\t\tout_pG_Address[k].first = (INMOST_DATA_ENUM_TYPE)out_pG_Entries[thr].size(); \n\t\t\tfor (INMOST_DATA_ENUM_TYPE jt = in_pG_Address[invP[k]].first; jt < in_pG_Address[invP[k]].last; ++jt) \n\t\t\t{ \n\t\t\t\tINMOST_DATA_ENUM_TYPE j = localP[in_pG_Entries[in_pG_Address[invP[k]].thr][jt]]; \n\t\t\t\tif (wbeg <= j && j < wend) \n\t\t\t\t\tout_pG_Entries[thr].push_back(j); \n\t\t\t} \n\t\t\tout_pG_Address[k].last = (INMOST_DATA_ENUM_TYPE)out_pG_Entries[thr].size(); \n\t\t\t \n \n\t\t}", "pragma": "parallel for ", "hash": "0eaccc68dc2ff184d83bbbd61a5b187024782b561316db14b1c392d11da4d061"}
{"code": "for(unsigned i=0; i<numq; i++) inten[i] += tmp_inten[i];", "pragma": "for ", "hash": "c8cd1f87b9cdd0d137b6bdc662e1c9c4db929c24693bc161888463824a337a7e"}
{"code": "for(int i = 0; i < nelr; i++) \n\t{ \n\t\tfor(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j]; \n\t}", "pragma": "parallel for ", "hash": "2e27b85dcaee46b4933a1cddefb1b849673d2945b351c4c1ffe604391b715cc2"}
{"code": "for (int i = 5; i <= i; i++)  \n \n    ;", "pragma": "for ", "hash": "b7439a77c9a0c90a0d322351767c577cb58dd4e0ff737ba40fb6a61d8a321a89"}
{"code": "for ( int k = 0; k < matrix.innerSize(); ++k ) \n    { \n        const Scalar sum = matrix.row( k ).sum(); \n        if ( !Ra::Core::Math::areApproxEqual( sum, Scalar( 0 ) ) ) \n        { \n            if ( !Ra::Core::Math::areApproxEqual( sum, Scalar( 1 ) ) ) \n            { \n                skinningWeightOk = false; \n                matrix.row( k ) /= sum; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "deb63e60bdc9ca7097f9f4d5294da02f594b3f6b6225c6f566267beac9cb4a2f"}
{"code": "for (unsigned int m = 0; m < M; m += W) { \n \n                memset(acc, 0, W*N*sizeof(complex float)); \n \n                for (int idx = 0; ; idx++) {  \n \n                    char alive = 0; \n                    for (int w = 0; w < W && m+w < M; w++) {  \n \n                        unsigned int i = pntrb[m+w] + idx;  \n \n                        if (i < pntre[m+w]) {  \n \n                            alive = 1; \n                            unsigned int k = col[i]; \n                            complex float v = val[i]; \n                            for (unsigned int n = 0; n < N; n++) \n                                acc[w*N+n] += v * B[k+n*ldb]; \n                        } \n                    } \n                    if (!alive)  \n \n                        break; \n                } \n \n                for (unsigned int n = 0; n < N; n++) \n                for (unsigned int w = 0; w < W && m+w < M; w++) \n                    C[(m+w)+n*ldc] = alpha * acc[w*N+n] + beta * C[(m+w)+n*ldc]; \n            }", "pragma": "for ", "hash": "0570e277da94de1dc6f2de7cb58b66fcf5f9d2d094f064ee75192f265f1645ac"}
{"code": "for( OMPInt i=0; i<nEl; ++i) \n\t    { \n\t      (*res)[ i] = (int) ceil((*p0C)[ i]);  \n\t    }", "pragma": "for ", "hash": "f5e2302aed2bf385018d04817ab326a818438cefa4ad3b34464b49d600168b72"}
{"code": "for( i = 0; i < m * n ; i++ ) { \n\t\t\t\t \n \n\t\t\t\ttmp_error = ( SUBXTYPE ) fabs( ( SUBXTYPE ) phigemm_get_real_part (C_mkl[ i ]) \n\t\t\t\t\t\t- (SUBXTYPE) phigemm_get_real_part (C_phigemm[ i ]) ); \n\t\t\t\tif (tmp_error > MAX_ERROR ) { \n\t\t\t\t\terrors++; \n\t\t\t\t} \n \n\t\t\t\t \n \n\t\t\t\ttmp_error = ( SUBXTYPE ) fabs( ( SUBXTYPE ) phigemm_get_img_part (C_mkl[ i ]) \n\t\t\t\t\t\t- (SUBXTYPE) phigemm_get_img_part (C_phigemm[ i ]) ); \n\t\t\t\tif (tmp_error > MAX_ERROR ) { \n\t\t\t\t\terrors++; \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for reduction(+ : errors) ", "hash": "33a87b64f3bf188d4910e608c17e6dac0a9a088f672d47a13481fb77c339554a"}
{"code": "for(i=0; i<Porig->ncols; i++){ \n                col_vec = vector_new(Porig->ncols); \n                matrix_get_col(Porig,vector_get_element(I,i),col_vec); \n                matrix_set_col(P,i,col_vec); \n                vector_delete(col_vec); \n            }", "pragma": "for ", "hash": "06d6868ecaa1ebb8737e5e24380aefe82881deca06d71bc6fbfc807d439618e9"}
{"code": "for (int i = 0; i < (int) workersInBatch.size(); i++) { \n          try { \n            workersInBatch[i]->main_mt(); \n          } catch (...) { \n            exception.capture(); \n          } \n        }", "pragma": "parallel for ", "hash": "2735ccae4b6112c5a5e6a731188f4c32bc9c7c7c301e171636c0f62d23f41eec"}
{"code": "for (int y = 0 ; y < map->bloc_h_db ; ++y)  \n \n\t\t{ \n\t\t\tfor (int x = 0 ; x < map->bloc_w_db ; ++x) \n\t\t\t{ \n\t\t\t\tmap->map_data(x, y).init(); \n\t\t\t\tmap->map_data(x, y).setUnderwater(map->h_map(x, y) < map->sealvl); \n\t\t\t\tmap->map_data(x, y).setLava(map->bmap(x >> 1, y >> 1) < map->nbbloc ? map->bloc[ map->bmap(x >> 1, y >> 1) ].lava : false); \n\t\t\t\tif (!map->map_data(x, y).isLava() && (x>>1) + 1 < map->bloc_w && map->bmap((x >> 1) + 1, y >> 1) < map->nbbloc) \n\t\t\t\t{ \n\t\t\t\t\tmap->map_data(x, y).setLava(map->bloc[ map->bmap((x >> 1) + 1, y >> 1) ].lava); \n\t\t\t\t\tif (!map->map_data(x, y).isLava() && (y>>1) + 1 < map->bloc_h && map->bmap( (x >> 1) + 1, (y >> 1) + 1) < map->nbbloc) \n\t\t\t\t\t\tmap->map_data(x, y).setLava( map->bloc[ map->bmap( (x >> 1) + 1, (y >> 1) + 1) ].lava ); \n\t\t\t\t\tif (!map->map_data(x, y).isLava() && (y>>1) - 1 >= 0 && map->bmap((x >> 1) + 1, (y >> 1) - 1) < map->nbbloc) \n\t\t\t\t\t\tmap->map_data(x, y).setLava( map->bloc[ map->bmap((x >> 1) + 1, (y >> 1) - 1) ].lava ); \n\t\t\t\t} \n\t\t\t\tif (!map->map_data(x, y).isLava() && (x>>1) - 1 >= 0 && map->bmap((x >> 1) - 1, y >> 1) < map->nbbloc) \n\t\t\t\t{ \n\t\t\t\t\tmap->map_data(x, y).setLava( map->bloc[ map->bmap((x >> 1) - 1, y >> 1) ].lava ); \n\t\t\t\t\tif (!map->map_data(x, y).isLava() && (y>>1) + 1 < map->bloc_h && map->bmap( (x >> 1) - 1, (y >> 1) + 1) < map->nbbloc) \n\t\t\t\t\t\tmap->map_data(x, y).setLava( map->bloc[ map->bmap( (x >> 1) - 1, (y >> 1) + 1) ].lava ); \n\t\t\t\t\tif (!map->map_data(x, y).isLava() && (y>>1) - 1 >= 0 && map->bmap((x >> 1) - 1, (y >> 1) - 1) < map->nbbloc) \n\t\t\t\t\t\tmap->map_data(x, y).setLava( map->bloc[ map->bmap((x >> 1) - 1, (y >> 1) - 1) ].lava ); \n\t\t\t\t} \n\t\t\t\tif (!map->map_data(x, y).isLava() && (y>>1) + 1 < map->bloc_h && map->bmap(x >> 1, (y >> 1) + 1) < map->nbbloc) \n\t\t\t\t\tmap->map_data(x, y).setLava( map->bloc[ map->bmap(x >> 1, (y >> 1) + 1) ].lava ); \n\t\t\t\tif (!map->map_data(x, y).isLava() && (y>>1) - 1 >= 0 && map->bmap(x >> 1, (y >> 1) - 1) < map->nbbloc) \n\t\t\t\t\tmap->map_data(x, y).setLava( map->bloc[ map->bmap(x >> 1, (y >> 1) - 1) ].lava ); \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "fdc05030ed140038ba3e93cf4393a5e8d49f8bd05385da014e17f8541c283101"}
{"code": "for (i = 0; i < n; i++){ \n     c[i] += a[i]+b[i]; \n  }", "pragma": "for ", "hash": "1af6b5058663756b5317b0d65a1781a7eb98fc41eea819d45310c98f1117d117"}
{"code": "for(size_t i = 0; i < dst.shape()[dim - 1]; ++i) \n        { \n            BroadcastUnroll < dim - 1 >::unroll(op, src1, src2, dst, id_src1, id_src2, id_dst); \n \n            id_src1[dim - 1] += !src1_is_broadcast; \n            id_src2[dim - 1] += !src2_is_broadcast; \n            ++id_dst[dim - 1]; \n        }", "pragma": "parallel for ", "hash": "53d88955e399e298609b424d6f24e6b49daf49018d656bf4dfcaa3552ed02d9e"}
{"code": "for (i=0; i<indlen; i++)\r \n\t{\r \n\t\tint ind=(int)(*(indPtr+i));\r \n\t\tint row=ind%mrows;\r \n\t\tint col=ind/mrows;\r \n\t\tint sta_col, end_col, sta_row, end_row;\r \n\t\tsta_col=((col-half_w)<0?0:(col-half_w));\r \n\t\tend_col=((col+half_w)<ncols?(col+half_w):ncols);\r \n\t\tsta_row=((row-half_h)<0?0:(row-half_h));\r \n\t\tend_row=((row+half_h)<mrows?(row+half_h):mrows);\r \n\t\tfor (int p=sta_col; p<end_col; p++) {\r \n\t\t\tint rowind=p*mrows;\r \n\t\t\tfor (int q=sta_row; q<end_row; q++)\r \n\t\t\t\t*(outPtr+q+rowind)=1;\r \n\t\t}\r \n\t}", "pragma": "parallel for ", "hash": "4504437be831fa1618f0e3ec6da7e4629302c77e89ee5f6b704e85f6c0139708"}
{"code": "for (int col = 1; col < m_data->series.size (); ++col)\r \n    {\r \n        double medium (0.0);\r \n\r \n        for (unsigned i = 0; i < m_data->series[col].size (); ++i)\r \n            medium += m_data->series[col][i];\r \n        medium /= m_data->series[col].size ();\r \n\r \n        d->series.push_back (Row (m_data->series[col].get_name (), m_data->series[0].size (), 0.0));\r \n        for (unsigned i = 0; i < m_data->series[col].size (); ++i)\r \n            d->series[col][i] = m_data->series[col][i] - medium;\r \n    }", "pragma": "parallel ", "hash": "4032f26c80d4c342ca54c75b6285093df402dfc250e2db4e1fce48112479147e"}
{"code": "for( int line = 0; line < m_AOIh; line++ ) \n            { \n                unsigned short red0, green0, blue0; \n                unsigned short red1, green1, blue1; \n                unsigned short difference = 0; \n                unsigned int* pPixel =  reinterpret_cast<unsigned int*>( static_cast<unsigned char*>( pIB->vpData ) + ( ( m_AOIy + line ) * pIB->pChannels[0].iLinePitch ) ) + m_AOIx; \n                for( int pixel = 0; pixel < m_AOIw; pixel++ ) \n                { \n                    GetBGR101010Packed_V2Pixel( *pPixel, red0, green0, blue0 ); \n                    if( pixel < m_AOIw - 1 ) \n                    { \n                        GetBGR101010Packed_V2Pixel( *( pPixel + 1 ), red1, green1, blue1 ); \n                        difference = abs( red0 - red1 ); \n                        m_pHistogramAverage[pChannel0Hor] += difference; \n                        ++m_ppHistogramBuffer[pChannel0Hor][difference]; \n                        difference = abs( green0 - green1 ); \n                        m_pHistogramAverage[pChannel1Hor] += difference; \n                        ++m_ppHistogramBuffer[pChannel1Hor][difference]; \n                        difference = abs( blue0 - blue1 ); \n                        m_pHistogramAverage[pChannel2Hor] += difference; \n                        ++m_ppHistogramBuffer[pChannel2Hor][difference]; \n                    } \n                    if( line < m_AOIh - 1 ) \n                    { \n                        GetBGR101010Packed_V2Pixel( *reinterpret_cast<unsigned int*>( reinterpret_cast<unsigned char*>( pPixel ) + pIB->pChannels[0].iLinePitch ), red1, green1, blue1 ); \n                        difference = abs( red0 - red1 ); \n                        m_pHistogramAverage[pChannel0Ver] += difference; \n                        ++m_ppHistogramBuffer[pChannel0Ver][difference]; \n                        difference = abs( green0 - green1 ); \n                        m_pHistogramAverage[pChannel1Ver] += difference; \n                        ++m_ppHistogramBuffer[pChannel1Ver][difference]; \n                        difference = abs( blue0 - blue1 ); \n                        m_pHistogramAverage[pChannel2Ver] += difference; \n                        ++m_ppHistogramBuffer[pChannel2Ver][difference]; \n                    } \n                    ++pPixel; \n                } \n            }", "pragma": "parallel for ", "hash": "dde7b5580ac39d22d179262fd0e5edd8913616c270f34f35e1fcdfcccfc9a65f"}
{"code": "for(int i = 0; i < nlocal; i++) { \n    neighs = &neighbor.neighbors[i * neighbor.maxneighs]; \n    const int numneighs = neighbor.numneigh[i]; \n    const MMD_float xtmp = x[i * 3 + 0]; \n    const MMD_float ytmp = x[i * 3 + 1]; \n    const MMD_float ztmp = x[i * 3 + 2]; \n    MMD_float fix = 0; \n    MMD_float fiy = 0; \n    MMD_float fiz = 0; \n \n \n \n \n \n \n#pragma simd reduction (+: fix,fiy,fiz,t_eng_vdwl,t_virial) \n \n    for(int k = 0; k < numneighs; k++) { \n      const int j = neighs[k]; \n      const MMD_float delx = xtmp - x[j * 3 + 0]; \n      const MMD_float dely = ytmp - x[j * 3 + 1]; \n      const MMD_float delz = ztmp - x[j * 3 + 2]; \n      const MMD_float rsq = delx * delx + dely * dely + delz * delz; \n      if(rsq < cutforcesq) { \n        const MMD_float sr2 = 1.0 / rsq; \n        const MMD_float sr6 = sr2 * sr2 * sr2 * sigma6; \n        const MMD_float force = 48.0 * sr6 * (sr6 - 0.5) * sr2 * epsilon; \n        fix += delx * force; \n        fiy += dely * force; \n        fiz += delz * force; \n \n        if(EVFLAG) { \n          t_eng_vdwl += sr6 * (sr6 - 1.0) * epsilon; \n          t_virial += (delx * delx + dely * dely + delz * delz) * force; \n        } \n      } \n \n    } \n \n    f[i * 3 + 0] += fix; \n    f[i * 3 + 1] += fiy; \n    f[i * 3 + 2] += fiz; \n \n  }", "pragma": "for ", "hash": "37e93d2fc2433c27af77a13a182120b3ff6542fa8d806f532fe1aa1fe1b3c017"}
{"code": "for(int i = 0; i < mapSize; i++) \n\t{ \n\t\tmCurrentPlan[i] = -1; \n\t}", "pragma": "parallel for ", "hash": "fc6a37e6385bd20559344a9431a481b699f7d1e165b82e28c4353243337bfe7b"}
{"code": "for (int i = 0; i < (int)RHS.size(); i++) \n\t\t\t{ \n\t\t\t\tfloat x[8]; \n\t\t\t\tRHS[i].store(x); \n\t\t\t\tobj->m_rhs[3 * i] = x[0]; \n\t\t\t\tobj->m_rhs[3 * i + 1] = x[1]; \n\t\t\t\tobj->m_rhs[3 * i + 2] = x[2]; \n\t\t\t}", "pragma": "for ", "hash": "d2c7ad244404bd90c48e37209055c3adf29e23daecfc96bcc0b3924f2312c5e0"}
{"code": "for (int i = 0; i < v.size; i++) \n   { \n      v.data[i] = v1.data[i] + v2.data[i]; \n   }", "pragma": "parallel for ", "hash": "98053987f024688ac631dceb5c5b65cdc7a00730ba4b717bcde3c21365ffc628"}
{"code": "for(i=first_weight; i < (int)past_end; i++) \n\t\t\t\t{ \n \n\t\t\t\t\tw = weights[i]; \n \n\t\t\t\t\tfann_type temp_slopes=0.0; \n\t\t\t\t\tunsigned int k; \n\t\t\t\t\tfann_type *train_slopes; \n\t\t\t\t\tfor(k=0;k<threadnumb;++k) \n\t\t\t\t\t{ \n\t\t\t\t\t\ttrain_slopes=ann_vect[k]->train_slopes; \n\t\t\t\t\t\ttemp_slopes+= train_slopes[i]; \n\t\t\t\t\t\ttrain_slopes[i]=0.0; \n\t\t\t\t\t} \n\t\t\t\t\ttemp_slopes+= decay * w; \n \n\t\t\t\t\tconst fann_type prev_step = prev_steps[i]; \n\t\t\t\t\tconst fann_type prev_slope = prev_train_slopes[i]; \n \n\t\t\t\t\tnext_step = 0.0; \n \n \n\t\t\t\t\t \n \n\t\t\t\t\tif(prev_step > 0.001) \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tif(temp_slopes > 0.0)  \n \n\t\t\t\t\t\t\tnext_step += epsilon * temp_slopes; \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tif(temp_slopes > (shrink_factor * prev_slope)) \n\t\t\t\t\t\t\tnext_step += mu * prev_step;\t \n \n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tnext_step += prev_step * temp_slopes / (prev_slope - temp_slopes);\t \n \n\t\t\t\t\t} \n\t\t\t\t\telse if(prev_step < -0.001) \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tif(temp_slopes < 0.0)  \n \n\t\t\t\t\t\t\tnext_step += epsilon * temp_slopes; \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tif(temp_slopes < (shrink_factor * prev_slope)) \n\t\t\t\t\t\t\tnext_step += mu * prev_step;\t \n \n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tnext_step += prev_step * temp_slopes / (prev_slope - temp_slopes);\t \n \n\t\t\t\t\t} \n\t\t\t\t\telse  \n \n\t\t\t\t\t\tnext_step += epsilon * temp_slopes; \n \n\t\t\t\t\t \n \n\t\t\t\t\tprev_steps[i] = next_step; \n\t\t\t\t\tprev_train_slopes[i] = temp_slopes; \n \n\t\t\t\t\tw += next_step; \n \n\t\t\t\t\tif(w > 1500) \n\t\t\t\t\t\tweights[i] = 1500; \n\t\t\t\t\telse if(w < -1500) \n\t\t\t\t\t\tweights[i] = -1500; \n\t\t\t\t\telse \n\t\t\t\t\t\tweights[i] = w; \n\t\t\t\t}", "pragma": "for ", "hash": "07a24b4084183e602c65f66159782e3c198222c5b393dfe8f6239a07084c9891"}
{"code": "for (i = 0; i < size; i++) { \n\t\tsum += values[(size_t)i * inc]; \n\t}", "pragma": "parallel for reduction(+:sum) private(i)", "hash": "11e3a5d41588240a8137e9775a0b2912a2ef29e439e6511b7e1590785d831ad2"}
{"code": "for (intmax_t j = 0; j < (intmax_t) size; ++j)", "pragma": "parallel for ", "hash": "207b46db43b28f8376cc2ea64114be53e61f9456f6e3dd07b37abcda395d8124"}
{"code": "for (int i=0; i<N; i++) { \n \n                        float fProjPixel=(pImg[i]-pDark[i]-pImgBB[i]); \n                        if (fProjPixel<=transmissionTreshold) { \n \n \n                            pImg[i]= defaultdose; \n                            #pragma omp critical \n                            { \n                                negPixelList.push_back(static_cast<size_t>(i)); \n                            } \n                        } \n                        else \n                           pImg[i]=-log(fProjPixel)+log((dose-fdose_ext_slice)<1 ? 1.0f : (dose-fdose_ext_slice));  \n \n                    }", "pragma": "parallel for private( pdark pimgbb)", "hash": "c8e1970073821aed421903eff5c0af80ac8f5ad817801dbc54eaeb52b0198773"}
{"code": "for (SizeT i = 0; i < sz; ++i) { Ty cdata=data[i]-meanl; if (finite(cdata)) skew += (cdata*cdata*cdata)/(var*sdev); }", "pragma": "for reduction(+:skew) ", "hash": "ead91331eb705e1018998ff6b55c84083ad14b3912e2ac5fa57b06d534a3798b"}
{"code": "for (int i = 0; i < 2; ++i) { \n     \n \n     \n \n     \n \n    g = 1; \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n    ^{ \n       \n \n      g = 2; \n       \n \n       \n \n       \n \n       \n \n    }", "pragma": "for private(g)", "hash": "21a6d2fc16b684ac9c779d77cc290155ea5bd819f34d0c62712cd45c239c1f0a"}
{"code": "for (i=0; i<n; i++) \n      printf(\"Thread %d executes loop iteration %d\\n\", \n             omp_get_thread_num(),i);", "pragma": "for ", "hash": "24cd24ecfb403c06c61fd6cee907385d9b1d6a9bb4bc01d5e2d236ab9fd6efb2"}
{"code": "for(i = 0; i < points; i++) \n        { \n            x = (double) rng_doub (1.0); \n            y = (double) rng_doub (1.0); \n             \n            if (x*x + y*y <= 1) \n            {  \n                hit++; \n            }  \n        }", "pragma": "for ", "hash": "4871f01e3600c306a27385d2396050fb185ba7c2ceb1db490d1e157d2699fd05"}
{"code": "for (int i = 0; i < 20; ++i) \n        { \n            report(i); \n        }", "pragma": "for ", "hash": "76a35ad18ddb79072c1e61c760dcc0becea020b9a45eedb2ab8b96a0212be997"}
{"code": "for (int i = 0; i < sz; i++) \n\t\t\t{ \n\t\t\t\t\tdouble r = color_tmp[3 * i + 0] * 255.0; \n\t\t\t\t\tdouble g = color_tmp[3 * i + 1] * 255.0; \n\t\t\t\t\tdouble b = color_tmp[3 * i + 2] * 255.0; \n\t\t\t\t\tcolors->SetComponent(i, 0, r); \n\t\t\t\t\tcolors->SetComponent(i, 1, g); \n\t\t\t\t\tcolors->SetComponent(i, 2, b); \n\t\t\t\t}", "pragma": "parallel for ", "hash": "a53fc202868e01181cd137192a3ccde36829b7e9711cc4ce7e276370b5349325"}
{"code": "for( i = 0; i < n; i++ ) {   \n \n    sum += a[i];               \n \n  }", "pragma": "parallel for reduction(  + : sum) private(  thread)", "hash": "b8ca17e7aa768390fcc3a05d70f8b69a1985a05debc0ae30355d5a343da5c083"}
{"code": "for(int i = 0; i < dOdI.lengthOf(); ++i) { \n        T* currElement = &dOdI(i); \n        if(*currElement != (T)0.) \n            *currElement = 1.; \n    }", "pragma": "parallel for ", "hash": "5f33f2179b9a818a5b941ca9156d67a9def02b92dcf38b7a3ace3f4879d58c98"}
{"code": "for(int ndI=0; ndI<ndList_len;ndI++) \n\t{ \n\t\tLBM_DataHandler fData_l(numSpd);  \n \n\t\tfData_l.u_bc = fData.u_bc; \n\t\tfData_l.rho_bc = fData.rho_bc; \n\t\tfData_l.omega = fData.omega; \n\t\tfData_l.dynamics = fData.dynamics; \n\t\tfData_l.Cs = fData.Cs; \n\t\tfData_l.omegaMRT = fData.omegaMRT; \n\t\t \n \n\t\tint nd = ndList[ndI]; \n\t\t \n \n\t\tset_ndType(nd,fData_l); \n\t\t \n \n\t\tset_fIn(fIn,nd,fData_l); \n\t\t \n \n\t\tcomputeFout(fData_l);  \n \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tif (timeAvg) \n\t\t{ \n\t\t\tuAvg[nd]+=fData_l.ux; \n\t\t\tvAvg[nd]+=fData_l.uy; \n\t\t\twAvg[nd]+=fData_l.uz; \n\t\t\trhoAvg[nd]+=fData_l.rho; \n\t\t} \n         \n         \n \n\t\t \n \n\t\tstreamData(fOut,nd,fData_l); \n \n\t}", "pragma": "parallel for ", "hash": "51a719eb4f5db1302cd9a01e513748ae3ff483e5553e877ba29b70c501c3b329"}
{"code": "for     (ix=0; ix < Nx; ix++) { \n\t    for (iz=0; iz < Nz; iz++) { \n\t\ti = ix * Nz  + iz; \n\t\tj = ix * Nrz + iz; \n                k = iz * Nrx + ix; \n \n                ub[i] = ua[i] +     dt2 * RX[k] + beta[i] * RZ[j]; \n                wb[i] = wa[i] + beta[i] * RX[k] + gama[i] * RZ[j]; \n\t    } \n\t}", "pragma": "parallel for private(i ix iz j k)", "hash": "0d6c5aeb90e77e7a3cecb2c7b13b1efdea89015a0eeac48a2c8c42267f4a94a0"}
{"code": "for ( nb = 0; nb < nblox; nb++ ) \n    { \n      wgp = (double*) malloc(lot*jump*sizeof(double)); \n      istart = istartv[nb]; \n      if ( nb == 0 ) nvex = nvex0; \n      else           nvex = NFFT; \n \n      i = istart; \n#pragma vdir nodep \n      for ( j = 0; j < nvex; j++ ) \n\t{ \n\t  wfc[i+1] = 0.5*wfc[i]; \n\t  i += jump; \n\t} \n      if ( nlon%2 != 1 ) \n\t{ \n\t  i = istart + nlon; \n\t  for ( j = 0; j < nvex; j++ ) \n\t    { \n\t      wfc[i] = 0.5*wfc[i]; \n\t      i += jump; \n\t    } \n\t} \n \n      ia = istart + 1; \n      la = 1; \n      for ( k = 0; k < nfax; ++k ) \n\t{ \n\t  ifac = ifax[k + 1]; \n \n\t  if ( k & 1 ) \n\t    rpassc(wgp, wgp+la, wfc+ia, wfc+ia+ifac*la, trig, \n\t\t   1, 1, nx, jump, nvex, nlon, ifac, la); \n\t  else \n\t    rpassc(wfc+ia, wfc+ia+la, wgp, wgp+ifac*la, trig, \n\t\t   1, 1, jump, nx, nvex, nlon, ifac, la); \n \n\t  la *= ifac; \n\t  ia = istart; \n\t} \n \n       \n \n \n      if ( nfax%2 != 0 ) \n\t{ \n\t  ibase = 0; \n\t  jbase = ia; \n\t  for ( jj = 0; jj < nvex; jj++ ) \n\t    { \n\t      i = ibase; \n\t      j = jbase; \n\t      for ( ii = 0; ii < nlon; ii++ ) \n\t\t{ \n\t\t  wfc[j++] = wgp[i++]; \n\t\t} \n\t      ibase = ibase + nx; \n\t      jbase = jbase + jump; \n\t    } \n\t } \n \n       \n \n \n      ix = istart + nlon; \n#pragma vdir nodep \n      for ( j = 0; j < nvex; j++ ) \n\t{ \n          wfc[ix]   = 0.0; \n          wfc[ix+1] = 0.0; \n          ix = ix + jump; \n\t} \n \n      free(wgp); \n    }", "pragma": "parallel for private(             i ia ibase ifac ii istart ix j jbase jj k la nvex wgp)", "hash": "44babd6b35b0391ffa9a5827a6b38eeaa217a9f49bb1209a197a3fb1d1c42da7"}
{"code": "for (int p = 0; p<nPoints; p++) \n\t\t{ \n\t\t\t \n \n\t\t\tif ( \n\t\t\t\t!FullStep \n\t\t\t\t&& (Class[p] == OldClass[p]) \n\t\t\t\t&& (LogP[p*MaxPossibleClusters + c] - LogP[p*MaxPossibleClusters + Class[p]] > DistThresh) \n\t\t\t\t) \n\t\t\t{ \n#pragma omp atomic \n\t\t\t\tnSkipped++; \n\t\t\t\tcontinue; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif (MinMaskOverlap > 0) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tconst float * __restrict PointMask = &(FloatMasks[p*nDims]); \n\t\t\t\t \n \n\t\t\t\tfloat dotprod = 0.0; \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tconst int NumUnmasked = CurrentCov->NumUnmasked; \n\t\t\t\tif (NumUnmasked) \n\t\t\t\t{ \n\t\t\t\t\tconst int * __restrict cu = &((*(CurrentCov->Unmasked))[0]); \n\t\t\t\t\tfor (int ii = 0; ii < NumUnmasked; ii++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tconst int i = cu[ii]; \n\t\t\t\t\t\tdotprod += PointMask[i]; \n\t\t\t\t\t\tif (dotprod >= MinMaskOverlap) \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\tif (dotprod < MinMaskOverlap) \n\t\t\t\t{ \n#pragma omp atomic \n\t\t\t\t\tnSkipped++; \n\t\t\t\t\tcontinue; \n\t\t\t\t} \n\t\t\t} \n \n \n\t\t\t \n \n\t\t\tfloat Mahal = 0; \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tfloat * __restrict Data_p = &(Data[p*nDims]); \n\t\t\tfloat * __restrict Mean_c = &(Mean[c*nDims]); \n\t\t\tfloat * __restrict v2m = &(Vec2Mean[0]); \n\t\t\tfor (int i = 0; i < nDims; i++) \n\t\t\t\tv2m[i] = Data_p[i] - Mean_c[i]; \n \n\t\t\t \n \n\t\t\tif (UseDistributional) \n\t\t\t\tBPDTriSolve(*CholBPD, Vec2Mean, Root); \n \n\t\t\t \n \n\t\t\tfor (int i = 0; i<nDims; i++) \n\t\t\t\tMahal += Root[i] * Root[i]; \n \n\t\t\t \n \n\t\t\tif (UseDistributional) \n\t\t\t{ \n\t\t\t\tconst float * __restrict icd = &(InvCovDiag[0]); \n\t\t\t\tfloat subMahal = 0.0; \n \n\t\t\t\tconst float * __restrict ctp = &(CorrectionTerm[p*nDims]); \n\t\t\t\tfor (int i = 0; i < nDims; i++) \n\t\t\t\t\tsubMahal += ctp[i] * icd[i]; \n\t\t\t\tMahal += subMahal*correction_factor; \n\t\t\t} \n\t\t\t \n \n\t\t\tLogP[p*MaxPossibleClusters + c] = Mahal / 2 \n\t\t\t\t+ LogRootDet \n\t\t\t\t- log(Weight[c]) \n\t\t\t\t+ (float)(0.5*log(2 * M_PI))*nDims; \n \n\t\t}", "pragma": "parallel for private( root vec2mean)", "hash": "b32da52a4db3f9fe5d2dfc5fadcfc811a36079477e8af6343104a40380ad497e"}
{"code": "for(int x=0; x<Get_NX(); x++) \n\t\t{ \n\t\t\tif( m_pDTM->is_NoData(x, y) ) \n\t\t\t{ \n\t\t\t\tSet_NoData(x, y); \n\t\t\t} \n\t\t\telse switch( Method ) \n\t\t\t{ \n\t\t\tcase 0:\tSet_MaximumSlope (x, y);\tbreak; \n\t\t\tcase 1:\tSet_Tarboton     (x, y);\tbreak; \n\t\t\tcase 2:\tSet_LeastSquare  (x, y);\tbreak; \n\t\t\tcase 3:\tSet_Evans        (x, y);\tbreak; \n\t\t\tcase 4:\tSet_Heerdegen    (x, y);\tbreak; \n\t\t\tcase 5:\tSet_BRM          (x, y);\tbreak; \n\t\t\tcase 6:\tSet_Zevenbergen  (x, y);\tbreak; \n\t\t\tcase 7:\tSet_Haralick     (x, y);\tbreak; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "040edaf2b0da1919d777cebceeb7fb8348d7c7b2841ef6e1ab72a491b6e5a3c0"}
{"code": "for (idx_t i = 0; i < n; i++) { \n        idx_t* idxo = labels + i * k; \n        float* diso = distances + i * k; \n        const idx_t* idxi = base_labels + i * k_base; \n        const float* disi = base_distances + i * k_base; \n \n        heap_heapify<C>(k, diso, idxo, disi, idxi, k); \n        if (k_base != k) {  \n \n            heap_addn<C>(k, diso, idxo, disi + k, idxi + k, k_base - k); \n        } \n        heap_reorder<C>(k, diso, idxo); \n    }", "pragma": "parallel for ", "hash": "0713618a4d55a83f734a309aae6f6e44ce7454fa46f7285bf68577064651c259"}
{"code": "for (size_t i = 0; i < resultDb.getSize(); ++i) { \n            progress.updateProgress(); \n \n            unsigned int key = resultDb.getDbKey(i); \n            char *data = resultDb.getData(i, thread_idx); \n \n            size_t entries = Util::countLines(data, resultDb.getEntryLen(i) - 1); \n            if (entries < (unsigned int) par.minSequences || entries > (unsigned int) par.maxSequences) { \n                continue; \n            } \n \n            size_t entries_num = 0; \n            while (*data != '\\0') { \n                entries_num++; \n                Util::parseKey(data, dbKey); \n                data = Util::skipLine(data); \n \n                const unsigned int memberKey = (unsigned int) strtoul(dbKey, NULL, 10); \n                size_t headerId = headerDb.getId(memberKey); \n                if (headerId == UINT_MAX) { \n                    Debug(Debug::ERROR) << \"Entry \" << key << \" does not contain a sequence!\" << \"\\n\"; \n                    EXIT(EXIT_FAILURE); \n                } \n                size_t seqId = seqDb.getId(memberKey); \n                if (seqId == UINT_MAX) { \n                    Debug(Debug::ERROR) << \"Entry \" << key << \" does not contain a sequence!\" << \"\\n\"; \n                    EXIT(EXIT_FAILURE); \n                } \n                if (entries_num == 1 && par.hhFormat) { \n                    char *header = headerDb.getData(headerId, thread_idx); \n                    size_t headerLen = headerDb.getEntryLen(headerId) - 1; \n                    size_t accessionLen = Util::skipNoneWhitespace(header); \n                    char *sequence = seqDb.getData(headerId, thread_idx); \n                    size_t sequenceLen = seqDb.getEntryLen(headerId) - 1; \n                    result.append(1, '#'); \n                    result.append(header, headerLen); \n                    result.append(1, '>'); \n                    result.append(header, accessionLen); \n                    result.append(\"_consensus\\n\"); \n                    result.append(sequence, seqDb.getEntryLen(headerId) - 1); \n                    result.append(1, '>'); \n                    result.append(header, headerLen); \n                    result.append(sequence, sequenceLen); \n                } else { \n                    result.append(1, '>'); \n                    result.append(headerDb.getData(headerId, thread_idx), headerDb.getEntryLen(headerId) - 1); \n                    result.append(seqDb.getData(headerId, thread_idx), seqDb.getEntryLen(headerId) - 1); \n                } \n            } \n            writer.writeData(result.c_str(), result.length(), key, thread_idx); \n            result.clear(); \n        }", "pragma": "for ", "hash": "e3322da53c4fb81a6fc0503b416de3668bf06f352e9140ae26fb73633e576370"}
{"code": "for(z=0; z<image->nz; z++){ \n                i=z*image->nx*image->ny; \n                for(y=0; y<image->ny; y++){ \n                    for(x=0; x<image->nx; x++){ \n \n                        finalValue=0.0; \n                        currentCoeffSum=0.0; \n \n                        index = i - image->nx*radius[1]; \n                        Y = y - radius[1]; \n \n                         \n \n                        c = (PrecisionTYPE)0; \n                        for(it=0; it<windowSize; it++){ \n                            if(-1<Y && Y<image->ny){ \n                                imageValue = readingValue[index]; \n                                windowValue = window[it]; \n                                temp = (PrecisionTYPE)imageValue * windowValue - c; \n                                t = finalValue + temp; \n                                c = (t - finalValue) - temp; \n                                finalValue = t; \n                            } \n                            else currentCoeffSum += window[it]; \n                            index+=image->nx; \n                            Y++; \n                        } \n                        if(currentCoeffSum!=0) \n                            finalValue *= coeffSum / (coeffSum-currentCoeffSum); \n                        writtingValue[i++] = (DTYPE)finalValue; \n                    } \n                } \n            }", "pragma": "parallel for private(                  c currentcoeffsum finalvalue i imagevalue index it t temp windowvalue x y y z)", "hash": "d9bca8ca9a35af0efc2a8b1e1b543373aa0cb000564dd496e12ce02fcc6cb48d"}
{"code": "for (j = i; \n\t\t    j < i + 1; \n\t\t    j++) \n\t\t{ \n\t\t    for (k = 0; \n\t\t\tk < i; \n\t\t\tk++) \n\t\t    { \n\t\t\tB[i][j] += alpha * A[i][k] * B[j][k]; \n\t\t    } \n\t\t}", "pragma": "parallel for private(k)", "hash": "94b6242a8d8cdc01a06df187264c23a5d1d4c6122fcd2663f6b86e665a6ca76a"}
{"code": "for(idx = 0; idx < count; ++idx) \n  { \n    if(src[idx] > SHRT_MAX) \n    { \n      dst[idx] = SHRT_MAX; \n    } \n    else if(src[idx] < SHRT_MIN) \n    { \n      dst[idx] = SHRT_MIN; \n    } \n    else \n    { \n      dst[idx] = (short )src[idx]; \n    } \n  }", "pragma": "parallel for ", "hash": "b3a05523744ced87b61839b9c2258b0087e0c9d415d9d1b6477cc89a8bb18272"}
{"code": "for ( unsigned int x = 0; x < gm.settings->POPULATION; x ++) { \n\t\t\tif ( populationlist.v.at(x).hasChanged ) { \n\t\t\t\tdouble total_away = 0.0; \n\t\t\t\t \n \n\t\t\t\tfor (unsigned int y = 0; y < gm.fitnessCases->TOTAL_CASES; y++) { \n\t\t\t\t\tdouble score = gm.errorFunction(populationlist.v[x].rpnVecSolveSelf( &gm.fitnessCases->cases[y][0]) - gm.fitnessCases->targets[y]); \n \n\t\t\t\t\tif (scaling) { \n\t\t\t\t\t\tscore *= gm.fitnessCases->multipliers[y]; \n\t\t\t\t\t} \n\t\t\t\t\ttotal_away += score; \n \n\t\t\t\t\tif (gm.settings->USE_CUT_SCORING && cutScore > 0) {  \n \n\t\t\t\t\t\tif (total_away > cutScore) { \n\t\t\t\t\t\t\tmissedCut += 1; \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\tpopulationlist.v.at(x).setScore(total_away); \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "b674a8370b7a56027908c701b55e4e8f2c3cc2b72578f9bfa3adcd1fb0d934d5"}
{"code": "for (j = 0; j < size; j++) \n    for (i = 0; i < size; i++) \n        coeffs[j][i] = (double)((int)(0.5 + coeffs[j][i] / min));", "pragma": "parallel for ", "hash": "502c0b477c0b0c2a5dbd41681a2b93d85378ea847a2621ec26f35bed525b1d44"}
{"code": "for(m = 0; m < this -> rank3; m++) \n                { \n                    #pragma omp parallel for private(n) ordered schedule(dynamic) \n                    for(n = 0; n < this -> rank4; n++) \n                    { \n                        c.data4[i][j][m][n] = this -> data4[i][j][m][n]*b; \n                    } \n                }", "pragma": "parallel for private(m)", "hash": "ae958307013c1dac4320d546b29002336e54eba329833044169ac06c1e5f19b5"}
{"code": "for (i = 0; i < count; i++) { \n                for (n = 0, j = 0; j < m; j++) { \n                for (k = 0; k < m; k++) { \n                        pout = out + d1*i + d2*j + m*k; \n                        pv1  = v1  + d1*i + d2*j + m*k; \n                        pv2  = v2  + d1*i + d2*k + m*j; \n                        for (l = 0; l < m; l++, n++) { \n                                pout[l] = pv1[l] * a + pv2[l] * b; \n                        } \n        } } }", "pragma": "for ", "hash": "2c23de6899b176d15104f201532d93e810af95ffb10a24382b54852280b7ddc6"}
{"code": "for (n = 0; n < nChains; ++n) {\r \n            en[n] = main_func(&U[n*nNodes*nLabels], &E[n*Eoff], &L[n*nNodes], nLabels, nNodes, Eoffset, tmp_buf+m*omp_get_thread_num());\r \n        }", "pragma": "parallel for ", "hash": "e3333986283f9e2dba7c9428f068d37e44fa08331fdc2b3636dbc723e365dffb"}
{"code": "for (int i = 0; i < n; i++) { \n    w[i] = cabs(x[i]); \n  }", "pragma": "parallel for ", "hash": "b2905d7d0478af29fd5a7349ced7012bd29c6cbc01c0e312ecfb7e425ec07561"}
{"code": "for( int i=0;i<static_cast<int>(_weights.size());i++){ \n        _weights[i]->_eta = eta; \n    }", "pragma": "parallel for ", "hash": "c14f24dbd02f18e5aff5008d694829191ff08a6e37538a84f0af80572cf40600"}
{"code": "for (lp=var/10-1; lp<iter; lp++) { \n    buf[lp] += omp_get_thread_num (); \n  }", "pragma": "for ", "hash": "8cc68394ba23d85eb708fd4ed1fbf355547f085f4850ead765c5cb083e8ae040"}
{"code": "for (int i = 0; i < GridSqr; ++i) \n\t{ \n\t\tconst int x = i % GridSize; \n\t\tconst int y = i / GridSize; \n\t\tint R = rand() * (omp_get_thread_num() + 3); \n\t\tbool Result = (R % 100) < Percentage ? true : false; \n\t\tArray[y * GridSize + x] = Result; \n\t}", "pragma": "parallel for ", "hash": "ab410a0f50e592b4c8eb2bcaa6dbb46b85540055e40925661a083c4e36ed93d1"}
{"code": "for (int i = 0; i < length - 1; i++) { \n                        auto val0 = (*input)(i); \n                        auto val1 = (*input)(i + 1); \n                        sum += val0 >= val1 ? (T) -1.f : (T) 0.0f; \n                    }", "pragma": "parallel reduction(sumt:sum) ", "hash": "13d2f9346600057487b865f22b50a947a02bc1502185cedd47335833e510d355"}
{"code": "for (int e = 0; e < bS; ++e) {               \n         \n        int maxStep = maxTimeStep ? (int)(*maxTimeStep)(e) : time; \n         \n         \n \n        for (int t = 0; t < time; ++t) {                                  \n \n            NDArray<T> xt   = (*x)({{t,t+1}, {e,e+1}, {}}, true); \n            NDArray<T> ht   = (*h)({{t,t+1}, {e,e+1}, {}}, true); \n            NDArray<T> ht_1 = (*hFinal)({{e,e+1}, {}}, true);                        \n \n             \n            if(t >= maxStep) { \n                ht = 0.; \n                if(maxStep != 0)                     \n                    ht_1.assign((*h)({{maxStep-1,maxStep}, {e,e+1}, {}})); \n            } \n            else { \n                helpers::rnnCell<T>({&xt, Wx, Wh, b, &ht_1}, &ht); \n                ht_1.assign(ht); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "502720a38a55183ef45146ddf953c6d1666c72c4147ce25386c4343a4960f35d"}
{"code": "for ( tgt_cell_add = 0; tgt_cell_add < tgt_grid_size; ++tgt_cell_add ) \n\t{ \n\t  long num_links = weightlinks[tgt_cell_add].nlinks; \n\t  if ( num_links ) \n\t    { \n\t      long offset    = weightlinks[tgt_cell_add].offset; \n\t      for ( long ilink = 0; ilink < num_links; ++ilink ) \n\t\t{ \n\t\t  rv->src_cell_add[offset+ilink] = weightlinks[tgt_cell_add].addweights[ilink].add; \n\t\t  rv->tgt_cell_add[offset+ilink] = tgt_cell_add; \n\t\t  rv->wts[offset+ilink] = weightlinks[tgt_cell_add].addweights[ilink].weight; \n\t\t} \n\t      free(weightlinks[tgt_cell_add].addweights); \n\t    } \n\t}", "pragma": "parallel for private(tgt_cell_add)", "hash": "bedfa823782fb0ff20c924856c213081c031ab33ebe79fa0c42d537f5a4018ca"}
{"code": "for (int b=start; b<SIZE/TILE_SIZE; b+=jump) { \n\t\tfor (int a=0; a<SIZE/TILE_SIZE; ++a) { \n\t\t \n\t\t\ttypename T::value_type * restrict Aptr = A.get_tile_unitialized(a,b); \n\t\t\ttypename T::value_type * restrict Bptr = B.get_tile_unitialized(a,b); \n\t \n\t\t\tfor (int i=0; i<TILE_SIZE; ++i) { \n\t\t\t\tfor (int j=0; j<TILE_SIZE; ++j) { \n\t\t\t\t\tAptr[i*TILE_SIZE+j] = i; \n\t\t\t\t\tBptr[i*TILE_SIZE+j] = TILE_SIZE-i; \n\t\t\t\t} \n\t\t\t} \n\t \n\t\t\tA.set_tile(Aptr, a, b); \n\t\t\tB.set_tile(Bptr, a, b); \n\t\t \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "1eb07056a0b8660c3568d164d81b124416d33907ca2ce91d489330f88e14eae5"}
{"code": "for (i = 0; i < size; ++i) { \n      libxsmm_dmmdispatch(LIBXSMM_AVG_M, LIBXSMM_AVG_N, LIBXSMM_AVG_K, \n        NULL \n, NULL \n, NULL \n, NULL \n, NULL \n, \n        NULL \n, NULL \n); \n    }", "pragma": "parallel for private(i)", "hash": "da09531d2e372db1a5ebc2c1ce8a403a8cf0284047e4a1edd9fa536e67381aba"}
{"code": "for(int i=0; i<vf.size(); i++) \n        { \n            max_norm = std::max(max_norm, vf[i].squaredNorm()); \n        }", "pragma": "parallel for reduction(: max max_norm) ", "hash": "e21196ff2eaf5ca66222a0719a75f6a1a2381b2104bb2bf999415a05cc27011c"}
{"code": "for (int i = 0; i < lines_to_parse; ++i) \n\t{ \n\t\t \n \n\t\tstd::string line = intermediate[i]; \n \n\t\t \n \n\t\t \n \n\t\tint page_id = atoi(line.c_str()); \n \n\t\t \n \n\t\tline.erase(0, line.find(':') + 1); \n \n\t\tstd::istringstream line_stream(line); \n \n\t\t \n \n\t\tstd::vector<int> links((std::istream_iterator<int>(line_stream)), \n\t\t\t\tstd::istream_iterator<int>()); \n \n\t\ttotal_links += links.size(); \n \n  #pragma omp critical \n\t\tpage_links.insert({page_id, links}); \n\t}", "pragma": "parallel for reduction(+:total_links) ", "hash": "34617568ba0f353732c95cade181ad29e7a17e157bd43e837afce144f460cb2c"}
{"code": "for (int i = 0; i < m_size; ++i) \n\t{\t \n\t\tfloat tMean = (m_tMax[i] + m_tMin[i])/2; \n\t\tfloat srMax = this->MaxSolarRadiation(d, m_latitude[i]); \n \n\t\t \n \n\t\tfloat latentHeat = 2.501f - 0.002361f * tMean; \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tfloat h0 = srMax * 37.59f / 30.0f; \n\t\tfloat petValue = 0.0023f * h0 * pow(m_tMax[i]-m_tMin[i], 0.5f) \n\t\t\t* (tMean + 17.8f) / latentHeat; \n\t\tm_pet[i] = m_petFactor * max(0.0f, petValue); \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t}", "pragma": "parallel for ", "hash": "fc5201e653e1fb80d9de9503dcd54cce9ad5bedac7b2b0a261354bdad4acdc6f"}
{"code": "for(int x=0;x<X;x++) \n       std::fill(NewBuffer[x].begin(),NewBuffer[x].end(),0);", "pragma": "parallel for ", "hash": "6cd883c0cb46afec8ba64c3001d81edd1c34b4e75e6e7e36d96da3534d099773"}
{"code": "for (int i = 0; i < 4; ++i) { \n\t\tstd::multimap<float, int> Q; \n\t\tstd::vector<std::multimap<float, int>::iterator> posInQ(roadmap.size(), Q.end()); \n \n\t\troadmap[i].distToGoal[i] = 0.0f; \n\t\tposInQ[i] = Q.insert(std::make_pair(0.0f, i)); \n \n\t\twhile (!Q.empty()) { \n\t\t\tconst int u = Q.begin()->second; \n\t\t\tQ.erase(Q.begin()); \n\t\t\tposInQ[u] = Q.end(); \n \n\t\t\tfor (int j = 0; j < static_cast<int>(roadmap[u].neighbors.size()); ++j) { \n\t\t\t\tconst int v = roadmap[u].neighbors[j]; \n\t\t\t\tconst float dist_uv = RVO::abs(roadmap[v].position - roadmap[u].position); \n \n\t\t\t\tif (roadmap[v].distToGoal[i] > roadmap[u].distToGoal[i] + dist_uv) { \n\t\t\t\t\troadmap[v].distToGoal[i] = roadmap[u].distToGoal[i] + dist_uv; \n \n\t\t\t\t\tif (posInQ[v] == Q.end()) { \n\t\t\t\t\t\tposInQ[v] = Q.insert(std::make_pair(roadmap[v].distToGoal[i], v)); \n\t\t\t\t\t} \n\t\t\t\t\telse { \n\t\t\t\t\t\tQ.erase(posInQ[v]); \n\t\t\t\t\t\tposInQ[v] = Q.insert(std::make_pair(roadmap[v].distToGoal[i], v)); \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "e918aedf9847bec83c6a6962996620d15f07a12e29cbdad7300b169910ab625f"}
{"code": "for (k = 0; k < NDIM; k++) {                 \n \n        dk = Pos(c)[k] - pmid[k];                \n \n        if (dk < 0)                              \n \n            dk = - dk; \n        if (dk > dmax)                           \n \n            dmax = dk; \n        dk -= ((real) 0.5) * psize;              \n \n        if (dk > 0) \n            dsq += dk * dk;                      \n \n    }", "pragma": "parallel for private(k)", "hash": "05f15bfcdde7385bc33a77557d6d9f519bd27c1cedd128a4b4f1d4ab9574ac2b"}
{"code": "for (int i = 0; i < levels_.size(); ++i) { \n        Convolve(levels_[i], filter, convolutions[i]); \n    }", "pragma": "parallel for ", "hash": "c44a9d0822738262f96405dd5fa2c271bfa7a61260a605817f2dd95b08b463c0"}
{"code": "for (int j=0; j < myLength; j++) { \n        double tmp = from[j]/W[j]; \n        sum += tmp * tmp; \n      }", "pragma": "parallel for reduction(+:sum) ", "hash": "1200934479a9104ae880906243d2fdf2ab1483818e1501345478e96a7a96a9a5"}
{"code": "for(size_t r = 0; r < (size_t)sizeRegistered.height; ++r) \n  { \n    const uint16_t *itD = scaled.ptr<uint16_t>(r); \n    const double y = lookupY.at<double>(0, r); \n    const double *itX = lookupX.ptr<double>(); \n \n    for(size_t c = 0; c < (size_t)sizeRegistered.width; ++c, ++itD, ++itX) \n    { \n      const double depthValue = *itD / 1000.0; \n \n      if(depthValue < zNear || depthValue > zFar) \n      { \n        continue; \n      } \n \n      Eigen::Vector4d pointD(*itX * depthValue, y * depthValue, depthValue, 1); \n      Eigen::Vector4d pointP = proj * pointD; \n \n      const double z = pointP[2]; \n \n      const double invZ = 1 / z; \n      const int xP = (fx * pointP[0]) * invZ + cx; \n      const int yP = (fy * pointP[1]) * invZ + cy; \n \n      if(xP >= 0 && xP < sizeRegistered.width && yP >= 0 && yP < sizeRegistered.height) \n      { \n        const uint16_t z16 = z * 1000; \n        uint16_t &zReg = registered.at<uint16_t>(yP, xP); \n        if(zReg == 0 || z16 < zReg) \n        { \n          zReg = z16; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "02d40d8be1774f5bb53c1d3cec1ebbc8e33d9b4a3e0bad99b67af31007e565e3"}
{"code": "for (int iq = 0; iq < nq_; iq++) { \n\tfor (int idim = 0; idim < NDOF; idim++) { \n\t  h[idim][iq] = f_q_[idim][iq]; \n\t} \n      }", "pragma": "parallel for ", "hash": "4b4e0bca58bbeae53714407ccea4128639b656062eacc77365800edf48f1ec78"}
{"code": "for (index i = 0; i < bq.getDimension(); ++i) {  \n \n\t\t\tbq[i] = q[i] * bFSet[i]; \n\t\t}", "pragma": "parallel for ", "hash": "32b078767a61910b6bb5f51d30491b17d48a9b8c5082488bd6835bfdb8f1f400"}
{"code": "for(long i=0;i<m;i++)\tif(Prm[i].type==4) \n\t\t{ \n\t\t\tmglPnt &q = Pnt[Prm[i].n1]; \n\t\t\tPrm[i].p *=dd; \n\t\t\tq.u *= dd;\tq.v *= dd; \n\t\t}", "pragma": "parallel for ", "hash": "293fcbc5747126c3e146d32631f333dd5cbdcd5e9de54366f6e3b062d3ec0ef9"}
{"code": "for (j = 0; j < n; j++) { \n    yj = y[j]; \n    c1 = Ap[j]; \n    c2 = Ap[j + 1]; \n    for (p = c1; p < c2; p++) { \n      yj += Ax[p] * x[Ai[p]]; \n    } \n    y[j] = yj; \n  }", "pragma": "parallel for private(   c1 c2 p yj)", "hash": "22b2f5a944f0505a7b4603cd6996b6fd28983b5be35b069be165d69debd6a6f9"}
{"code": "for(rocsparse_int j = 0; j < batch_count; j++) \n    { \n        c1[j] = du[j] / d[j]; \n        x1[j] = x[j] / d[j]; \n    }", "pragma": "parallel for ", "hash": "5a856dd005231469626a3ff8d8f5bd7e9fee5f41584e75322c6d7dc9a888f69f"}
{"code": "for (int i=0; i<(int)scene.images.GetSize(); ++i) { \n  #pragma omp flush (bAbort) \n\t\tif (bAbort) \n\t\t\tcontinue; \n\t#else \n\tFOREACH(i, scene.images) { \n\t#endif \n\t\t++progress; \n\t\tMVS::Image& imageData = scene.images[i]; \n\t\tconst PBA::Camera& cameraNVM = cameras[i]; \n\t\tif (cameraNVM.GetMeasurementDistortion() == 0) \n\t\t\tcontinue; \n\t\tif (!imageData.ReloadImage()) { \n\t\t\t#ifdef _USE_OPENMP \n\t\t\tbAbort = true; \n   #pragma omp flush (bAbort) \n\t\t\tcontinue; \n\t\t\t#else \n\t\t\treturn false; \n\t\t\t#endif \n\t\t} \n\t\tMVS::UndistortImage(imageData.camera, cameraNVM.GetNormalizedMeasurementDistortion(), imageData.image, imageData.image); \n\t\tconst String name(pathData + String::FormatString(_T(\"%05u.png\"), i)); \n\t\tUtil::ensureDirectory(name); \n\t\tif (!imageData.image.Save(name)) { \n\t\t\t#ifdef _USE_OPENMP \n\t\t\tbAbort = true; \n   #pragma omp flush (bAbort) \n\t\t\tcontinue; \n\t\t\t#else \n\t\t\treturn false; \n\t\t\t#endif \n\t\t} \n\t\timageData.ReleaseImage(); \n\t}", "pragma": "parallel for ", "hash": "0653356e5431cb613a2b28ef42b26b0cd26cf342ba13b188180854806d41481a"}
{"code": "for (int i = 0; i < n; ++i) \n            sum_deviation += (data[i] - m) * (data[i] - m);", "pragma": "parallel for reduction(+:sum_deviation) ", "hash": "ede63584a84614f2546965eecde483ce1ccd70f3e20ea521d1e79cf73fd6c175"}
{"code": "for (int ii = 0; ii < nn; ++ii) { \n      i = ilist[ii]; \n      if (atom->mask[i] & groupbit) { \n \n         \n \n        Hdia_inv[i] = 1. / eta[atom->type[i]]; \n        b_s[i]      = -chi[atom->type[i]]; \n        if (efield) b_s[i] -= chi_field[i]; \n        b_t[i]      = -1.0; \n \n         \n \n        double tp = 0.0; \n        double sp = 0.0; \n        for (int j=0; j<aspc_order+2; j++) { \n          tp+= aspc_b[j] * t_hist[i][j]; \n          sp+= aspc_b[j] * s_hist[i][j]; \n        } \n \n         \n \n        t[i] = aspc_omega * t_hist[i][0] + m_aspc_omega * tp; \n        s[i] = aspc_omega * s_hist[i][0] + m_aspc_omega * sp; \n      } \n    }", "pragma": "parallel for private(i)", "hash": "b9fe7f903fe47910e99344f40d1ac3ea04f53b35b820b6a7e2aa03e34df1b100"}
{"code": "for (i=0; i<ncols; i++) \n          cscale[i] = (collen[i] > 0 ? log(1.0*nrows/collen[i]) : 0.0);", "pragma": "for ", "hash": "8264e946bd642a50fc84948b5fb42e695fac102e282def69522afeb9f2f0bf31"}
{"code": "for(size_t j = 0; j < rows; ++j) { \n      const float* xRow = x + j * cols; \n      const float* yRow = y + j * cols; \n      const float* adjRow = adj + j * cols; \n      float* gradXRow = gradX + j * cols; \n \n      float sum_x = 0.f; \n      float sum_adj = 0.f; \n      float sum_adj_x = 0.f; \n      float sum_sqr = 0.f; \n \n#pragma omp simd reduction(+ : sum_x, sum_adj_x, sum_adj) \n      for(size_t i = 0; i < cols; ++i) { \n        sum_x += xRow[i]; \n        sum_adj_x += adjRow[i] * (yRow[i] - (beta ? beta[i] : 0.f)) / gamma[i]; \n        sum_adj += adjRow[i]; \n      } \n \n      float mean = sum_x / cols; \n#pragma omp simd reduction(+ : sum_sqr) \n      for(size_t i = 0; i < cols; ++i) { \n        float ex = xRow[i] - mean; \n        sum_sqr += ex * ex; \n      } \n \n      float sigma = std::sqrt(eps + sum_sqr / cols); \n#pragma omp simd \n      for(size_t i = 0; i < cols; ++i) { \n        float grad_x = 0.f; \n        float x_hat = yRow[i] / gamma[i]; \n        grad_x += cols * adjRow[i]; \n        grad_x -= sum_adj; \n        grad_x -= sum_adj_x * x_hat; \n        grad_x /= cols * sigma; \n \n        gradXRow[i] += gamma[i] * grad_x; \n        gradGamma[i] += adjRow[i] * x_hat; \n      } \n    }", "pragma": "parallel for reduction(+ : gradgamma[:cols]) ", "hash": "bd6fd135c5c5e444ea8e4d852a01ff611b989ce1a8380687d8f1d96d3d481e38"}
{"code": "for(unsigned int idx = 0; idx < out.size(); ++idx) \n            out[idx] = c*a.cross(b[idx]);", "pragma": "parallel for ", "hash": "ed0071f4d56136421836103b9dd6fce8931c7a8d82f05bc3a848d7c4999b37b1"}
{"code": "for (size_t i = 0; i < nQueries; ++i) { \n    const Query& query = queries[i]; \n    QueryResult dijkstraResult; \n    const int perfId = logger.beginPerf(); \n    Command::dijkstraQuery(network, &hubs, query.dep, str2time(query.time), \n                           query.dest, &dijkstraResult); \n    const double secondsDijkstra = logger.endPerf(perfId); \n \n    numPathsDi += dijkstraResult.destLabels.size(); \n    numReachedDi += !!dijkstraResult.destLabels.size(); \n    numPathsTp += tpResults[i].size(); \n    numReachedTp += !!tpResults[i].size(); \n \n    vector<QueryResult::Path> dijkstraPaths = \n        dijkstraResult.optimalPaths(network); \n    QueryCompare comparator; \n    comparator.hubs(&hubs); \n    int queryType = comparator.compare(dijkstraPaths, tpResults[i]); \n \n    if (queryType == 0) \n      ++numInvalid; \n    else if (queryType == 1) \n      ++numSubset; \n    else if (queryType == 2) \n      ++numAlmostSubset; \n    else if (queryType == 3) \n      ++numFailed; \n    else if (queryType == 4) \n      ++numTpInvalid; \n \n    stringstream queryStream; \n    queryStream << \"type\" << queryType << \",\" \n                << query.dep << \",\" \n                << query.dest << \",\" \n                << query.time << \",\" \n                << dijkstraPaths.size() << \",\" \n                << labelsToString(dijkstraPaths) << \",\" \n                << tpResults[i].size() << \",\" \n                << labelsToString(tpResults[i]) << \",\" \n                << 1000.*secondsDijkstra << \",\" \n                << 1000.*secondsTP[i] << \",\" \n                << queryGraphSizes[i] \n                << \",\" \n                << \"/route \" << query.dep \n                << \" 01.05.2012 \" \n                << query.time.substr(9, 2) << \":\" \n                << query.time.substr(11, 2) << \":00\" \n                << \" \" << query.dest; \n    const string queryString = queryStream.str(); \n \n    #pragma omp atomic \n    ++progress; \n \n    #pragma omp critical(experiment_log) \n    {   \n \n    expLog.info(queryString); \n    if ((progress + 1) % 10 == 0) \n      serverLog.info(\"%i of %i DI queries done.\", progress, queries.size()); \n    } \n  }", "pragma": "for ", "hash": "fcb7973bdbbc3d49d77cc2f8f50f7be65fe2a1dabc2cb167d5ec1629caac2c2f"}
{"code": "for (idx = 0; idx < vec1size; ++idx) { \n            idx3 = idx * 3; \n            V1 = vec1->VXYZ(idx3); \n            V2 = vec2->VXYZ(idx3); \n            V1.Normalize(); \n            V2.Normalize(); \n            corr_coeff += (V1 * V2); \n          }", "pragma": "for ", "hash": "7e1ea483f68c3b94a8c153ecfa0cde0ec8da0f04e0a5f1c61bb9e3afa07d5b1d"}
{"code": "for (uint64_t edge_idx = 0; edge_idx < sdbg_->size(); ++edge_idx) { \n    if (sdbg_->IsValidEdge(edge_idx) && \n        sdbg_->NextSimplePathEdge(edge_idx) == SDBG::kNullID && \n        locks.try_lock(edge_idx)) { \n      bool will_be_added = true; \n      uint64_t cur_edge = edge_idx; \n      uint64_t prev_edge; \n      int64_t depth = sdbg_->EdgeMultiplicity(edge_idx); \n      uint32_t length = 1; \n \n      while ((prev_edge = sdbg_->PrevSimplePathEdge(cur_edge)) != \n             SDBG::kNullID) { \n        cur_edge = prev_edge; \n        if (!locks.try_lock(cur_edge)) { \n          will_be_added = false; \n          break; \n        } \n        depth += sdbg_->EdgeMultiplicity(cur_edge); \n        ++length; \n      } \n \n      if (!will_be_added) { \n        continue; \n      } \n \n      uint64_t rc_start = sdbg_->EdgeReverseComplement(edge_idx); \n      uint64_t rc_end; \n      assert(rc_start != SDBG::kNullID); \n \n      if (!locks.try_lock(rc_start)) { \n        rc_end = sdbg_->EdgeReverseComplement(cur_edge); \n        if (std::max(edge_idx, cur_edge) < std::max(rc_start, rc_end)) { \n          will_be_added = false; \n        } \n      } else { \n         \n \n        uint64_t rc_cur_edge = rc_start; \n        rc_end = rc_cur_edge; \n        bool extend_full = true; \n        while ((rc_cur_edge = sdbg_->NextSimplePathEdge(rc_cur_edge)) != \n               SDBG::kNullID) { \n          rc_end = rc_cur_edge; \n          if (!locks.try_lock(rc_cur_edge)) { \n            extend_full = false; \n            break; \n          } \n        } \n        if (!extend_full) { \n          rc_end = sdbg_->EdgeReverseComplement(cur_edge); \n          assert(rc_end != SDBG::kNullID); \n        } \n      } \n \n      if (will_be_added) { \n        std::lock_guard<SpinLock> lk(path_lock); \n        vertices_.emplace_back(cur_edge, edge_idx, rc_start, rc_end, depth, \n                               length); \n        count_palindrome += cur_edge == rc_start; \n      } \n    } \n  }", "pragma": "parallel for reduction(+ : count_palindrome) ", "hash": "21cbc3a5543e27d311bb0755d9eada75177c41c57689393260d896f64e06a2cd"}
{"code": "for (size_t i = 0;i < stringSize;i++) \n\t\t\ts += cStr[i];", "pragma": "parallel for ", "hash": "84bbc68e766517dde71120a5674b7621cece5e9181f90c8decb489969bf2ca02"}
{"code": "for (int sp = 0; sp < conf -> nSubpopulations; ++sp) { \n\t\t\tint popIndex = sp * conf -> familySize; \n \n\t\t\tnIndsFronts0[sp] = nonDominationSort(subpops + popIndex, conf -> subpopulationSize, conf); \n\t\t}", "pragma": "parallel for ", "hash": "8d4dd855b07902da8537ce941a1eb2b802facb5850c9d4d86f27b07d55c624bb"}
{"code": "for ( int j=m_shift_y; j<m_dim_y; j++ ) \n      { \n        for ( int i=0; i<m_shift_x; i++ ) \n        { \n          int ij_1 = j+i*m_dim_y; \n          int ij_2 = (j-m_shift_y)+(i+m_shift_x)*m_dim_y; \n \n          if ( (i+j)%2 == 1 ) fak2 = -fak; \n          else fak2 = fak; \n \n          tmp           = data[ij_1][0]; \n          data[ij_1][0] = data[ij_2][0] * fak2; \n          data[ij_2][0] = tmp * fak2; \n \n          tmp           = data[ij_1][1]; \n          data[ij_1][1] = data[ij_2][1] * fak2; \n          data[ij_2][1] = tmp * fak2; \n        } \n      }", "pragma": "for ", "hash": "18dfcbf3a322d265a6ec620d68bc3d9ed56fc127e81b42cb861817a25176f572"}
{"code": "for(k = 0; k < nOutputPlane; k++) \n    { \n       \n \n      real *ptr_gradOutput = gradOutput_data + k*noutSlice; \n      long l; \n      for(l = 0; l < noutSlice; l++) \n        gradBias_data[k] += scale*ptr_gradOutput[l]; \n    }", "pragma": "parallel for private(k)", "hash": "8f8f35fb7e7aad942eae241a7d2214d4c300d859ff820742a785059065411e95"}
{"code": "for(size_t i = 1 ; i < N - 1 ; ++i) \n        { \n            dxdt[i] = coupling_func( x[i+1] - x[i] ) + \n                      coupling_func( x[i-1] - x[i] ); \n        }", "pragma": "parallel for ", "hash": "f776097a308dcbd159c65bedd4a346e90bc8ee08751dd1dec6911b9d1cf5f610"}
{"code": "for (f = 0; f < nfrequency; f++) { \n        int i,j,pol1,pol2; \n\t\tfor (i = 0; i < nstation; i++) { \n\t\t\tfor (j = 0; j <= i; j++) { \n\t\t\t\tint k = f * (nstation + 1) * (nstation / 2) + i * (i + 1) / 2 + j; \n\t\t\t\tfor (pol1 = 0; pol1 < npol; pol1++) { \n\t\t\t\t\tfor (pol2 = 0; pol2 < npol; pol2++) { \n\t\t\t\t\t\tint index = (k * npol + pol1) * npol + pol2; \n\t\t\t\t\t\tmatrix[(((f * nstation + i) * nstation + j) * npol + pol1) * npol + pol2] = packed[index]; \n\t\t\t\t\t\tmatrix[(((f * nstation + j) * nstation + i) * npol + pol2) * npol + pol1] = conjf(packed[index]); \n\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t}", "pragma": "for ", "hash": "40b8a4eb60af274e763b184f5103c3fa16cafeac8c6dfa6a1e7b2380698b61d2"}
{"code": "for (i = 0; i < fa->len; i++) { \n            for (int j = i; j < fb->len; j++) { \n                d[i * fb->len + j] = fvec_dist(fa->x[i], fb->x[j]); \n                d[j * fb->len + i] = d[i * fb->len + j]; \n            } \n \n#pragma omp critical \n            if (verbose > 0) { \n                r += fb->len - i; \n                prog_bar(0, (fa->len * fa->len + fa->len) / 2.0, r); \n            } \n        }", "pragma": "parallel for ", "hash": "2fa888ad860f692eebccc20ae7fe86966d080a1a067ba136ae013dc5bf37e3b8"}
{"code": "for(i=0;i<10000000;i++) \n          {         \n            squares+=(num1[i]-mean)*(num1[i]-mean); \n          }", "pragma": "parallel for reduction(+:squares) private(i)", "hash": "bd0a9fe5c73c4d1ecc1f6c0478b15cba9762e02f45804025ea79e711189e27a6"}
{"code": "for(size_t i=m+1;i<d.n_elem;i++) { \n\t  size_t pii=pi(i); \n\t   \n \n\t  B(m,pii)=A(pii,Aind)/B(m,pim); \n\t   \n \n\t  d(pii)-=B(m,pii)*B(m,pii); \n\t}", "pragma": "parallel for ", "hash": "a83543dec56d92972178a6c42a1364e958bad4c43ca4086a8a85a14698284a1b"}
{"code": "for (int i=0; i<n; i++) w[i] = alpha * x[i] + y[i];", "pragma": "parallel for ", "hash": "3c378f1ce9c1f7458a91851f08ea72f18aaf94fc3904ade1814ce5c8baf9970c"}
{"code": "for (ImpLong j = 0; j < n; j++) { \n                if (data->RT.row_ptr[j+1]!=data->RT.row_ptr[j]) \n                    update(data->RT, j, gamma_w, v, u, param->lambda_i, q[j] ,p); \n            }", "pragma": "parallel for ", "hash": "3b7b2e706eac218b6b0670a96ce92db7ee1043490e72a9f636112a5ca8a26fe5"}
{"code": "for (i = 0; i < num; i++) { \n        pthread_attr_t sattr; \n        r = pthread_attr_init(&sattr); \n        if (r != 0) \n            printf(\"ERROR: failed to init attr %s\\n\", strerror(r)); \n        set_attr(&sattr, stksize); \n        r = pthread_create(&threads[i], &sattr, start_routine, &i); \n        if (r != 0) \n            printf(\"ERROR: failed to create pthread %s\\n\", strerror(r)); \n        pthread_attr_destroy(&sattr); \n    }", "pragma": "parallel for ", "hash": "a1ed319e0523582b86a78a9cae3989a02640fc6bbc466ca1a0c790851ee0283b"}
{"code": "for (int z=0; z<extent.depth; z++) {\r \n\t\tfor (int y=0; y<extent.height; y++) {\r \n\t\t\tfor (int x=0; x<extent.width; x++) {\r \n\t\t\t\th_input[extent.index(x, y, z)] = make_uchar4(x, y, z, x+y+z);\r \n\t\t\t}\r \n\t\t}\r \n\t}", "pragma": "parallel ", "hash": "1a181cfb50d9d56d80ca5b94f8b0e5f1a970d5452d169a1f96be5cb084f4ee53"}
{"code": "for(long i=t->id;i<t->n;i+=mglNumThr)\r \n\t\t{\r \n\t\t\tlong j = (i/nx)%ny;\r \n\t\t\tmreal v = (j>0 && j<ny-1) ? (a[i-nx]+a[i+nx])/2 : NAN;\r \n\t\t\tb[i] = v<a[i]?v:a[i];\r \n\t\t}", "pragma": "parallel ", "hash": "2a71a537d0d7ac3379ddf97528363ea2e0aa5148a868fc9170345b145b7d3f32"}
{"code": "for ( int index = 0; index < static_cast<int>( nCells ); ++index ) \n    { \n        if ( mapCellVisibility.empty() || mapCellVisibility[index] ) \n        { \n            cvf::Vec2ui ij           = ijFromCellIndex( index ); \n            aggregatedResults[index] = calculateValueInMapCell( ij.x(), ij.y(), resultValues ); \n        } \n    }", "pragma": "parallel for ", "hash": "25c1865f6872949d619fb16f563bd008611e21694adebd974766d79080370a45"}
{"code": "for( int icell = 0; icell < geometry->n_cells_total; ++icell ) \n        { \n            for( unsigned int i_pair = 0; i_pair < exchange_pairs.size(); ++i_pair ) \n            { \n                int ispin = exchange_pairs[i_pair].i + icell*geometry->n_cell_atoms; \n                int jspin = idx_from_pair(ispin, boundary_conditions, geometry->n_cells, geometry->n_cell_atoms, geometry->atom_types, exchange_pairs[i_pair]); \n                if( jspin >= 0 ) \n                { \n                    for( int alpha = 0; alpha < 3; ++alpha ) \n                    { \n                        int i = 3 * ispin + alpha; \n                        int j = 3 * jspin + alpha; \n \n                        hessian(i, j) += -exchange_magnitudes[i_pair]; \n                        #ifndef SPIRIT_USE_OPENMP \n                        hessian(j, i) += -exchange_magnitudes[i_pair]; \n                        #endif \n                    } \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "72ebc75d1087695f9cc25a6042c9ffcff4e96fe8695aa9df637f22db3048e928"}
{"code": "for (long j = 1; j <= n; j++) { \n\t\t\tx[j] += ak*p[j]; \n\t\t\tr[j] -= ak*z[j]; \n\t\t\trr[j] -= ak*zz[j]; \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t}", "pragma": "parallel for ", "hash": "e91bf1de46c82b701c585acdf27f4f165e8fcede88a0a00614d80f95bcc323cb"}
{"code": "for ( cid = 0 ; cid < s->nr_marked ; cid++ ) { \n        c = &(s->cells[s->cid_marked[cid]]); \n        if ( !(c->flags & cell_flag_ghost) ) \n            cell_welcome( c , s->partlist ); \n        else { \n            for ( k = 0 ; k < c->incomming_count ; k++ ) \n                e->s.partlist[ c->incomming[k].id ] = NULL; \n            c->incomming_count = 0; \n            } \n        }", "pragma": "parallel for private(c cid k)", "hash": "c15b3f396408ad258584646eb02943648d8737a13df3884a2818213221a70f7d"}
{"code": "for (int i=0; i<N; i++) { \n                    float fProjPixel=pFlat[i]; \n                    if (fProjPixel<=0) \n                        pFlat[i]=0; \n                    else { \n                        if (m_bComputeLogarithm) \n                        { \n                            pFlat[i]=log(fProjPixel)+log(dose); \n                        } \n                        else \n                        { \n                            pFlat[i] = fProjPixel*dose; \n                        } \n                        } \n                }", "pragma": "parallel for ", "hash": "dca363616b30cce6148f1d0f7901cb8e3dd65c4a28a906df0e982fc0082bcccc"}
{"code": "for(unsigned int icx = 0; icx < (VOLUME/2); icx++) { \n    icy = ioff + icx; \n \n    rn_s = l_s + icx; \n    rn_c = l_c + icx; \n    _vector_assign(phi1,(*rn_s).s0); \n \n    w1=&sw_inv_32[icy][0][0]; \n    w2=w1+2;   \n \n    w3=w1+4;   \n \n    w4=w1+6;   \n \n    _su3_multiply(psi, *w1, phi1);  \n    _su3_multiply(chi, *w2, (*rn_s).s1); \n    _vector_add((*rn_s).s0, psi,chi); \n    _su3_multiply(psi, *w4, phi1);  \n    _su3_multiply(chi, *w3, (*rn_s).s1); \n    _vector_add((*rn_s).s1, psi, chi); \n \n    _vector_assign(phi1,(*rn_c).s0); \n \n    _su3_multiply(psi, *w1, phi1);  \n    _su3_multiply(chi, *w2, (*rn_c).s1); \n    _vector_add((*rn_c).s0, psi,chi); \n    _su3_multiply(psi, *w4, phi1);  \n    _su3_multiply(chi, *w3, (*rn_c).s1); \n    _vector_add((*rn_c).s1, psi, chi); \n \n    _vector_assign(phi3,(*rn_s).s2); \n \n    w1++;  \n \n    w2++;  \n \n    w3++;  \n \n    w4++;  \n \n    _su3_multiply(psi, *w1, phi3);  \n    _su3_multiply(chi, *w2, (*rn_s).s3); \n    _vector_add((*rn_s).s2, psi, chi); \n    _su3_multiply(psi, *w4, phi3);  \n    _su3_multiply(chi, *w3, (*rn_s).s3); \n    _vector_add((*rn_s).s3, psi, chi); \n \n    _vector_assign(phi3,(*rn_c).s2); \n \n    _su3_multiply(psi, *w1, phi3);  \n    _su3_multiply(chi, *w2, (*rn_c).s3); \n    _vector_add((*rn_c).s2, psi, chi); \n    _su3_multiply(psi, *w4, phi3);  \n    _su3_multiply(chi, *w3, (*rn_c).s3); \n    _vector_add((*rn_c).s3, psi, chi); \n \n    ++icy; \n \n     \n \n  }", "pragma": "for ", "hash": "79ada71a4d2a146333dc6d3dc7489f10f61e17eb2c53267faae8d8682e9e5e79"}
{"code": "for (y=source->region.y; y < (ssize_t) source->region.height; y++) \n  { \n    const int \n      id = GetOpenMPThreadId(); \n \n    MagickBooleanType \n      sync; \n \n    register const IndexPacket \n      *magick_restrict duplex_indexes, \n      *magick_restrict indexes; \n \n    register const PixelPacket \n      *magick_restrict duplex_pixels, \n      *magick_restrict pixels; \n \n    register IndexPacket \n      *magick_restrict destination_indexes; \n \n    register ssize_t \n      x; \n \n    register PixelPacket \n      *magick_restrict destination_pixels; \n \n    if (status == MagickFalse) \n      continue; \n    pixels=GetCacheViewVirtualPixels(source->view,source->region.x,y, \n      source->region.width,1,source->exception); \n    if (pixels == (const PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(source->view); \n    for (x=0; x < (ssize_t) source->region.width; x++) \n      PixelSetQuantumColor(source->pixel_wands[id][x],pixels+x); \n    if (source_image->colorspace == CMYKColorspace) \n      for (x=0; x < (ssize_t) source->region.width; x++) \n        PixelSetBlackQuantum(source->pixel_wands[id][x], \n          GetPixelIndex(indexes+x)); \n    if (source_image->storage_class == PseudoClass) \n      for (x=0; x < (ssize_t) source->region.width; x++) \n        PixelSetIndex(source->pixel_wands[id][x], \n         GetPixelIndex(indexes+x)); \n    duplex_pixels=GetCacheViewVirtualPixels(duplex->view,duplex->region.x,y, \n      duplex->region.width,1,duplex->exception); \n    if (duplex_pixels == (const PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    duplex_indexes=GetCacheViewVirtualIndexQueue(duplex->view); \n    for (x=0; x < (ssize_t) duplex->region.width; x++) \n      PixelSetQuantumColor(duplex->pixel_wands[id][x],duplex_pixels+x); \n    if (duplex_image->colorspace == CMYKColorspace) \n      for (x=0; x < (ssize_t) duplex->region.width; x++) \n        PixelSetBlackQuantum(duplex->pixel_wands[id][x], \n          GetPixelIndex(duplex_indexes+x)); \n    if (duplex_image->storage_class == PseudoClass) \n      for (x=0; x < (ssize_t) duplex->region.width; x++) \n        PixelSetIndex(duplex->pixel_wands[id][x], \n          GetPixelIndex(duplex_indexes+x)); \n    destination_pixels=GetCacheViewAuthenticPixels(destination->view, \n      destination->region.x,y,destination->region.width,1,exception); \n    if (destination_pixels == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    destination_indexes=GetCacheViewAuthenticIndexQueue(destination->view); \n    for (x=0; x < (ssize_t) destination->region.width; x++) \n      PixelSetQuantumColor(destination->pixel_wands[id][x], \n        destination_pixels+x); \n    if (destination_image->colorspace == CMYKColorspace) \n      for (x=0; x < (ssize_t) destination->region.width; x++) \n        PixelSetBlackQuantum(destination->pixel_wands[id][x], \n          GetPixelIndex(destination_indexes+x)); \n    if (destination_image->storage_class == PseudoClass) \n      for (x=0; x < (ssize_t) destination->region.width; x++) \n        PixelSetIndex(destination->pixel_wands[id][x], \n          GetPixelIndex(destination_indexes+x)); \n    if (transfer(source,duplex,destination,context) == MagickFalse) \n      status=MagickFalse; \n    for (x=0; x < (ssize_t) destination->region.width; x++) \n      PixelGetQuantumColor(destination->pixel_wands[id][x], \n        destination_pixels+x); \n    if (destination_image->colorspace == CMYKColorspace) \n      for (x=0; x < (ssize_t) destination->region.width; x++) \n        SetPixelIndex(destination_indexes+x,PixelGetBlackQuantum( \n          destination->pixel_wands[id][x])); \n    sync=SyncCacheViewAuthenticPixels(destination->view,exception); \n    if (sync == MagickFalse) \n      { \n        InheritException(destination->exception,GetCacheViewException( \n          source->view)); \n        status=MagickFalse; \n      } \n    if (source_image->progress_monitor != (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n  #pragma omp critical (MagickWand_DuplexTransferPixelViewIterator) \n        proceed=SetImageProgress(source_image,DuplexTransferPixelViewTag, \n          progress++,source->region.height); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  }", "pragma": "parallel for ", "hash": "ee84c36fca402b6e91f804aeed5261c5dc67560d0f7189788ca6e45e31f91781"}
{"code": "for (int i = 0; i < (int)numParticles; i++) \n\t\t{ \n\t\t\tif (m_model->getParticleState(i) == ParticleState::Active) \n\t\t\t{ \n\t\t\t\tVector3r& vi = m_model->getVelocity(i); \n\t\t\t\tconst Vector3r new_vi = x.segment<3>(3 * i); \n\t\t\t\tm_vDiff[i] = new_vi - vi; \n\t\t\t\tvi = new_vi; \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "6ea451c50759bb9f04cb4d93f75c7ba5ac8131146ad883950cdae7b27865787b"}
{"code": "for(int j=0;j<ht;j++) for(int i=0;i<wd;i++) \n  { \n    out[4*(j*wd+i)+0] = 100.0f * output[0][(j+max_supp)*w+max_supp+i];  \n \n    out[4*(j*wd+i)+1] = input[4*(j*wd+i)+1];  \n \n    out[4*(j*wd+i)+2] = input[4*(j*wd+i)+2]; \n  }", "pragma": "parallel for ", "hash": "3648023236365dd28608cea9c8b75aed2afdf9a224d39432aa5ee72945b9e957"}
{"code": "for (int i=_N_active; i<_N_real; i++){ \n\t\t\tfor (int j=_N_start; j<_N_active; j++){ \n\t\t\t\tif (_gravity_ignore_10 && i==1 && j==0 ) continue; \n\t\t\t\tconst double dx = particles[i].x - particles[j].x; \n\t\t\t\tconst double dy = particles[i].y - particles[j].y; \n\t\t\t\tconst double dz = particles[i].z - particles[j].z; \n\t\t\t\tconst double r2 = dx*dx + dy*dy + dz*dz + softening2; \n\t\t\t\tconst double r = sqrt(r2); \n\t\t\t\tconst double prefact = -G/(r2*r)*particles[j].m; \n\t\t\t\t \n\t\t\t\tdouble ax = particles[i].ax; \n\t\t\t\tcs[i].x  +=\tprefact*dx;  \n\t\t\t\tparticles[i].ax    = ax + cs[i].x; \n\t\t\t\tcs[i].x  += ax - particles[i].ax;  \n\t\t\t\t \n\t\t\t\tdouble ay = particles[i].ay; \n\t\t\t\tcs[i].y  +=\tprefact*dy;  \n\t\t\t\tparticles[i].ay    = ay + cs[i].y; \n\t\t\t\tcs[i].y  += ay - particles[i].ay;  \n\t\t\t\t \n\t\t\t\tdouble az = particles[i].az; \n\t\t\t\tcs[i].z  +=\tprefact*dz;  \n\t\t\t\tparticles[i].az    = az + cs[i].z; \n\t\t\t\tcs[i].z  += az - particles[i].az;  \n\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "aa917014c44aadf5722266310404eb2f4c12f4d17c938213c2f5d5f44ff7b57e"}
{"code": "for(rocsparse_int i = 0; i < M; i++) \n    { \n        rocsparse_int start = csr_row_ptr_A[i] - base; \n        rocsparse_int end   = csr_row_ptr_A[i + 1] - base; \n        rocsparse_int count = 0; \n \n        for(rocsparse_int j = start; j < end; j++) \n        { \n            if(std::abs(csr_val_A[j]) > std::real(tol) \n               && std::abs(csr_val_A[j]) > std::numeric_limits<float>::min()) \n            { \n                count++; \n            } \n        } \n \n        nnz_per_row[i] = count; \n    }", "pragma": "parallel for ", "hash": "4a65ac7054561149ead6a794f0b7f2e6ef2aa5359f7c640232a8fdfa4c39ee5a"}
{"code": "for (int64_t batchPosNum = 0; batchPosNum < PositionsPerBatch; ++batchPosNum) \n\t\t\t\t{ \n\t\t\t\t\tTrainingGroupInfo group; \n \n\t\t\t\t\tint64_t rootPosIdx = positionDrawFunc(); \n\t\t\t\t\tBoard pos = Board(rootPositions[rootPosIdx]); \n \n\t\t\t\t\tttable.InvalidateAllEntries(); \n \n\t\t\t\t\tif (pos.GetGameStatus() == Board::ONGOING) \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tMoveList ml; \n\t\t\t\t\t\tpos.GenerateAllLegalMoves<Board::ALL>(ml); \n \n\t\t\t\t\t\tauto movePickerDist = std::uniform_int_distribution<size_t>(0, ml.GetSize() - 1); \n \n\t\t\t\t\t\tpos.ApplyMove(ml[movePickerDist(rng)]); \n\t\t\t\t\t} \n \n\t\t\t\t\t \n \n\t\t\t\t\tfor (int64_t moveNum = 0; moveNum < HalfMovesToMake; ++moveNum) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif (pos.GetGameStatus() != Board::ONGOING) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tSearch::SearchResult result = Search::SyncSearchNodeLimited(pos, SearchNodeBudget, &annEvalThread, &gStaticMoveEvaluator, &killer, &ttable, &counter, &history); \n \n\t\t\t\t\t\tBoard leafPos = pos; \n\t\t\t\t\t\tleafPos.ApplyVariation(result.pv); \n \n\t\t\t\t\t\tScore rootScoreWhite = result.score * (pos.GetSideToMove() == WHITE ? 1 : -1); \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tScore leafScore = annEvalThread.EvaluateForWhite(leafPos); \n \n\t\t\t\t\t\tTrainingGroupInfo::PositionType posType; \n \n\t\t\t\t\t\tif (result.pv.size() > 0 && (leafScore == rootScoreWhite)) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tposType = TrainingGroupInfo::PositionType::EVAL; \n\t\t\t\t\t\t} \n\t\t\t\t\t\telse \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tposType = TrainingGroupInfo::PositionType::FIXED; \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tgroup.unscaledScores.push_back(annEvalThread.UnScale(rootScoreWhite)); \n\t\t\t\t\t\tgroup.positionTypes.push_back(posType); \n \n\t\t\t\t\t\tFeaturesConv::ConvertBoardToNN(leafPos, featureConvTemp); \n \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tNNVector featureVector = MapStdVector(featureConvTemp); \n\t\t\t\t\t\t\tgroup.leaves.push_back(std::move(featureVector)); \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tif (posType == TrainingGroupInfo::PositionType::EVAL) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tpos.ApplyMove(result.pv[0]); \n\t\t\t\t\t\t\tkiller.MoveMade(); \n\t\t\t\t\t\t\tttable.AgeTable(); \n\t\t\t\t\t\t\thistory.NotifyMoveMade(); \n\t\t\t\t\t\t} \n\t\t\t\t\t\telse \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n     #pragma omp critical(append_to_training_groups) \n\t\t\t\t\t{ \n\t\t\t\t\t\tassert(group.leaves.size() == group.positionTypes.size()); \n\t\t\t\t\t\tassert(group.leaves.size() == group.unscaledScores.size()); \n \n\t\t\t\t\t\ttrainingGroups.push_back(std::move(group)); \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "for ", "hash": "a6ae95a86cf0c88e81018893748f01dc71240cb48d7e0c1307521eda22381d71"}
{"code": "for(long i=0;i<n;i++) \n\t\t{ \n\t\t\tif(gr->Stop)\tcontinue; \n\t\t\tvv = x->v(i,mx);\tdd = i<nx-1 ? x->v(i+1)-vv : vv-x->v(i-1); \n\t\t\tx1 = vv + dd/2*(dv-gr->BarWidth);\tx2 = x1 + gr->BarWidth*dd; \n\t\t\tx2 = (x2-x1)/m;\t\tx1 += j*x2;\t\tx2 += x1;\tvv = (x2+x1)/2; \n\t\t\tmreal c = sh ? gr->NextColor(pal,i):cc; \n\t\t\tregister long n1,n2; \n \n\t\t\tdd = open->v(i,j); \n\t\t\tn1=gr->AddPnt(mglPoint(x1,dd,zVal),c); \n\t\t\tn2=gr->AddPnt(mglPoint(vv,dd,zVal),c); \n\t\t\tgr->line_plot(n1,n2); \n\t\t\tdd = close->v(i,j); \n\t\t\tn1=gr->AddPnt(mglPoint(vv,dd,zVal),c); \n\t\t\tn2=gr->AddPnt(mglPoint(x2,dd,zVal),c); \n\t\t\tgr->line_plot(n1,n2); \n\t\t\tn1=gr->AddPnt(mglPoint(vv,low->v(i,j),zVal),c); \n\t\t\tn2=gr->AddPnt(mglPoint(vv,high->v(i,j),zVal),c); \n\t\t\tgr->line_plot(n1,n2); \n\t\t}", "pragma": "parallel for private(dd vv x1 x2)", "hash": "c95182203f16080b87481f31f90036fb4228f7757a2ac25a75578e3fe75aad3a"}
{"code": "for (int i = 0; i < num_dense_feature_groups_; ++i) { \n    if (is_feature_group_used[dense_feature_group_map_[i]]) { \n      feature_masks_[i] = 1; \n      ++used_dense_feature_groups; \n    } else { \n      feature_masks_[i] = 0; \n    } \n  }", "pragma": "parallel for reduction(+:used_dense_feature_groups) ", "hash": "4011d732cfdbfc22e2ed32b05c0901086c7cba2d07f0f86fda4a15ad36dc8217"}
{"code": "for(size_t tid=0;tid<omp_p;tid++){ \n          size_t a=((tid+0)*n_src)/omp_p; \n          size_t b=((tid+1)*n_src)/omp_p; \n          for(size_t i=a;i<b;i++){ \n            for(size_t j=0;j<PVFMM_COORD_DIM;j++){ \n              src_coord[i*PVFMM_COORD_DIM+j]=src_pos[i*PVFMM_COORD_DIM+j]*scale_x+shift_x[j]; \n              while(src_coord[i*PVFMM_COORD_DIM+j]< 0.0) src_coord[i*PVFMM_COORD_DIM+j]+=1; \n              while(src_coord[i*PVFMM_COORD_DIM+j]>=1.0) src_coord[i*PVFMM_COORD_DIM+j]-=1; \n            } \n            pt_mid[i]=pvfmm::MortonId(&src_coord[i*PVFMM_COORD_DIM]); \n          } \n          if(src_value.Dim()) for(size_t i=a;i<b;i++){ \n            for(int j=0;j<ker_dim[0];j++){ \n              src_value[i*ker_dim[0]+j]=sl_den[i*ker_dim[0]+j]*src_scal[j]; \n            } \n          } \n          if(surf_value.Dim()) for(size_t i=a;i<b;i++){ \n            for(int j=0;j<ker_dim[0]+PVFMM_COORD_DIM;j++){ \n              surf_value[i*(ker_dim[0]+PVFMM_COORD_DIM)+j]=dl_den[i*(ker_dim[0]+PVFMM_COORD_DIM)+j]*surf_scal[j]; \n            } \n          } \n        }", "pragma": "parallel for ", "hash": "ef6b37d67197f3883b12792d40a6c605164b753560498142ee24584436e9b4de"}
{"code": "for (int m=1; m<imax; m++) \n  { \n    for (int n=1; n<jmax; n++) \n    { \n       \n \n       \n \n      if (elevations[m][n] > -9999) \n      { \n        double local_rainfall_rate =0; \n        double local_time_step=60; \n   \n        old_j_mean_array[m][n] = new_j_mean_array[m][n]; \n        jo_array[m][n] = j_array[m][n]; \n   \n         \n \n         \n \n   \n   \n        if (current_rainGrid.get_rainfall(m, n) > 0) \n        { \n           \n \n           \n \n          local_rainfall_rate = rain_factor * ((current_rainGrid.get_rainfall(m, n) \n              / 1000) / 3600); \n        } \n   \n         \n \n         \n \n        if (local_rainfall_rate == 0) \n        { \n          j_array[m][n] = jo_array[m][n] / (1 + ((jo_array[m][n] * local_time_step) / M)); \n   \n          new_j_mean_array[m][n] = M / local_time_step * \n              std::log(1 + ((jo_array[m][n] * local_time_step) / M)); \n        } \n   \n         \n \n         \n \n        if (local_rainfall_rate > 0) \n        { \n           \n \n           \n          j_array[m][n] = local_rainfall_rate / (((local_rainfall_rate - jo_array[m][n]) / jo_array[m][n]) \n                     * std::exp((0 - local_rainfall_rate) * local_time_step / M) + 1); \n   \n          new_j_mean_array[m][n] = (M / local_time_step) \n                              * std::log(((local_rainfall_rate - jo_array[m][n]) + jo_array[m][n] \n                              * std::exp((local_rainfall_rate *local_time_step) \n                                         / M)) / local_rainfall_rate); \n        } \n   \n         \n \n        if (new_j_mean_array[m][n] < 0) \n        { \n          new_j_mean_array[m][n] = 0; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "e841f3bf77f35c359110ddabc4a4b6def4bccfb4a082aa045592ceeadc03c538"}
{"code": "for(int i=0;i<nth;i++) { \n    p[i].resize(2); \n    p[i][0]=new KDigestor(Pa); \n    p[i][1]=new KDigestor(Pb); \n  }", "pragma": "parallel for ", "hash": "e13a9f699e9992b3197c309f16cd066486306e2e9dba1908020514c824ddfaed"}
{"code": "for (int boxNr = 0; boxNr < numBoxes; boxNr++) {\t\t \n\t\t \n\t\tLogManager *log = LogManager::getSingletonPtr(); \n\t\tBVH *tree;\t\t\t\t \n\t\tVoxelHashTableIterator it;\t\t \n\t\t \n \n\t\tstdext::hash_map<unsigned int, Vertex> vertexMap; \n\t\tTriangle *triangleCache; \n\t\tunsigned int *triangleIndexCache; \n\t\tFILE *triangleFile, *triangleIdxFile; \n\t\tchar output[500]; \n \n\t\t \n \n\t\tit = voxelHashTable->find(boxNr); \n\t\tif (it == voxelHashTable->end()) \n\t\t\tcontinue; \n \n\t\tstdext::hash_map<unsigned int, unsigned int> vertexHash; \n\t\tBufferedOutputs<Vertex> *vert_output = new BufferedOutputs<Vertex>(getVVertexFileName(boxNr).c_str(), 100000); \n\t\tvert_output->clear(); \n \n#pragma omp critical \n\t\t{ \n\t\t\tboxesBuilt++; \n\t\t}\t\t \n\t\tboxesBuilt++; \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tCashedBoxSingleFile<Vertex> *pVertexCache = new CashedBoxSingleFile<Vertex>(getVertexFileName(), numBoxes, 10, false); \n\t\tCashedBoxSingleFile<Vertex> &vertexCache = *pVertexCache; \n \n\t\tunsigned int numTris = it->second;\t\t \n\t\t \n\t\tsprintf(output, \" - Processor %d voxel %d / %d (%u tris)\", omp_get_thread_num(), boxesBuilt, numUsedVoxels, numTris); \n\t\tlog->logMessage(LOG_INFO, output);\t\t \n \n\t\t \n \n\t\tFILE *test = fopen(getBVHFileName(boxNr).c_str(), \"rb\"); \n\t\tif (test != 0) { \n\t\t\tcout << \"   skipping, already built.\" << endl; \n\t\t\tfclose(test); \n\t\t\tcontinue; \n\t\t} \n \n\t\t \n \n\t\t \n \n\t\tif ((triangleFile = fopen(getVTriangleFileName(boxNr).c_str(), \"rb\")) == NULL) { \n\t\t\tcout << \"ERROR: could not open file \" << getVTriangleFileName(boxNr) << \" !\" << endl; \n\t\t\tcontinue; \n\t\t} \n \n\t\tif ((triangleIdxFile = fopen(getTriangleIdxFileName(boxNr).c_str(), \"rb\")) == NULL) { \n\t\t\tcout << \"ERROR: could not open file \" << getTriangleIdxFileName(boxNr) << \" !\" << endl; \n\t\t\tcontinue; \n\t\t}\t\t \n \n\t\ttriangleCache = new Triangle[numTris]; \n\t\ttriangleIndexCache = new unsigned int[numTris]; \n\t\tsize_t ret = fread(triangleCache, sizeof(Triangle), numTris, triangleFile); \n\t\tif (ret != numTris) { \n\t\t\tcout << \"ERROR: could only read \" << ret << \" of \" << numTris << \" triangles from file \" << getVTriangleFileName(boxNr) << \" !\" << endl;\t\t\t \n\t\t\tcontinue; \n\t\t} \n\t\tret = fread(triangleIndexCache, sizeof(unsigned int), numTris, triangleIdxFile); \n\t\tif (ret != numTris) { \n\t\t\tcout << \"ERROR: could only read \" << ret << \" of \" << numTris << \" triangles from file \" << getVTriangleFileName(boxNr) << \" !\" << endl;\t\t\t \n\t\t\tcontinue; \n\t\t} \n \n\t\tfclose(triangleIdxFile); \n\t\tfclose(triangleFile); \n \n\t\tVector3 bb_min, bb_max; \n\t\tbb_min.e[0] = FLT_MAX; \n\t\tbb_min.e[1] = FLT_MAX; \n\t\tbb_min.e[2] = FLT_MAX; \n\t\tbb_max.e[0] = -FLT_MAX; \n\t\tbb_max.e[1] = -FLT_MAX; \n\t\tbb_max.e[2] = -FLT_MAX; \n \n\t\tstdext::hash_map<unsigned int, unsigned int>::iterator it2; \n \n\t\tfor (unsigned int i = 0; i < numTris; i++) {\t\t\t \n\t\t\tfor(int j=0;j<3;j++) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tit2 = vertexHash.find(triangleCache[i].p[j]); \n\t\t\t\tif (it2 == vertexHash.end())  \n\t\t\t\t{ \n\t\t\t\t\tvertexHash.insert(std::pair<unsigned int,unsigned int>(triangleCache[i].p[j], (unsigned int)vertexHash.size())); \n\t\t\t\t\tvert_output->appendElement(vertexCache[triangleCache[i].p[j]]); \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tvertexMap[vertexHash.size() - 1] = vertexCache[triangleCache[i].p[j]]; \n \n\t\t\t\t\tupdateBB(bb_min, bb_max, vertexCache[triangleCache[i].p[j]].v); \n\t\t\t\t\ttriangleCache[i].p[j] = vertexHash.size() - 1; \n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{ \n\t\t\t\t\ttriangleCache[i].p[j] = it2->second; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n \n\t\t \n \n\t\tif ((triangleFile = fopen(getVTriangleFileName(boxNr).c_str(), \"wb\")) == NULL) { \n\t\t\tcout << \"ERROR: could not open file \" << getVTriangleFileName(boxNr) << \" !\" << endl; \n\t\t\tcontinue; \n\t\t} \n \n\t\tret = fwrite(triangleCache, sizeof(Triangle), numTris, triangleFile); \n \n\t\tfclose(triangleFile); \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tfor (unsigned int i = 0; i < numTris; i++) {\t\t\t \n\t\t\tvertexMap[triangleCache[i].p[0]] = vertexCache[triangleCache[i].p[0]]; \n\t\t\tvertexMap[triangleCache[i].p[1]] = vertexCache[triangleCache[i].p[1]]; \n\t\t\tvertexMap[triangleCache[i].p[2]] = vertexCache[triangleCache[i].p[2]]; \n\t\t\tupdateBB(bb_min, bb_max, vertexCache[triangleCache[i].p[0]].v); \n\t\t\tupdateBB(bb_min, bb_max, vertexCache[triangleCache[i].p[1]].v); \n\t\t\tupdateBB(bb_min, bb_max, vertexCache[triangleCache[i].p[2]].v); \n\t\t} \n \n\t\tvoxelMinsTemp[boxNr] = bb_min; \n\t\tvoxelMaxsTemp[boxNr] = bb_max; \n \n\t\t \n \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n \n\t\ttree = new BVH(triangleCache, triangleIndexCache, numTris, &vertexMap, bb_min, bb_max, boxNr, getBVHTestFileName(boxNr).c_str()); \n\t\ttree->buildTreeSAH();\t\t \n\t\ttree->saveToFile(getBVHFileName(boxNr).c_str()); \n\t\ttree->printTree(false); \n\t\t \n\t\tdelete pVertexCache; \n\t\tdelete triangleCache; \n\t\tdelete triangleIndexCache; \n\t\tdelete tree; \n \n\t\tvert_output->flush(); \n\t\tdelete vert_output; \n\t}", "pragma": "parallel for ", "hash": "1a8dbf534dce9b7a583a5ceb07409f7039d0f7b6c4c5886745fa33ac720a2760"}
{"code": "for (int i = 0; i < m; i++) \n      diagptr[i]--;", "pragma": "parallel for ", "hash": "b932db428b4501abd46581955373476a67469841cf0c9788467f373ee163b6b8"}
{"code": "for(int row = 0; row < height; row++) \n        for(int col = 0 + (FC(row, 0, filters) & 1), indx = (row * width + col) >> 1; col < width; \n            col += 2, indx++) \n        { \n          out[row * width + col] = RawDataTmp[indx]; \n        }", "pragma": "for ", "hash": "3b5d78115d47e7cc7518d1025befad4f61060a18b30460ce237eafd5597faf2d"}
{"code": "for( int i=0; i<samples.size(); i++ ) \n\t\tfor( int j=0; j<fids.size(); j++ ) \n\t\t\tr(i,j) = get(samples[i],fids[j]);", "pragma": "parallel for ", "hash": "45f98ffcfddf10593e27dc4fd4e5cdd4657213277a23dd77c36d55cfbaac6e3c"}
{"code": "for(int i = 0; i < N; i++) { \n\t\t\t\t\tp[k+1][i] += beta[l] * p[l][i]; \n\t\t\t\t\tq[k+1][i] += beta[l] * q[l][i]; \n\t\t\t\t}", "pragma": "parallel for simd ", "hash": "cdb370f36464c1b0b1f8930d6c24beabc08bcc705216a9670f14073b4baf7292"}
{"code": "for (int i = 0; i < wb_size; i++) \n      wb_pbo_buf[i] = wptr[i];", "pragma": "parallel for ", "hash": "ea22f88e1a17aaf0e0c8e81394c98272892d1f6c1f6154df23351c035030a7cd"}
{"code": "for(int i = 0; i < np; i++) \n    { \n        double x = c_particle[i*7 + 0];  \n \n        double y = c_particle[i*7 + 1];  \n \n        double px = c_particle[i*7 + 2];  \n \n        double py = c_particle[i*7 + 3];  \n \n        double p = c_particle[i*7 + 4];  \n \n        double s =  c_particle[i*7 + 5];  \n \n        double tau = c_particle[i*7 + 6]; \n \n        double aInitCond[6] = {x*1000,y*1000, s*0., px, py, gamma*(1 + p)}; \n \n        int npoints_traj = NstepMotion*Nsuperperiod - (Nsuperperiod - 1)*(2-bRough); \n        int nstep = npoints_traj*11; \n        double *aMotion = new double [nstep]; \n \n        ret = trajectory(aMagField, colsMF, lenMF, misalign, bRough, aInitCond, undul_param, NstepMotion, Nsuperperiod, aMotion); \n         \n \n         \n \n         \n \n         \n \n \n         \n   c_particle[i*7 + 0] = aMotion[npoints_traj- 1 ]/1000.;  \n \n         \n   c_particle[i*7 + 1] = aMotion[2*npoints_traj - 1]/1000.;  \n \n         \n  c_particle[i*7 + 2] = aMotion[4*npoints_traj  - 1];  \n \n         \n  c_particle[i*7 + 3] = aMotion[5*npoints_traj  - 1];  \n \n         \n   c_particle[i*7 + 4] = p;  \n \n         \n   c_particle[i*7 + 5] = aMotion[3*npoints_traj - 1]/1000.;  \n \n         \n c_particle[i*7 + 6] = tau; \n        delete []aMotion; \n    }", "pragma": "parallel for ", "hash": "5114143cf9f5b05b6aa682d9808ab54dbc952fe572495ae540793bb4d0586970"}
{"code": "for (size_t i=0; i < args.size(); i++) { \n            result[i] = lambda(args[i]); \n        }", "pragma": "parallel for ", "hash": "3f65ed4771b047d6451925b9f6b7e51245fa09391d95ae01bbd0dad0b538e559"}
{"code": "for(long i=0;i<nz;i++)\ta[xx+nx*(yy+i*ny)] = val;", "pragma": "parallel for ", "hash": "4df90f98d1740f317cf64c0807c726cdaf0572ad8f127a4ce0c07aaba8e5fb21"}
{"code": "for (int m=0; m<(int)sqrt(sd); ++m) \n    { \n        for (int n=0; n<(int)sqrt(sd); ++n) \n        { \n            int sdIdx=n+m*(int)sqrt(sd); \n             \n \n \n            long int it=0; \n             \n \n            for (int i=0; i<(N-1); ++i) \n            { \n                for (int j=0; j<(N-1); ++j) \n                { \n                    int idx1 = j+(i)*N; \n                    int idx2 = (j+(i)*N)+1; \n                    int idx3 = j+(i+1)*N; \n                    int idx4 = (j+1)+(i+1)*N; \n \n                     \n \n                     \n \n \n                    AccessIdxs()[sdIdx][it+0]=idx1; \n                    AccessIdxs()[sdIdx][it+1]=idx3; \n                    AccessIdxs()[sdIdx][it+2]=idx2; \n \n                    AccessIdxs()[sdIdx][it+3]=idx2; \n                    AccessIdxs()[sdIdx][it+4]=idx3; \n                    AccessIdxs()[sdIdx][it+5]=idx4; \n \n                    it+=6; \n                } \n            } \n \n             \n \n            for (int i=0; i<N; ++i) \n            { \n                for (int j=0; j<N; ++j) \n                { \n                    int Nidx=j+(i)*N; \n                    int ic=i+(N-1)*m; \n                    int jc=j+(N-1)*n; \n                    int idx1=jc+ic*h; \n                     \n \n                    AccessMeshVerts()[sdIdx][Nidx]=verts[idx1]; \n                } \n            } \n \n             \n \n            double fw=(w-1)*sizeScale;  \n \n            double dx=fw/(double)sqrt(sd);  \n \n \n            double x=n*dx+dx/2.0-(fw/2.0); \n            double y=m*dx+dx/2.0-(fw/2.0); \n \n            AccessPositions()[sdIdx]=glm::vec2(x,y); \n \n             \n \n        } \n         \n \n    }", "pragma": "parallel for private(n sd)", "hash": "6f6194588d1f28bb88bea22a61dec1af96822ba4aa2692c264a00d6131feaae4"}
{"code": "for ( j = 0; j < lj; j++ ) \n  { \n    jw = j * mj; \n    ja  = jw; \n    jb  = ja; \n    jc  = j * mj2; \n    jd  = jc; \n \n    wjw[0] = w[jw*2+0];  \n    wjw[1] = w[jw*2+1]; \n \n    if ( sgn < 0.0 )  \n    { \n      wjw[1] = - wjw[1]; \n    } \n \n    for ( k = 0; k < mj; k++ ) \n    { \n      c[(jc+k)*2+0] = a[(ja+k)*2+0] + b[(jb+k)*2+0]; \n      c[(jc+k)*2+1] = a[(ja+k)*2+1] + b[(jb+k)*2+1]; \n \n      ambr = a[(ja+k)*2+0] - b[(jb+k)*2+0]; \n      ambu = a[(ja+k)*2+1] - b[(jb+k)*2+1]; \n \n      d[(jd+k)*2+0] = wjw[0] * ambr - wjw[1] * ambu; \n      d[(jd+k)*2+1] = wjw[1] * ambr + wjw[0] * ambu; \n    } \n  }", "pragma": "for ", "hash": "b495f3b1ec0b6804f6c9767af5285a8f31e42e99197f338f628e6c045244a589"}
{"code": "for (j = 0; j < i; j++) { \n\tfor (k = 0; k < i; k++) { \n\t    B[i][j] += alpha * A[i][k] * B[j][k]; \n\t} \n    }", "pragma": "parallel for private(k)", "hash": "8485902f758ea7a174727a154aa5e0fd0e34a355d8f71b3e4efff156723c1a92"}
{"code": "for (i = 0; i < 10; i++) \n    { \n      #pragma omp ordered \n\t; \n    }", "pragma": "for ", "hash": "62f16557c97de6b373b8003eabe83a1adc82b845f2eb763e74415b28a7285d84"}
{"code": "for (int i = 0; i < numQueryEntries; i++) { \n\t\tunsigned int *vec = tally + i * segmentSizePow2; \n\t\tunsigned int *cntvec = tallyCnt + i * segmentSizePow2; \n\t\tint prev = vec[0]; \n\t\tint ct = 0; \n\t\tint counter = 0; \n\t\tfor (int j = 1; j < segmentSizePow2; j++) { \n\t\t\tcounter++; \n\t\t\tif (prev != vec[j]) { \n\t\t\t\tvec[ct] = prev; \n\t\t\t\tcntvec[ct] = counter; \n\t\t\t\tprev = vec[j]; \n\t\t\t\tcounter = 0; \n\t\t\t\tct++; \n\t\t\t} \n\t\t} \n\t\tvec[ct] = prev; \n\t\tcntvec[ct] = counter; \n\t\tct++; \n\t\tfor (; ct < segmentSizePow2; ct++) { \n\t\t\tvec[ct] = 0; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "4819b020678f9718d498424935fe111fb48628e19d14c8a020d16cc4ebef7b96"}
{"code": "for(i=0; i<lambda; i++) \n  { \n    indvdl = population->member[i]; \n    fg(indvdl->op, &(indvdl->f), indvdl->g); \n    indvdl->phi = 0.0; \n    for(j=0; j<constraint; j++) \n    { \n      if(indvdl->g[j] > 0.0) \n        indvdl->phi += (indvdl->g[j] * indvdl->g[j]); \n    } \n    population->f[i] = indvdl->f; \n    population->phi[i] = indvdl->phi; \n  }", "pragma": "parallel for ", "hash": "105b1d20322fac19d3b7870abe05bb4313b66b1048d0044237e75b76401ac133"}
{"code": "for(i=0; i<=numObj; i++){ \n          \n \n         for(j=1;j<words;j++){ \n            d[i][j]=0ULL; \n         } \n      }", "pragma": "parallel for ", "hash": "c3cb25b0bd12ddaa4345699d7571e578b141ef7640c1e121984c3fc25044bbfb"}
{"code": "for (int p = 0; p < nrank; p++) \n      if (sendcount[p] > 0) \n      { \n        const int xmin  = tilesBnd[p].x; \n        const int ymin  = tilesBnd[p].y; \n        const int xmax  = tilesBnd[p].z + xmin; \n        const int ymax  = tilesBnd[p].w + ymin; \n        const int displ = senddispl[p] / mpiDataSize; \n         \n \n        for (int j = ymin; j < ymax; j++) \n          for (int i = xmin; i < xmax; i++) \n          { \n            const int iloc = i - wCrd.x; \n            const int jloc = j - wCrd.y; \n            assert(iloc >= 0);  \n            assert(jloc >= 0); \n            assert(iloc < wSize.x); \n            assert(jloc < wSize.y); \n \n            const int idx = jloc*wSize.x + iloc; \n            sendbuf[displ + (j-ymin)*(xmax-xmin)+(i-xmin)] = vec5{{ \n              src[idx].x,src[idx].y,src[idx].z, src[idx].w,  \n                depth[idx]}}; \n          } \n      }", "pragma": "for ", "hash": "f73f31434eb47a7aa8115b506c3f7bcdd3ddf0b0d0238ddc54c3a77c09692433"}
{"code": "for (int o = 0; o < this->orders.size(); ++o) { \n        std::vector<double> flux = source->get_photon_flux(this->sim_wavelength[o]); \n        this->sim_flux[o] = flux; \n        double total_flux = 0.; \n        for (int i = 0; i < flux.size(); ++i) { \n            this->flux_times_efficiency[o][i] = this->sim_flux[o][i] * this->sim_efficiencies[o][i]; \n            total_flux += this->sim_flux[o][i] * this->sim_efficiencies[o][i]; \n        } \n    }", "pragma": "parallel for ", "hash": "a817876d3bef1ed21a4f95657f8d1e9aebb79cd33e348d3dacda17c3ad73b307"}
{"code": "for(unsigned int y=0; y<destHeight; y++)\r \n\t\t\t{\r \n\t\t\t\tfloat color[4];\r \n\t\t\t\tfloat totalColor[4];\r \n\t\t\t\tfloat * pixel = destData + destWidth*y*components;\r \n\t\t\t\r \n\t\t\t\tfor(unsigned int x=0; x<destWidth; x++)\r \n\t\t\t\t{\r \n\t\t\t\t\tunsigned int i;\r \n\t\t\t\t\tMVector2 srcPos, destPos = MVector2((float)x, (float)y);\r \n\t\t\t\t\r \n\t\t\t\t\tfloat score = 0;\r \n\t\t\t\t\tmemset(totalColor, 0, components*sizeof(float));\r \n\t\t\r \n\t\t\t\t\tfloat dx, dy;\r \n\t\t\t\t\tfor(dy=-yFilter; dy<=yFilter; dy+=yFilter)\r \n\t\t\t\t\tfor(dx=-xFilter; dx<=xFilter; dx+=xFilter)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tsrcPos = (destPos + MVector2(dx, dy))*scale;\r \n\t\t\t\t\t\tgetImageSubPixel_float(&copy, srcPos.x-0.5f, srcPos.y-0.5f, color);\r \n\t\t\t\t\t\tfor(i=0; i<components; i++)\r \n\t\t\t\t\t\t\ttotalColor[i] += color[i];\r \n\t\t\t\t\t\tscore++;\r \n\t\t\t\t\t}\r \n\t\t\t\t\t\r \n\t\t\t\t\tfor(i=0; i<components; i++)\r \n\t\t\t\t\t\tpixel[i] = (totalColor[i] / score);\r \n\t\t\t\r \n\t\t\t\t\tpixel += components;\r \n\t\t\t\t}\r \n\t\t\t}", "pragma": "parallel for ", "hash": "19f71e8faa83d6b07a0b8c6a421233cff6ab9b5f7152aaad7cd42e164c190d1c"}
{"code": "for (size_t i = 0; i < resultSize; ++i) { \n                progress.updateProgress(); \n                char *data = resultDbr.getData(i, thread_idx); \n                unsigned int queryKey = resultDbr.getDbKey(i); \n                char queryKeyStr[1024]; \n                char *tmpBuff = Itoa::u32toa_sse2((uint32_t) queryKey, queryKeyStr); \n                *(tmpBuff) = '\\0'; \n                char dbKeyBuffer[255 + 1]; \n                while (*data != '\\0') { \n                    Util::parseKey(data, dbKeyBuffer); \n                    size_t targetKeyLen = strlen(dbKeyBuffer); \n                    char *nextLine = Util::skipLine(data); \n                    size_t oldLineLen = nextLine - data; \n                    size_t newLineLen = oldLineLen; \n                    newLineLen -= (targetKeyLen + 1); \n                     \n \n                    const unsigned int dbKey = (unsigned int) strtoul(dbKeyBuffer, NULL, 10); \n                     \n \n                    size_t offset = __sync_fetch_and_add(&(targetElementSize[dbKey]), newLineLen) - prevBytesToWrite; \n                    if (dbKey >= prevDbKeyToWrite && dbKey <= dbKeyToWrite) { \n                         \n \n                        memcpy(&tmpData[offset], data + (targetKeyLen + 1), oldLineLen - (targetKeyLen + 1)); \n                    } \n                    data = nextLine; \n                } \n            }", "pragma": "for ", "hash": "c188417845a0381f793489e9b254d16718f3e7bf0dba43bf88fb892af6eef136"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tlong k = i*nx;\r \n\t\tb[k] = -(mgl3*a[k]-mgl4*a[k+1]+a[k+2])*dd;\r \n\t\tb[k+nx-1] = (mgl3*a[k+nx-1]-mgl4*a[k+nx-2]+a[k+nx-3])*dd;\r \n\t\tfor(long j=1;j<nx-1;j++)\tb[j+k] = (a[j+k+1]-a[j+k-1])*dd;\r \n\t}", "pragma": "parallel ", "hash": "213ac4bdf59bd33c5f31081f1a18dd7f8f40c1b01cd5f1fa20708d8452724a85"}
{"code": "for (i = 0; i < argc; ++i) \n    si = i + 3;", "pragma": "parallel for simd private(si)", "hash": "a9100cf9add774e4ad66d5815a07b31dbd0c97dfa2fb8b709154eac1cec73c2b"}
{"code": "for (int tid = 0; tid < globals.num_cpu_threads; ++tid) { \n            std::vector<bool> no_in(globals.max_read_length); \n            std::vector<bool> no_out(globals.max_read_length); \n            std::vector<bool> has_solid_kmer(globals.max_read_length); \n \n            uint64_t i = start_idx[tid]; \n \n             \n \n            while (i != end_idx[tid]) { \n                uint64_t read_id = globals.package.get_id(mercy_cand[i] >> 2); \n                assert(!read_marker.get(read_id)); \n                read_marker.set(read_id); \n                int first_0_out = globals.max_read_length + 1; \n                int last_0_in = -1; \n \n                std::fill(no_in.begin(), no_in.end(), false); \n                std::fill(no_out.begin(), no_out.end(), false); \n                std::fill(has_solid_kmer.begin(), has_solid_kmer.end(), false); \n \n                while (i != end_idx[tid] && globals.package.get_id(mercy_cand[i] >> 2) == read_id) { \n                    int offset = (mercy_cand[i] >> 2) - globals.package.get_start_index(read_id); \n                    if ((mercy_cand[i] & 3) == 2) { \n                        no_out[offset] = true; \n                        first_0_out = std::min(first_0_out, offset); \n                    } \n                    else if ((mercy_cand[i] & 3) == 1) { \n                        no_in[offset] = true; \n                        last_0_in = std::max(last_0_in, offset); \n                    } \n \n                    has_solid_kmer[offset] = true; \n                    ++i; \n                } \n \n                if (last_0_in < first_0_out) { \n                    continue; \n                } \n \n                int read_length = globals.package.length(read_id); \n                int last_no_out = -1; \n \n                for (int i = 0; i + globals.kmer_k < read_length; ++i) { \n                    if (globals.is_solid.get(globals.package.get_start_index(read_id) + i)) { \n                        has_solid_kmer[i] = has_solid_kmer[i + 1] = true; \n                    } \n                } \n \n                for (int i = 0; i + globals.kmer_k <= read_length; ++i) { \n                    if (no_in[i] && last_no_out != -1) { \n                        for (int j = last_no_out; j < i; ++j) { \n                            globals.is_solid.set(globals.package.get_start_index(read_id) + j); \n                        } \n \n                        num_mercy += i - last_no_out; \n                    } \n \n                    if (has_solid_kmer[i]) { \n                        last_no_out = -1; \n                    } \n \n                    if (no_out[i]) { \n                        last_no_out = i; \n                    } \n                } \n \n            } \n        }", "pragma": "parallel for reduction(+:num_mercy) ", "hash": "39366a0717264200452aa12a25b659755be81112334e91c83515e36acd5b3fc8"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      a[0] += i; \n      a[1] += 2 * i; \n      a[2] += 3 * i; \n    }", "pragma": "for reduction(+:a[:3]) ", "hash": "0b7ed43597d7c7a388fc3c3c4a54c93c3bc56ac8e0a09dc6da839c40a8dd33f0"}
{"code": "for (int i = 0; i < numHiddenUnits; i++) \n  { \n    x[i] = exp(x[i]) / sum; \n  }", "pragma": "parallel for ", "hash": "3949d8331c8eaa8994ed8fc45f1a9e5a631e2066d01a312bdce2a550fb3a1108"}
{"code": "for(int i=0; i<nImg; i++) \n  { \n    float max = FLT_MIN; \n \n#pragma omp simd \n    for(int fm = 0; fm < nFM; fm++) \n    { \n      output[i][fm] = input[i][fm]; \n      if(input[i][fm] > max) \n        max = input[i][fm]; \n    } \n \n    float sum_of_exp = 0.0; \n#pragma omp simd reduction(+: sum_of_exp) \n    for(int fm = 0; fm < nFM; fm++) \n    { \n      output[i][fm] = output[i][fm] - max; \n      output[i][fm] = exp(output[i][fm]); \n      sum_of_exp += output[i][fm]; \n    } \n \n    float recp_soe = 1.0/sum_of_exp; \n \n     \n \n#pragma omp simd \n    for(int fm = 0; fm < nFM; fm++) \n      output[i][fm] = output[i][fm]*recp_soe; \n  }", "pragma": "parallel for ", "hash": "3ef394dc35c2116b2204536b025797bdb2481c001be9ed20a1a1ab0198618918"}
{"code": "for(size_t ui=0;ui<tagsToClear.size();ui++) \n\t\tnodes[tagsToClear[ui]].tagged=false;", "pragma": "parallel for ", "hash": "8bfb6fc6e617b75cc7c1fbed20020222660c4c45f125acc27bd5f6bf3d402ee2"}
{"code": "for(long k=0;k<n;k++)\tfor(long j=0;j<n;j++)\tfor(long i=0;i<n;i++)\r \n\t{\r \n\t\tdouble x=2*i/(n-1.)-1, y=2*j/(n-1.)-1, z=2*k/(n-1.)-1;\r \n\t\tregister long i0 = i+n*(j+k*n);\r \n \n\r \n \n\r \n\t\tdouble r1 = pow(x*x+y*y+(z-0.3)*(z-0.3)+0.03,1.5);\r \n\t\tdouble r2 = pow(x*x+y*y+(z+0.3)*(z+0.3)+0.03,1.5);\r \n\t\tex->a[i0]=0.2*x/r1 - 0.2*x/r2;\r \n\t\tey->a[i0]=0.2*y/r1 - 0.2*y/r2;\r \n\t\tez->a[i0]=0.2*(z-0.3)/r1 - 0.2*(z+0.3)/r2;\r \n\t}", "pragma": "parallel for ", "hash": "a06389db9003446eb061366e65a36f7f3428f4613f4b9929a41a8268648afc46"}
{"code": "for (int i = 0; i < total_tree; ++i) { \n    output[i] = models_[i]->PredictLeafIndex(value); \n  }", "pragma": "parallel for ", "hash": "23d31b076eb5245fa32fc08245570660ab3c1ab60afbccead237c4f3719d35ef"}
{"code": "for (j=0; j<array_elements; j++) \n    b[j] = scalar*c[j];", "pragma": "parallel for ", "hash": "b5ebd22d90a80e5888bd9fbec1903c50128acda69a392ac2cfe4293270decd3b"}
{"code": "for (int x = 0; x < imagewidth; ++x) { \n              ((uint32*) (raster))[x] = image.at<cv::Vec3b>(y, x)[2] << 16 \n                  | image.at<cv::Vec3b>(y, x)[1] << 8 \n                  | image.at<cv::Vec3b>(y, x)[0] << 0; \n            }", "pragma": "parallel for ", "hash": "b1ec356848440e2b3f5b8f1a0fabdbca28a6112e7c980fa66ca98ddf7b96a1b5"}
{"code": "for(i = 0; i < row_dim; i++) \n\t{ \n\t\t \n \n\t\tvec_b[i] = 0.0; \n\t\trow_index = row_dim * i; \n \n\t\tfor(j = 0; j < col_dim; j++) \n\t\t\tvec_b[i] += mat_a[row_index + j] * vec_x[j]; \n\t}", "pragma": "parallel for private(j)", "hash": "731a7f579e404599d131216a4c2744e21f3c611c3687ee5c5496e38a3a4ab6a1"}
{"code": "for (int ix=0; ix<N; ++ix) { \n        float rx=box.ctr[0]+len*(ix-N/2); \n        int ixp =(ix+1  )%N; \n        int ixm =(ix-1+N)%N; \n        for (int iy=0; iy<N; ++iy) { \n          float ry=box.ctr[1]+len*(iy-N/2); \n          int iyp =(iy+1  )%N; \n          int iym =(iy-1+N)%N; \n          int st  =((ix+iy)%2==rb)?0:1; \n          for (int iz=st; iz<N; iz+=2) { \n            float rz=box.ctr[2]+len*(iz-N/2); \n            float g =beta/(rx*rx+ry*ry+rz*rz+1e-30); \n            int izp=(iz+1  )%N; \n            int izm=(iz-1+N)%N; \n            int ii = N*N*ix+N*iy+iz; \n            v[ii] = h2*f[ii]+ \n                    (1+g*rx*rx)*(v[N*N*ixp+N*iy +iz ]+v[N*N*ixm+N*iy +iz ])+ \n                    (1+g*ry*ry)*(v[N*N*ix +N*iyp+iz ]+v[N*N*ix +N*iym+iz ])+ \n                    (1+g*rz*rz)*(v[N*N*ix +N*iy +izp]+v[N*N*ix +N*iy +izm])+ \n                    (g*rx*ry/2)*(v[N*N*ixp+N*iyp+iz ]+v[N*N*ixm+N*iym+iz ] \n                                -v[N*N*ixm+N*iyp+iz ]-v[N*N*ixp+N*iym+iz ])+ \n                    (g*rx*rz/2)*(v[N*N*ixp+N*iy +izp]+v[N*N*ixm+N*iy +izm] \n                                -v[N*N*ixm+N*iy +izp]-v[N*N*ixp+N*iy +izm])+ \n                    (g*ry*rz/2)*(v[N*N*ix +N*iyp+izp]+v[N*N*ix +N*iym+izm] \n                                -v[N*N*ix +N*iym+izp]-v[N*N*ix +N*iyp+izm]); \n            v[ii]/= 6+2*beta; \n          } \n        } \n      }", "pragma": "parallel for ", "hash": "70a77360ea8cce9ab530fd2d7e600587ec0a57c76e197249ace0c7a57108874c"}
{"code": "for (int i = 0; i < count; i++) \n  { \n    if (map[i] > 1) \n      new_map[i] = (imbyte)255; \n    else if (map[i] < 0) \n      new_map[i] = (imbyte)0; \n    else \n      new_map[i] = (imbyte)(map[i]*255); \n  }", "pragma": "parallel for ", "hash": "db18f7aa2b35732edb11e0d1851da946acc485ed7cbff55bac48350fd076dafc"}
{"code": "for (int i = 0; i < nlocal; i++) { \n      if (mask[i] & groupbit) { \n        v[i].x *= factor_eta; \n        v[i].y *= factor_eta; \n        v[i].z *= factor_eta; \n      } \n    }", "pragma": "parallel for ", "hash": "3806923a76c186f4618ff743ec1280ceaba0588eb5d16fdd6478f2370165f528"}
{"code": "for (size_t i = 0; i < tl; i++) \n      sortedTreeMids[i] = treeMids[treeIdxs[i]];", "pragma": "parallel for ", "hash": "5c8f2d2ffb50b2f5ef87e766024fba88a93c314fd05d085ee4a0579368a04d84"}
{"code": "for ( i = g_id; i < angle_cos_size; i += g_numprocs ) \n    { \n        rep |= angle_cos_calc( F[tid], i, _E ? ES[tid] + ENERGY_ANGLE_COS : _E ); \n    }", "pragma": "for ", "hash": "ff4d752e9f200f2574d17bf20bfbf76ca8213c8e8490dd4aa0fec3fd9500521a"}
{"code": "for (long j = 1; j <= n; j++) bknum = bknum + z[j] * rr[j];", "pragma": "parallel for reduction(+:bknum) ", "hash": "139a0399fc0b1bc2754125c608e2205d541b0bed7bf83c4e52b8b3eb01a47737"}
{"code": "for(size_type job = 0; job < node_ranges.size(); job++) \n  { \n    ProducerBuffer<RankArray> ra(*(mb.ra[job])); \n    for(node_type node = node_ranges[job].first; node <= node_ranges[job].second; node++) \n    { \n      if(!(source.contains(node))) { continue; } \n      mergeRecords(this->record(node), source.record(node), ra, node, this->sequences()); \n    } \n  }", "pragma": "parallel for ", "hash": "2c2f557077cd54f06d49875fa704cea36461d8322a08c8e4f0386f3c9b89d601"}
{"code": "for(int j = 0; j < height; j++) \n  { \n#pragma omp flush (processing) \n    IM_BEGIN_PROCESSING; \n \n    int offset = j * width; \n    int new_offset = offset; \n \n    for(int i = 0; i < width; i++) \n    { \n      int x; \n      imcfloat value = 0; \n \n       \n \n     \n      kernel_line = kernel_map; \n     \n      for(x = -kw2; x <= kw2; x++) \n      { \n        if (i + x < 0)             \n \n          value += new_map[offset - (i + x + 1)] * (float)kernel_line[x+kw2]; \n        else if (i + x >= width)   \n \n          value += new_map[offset + 2*width - 1 - (i + x)] * (float)kernel_line[x+kw2]; \n        else if (offset != -1) \n          value += new_map[offset + (i + x)] * (float)kernel_line[x+kw2]; \n      } \n       \n      value /= (float)totalW; \n \n      aux_line[i] = value; \n    }     \n \n    memcpy(new_map + new_offset, aux_line, width*sizeof(imcfloat)); \n \n    IM_COUNT_PROCESSING; \n#pragma omp flush (processing) \n    IM_END_PROCESSING; \n  }", "pragma": "parallel for ", "hash": "efdb9cc965079432c9663512e99a330cb8ce49620113d5ba256cdd99dc0d84f1"}
{"code": "for (int x = minC[0]; x < maxC[0]; ++x) \n\t\t{ \n\t\t\tfor (int y = minC[1]; y < maxC[1]; ++y) \n\t\t\t{ \n\t\t\t\tfor (int z = minC[2]; z < maxC[2]; ++z) \n\t\t\t\t{ \n\t\t\t\t\tiAVec3d coord(x, y, z); \n\t\t\t\t\t \n \n\t\t\t\t\tconst size_t CornerCount = 8; \n\t\t\t\t\tiAVec3f corners[CornerCount]; \n\t\t\t\t\tcorners[0] = origin + coord * spacing; \n\t\t\t\t\tfor (int i = 0; i < 3; ++i) \n\t\t\t\t\t{ \n\t\t\t\t\t\tiAVec3d tmpcoord(coord); \n\t\t\t\t\t\ttmpcoord[i] += 1; \n\t\t\t\t\t\tcorners[1 + i] = origin + tmpcoord * spacing; \n\t\t\t\t\t\ttmpcoord[(i + 1) % 3] += 1; \n\t\t\t\t\t\tcorners[4 + i] = origin + tmpcoord * spacing; \n\t\t\t\t\t} \n\t\t\t\t\tcorners[7] = origin + (coord + 1) * spacing; \n\t\t\t\t\tbool match = false; \n\t\t\t\t\tfor (size_t c = 0; c < CornerCount; ++c) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif (pointContainedInFiber(corners[c], fiberData)) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tmatch = true; \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t\tif (match) \n\t\t\t\t\t{ \n\t\t\t\t\t\timg->SetScalarComponentFromDouble(x, y, z, 0, img->GetScalarComponentAsDouble(x, y, z, 0) + 1); \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "171a2bfadb0788e82efd31217f69a25d5f4d86c2d19a1be0c6153d49c9daf4c8"}
{"code": "for ( cid = 0 ; cid < e->s.nr_cells ; cid++ ) { \n     \n         \n \n        c = &( e->s.cells[cid] ); \n        count = ind[cid]; \n     \n         \n \n        epot_acc += c->epot; \n             \n         \n \n        for ( k = 0 ; k < c->count ; k++ ) { \n         \n             \n \n            p = &( c->parts[k] ); \n         \n             \n \n            if ( x != NULL ) \n                for ( j = 0 ; j < 3 ; j++ ) \n                    x[count*3+j] = c->origin[j] + p->x[j]; \n            if ( v != NULL) \n                for ( j = 0 ; j < 3 ; j++ ) \n                    v[count*3+j] = p->v[j]; \n            if ( type != NULL ) \n                type[count] = p->type; \n            if ( pid != NULL ) \n                pid[count] = p->id; \n            if ( vid != NULL ) \n                vid[count] = p->vid; \n            if ( q != NULL ) \n                q[count] = p->q; \n            if ( flags != NULL ) \n                flags[count] = p->flags; \n                 \n             \n \n            count += 1; \n                 \n            } \n             \n        }", "pragma": "parallel for reduction(+:epot_acc) private(c cid count j k p)", "hash": "b5850a027d45cb20f67c401a4eacc27a9929bc6fb53b3f19925f2cc10dcc52bc"}
{"code": "for (char i = 0; i < 10; i += '\\1') { \n    c[i] = a[i] + b[i]; \n  }", "pragma": "parallel for simd ", "hash": "84a5917b295c3768b20c626fb95d8f1ca6ba9212852d9c6987c094234067e64d"}
{"code": "for(index irow = 0; irow < mat.nbrows; irow++) \n\t\t{ \n\t\t\txx[irow] = scalar_relax<scalar,index>(mat.vals, mat.bcolind, mat.browptr[irow], \n\t\t\t                                      mat.diagind[irow], mat.browptr[irow+1], \n\t\t\t                                      dblocks[irow], bb[irow], xx, xx); \n\t\t}", "pragma": "for ", "hash": "2d00af6096251b08931033c8f8109cfc1f3502fb18739f5bae69518035b511ef"}
{"code": "for( int i = 0; i < width * width; ++i ){ \n\t\t\t\tint x = i % width - width / 2; \n\t\t\t\tint y = i / width - width / 2; \n\t\t\t\t \n\t\t\t\tDrawLine( \n\t\t\t\t\tx1 + x, y1 + y, \n\t\t\t\t\tx2 + x, y2 + y, \n\t\t\t\t\tyc, uPattern \n\t\t\t\t); \n\t\t\t}", "pragma": "parallel for ", "hash": "e7872fb6cfa029cd51721df1fb85dad0d20bee7add73c80fba48159dd16138e7"}
{"code": "for (int64_t i = 0; i < (int64_t)reads.size(); ++i) \n        { \n            if ((int)reads[i].size() < kmer_size) \n                continue; \n \n            Sequence seq(reads[i]); \n            hash_graph.InsertKmers(seq); \n            sum += seq.size() - kmer_size + 1; \n        }", "pragma": "parallel for ", "hash": "d494a1a19e311d09b7916cf43b387d4fef56130040c0600ab829304d10ab1971"}
{"code": "for (int i = 0; i < segmentManager.Count (); i++) { \n\t\tfor (short j = 0; j < MAX_SIDES_PER_SEGMENT; j++) { \n\t\t\tif (!ShouldProjectFace (i, j)) \n\t\t\t\tcontinue; \n\t\t\tCDoubleVector vSideCenter = segmentManager.Segment (i)->ComputeCenter (j); \n\t\t\tsumDistance += Distance (vSideCenter, ProjectPointOnLine (&m_vCenter, &m_projectOrient.U (), &vSideCenter)); \n\t\t\tcount++; \n\t\t} \n\t}", "pragma": "parallel for reduction( + : count sumdistance) ", "hash": "efaa1633019c3ed8c98dc097e0e580e820a55da9459e0d3fe0a5463465964dd7"}
{"code": "for (idx_t i = 0; i < n; i++) { \n            int64_t list_no = list_nos[i]; \n            if (list_no >= 0) { \n                const float* xi = x + i * d; \n                uint8_t* code = codes + i * (code_size + coarse_size); \n                if (by_residual) { \n                    quantizer->compute_residual(xi, residual.data(), list_no); \n                    xi = residual.data(); \n                } \n                if (coarse_size) { \n                    encode_listno(list_no, code); \n                } \n                squant->encode_vector(xi, code + coarse_size); \n            } \n        }", "pragma": "for ", "hash": "7199ea0a7da712d546d7f9e6ea5998f642e17274f3f231d23a640c0591609e9a"}
{"code": "for (i = 1; i < grid_points[0]-1; i++) { \n    for (j = 3; j < grid_points[1]-3; j++) { \n      for (k = 1; k < grid_points[2]-1; k++) { \n\tfor (m = 0; m < 5; m++) { \n\t  rhs[i][j][k][m] = rhs[i][j][k][m] - dssp *  \n\t    (  u[i][j-2][k][m] - 4.0*u[i][j-1][k][m] +  \n\t       6.0*u[i][j][k][m] - 4.0*u[i][j+1][k][m] +  \n\t       u[i][j+2][k][m] ); \n\t} \n      } \n    } \n  }", "pragma": "for private(j k m)", "hash": "5c29ca6ebc31d6c8329b1594569375c1d73a45a49f3761e135cea1567f3e8e43"}
{"code": "for (int i = 0; i < w*h; i++) \n        reinterpret_cast<float4*>(wptr)[i] = imgGlb[i];", "pragma": "parallel for ", "hash": "da50e46b49be015b46ca49d242a46b6b3339b49d7f58980391e522670efd6b12"}
{"code": "for (i=0; i <= (long) MaxMap; i++) \n      { \n        x_map[i].x=0.299000*i; \n        y_map[i].x=0.587000*i; \n        z_map[i].x=0.114000*i; \n        x_map[i].y=(-0.168736)*i; \n        y_map[i].y=(-0.331264)*i; \n        z_map[i].y=0.500000*i; \n        x_map[i].z=0.500000*i; \n        y_map[i].z=(-0.418688)*i; \n        z_map[i].z=(-0.081312)*i; \n      }", "pragma": "parallel for ", "hash": "dd76ce4b1c7a5275f718ea83329bb675aa796e9a61f339588d1f55a15ac5bb20"}
{"code": "for(y=0;y<p->hlen;y++) { \n\t  EXECUTE(p->instV, &d[p->vlen*2*y], &tBuf[p->vlen*2*y]); \n\t}", "pragma": "parallel for ", "hash": "ccc0a5938d91ab93fa1eac902da087df743555b68bd6fca79579b979158b9dcb"}
{"code": "for (std::size_t i = 0; i < samples; i++) { \n \n        if ( verbose > 2 && !omp_get_thread_num() ) \n            display -> Progress(i, samples, omp_get_num_threads() ); \n \n        for (std::size_t j = 0; j < N; j++) \n        if ( i != j ){ \n \n            double r = (positions[i] - positions[j]).Mag(); \n \n            if ( r < seperations[i] ) \n                seperations[i] = r; \n        } \n    }", "pragma": "parallel for ", "hash": "e88f4a32df79d0440f51d90c8332a50a3df9fb6810c47c503ab4035c733b8045"}
{"code": "for (i = 0; i < matrix_size; ++i) \n\t\t{ \n\t\t\tfor (j = 0; j < matrix_size; ++j) \n\t\t\t{ \n\t\t\t\tC[i][j] = 0.0; \n\t\t\t\tfor (k = 0; k < matrix_size; ++k) \n\t\t\t\t{ \n\t\t\t\t\tC[i][j] = C[i][j] + A[i][k]*B[k][j]; \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "1bee9e3d41ab2954567635b1d3d26667ae2870d556caf010ba4fb7950f1072b0"}
{"code": "for (auto i = 0; i < static_cast<int>(current.point_set.size()); ++i) \n    { \n      const auto& pi = current.point_set[i]; \n \n      const auto ymin = std::max(pi.y() - radius, 0); \n      const auto ymax = std::min(pi.y() + radius, h); \n \n      const auto xmin = std::max(pi.x() - radius, 0); \n      const auto xmax = std::min(pi.x() + radius, w); \n \n      auto num_candidates = 0; \n      for (auto y = ymin; y < ymax; ++y) \n      { \n        for (auto x = xmin; x < xmax; ++x) \n        { \n          const auto j = previous.point_map(x, y); \n          if (j == -1) \n            continue; \n          candidate_matches(num_candidates, i) = j; \n          ++num_candidates; \n \n          if (num_candidates >= max_candidate_number) \n            break; \n        } \n \n        if (num_candidates >= max_candidate_number) \n          break; \n      } \n      num_candidate_matches(i) = num_candidates; \n    }", "pragma": "parallel for ", "hash": "b6d52ac9201d523e75077b074789c9335b72188ad614322a64b8fcfd5e10affa"}
{"code": "for(int i = 0;i < blocks.size();++i) \n      *blocks[i] = a;", "pragma": "parallel for ", "hash": "018e84686218539537008b5ad9d99bad2baafc158317f2adfe30c1e1edd9f42b"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      b[4] += i; \n      b[5] += 2 * i; \n      b[6] += 3 * i; \n    }", "pragma": "for reduction(+:b[4:3]) ", "hash": "09692e25ed01328f4f890799fac2cc9d6941deec6411c071d96f8f0d2cbf11ae"}
{"code": "for(int x=0; x<QDP_sites_on_node; x++) { \n      for(int b=0; b<2; b++) {  \n \n\tint k = (2*x+b)*(QLA_Nc*(2*QLA_Nc+1)); \n\t \n \n\tfor(int i=0; i<2*QLA_Nc; i++) { \n\t  int ic = i/2; \n\t  int is = 2*b + i%2; \n\t  flw->clov[k++] = QLA_real(QLA_elem_P(dp[x], ic, is, ic, is)); \n\t} \n\t \n \n\tfor(int i=0; i<2*QLA_Nc; i++) { \n\t  int ic = i/2; \n\t  int is = 2*b + i%2; \n\t  for(int j=i+1; j<2*QLA_Nc; j++) { \n\t    QLA_Complex z1, z2; \n\t    int jc = j/2; \n\t    int js = 2*b + j%2; \n\t     \n \n\t     \n \n\t    QLA_c_eq_c(z1, QLA_elem_P(dp[x], ic, is, jc, js)); \n\t    QLA_c_peq_ca(z1, QLA_elem_P(dp[x], jc, js, ic, is)); \n\t    QLA_c_eq_r_times_c(z2, 0.5, z1); \n\t    flw->clov[k++] = QLA_real(z2); \n\t    flw->clov[k++] = -QLA_imag(z2);  \n \n\t  } \n\t} \n      } \n    }", "pragma": "parallel for ", "hash": "6cdf156d430f84606d4ebc1640ec634b1399b1d52a694493770e41e010fcce66"}
{"code": "for (i = nlocal; i < nall; ++i) { \n      if (atom->mask[i] & groupbit) b[i] = 0; \n    }", "pragma": "for ", "hash": "5b7482ab15f04f5c19ad5ecfd8af5e4b14a629ae6da666c6ead6b3f29d7df06f"}
{"code": "for (int pi = 0; pi < nParticles; pi++) { \n\t\t\tParticle& p = *particles[pi]; \n\t\t\t \n\t\t\t \n \n\t\t\tNode* n = &grid[p.gi]; \n\t\t\tfloat *px = p.px; \n\t\t\tfloat *py = p.py;  \n\t\t\tfor (int i = 0; i < 3; i++, n += gSizeY_3) { \n\t\t\t\tfloat pxi = px[i]; \n\t\t\t\tfor (int j = 0; j < 3; j++, n++) { \n\t\t\t\t\tfloat pyj = py[j]; \n\t\t\t\t\tfloat phi = pxi * pyj; \n\t\t\t\t\tp.u += phi * n->ax; \n\t\t\t\t\tp.v += phi * n->ay; \n\t\t\t\t} \n\t\t\t} \n\t\t\t \n\t\t\tp.v += mat.gravity; \n\t\t\t \n\t\t\t \n \n\t\t\tn = &grid[p.gi]; \n\t\t\tfor (int i = 0; i < 3; i++, n += gSizeY_3) { \n\t\t\t\tfloat pxi = px[i]; \n\t\t\t\tfor (int j = 0; j < 3; j++, n++) { \n\t\t\t\t\tfloat pyj = py[j]; \n\t\t\t\t\tfloat phi = pxi * pyj; \n\t\t\t\t\tn->u += phi * p.u; \n\t\t\t\t\tn->v += phi * p.v; \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "4853f57a84f8dbc6edee79f4e42309ba2602c1102eb65ab9ffc5b0796fc95285"}
{"code": "for(int iit=0; iit<objects.size(); iit++) { \n     Object **it= &(objects[iit]); \n     (*it)->intProperty[ckey_int]=int((*f)(double((*it)->intProperty[ckey_int]),(*it)->doubleProperty[a1], (*it)->doubleProperty[a2])); \n    }", "pragma": "parallel for ", "hash": "abff12d90b9738e7438bbffba5683d552a9ed0c1dfb54df32228a5aa3f181921"}
{"code": "for (int feature_index = 0; feature_index < num_features_; ++feature_index) { \n    if (!is_feature_aggregated_[feature_index]) continue; \n \n     \n \n    smaller_leaf_histogram_array_[feature_index].FromMemory( \n      output_buffer_.data() + buffer_read_start_pos_[feature_index]); \n \n     \n \n    smaller_leaf_histogram_array_[feature_index].FindBestThreshold( \n      smaller_leaf_splits_->sum_gradients(), \n      smaller_leaf_splits_->sum_hessians(), \n      smaller_leaf_splits_->num_data_in_leaf(), \n      &smaller_leaf_splits_->BestSplitPerFeature()[feature_index]); \n \n     \n \n    if (larger_leaf_splits_ == nullptr || larger_leaf_splits_->LeafIndex() < 0) continue; \n \n     \n \n    larger_leaf_histogram_array_[feature_index].Subtract( \n      smaller_leaf_histogram_array_[feature_index]); \n \n     \n \n    larger_leaf_histogram_array_[feature_index].FindBestThreshold( \n      larger_leaf_splits_->sum_gradients(), \n      larger_leaf_splits_->sum_hessians(), \n      larger_leaf_splits_->num_data_in_leaf(), \n      &larger_leaf_splits_->BestSplitPerFeature()[feature_index]); \n  }", "pragma": "parallel for ", "hash": "8c70e42521dc384ecbc8f90e0935ead295ba48bb02cd28ab4c3c068993b57bde"}
{"code": "for( int i=0;i<max;++i ) { \n    for( int l=0;l<p[0].matrices();++l ) { \n      basics::Field2<basics::Matrix> dest(&temp->X().at(l)[i],&temp->Y().at(l)[i]); \n      m_eval.m_evals[m_division[m_rank].elements[i]]->evaluate(dest,p.at(l)[i]); \n      dest *= m_eval.m_weight[l]*m_eval.m_geometry.m_Lz/2; \n    } \n    applyLocalGlobal(res.X()[i],temp->X()[i],m_eval.m_GLL2G,'N','N'); \n    applyLocalGlobal(res.Y()[i],temp->Y()[i],m_eval.m_GLL2G,'N','N'); \n  }", "pragma": "parallel for ", "hash": "f8ee003304783555b159fed70c94a618635d0eca107decade333e393623622b9"}
{"code": "for (int body_a = 0; body_a < (signed)num_fluid_bodies; body_a++) { \n        real corr = 0; \n        real3 vorticity_grad(0); \n        real3 pos_a = sorted_pos[body_a]; \n        for (int i = 0; i < data_manager->cd_data->c_counts_3dof_3dof[body_a]; i++) { \n            int body_b = data_manager->cd_data->neighbor_3dof_3dof[body_a * ChNarrowphase::max_neighbors + i]; \n            if (body_a == body_b) { \n                continue; \n            } \n            real3 xij = (pos_a - sorted_pos[body_b]); \n \n            real dist = Length(xij); \n            corr += k * Pow(KERNEL(dist, h) / KERNEL(dq, h), n); \n        } \n \n        data_manager->host_data.gamma[start_density + body_a] += corr; \n    }", "pragma": "parallel for ", "hash": "55ffa937abb6a08dc2294db7e3f47e8fbd51fc0f612c08a2b7a6bfe5b85d239b"}
{"code": "for (int y = 0; y < HEIGHT; y++) \n    { \n        fprintf(stdout, \"\\rRendering: %8.2f%%\", (double)y / HEIGHT * 100); \n        for (int x = 0; x < WIDTH; x++) \n        { \n            Vec3 radiance = 0.f; \n            for (int i = 0; i < NUM_SAMPLES; i++) \n            { \n                float dx = (2 * (x + 0.5) / (double)WIDTH - 1) * aspect * scale; \n                float dy = (1 - 2 * (y + 0.5) / (double)HEIGHT) * scale; \n                Vec3 dir = normalize(Vec3(dx + g_uniformRnd(g_rndEngine) / 1000, dy + g_uniformRnd(g_rndEngine) / 1000, -1)); \n                Ray primRay(origin, dir); \n                radiance += Shade(primRay, 0); \n            } \n \n            g_frameBuffer[x + y * WIDTH] = radiance / NUM_SAMPLES; \n        } \n    }", "pragma": "parallel for ", "hash": "b95d6e1cda5b300c138ae41997e38b7a27b1289f67bd91b1f62c1b4c824f6525"}
{"code": "for(i=1; i<Task->n-1; i++) \n            { \n                for(j=1; j<Task->n-1; j++) \n                { \n                    uy[i][j] = (2/h/h*(uy[i-1][j]+uy[i][j-1])-force->U[i][j])/8.*h*h; \n \n                    uxy[i][j] = (7.5*(-uy[i-1][j])/h/h/h \n                            -1.5*(uxy[i-1][j])/h/h \n                            +2.*(uxy[i][j-1])/h/h \n                            -force->dUdx[i][j]) \n                            /(12/h/h+4/h/h); \n                    uyy[i][j] = (7.5*(uy[i][j+1]-uy[i][j-1])/h/h/h \n                            -1.5*(uyy[i][j-1])/h/h \n                            +2.*(uyy[i-1][j])/h/h \n                            -force->dUdy[i][j]) \n                            /(12/h/h+4/h/h); \n                    uxyy[i][j] = (7.5*(uxy[i][j+1]-uxy[i][j-1] \n                            +uyy[i+1][j]-uyy[i-1][j])/h/h/h \n                            -1.5*(uxyy[i][j-1] \n                            +uxyy[i-1][j])/h/h \n                            -force->dUdxdy[i][j] \n                            )/24*h*h; \n                } \n            }", "pragma": "parallel for private(i j)", "hash": "073016e1ab9ad5029e11bce8efafa450a8691dbd3392bbc7efb6c21b1646f17f"}
{"code": "for (i = 0; i < sol->ko_ld->num_keys; i++) { \n                    key = sol->ko_ld->keys[i]; \n                    assert(from_key_ko(sol, s, key, j)); \n                    light_value new_v = negamax_node(sol, s, key, j, 1); \n                    assert(new_v.low >= sol->ko_nodes[j][i].low); \n                    assert(new_v.high <= sol->ko_nodes[j][i].high); \n                    changed = changed || !equal_light(sol->ko_nodes[j][i], new_v); \n                    sol->ko_nodes[j][i] = new_v; \n                }", "pragma": "for ", "hash": "08352a48d4500806b37f63c24431e43b49eb02e2dca3afd891cc6d1b7ca377ad"}
{"code": "for(int y=0; y<height; y++) \n\t\t\t{ \n\t\t\t\tfor(int x=0; x<width; x++) \n\t\t\t\t{ \n\t\t\t\t\tHistogram h(truncate,mode); \n \n\t\t\t\t\tfor(int j=0,idx=0; j<2*r+1; j++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tfor(int i=0; i<2*r+1; i++,idx++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tfloat addval = 1.f; \n\t\t\t\t\t\t\th.add(addval, src2.at<uchar>(y+j,x+i), metric); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t\tdst.at<uchar>(y,x) = h.returnVal(); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "f4777456956011828e13c23d3a5a99164821c21eb59bead35066564f10b9d115"}
{"code": "for (node u = 0; u < n; ++u) { \n\t\taugmentedGraph.forNodes([&](node v) { \n\t\t\tif (u == v) return; \n\t\t\tdouble dist = std::max(this->vertexCoordinates[u].distance(this->vertexCoordinates[v]), 1e-5); \n\t\t\tentropy += (fabs(q) < 0.001)? log(dist) : pow(dist, -q); \n\t\t}); \n\t}", "pragma": "parallel for reduction(+:entropy) ", "hash": "b051a8de735bdf61f6950ae60bca96ff3ae67310afcc0f30a2f343984c0f6761"}
{"code": "for (a=0; a<layer1_size; a++) \n            {    \n                if (neu1[a].ac>10) neu1[a].ac=10;   \n                if (neu1[a].ac<0) neu1[a].ac=0;   \n            }", "pragma": "parallel for ", "hash": "dc27e0087649845be078f8da23bc478fc9adc87abe0682144c584a51b7b2593c"}
{"code": "for (GoodIter I = begin; I - I; ++I) \n    ++I;", "pragma": "for simd ", "hash": "799379bfc2944f1faeb76eed2baa2af4fdbf6032ace1f81f51bc0e9d27fb588c"}
{"code": "for ( j=0; j<nscol; j++ ) { \n                for ( i=j*L_ENTRY; i<nsrow*L_ENTRY; i++ ) { \n                    iidx = j*nsrow*L_ENTRY+i; \n                    Lx[psx*L_ENTRY+iidx] -= gpu_p->h_Lx[iHostBuff2][iidx]; \n                } \n            }", "pragma": "parallel for private(iidx)", "hash": "e111f0e894d17c40c099efaa7fbe6d2ed4d60bbaf6459f90608e652fd5370a0f"}
{"code": "for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i + 1][j][k][n]; \n                    } \n                } \n            } \n        }", "pragma": "for ", "hash": "febe809ce9660384de860309270dc4ad64b945b7deafe1e1a8c86d220bd7b30f"}
{"code": "for (int j = 0; j < row; j++) \n\t{ \n\t\tuint8_t* sp1; \n\t\tuint8_t* sp2; \n\t\tuint32_t* dp; \n \n\t\tfor (int k = 0; k < cn; k++) \n\t\t{ \n\t\t\tsp1 = src.ptr<uint8_t>(j) + k; \n\t\t\tsp2 = src.ptr<uint8_t>(j) + k + cn; \n\t\t\tdp = dest.ptr<uint32_t>(j) + k; \n \n\t\t\tuint32_t sum = 0; \n \n\t\t\tsum += *sp1 * (r + 1); \n\t\t\tfor (int i = 1; i <= r; i++) \n\t\t\t{ \n\t\t\t\tsum += *sp2; \n\t\t\t\tsp2 += cn; \n\t\t\t} \n\t\t\t*dp = sum; \n\t\t\tdp += cn; \n \n\t\t\tfor (int i = 1; i <= r; i++) \n\t\t\t{ \n\t\t\t\tsum += *sp2 - *sp1; \n\t\t\t\tsp2 += cn; \n \n\t\t\t\t*dp = sum; \n\t\t\t\tdp += cn; \n\t\t\t} \n\t\t\tfor (int i = r + 1; i < col - r - 1; i++) \n\t\t\t{ \n\t\t\t\tsum += *sp2 - *sp1; \n\t\t\t\tsp1 += cn; \n\t\t\t\tsp2 += cn; \n \n\t\t\t\t*dp = sum; \n\t\t\t\tdp += cn; \n\t\t\t} \n\t\t\tfor (int i = col - r - 1; i < col; i++) \n\t\t\t{ \n\t\t\t\tsum += *sp2 - *sp1; \n\t\t\t\tsp1 += cn; \n \n\t\t\t\t*dp = sum; \n\t\t\t\tdp += cn; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "a22f71c5bffd0adae25ef9af5d69a9458851711874680299efda4d15b3fc24e1"}
{"code": "for (uintx i = 0; i < len; ++i) { \n\t\t\tValue transformed = snow::call(NULL, closure, (*array)[i], value((intx)i)); \n\t\t\t(*result)[i] = transformed.value(); \n\t\t}", "pragma": "parallel for ", "hash": "193b024563a3156e7427204248eab34adf19bd168434dd19c93ba2cc9aa6d16d"}
{"code": "for(countView=0;countView<V.size();countView++)\r \n\t\t\tV[countView]->grabFrame(frameIndex);", "pragma": "for ", "hash": "48c1f6e77fa51b49c36b8bf3cd3cff4fe75b892a9b0414ca171dba36bab4b276"}
{"code": "for( int i=0;i<max;++i ) { \n    for( int l=0;l<res[i].matrices();++l ) { \n      basics::multPointwise(res[i][l],p[i][l],(*m_invEval.m_iJ)[m_division[m_rank].elements[i]]); \n      res[i][l] *= Real(1)/(m_eval.m_weight[l]*m_eval.m_geometry.m_Lz/2); \n    } \n  }", "pragma": "parallel for ", "hash": "2d153676e7785e69b6ee9ad778090e765757f8bdbadd200def44e05d440113b1"}
{"code": "for(int y = 0; y < nY; y++) { \n            for(int x = 0; x < nX; x++) { \n               for(int e = 0; e < nEns; e++) { \n                  if(Util::isValid(temperature(y, x, e)) && Util::isValid(dewpoint(y, x, e))) \n                     output(y, x, e) = computeRh(temperature(y, x, e), dewpoint(y, x, e)); \n               } \n            } \n         }", "pragma": "parallel for ", "hash": "d73f99245971438d80a1921587c3a2c52c0f98a40d1c6916635c7f0200063f55"}
{"code": "for (i = 0; i < size; i++) \n      y_data[i] *= alpha;", "pragma": "parallel for private(i)", "hash": "b9b8e64a21d6deebd0b503bcceb7aeadc6f67b6577733f0ae0be027be9ae2076"}
{"code": "for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p3 = i * 10000 + j * 100 + k;", "pragma": "parallel for private(conditional: p3)", "hash": "345d91cf3705439bef49f25292099e38350c0a3dd1ed692a8481dfdeb5c6f727"}
{"code": "for (j = 0; j < system->N; ++j) { \n        start_j = Start_Index(j, bonds); \n        end_j = End_Index(j, bonds); \n \n        for (pk = start_j; pk < end_j; ++pk) { \n          bo_jk = &(bonds->select.bond_list[pk].bo_data); \n          for (k = 0; k < nthreads; ++k) \n            bo_jk->CdboReduction[k] = 0.; \n        } \n      }", "pragma": "for ", "hash": "6237da3f5683c68867c97ae6dea5958c9124a3deb489facbd5da0de543fde9d4"}
{"code": "for (int m = 0; m < Nm; m++) { \n    for (int g = 0; g < Ng; g++) { \n      for (int l = 0; l < Nl; l++) { \n        for (int k = 0; k < Nk; k++) { \n          for (int j = 0; j < Nj; j++) { \n            double total = 0.0; \n            _mm_prefetch((const char*) (&q[m][g][l][k][j][0] + 32*VLEN), _MM_HINT_T1); \n            #pragma vector nontemporal(r) \n            #pragma omp simd reduction(+:total) aligned(a,b,c,x,y,z,r,q:64) \n            for (int v = 0; v < VLEN; v++) { \n               \n \n              r[m][g][l][k][j][v] = \n                q[m][g][l][k][j][v] + \n                a[g][v] * x[m][g][k][j][v] + \n                b[g][v] * y[m][g][l][j][v] + \n                c[g][v] * z[m][g][l][k][v]; \n \n               \n \n              x[m][g][k][j][v] = 0.2*r[m][g][l][k][j][v] - x[m][g][k][j][v]; \n              y[m][g][l][j][v] = 0.2*r[m][g][l][k][j][v] - y[m][g][l][j][v]; \n              z[m][g][l][k][v] = 0.2*r[m][g][l][k][j][v] - z[m][g][l][k][v]; \n \n               \n \n              total += r[m][g][l][k][j][v]; \n \n            }  \n \n \n            sum[m][l][k][j] += total; \n \n          }  \n \n        }  \n \n      }  \n \n    }  \n \n  }", "pragma": "parallel for ", "hash": "6027b5b97c105da2c26bf2a4ca7452030c9e92cf28f8d13a2370259e6597cf22"}
{"code": "for (i = 0; i < nblklist; i++) { \n\t\tif ((int)i % mpisize == mpirank) \n\t\t\tcompute_block(alpha, a, b, beta, c, cidxa, aidxa, cidxb, \n\t\t\t    aidxb, cidxc, aidxc, blklist[i], pairs, buf); \n\t}", "pragma": "for ", "hash": "40c6fce5e450cbcae8e95f5825a0b1f3ee13b618571d7bcceafca7779ae26b7b"}
{"code": "for(int i = 0; i < *points_count; i++) \n      { \n        (*points)[i * 2]     += dx; \n        (*points)[i * 2 + 1] += dy; \n      }", "pragma": "parallel for simd ", "hash": "2d20c6199ca7c7b7eb2c86671749df7502c31f15620d6adef2822d2553733fde"}
{"code": "for(size_t ui=0;ui<clusteredBulk.size();ui++) \n\t\ttotalSize+=clusteredBulk[ui].size();", "pragma": "parallel for reduction(+:totalsize) ", "hash": "870f9ace891fc2519699fd8f9e77d7a1ca64d202083a877ee1788b19106cc895"}
{"code": "for (j = 0; j < reps; j++) { \n\t    for (i = 0; i < N; i++) { \n\t\t \n \n                sprintf(name, \"testfile_%d_1\", omp_get_thread_num()); \n\t\tfd = open(name, O_RDONLY); \n\t\tif (fd < 0) { \n\t\t    fprintf(stderr, \"ERROR: unable to open test file for reading in file_read_random\\n\"); \n\t\t} \n\t\telse { \n                     \n \n                    block = rand() % N; \n\t\t \n\t\t     \n \n\t\t    lseek(fd, block * size, SEEK_SET); \n\t\t    read(fd, data[omp_get_thread_num()], size); \n\t\t    close(fd); \n                } \n\t    } \n\t}", "pragma": "parallel private(    block fd i j name)", "hash": "6f8c2b2ca83807e943523a057f49d8700f832d181230988e29727ca332dda193"}
{"code": "for(int y = 0; y < nY; y++) { \n         for(int x = 0; x < nX; x++) { \n            for(int e = 0; e < nEns; e++) { \n               if(t < mWindow) { \n                  (*fields[t])(y, x, e) = Util::MV; \n               } \n               else { \n                  float previous = (*fieldsAcc[t - mWindow])(y, x, e); \n                  float current  = (*fieldsAcc[t])(y, x, e); \n                  if(Util::isValid(current) && Util::isValid(previous)) { \n                     (*fields[t])(y, x, e) = current - previous; \n                  } \n                  else { \n                     (*fields[t])(y, x, e) = Util::MV; \n                  } \n               } \n            } \n         } \n      }", "pragma": "parallel for ", "hash": "d113d12595c7ca7b4d83090793f69c6657ccb377af30fa02447590fec544f1e9"}
{"code": "for(int j = oj; j < (height - 1); j += 2) \n  { \n    for(int i = oi; i < (width - 1 - g2_offset); i += 2) \n    { \n      out[(size_t)j * width + i] = in[(size_t)j * width + i] / gr_ratio; \n    } \n  }", "pragma": "parallel for ", "hash": "d237820f2b8bdace2dd27e0e0c24994c9198432af35acdb6e258d86be8e6ad4b"}
{"code": "for (long i = 0; i < (long)coeff_.size(); i++) coeff[i] = coeff_[i];", "pragma": "parallel for ", "hash": "8858487feaa55a6500561caf541d3ddd2cd22e06e96cbb05461f83d705b5602f"}
{"code": "for (int i = 0; i < count; i++) \n  { \n    float num   = (float)(map1[i] - map2[i]); \n    float denom = (float)(map1[i] + map2[i]); \n \n    if (denom == 0)  \n      new_map[i] = 0; \n    else \n      new_map[i] = num / denom; \n  }", "pragma": "parallel for ", "hash": "3eadc29465e7d2c5dba239fc54be22c13507fddef0fb8fbf2e8c1baa8009ea84"}
{"code": "for (j=0; j<N; j++) \n            c[j] = a[j];", "pragma": "parallel for ", "hash": "5b760140ec4058b5d1f85128865ddcb036fe0deae42af281664a976501f53f24"}
{"code": "for(long i=t->id;i<t->n;i+=mglNumThr) \n\t\t{ \n\t\t\tregister long k = i*nx;\tmemset(b,0,2*nx*sizeof(double)); \n\t\t\tfor(long j=0;j<nn;j++)\tb[2*j]=(a[j+k]+a[nn-j+k])*0.5-sin(M_PI*j/nn)*(a[j+k]-a[nn-j+k]); \n\t\t\tmgl_fft(b,1,nn,t->v,w,false); \n\t\t\tdouble f1=0.5*(a[k]-a[nn+k]), s=-1; \n\t\t\ta[nn+k]=0.5*(a[k]+a[nn+k]*(nn%2?-1:1)); \n\t\t\tfor(long j=1;j<nn;j++) \n\t\t\t{ \n\t\t\t\tf1 += a[j+k]*cos(M_PI*j/nn); \n\t\t\t\ta[nn+k] += a[j+k]*s;\ts = -s; \n\t\t\t} \n\t\t\ta[k]=b[0]*f;\ta[1+k]=f1*f;\ta[nn+k]*=f;\t \n \n\t\t\tfor(long j=1;j<nn/2;j++) \n\t\t\t{ \n\t\t\t\ta[2*j+k] = b[2*j]*f; \n\t\t\t\ta[2*j+1+k] = a[2*j-1+k]-b[2*j+1]*f; \n\t\t\t} \n\t\t\tif(nn%2)\ta[nn-1+k] = b[nn-1]*f; \n\t\t}", "pragma": "for ", "hash": "b0f18427e6ac52664e90ca3a652b5c79110aea22a74fc53e0a4e59ab9d79f2c6"}
{"code": "for (unsigned int i = 0; i < model.surfels.size(); i++) \n  { \n     \n \n    if (!canUpdateSurfel[i] || shouldRemove[i]) \n      continue; \n \n    float normalAngle = getAngleNormalToCamera(model.surfels[i], viewedFrom); \n    std::pair<float, float> pixel = projections[i]; \n \n     \n \n    Eigen::Vector3f corrPoint, corrNormal; \n    bool interpolationSuccess = interpolatePointAndNormal(pixel, *data.pointGrid, *data.normalGrid, *data.validityGrid, \n                                                          corrPoint, corrNormal, params.maxInterpolationDist); \n \n     \n \n    if (interpolationSuccess) \n    { \n      int x = round(pixel.first); \n      int y = round(pixel.second); \n \n       \n \n      float depthDiff = model.surfels[i].location.dot(lookDir) - corrPoint.dot(lookDir); \n \n       \n \n      if (fabs(depthDiff) <= params.corrDistForUpdate) \n      { \n        float corrNormalAngle = getAngleNormalToCamera(corrNormal, corrPoint, viewedFrom); \n        bool willingToAddPixel = (*data.willingToAdd)[x][y] && corrNormalAngle < params.maxNormalAngle; \n \n         \n \n        float normalsDot = model.surfels[i].normal.dot(corrNormal); \n        if (corrNormalAngle < params.maxNormalAngle && model.surfels[i].visibility_confidence < params.highConfidence \n            && normalsDot > -1 * minDotWithExistingNormal && normalsDot < minDotWithExistingNormal) \n        { \n          shouldRemove[i] = true; \n          continue; \n        } \n \n         \n \n        if (normalAngle > params.maxNormalAngle || !willingToAddPixel) \n          continue; \n \n         \n \n        addObservation(model.surfels[i], corrPoint, corrNormal, viewedFrom, lookDir, data.camParams.focalLength); \n \n         \n \n        if (params.colorUpdateRule == COLOR_UPDATE_BEST_VIEWPOINT) \n        { \n          float newAngle = getAngleNormalToCamera(model.surfels[i], viewedFrom); \n          if (newAngle < model.minAngleFromNormal[i]) \n          { \n            Eigen::Vector3f pixelColor; \n            interpolateImagePixel(pixel, data.image, pixelColor); \n            model.colors[i] = pixelColor; \n            model.minAngleFromNormal[i] = newAngle; \n          } \n        } \n        else if (params.colorUpdateRule == COLOR_UPDATE_MEDIAN_COLOR) \n        { \n          Eigen::Vector3f pixelColor; \n          interpolateImagePixel(pixel, data.image, pixelColor); \n          model.allColors[i].insert(pixelColor); \n          std::multiset<Eigen::Vector3f, colorcomp>::iterator it = model.allColors[i].begin(); \n          unsigned int middleElement = model.allColors[i].size() / 2; \n          for (unsigned int j = 0; j < middleElement; j++) \n            it++; \n          model.colors[i] = *it; \n        } \n        else if (params.colorUpdateRule == COLOR_UPDATE_FIRST_COLOR) \n        { \n           \n \n        } \n        else if (params.colorUpdateRule == COLOR_UPDATE_LAST_COLOR) \n        { \n          Eigen::Vector3f pixelColor; \n          interpolateImagePixel(pixel, data.image, pixelColor); \n          model.colors[i] = pixelColor; \n        } \n        else if (params.colorUpdateRule == COLOR_UPDATE_NEAREST) \n        { \n          if (depthDiff > 0.0) \n          { \n            Eigen::Vector3f pixelColor; \n            interpolateImagePixel(pixel, data.image, pixelColor); \n            model.colors[i] = pixelColor; \n            model.minDistanceSeen[i] = model.surfels[i].location.dot(lookDir); \n          } \n        } \n        else \n        { \n          assert(false && \"unknown color update rule\"); \n        } \n \n        model.lastSeen[i] = data.currentTime; \n      } \n      else if (depthDiff < -1 * params.corrDistForUpdate) \n      { \n         \n \n        if (model.surfels[i].visibility_confidence < params.highConfidence) \n        { \n          shouldRemove[i] = true; \n        } \n         \n \n      } \n      else \n      { \n         \n \n         \n \n         \n \n      }  \n \n    }  \n \n  }", "pragma": "parallel for ", "hash": "a66839da814a4819f0d56c20b4347fbb4dfe31adfb0302fb7a5d2cb7708c614d"}
{"code": "for (particleID = 0; particleID < Nparticles; particleID++) { \n \n\t\t\t\t \n \n \n\t\t\t\tdouble rf = 1.0;  \n \n\t\t\t\tdouble phif = 0.0; \n\t\t\t\tdouble thetaf = PiOver2(); \n\t\t\t\tdouble af = 0;  \n \n\t\t\t\tdouble alphaf = 1;  \n \n \n\t\t\t\tTPseudoParticle ps(input->particle_type, double(input->Anumber), rf, phif, \n\t\t\t\t\t\tthetaf, q0, tl, af, alphaf, charge, bp); \n\t\t\t\tps.Evolve(env, rn); \n#pragma omp critical \n\t\t\t\t \n \n \n\t\t\t}", "pragma": "for ", "hash": "09aebcc9d9d61ce3e3e4285a844e4856bd793279153b52dc2b8d097f7da48af1"}
{"code": "for (int y = 0; y < h; ++y) { \n\t\t\tlineToRotate(y); \n\t\t}", "pragma": "parallel for ", "hash": "5e43dcf9daa3905ac1246e764305c1ba86cb9ecce5b2afe5c98a92c7e7b11258"}
{"code": "for (int i = 0; i < nrow; ++i) { \n    OMP_LOOP_EX_BEGIN(); \n    const int tid = omp_get_thread_num(); \n    auto one_row = get_row_fun(i); \n    ret->PushOneRow(tid, i, one_row); \n    OMP_LOOP_EX_END(); \n  }", "pragma": "parallel for ", "hash": "329c1a2668c163224b5418f842b33f09d4e14b142cb6d793b5e200e1b94bd8fb"}
{"code": "for (i=1; i<=nc; i++) \n        { \n            xsum1 = 0.0; \n            kmax = MIN(i-1, nab1); \n            #pragma omp simd reduction(+:xsum1) \n            for (k=0; k<=kmax; k++) \n            { \n                xsum1 = xsum1 + ap2[k]*awork[i-k-1]; \n            } \n            cwork[nc-i] = xsum1;  \n \n        }", "pragma": "parallel for private(   i k kmax xsum1)", "hash": "f3c0bdcb64932ac0d50a4441cbd74f111186648138894f328d54f76747c50018"}
{"code": "for (int i = 0; i < (int)nParticles; i++) \n\t\t\t{ \n\t\t\t\tpd.getPosition(i) += model.getDeltaX(i); \n\t\t\t}", "pragma": "for ", "hash": "b2af2ef165b7272437c1ff307711f5a6a91c396f57b325b6963c791a6daea4ef"}
{"code": "for(int kw = 0; kw < WW_t; kw++){                    \n \n        libxsmm_meltw_unary_param trans_param_flip_2; \n        trans_param_flip_2.in.primary  = &weight_buffer_a[kw*C_t*F_t]; \n        trans_param_flip_2.out.primary = &flip_weight_a[kw*C_t*F_t]; \n        trans_flip_2( &trans_param_flip_2 ); \n    }", "pragma": "parallel for ", "hash": "750c668c94109c36d6328643bf9a0e3c3633e63b6e8e6d500e42c95532faea7f"}
{"code": "for (int igrid = 0; igrid < npoints; ++igrid) { \n \n\t\t\t\tif (RS.Value(igrid)) { \n \n\t\t\t\t\t \n \n\t\t\t\t\tCqVector3D Nval; \n\t\t\t\t\tN->GetVector(Nval, igrid); \n\t\t\t\t\tNval = normalTrans * Nval; \n\t\t\t\t\tV3f Nval2(Nval.x(), Nval.y(), Nval.z()); \n \n\t\t\t\t\t \n \n\t\t\t\t\tCqVector3D Ival; \n\t\t\t\t\tI()->GetVector(Ival, igrid); \n\t\t\t\t\tV3f Ival2(Ival.x(), Ival.y(), Ival.z()); \n \n\t\t\t\t\tCqVector3D Pval; \n\t\t\t\t\tP->GetVector(Pval,igrid); \n\t\t\t\t\tPval = positionTrans * Pval; \n\t\t\t\t\tV3f Pval2(Pval.x(), Pval.y(), Pval.z()); \n \n\t\t\t\t\tV3f L[nLights]; \n\t\t\t\t\tC3f Cl[nLights]; \n\t\t\t\t\tint num = 0; \n\t\t\t\t\tfor (int j = 0; j < nLights; j++) { \n\t\t\t\t\t\tV3f Lval2 = memL[igrid * nLights + j]; \n\t\t\t\t\t\tC3f Clval2 = memCl[igrid * nLights + j]; \n \n\t\t\t\t\t\tif (!isnan(Lval2.x)) { \n\t\t\t\t\t\t\tL[num] = Lval2; \n\t\t\t\t\t\t\tCl[num] = Clval2; \n\t\t\t\t\t\t\tnum++; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n\t\t\t\t\t \n \n\t\t\t\t\tfloat areaSurf; \n\t\t\t\t\tarea->GetFloat(areaSurf,igrid); \n\t\t\t\t\tfloat radius = sqrt(areaSurf/M_PI); \n \n\t\t\t\t\tNval2.normalize(); \n\t\t\t\t\tHemisphere hemisphere(Nval2,phong,L,Cl,num); \n\t\t\t\t\themisphere.setRadius(radius); \n \n\t\t\t\t\tif (dPdu != NULL && dPdv != NULL) { \n\t\t\t\t\t\tCqVector3D dPduVec; \n\t\t\t\t\t\tCqVector3D dPdvVec; \n\t\t\t\t\t\tdPdu->GetVector(dPduVec, igrid); \n\t\t\t\t\t\tdPdv->GetVector(dPdvVec, igrid); \n\t\t\t\t\t\themisphere.setdPdu(V3f(dPduVec.x(), dPduVec.y(), dPduVec.z())); \n\t\t\t\t\t\themisphere.setdPdv(V3f(dPdvVec.x(), dPdvVec.y(), dPdvVec.z())); \n\t\t\t\t\t} \n\t\t\t\t\tapproxHemi->approximate(hemisphere); \n \n\t\t\t\t\t \n \n\t\t\t\t\tapproxHemi->writeToFloatArray(&buffer[0]); \n\t\t\t\t\tH->ArrayEntry(0)->SetFloat(buffer[0],igrid); \n\t\t\t\t\tfor (int i=1; i < approxHemi->getFloatArraySize(); i++) { \n\t\t\t\t\t\tH->ArrayEntry(i)->SetFloat(buffer[i],igrid); \n\t\t\t\t\t} \n \n \n\t\t\t\t\t \n \n\t\t\t\t\tIval2.setValue(-Ival.x(), -Ival.y(), -Ival.z()); \n\t\t\t\t\tV3f dir = Ival2.normalize(); \n \n\t\t\t\t\tC3f col = approxHemi->getRadiosityInDir(dir); \n \n\t\t\t\t\tresult->SetColor(CqColor(col.x, col.y, col.z), igrid); \n \n\t\t\t\t}  \n \n\t\t\t}", "pragma": "for ", "hash": "26c14304919c35f5768d8699ccb971e5978080a0d1cafec0bfef81ae7db0a135"}
{"code": "for(int xn = 0; xn<NMAX; xn++){ \n      double exact, multipole; \n        double x = (double)xn+1.; \n        VecDoub X(3,1); \n        X[p]=x; \n        if(qq==\"general\"){ \n            X[0]=x/2.;X[1]=x/3.;X[2]=x; \n        } \n        VecDoub ex = rho.Forces(X); \n        exact = rho.Forces(X)[q]; \n        multipole = ME.Forces(X)[q]; \n        EXPECT_NEAR(exact,multipole,5e-3*norm(ex)); \n    }", "pragma": "parallel for ", "hash": "b307beb3221c178e326be42a7b975d3c3965313be9fe1a2c98dd80ca599f9fb9"}
{"code": "for (int atom = 0; atom < numOfAtoms; ++atom) { \n        const std::string symbol = this->flGeometry_.getAtomSymbol(atom); \n        if (symbol == \"X\") { \n            continue; \n        } \n \n        const double z = this->flGeometry_.getCharge(atom); \n        const TlPosition p = this->flGeometry_.getCoordinate(atom); \n        TlDenseVector_Lapack R(3); \n        R.set(0, p[0]); \n        R.set(1, p[1]); \n        R.set(2, p[2]); \n \n        const TlDenseVector_Lapack RT = R - T; \n        const double RT2 = RT.norm2(); \n \n        TlDenseGeneralMatrix_Lapack mRT(3, 1); \n        mRT.set(0, 0, RT.get(0)); \n        mRT.set(1, 0, RT.get(1)); \n        mRT.set(2, 0, RT.get(2)); \n        TlDenseGeneralMatrix_Lapack mRTt = mRT; \n        mRTt.transposeInPlace(); \n        const TlDenseSymmetricMatrix_Lapack RTRT = mRT * mRTt; \n        assert(RTRT.getNumOfRows() == 3); \n        assert(RTRT.getNumOfCols() == 3); \n \n        M += z * (RT2 * I - RTRT); \n    }", "pragma": "parallel for ", "hash": "1dfea5f7d363f04bad5d29667551430e6c8c5d820bb90381cbef1e0937750a4d"}
{"code": "for (i = 0; i < nframes; i++) \n  { \n     \n \n    int j; \n    real   ISD; \n    double dISD; \n    matrix rrot, rrotx, rroty, rrotz; \n    rvec *iframe, *jframe, *cframe, *rframe, rrot_xyz, xold; \n    if (bRROT) \n    { \n      snew(iframe,iatoms); \n       \n \n      rrot_xyz[0] = (real)rand(); \n      rrot_xyz[1] = (real)rand(); \n      rrot_xyz[2] = (real)rand(); \n    } \n    if (bFit) \n    { \n      snew(jframe,iatoms); \n    } \n     \n     \n \n    for (j = 0; j < nframes; j++) \n    { \n       \n \n       \n       \n \n      if (i == j) \n      { \n        ISDmat[i][j] = 0; \n        continue; \n      } \n       \n       \n \n      if (bRROT) \n      { \n         \n \n        copy_rvecn(frames[i], iframe, 0, iatoms); \n        rframe = iframe; \n      } \n      else \n      { \n        rframe = frames[i]; \n      } \n       \n       \n \n      if (bFit) \n      { \n         \n \n        copy_rvecn(frames[j], jframe, 0, iatoms); \n         \n \n        do_fit(iatoms, iweights, frames[i], jframe); \n        cframe = jframe; \n      } \n      else \n      { \n        cframe = frames[j]; \n      } \n       \n       \n \n      if (bDFLT || bRMSD || bSRMS || bRG || bSRG || bE2E || bSE2E ||  \n        bMIR || bANG || bDIH || bANGDIH || bPHIPSI || bDRMS ||  \n        bSDRMS || bPCOR || bACOR || bANG2 || bDIH2 || bANGDIH2 ||  \n        bPHIPSI2 || bANGDIH2G || bRMSDIH || bRROT) \n      { \n        ISD = call_ISDM(iatoms, cframe, rframe, ISDM); \n      } \n       \n       \n \n      if (bMAMMOTH) \n      { \n         \n \n        ISD = calc_mammoth(iatoms, cframe, rframe, rnum); \n      } \n       \n       \n \n      if (bESA) \n      { \n         \n \n        ISD = calc_esa(iatoms, cframe, rframe); \n      } \n       \n       \n \n      dISD = (double)ISD; \n       \n \n      ISDmat[i][j] = ISD; \n       \n \n      if (dISD > maxdiff[i]) \n      { \n        maxdiff[i] = dISD; \n      } \n      avgdiff[i] += dISD; \n       \n       \n \n       \n \n    } \n     \n     \n \n    avgdiff[i] /= (nframes - 1); \n     \n     \n \n    #pragma omp critical \n    { \n      finished_calcs += nframes; \n      while ((double)(finished_calcs) / nframes2 >= (double)percent_calcs / 100) \n      { \n        fprintf(stderr, \"Approximately %i percent complete. \\r\", percent_calcs); \n        percent_calcs++; \n      } \n    }  \n \n     \n     \n \n    if (bRROT) \n    { \n      sfree(iframe); \n    } \n    if (bFit) \n    { \n      sfree(jframe); \n    } \n  }", "pragma": "parallel for ", "hash": "2e9df5fc3b4814e13ff3c496a4bfbb9f03240c8aa4d44b96af410497e0153b3f"}
{"code": "for (int i = 0; i < (int) instRows.size(); i++) { \n    try { \n      auto& instRow = instRows[i]; \n      genInstRowPattern(instRow); \n#pragma omp critical \n      { \n        rowIdx++; \n        cnt++; \n        if (VERBOSE > 0) { \n          if (cnt < 10000) { \n            if (cnt % 1000 == 0) { \n              logger_->info(DRT, 82, \"  Complete {} groups.\", cnt); \n            } \n          } else { \n            if (cnt % 10000 == 0) { \n              logger_->info(DRT, 83, \"  Complete {} groups.\", cnt); \n            } \n          } \n        } \n      } \n    } catch (...) { \n      exception.capture(); \n    } \n  }", "pragma": "parallel for ", "hash": "06f5c37d634a563aa825702e7c390e1074868fb25f7dee439f45291ca76bc095"}
{"code": "for (int f = 0; f < fc; f++) \n\t{ \n\t\tfor (int yy = 0; yy < h; yy++) \n\t\tfor (int xx = 0; xx < w; xx++) \n\t\t{ \n\t\t\tframesSqRS(xx,yy,f) = framesFilteredRS(xx,yy,f) * framesFilteredRS(xx,yy,f); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "01555dd6b083b2504033e159cf19848b94bdcd0200ff0f17892270d6177ea27f"}
{"code": "for (i = 1; i <= grid_points[0]-2; i++) { \n      for (j = 1; j <= grid_points[1]-2; j++) { \n\tfor (k = 1; k <= grid_points[2]-2; k++) { \n\t  rhs[m][i][j][k] = rhs[m][i][j][k] * dt; \n\t} \n      } \n    }", "pragma": "for ", "hash": "b49ef3740610b3b56eaf8b5ee76c00df62ac2216e8dcf2e7e8e3fb760d354574"}
{"code": "for (int y = 0; y < size.height; y++) { \n      Vec4T const* src = args.get(i).ptr<Vec4T const>(y); \n      cv::Vec4f* dst = local_view.ptr<cv::Vec4f>(y); \n \n      for (int x = 0; x < size.width; x++) { \n         \n \n        cv::Vec3f const bgr(converter[src[x][0]],    \n \n                            converter[src[x][1]],    \n \n                            converter[src[x][2]]);   \n \n        float const alpha = src[x][3] * alpha_scale; \n \n         \n \n        cv::Vec3f const xyz = tnzu::to_xyz(bgr); \n \n        dst[x][0] += xyz[0]; \n        dst[x][1] += xyz[1]; \n        dst[x][2] += xyz[2]; \n        dst[x][3] += alpha; \n      } \n    }", "pragma": "parallel for ", "hash": "996e505d6ae7bddef884c80a2063630230a98a1be52bf653dde83a3735991e7c"}
{"code": "for(int i = 0; i<count; ++i){\r \n                    outData[i].PutX(0);outData[i].PutY(0);outData[i].PutZ(0);}", "pragma": "parallel ", "hash": "9e70bac8436fba32ecbc9fc161f22221f58189124cac2a4db19e4ea926f0b321"}
{"code": "for (i = -3; i < 119; i += 2) \n    { \n      ++s2; \n      if ((a[i + 4] % 11) == 9) \n\tv2 = i; \n      else \n\t++r2; \n    }", "pragma": "parallel for reduction( +:r2 s2) private(conditional: v2)", "hash": "eec7ba32c9c55277a4abda691d5c8c4fd26e4392051df2b8fea0129e64889e39"}
{"code": "for (i=0; i<m; i++) { \n        u = SDGdata->startVertex[i]; \n        omp_set_lock(&vLock[u]); \n        pos[i] = degree[u]++; \n        omp_unset_lock(&vLock[u]); \n    }", "pragma": "for ", "hash": "e4e0ab46df144ab1fb704ddcef27788079d5c53f4042411b9be60c6df1ad45bb"}
{"code": "for (j = i+1; j < N; j++) {  \n\t\t\tratio = A[j][i]/A[i][i]; \n\t\t\t \n \n\t\t\tfor (k = i; k < N+1; k++) { \n\t\t\t\tA[j][k] -= (ratio*A[i][k]);  \n\t\t\t} \n\t\t}", "pragma": "parallel for private(k ratio)", "hash": "d553b709c0c4e489595703d8e4d61c6cdec3ae2a11d41ca9af9712eadcee7430"}
{"code": "for (index = 0; index < count; index++) { \n\t\tSHA512_CTX ctx; \n\t\tunsigned char decryptedVerifierHashInputBytes[16], decryptedVerifierHashBytes[32]; \n\t\tunsigned char hash[64]; \n \n\t\tDecryptUsingSymmetricKeyAlgorithm(&key[128*index], cur_salt->encryptedVerifier, decryptedVerifierHashInputBytes, 16); \n\t\tDecryptUsingSymmetricKeyAlgorithm(&key[128*index+64], cur_salt->encryptedVerifierHash, decryptedVerifierHashBytes, 32); \n\t\tSHA512_Init(&ctx); \n\t\tSHA512_Update(&ctx, decryptedVerifierHashInputBytes, 16); \n\t\tSHA512_Final(hash, &ctx); \n\t\tif (!memcmp(hash, decryptedVerifierHashBytes, 20)) \n\t\t{ \n\t\t\tcracked[index] = 1; \n#pragma omp atomic \n\t\t\tany_cracked |= 1; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "a6de3177f5eedd2a64750068ff326ac635cf2c8855aede6d7be971f358aaf964"}
{"code": "for (i = 0; i < GRAYLEVELS; i++) \n        histoNorm[i] = (uint)(histo[i] / ratio);", "pragma": "parallel for ", "hash": "a566633490dd0dc354440ab8580db1fa6980364541d96473302200ac158a606d"}
{"code": "for (tile_y=0; tile_y < (ssize_t) image->rows; tile_y+=(ssize_t) tile_height) \n      { \n        register ssize_t \n          tile_x; \n \n        if (status == MagickFalse) \n          continue; \n        tile_x=0; \n        for ( ; tile_x < (ssize_t) image->columns; tile_x+=(ssize_t) tile_width) \n        { \n          MagickBooleanType \n            sync; \n \n          register const Quantum \n            *magick_restrict p; \n \n          register Quantum \n            *magick_restrict q; \n \n          register ssize_t \n            y; \n \n          size_t \n            height, \n            width; \n \n          width=tile_width; \n          if ((tile_x+(ssize_t) tile_width) > (ssize_t) image->columns) \n            width=(size_t) (tile_width-(tile_x+tile_width-image->columns)); \n          height=tile_height; \n          if ((tile_y+(ssize_t) tile_height) > (ssize_t) image->rows) \n            height=(size_t) (tile_height-(tile_y+tile_height-image->rows)); \n          p=GetCacheViewVirtualPixels(image_view,tile_x,tile_y,width,height, \n            exception); \n          if (p == (const Quantum *) NULL) \n            { \n              status=MagickFalse; \n              break; \n            } \n          for (y=0; y < (ssize_t) width; y++) \n          { \n            register const Quantum \n              *magick_restrict tile_pixels; \n \n            register ssize_t \n              x; \n \n            if (status == MagickFalse) \n              continue; \n            q=QueueCacheViewAuthenticPixels(rotate_view,(ssize_t) \n              (rotate_image->columns-(tile_y+height)),y+tile_x,height,1, \n              exception); \n            if (q == (Quantum *) NULL) \n              { \n                status=MagickFalse; \n                continue; \n              } \n            tile_pixels=p+((height-1)*width+y)*GetPixelChannels(image); \n            for (x=0; x < (ssize_t) height; x++) \n            { \n              register ssize_t \n                i; \n \n              if (GetPixelWriteMask(image,tile_pixels) == 0) \n                { \n                  tile_pixels-=width*GetPixelChannels(image); \n                  q+=GetPixelChannels(rotate_image); \n                  continue; \n                } \n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n              { \n                PixelChannel channel=GetPixelChannelChannel(image,i); \n                PixelTrait traits=GetPixelChannelTraits(image,channel); \n                PixelTrait rotate_traits=GetPixelChannelTraits(rotate_image, \n                  channel); \n                if ((traits == UndefinedPixelTrait) || \n                    (rotate_traits == UndefinedPixelTrait)) \n                  continue; \n                SetPixelChannel(rotate_image,channel,tile_pixels[i],q); \n              } \n              tile_pixels-=width*GetPixelChannels(image); \n              q+=GetPixelChannels(rotate_image); \n            } \n            sync=SyncCacheViewAuthenticPixels(rotate_view,exception); \n            if (sync == MagickFalse) \n              status=MagickFalse; \n          } \n        } \n        if (image->progress_monitor != (MagickProgressMonitor) NULL) \n          { \n            MagickBooleanType \n              proceed; \n \n            #pragma omp critical (MagickCore_IntegralRotateImage) \n            proceed=SetImageProgress(image,RotateImageTag,progress+=tile_height, \n              image->rows); \n            if (proceed == MagickFalse) \n              status=MagickFalse; \n          } \n      }", "pragma": "parallel for ", "hash": "5c4ba40ab3fbae1bf0252adecbd1170ac791bd3f062f7d3c5975b957b436929d"}
{"code": "for (size_t i = 0; i < n; i += 4) { \n        v.load(simg + i); \n        s = square(v); \n        out[i / 4] = sqrt(s[1] + s[2]) / v[0]; \n    }", "pragma": "parallel for private(d s v)", "hash": "6da113f0f36fa4207c40492bab023543668fadbe6c3bd6e7769501007688108d"}
{"code": "for(index=0; index<actionsForThreads.size(); index++) \n                    { \n                        #pragma omp critical \n                        { \n                             \n \n                            Mcts::Utils::OmpHelpers::Message(\"Pragma Omp For Expansion Step started..\"); \n                            std::string expansionAction = actionsForThreads[index]; \n                            localState = state->clone(); \n                            localState->performAction(expansionAction); \n                            localNode = node->addChildNode(expansionAction, localState); \n \n                             \n \n                            Mcts::Utils::OmpHelpers::Message(\"Pragma Omp For Coping values started..\"); \n                            localNode = localNode->clone(); \n                        } \n \n                         \n \n                        int simulationStepIterations = 0; \n                        Mcts::Utils::OmpHelpers::Message(\"Pragma Omp For Simulation Step started..\"); \n                        while (!localState->getAvailableActions().empty()) \n                        { \n                            std::vector<std::string> actions = localState->getAvailableActions(); \n                            std::random_shuffle(actions.begin(), actions.end()); \n                            std::string action = actions.back(); \n                            localState->performAction(action); \n \n                            simulationStepIterations++; \n                            if (simulationStepIterations >= MCTS_SIMULATION_MAX_ITERATIONS) \n                            { \n                                break; \n                            } \n                        } \n \n                        #pragma omp critical \n                        { \n                             \n \n                             \n \n                            Mcts::Utils::OmpHelpers::Message(\"Pragma Omp For Backpropagation Step started..\"); \n                            for (int j = 0; j < node->childNodes.size(); j++) \n                            { \n                                Mcts::Tree::Node *browsingNode = &node->childNodes[j]; \n                                Mcts::Utils::OmpHelpers::Message(\"Pragma Omp For Backpropagation check started..\"); \n                                if (browsingNode->getPreviousAction() == \n                                    localNode->getPreviousAction()) \n                                { \n                                    Mcts::Utils::OmpHelpers::Message(\"Pragma Omp For Backpropagation if hit!\"); \n                                    while (browsingNode->getParentNode() != NULL) \n                                    { \n                                        Mcts::Utils::OmpHelpers::Message(\"Pragma Omp For Backpropagation while..\"); \n                                         \n \n                                        browsingNode->update( \n                                                localState->getStateValue( \n                                                        browsingNode->getLastActivePlayer() \n                                                ) \n                                        ); \n                                        browsingNode = browsingNode->getParentNode(); \n                                    } \n                                    break; \n                                } \n                            } \n                        } \n \n                        Mcts::Utils::OmpHelpers::Message(\"Pragma Omp Parallel section finishing..\"); \n                    }", "pragma": "for ", "hash": "5c9db6a030073355da15ef9819e4ac999cf7b49a8f6c3242fe8bb9cf0b17c795"}
{"code": "for (ii = 0; ii < num_threads; ii++) \n   { \n     size = num_cols_diag_RT/num_threads; \n     rest = num_cols_diag_RT - size*num_threads; \n     if (ii < rest) \n     { \n        ns = ii*size+ii; \n        ne = (ii+1)*size+ii+1; \n     } \n     else \n     { \n        ns = ii*size+rest; \n        ne = (ii+1)*size+rest; \n     } \n \n   P_mark_array[ii] = hypre_CTAlloc(HYPRE_Int, num_cols_diag_P+num_cols_offd_RAP); \n   A_mark_array[ii] = hypre_CTAlloc(HYPRE_Int, num_nz_cols_A); \n   P_marker = P_mark_array[ii]; \n   A_marker = A_mark_array[ii]; \n   jj_count_diag = start_indexing; \n   jj_count_offd = start_indexing; \n \n   for (ic = 0; ic < num_cols_diag_P+num_cols_offd_RAP; ic++) \n   {       \n      P_marker[ic] = -1; \n   } \n   for (i = 0; i < num_nz_cols_A; i++) \n   {       \n      A_marker[i] = -1; \n   }    \n \n    \n \n    \n   for (ic = ns; ic < ne; ic++) \n   { \n       \n       \n \n \n      jj_row_begin_diag = jj_count_diag; \n      jj_row_begin_offd = jj_count_offd; \n \n      if (square) \n         P_marker[ic] = jj_count_diag++; \n \n      for (i=0; i < num_sends_RT; i++) \n        for (j = send_map_starts_RT[i]; j < send_map_starts_RT[i+1]; j++) \n            if (send_map_elmts_RT[j] == ic) \n            { \n                for (k=RAP_ext_i[j]; k < RAP_ext_i[j+1]; k++) \n                { \n                   jcol = RAP_ext_j[k]; \n                   if (jcol < num_cols_diag_P) \n                   { \n                        if (P_marker[jcol] < jj_row_begin_diag) \n                        { \n                                P_marker[jcol] = jj_count_diag; \n                                jj_count_diag++; \n                        } \n                   } \n                   else \n                   { \n                        if (P_marker[jcol] < jj_row_begin_offd) \n                        { \n                                P_marker[jcol] = jj_count_offd; \n                                jj_count_offd++; \n                        } \n                   } \n                } \n                break; \n            } \n  \n       \n \n    \n      for (jj1 = R_diag_i[ic]; jj1 < R_diag_i[ic+1]; jj1++) \n      { \n         i1  = R_diag_j[jj1]; \n  \n          \n \n          \n         if (num_cols_offd_A) \n         { \n           for (jj2 = A_offd_i[i1]; jj2 < A_offd_i[i1+1]; jj2++) \n           { \n            i2 = A_offd_j[jj2]; \n  \n             \n \n  \n            if (A_marker[i2] != ic) \n            { \n  \n                \n \n  \n               A_marker[i2] = ic; \n                \n                \n \n  \n               for (jj3 = P_ext_diag_i[i2]; jj3 < P_ext_diag_i[i2+1]; jj3++) \n               { \n                  i3 = P_ext_diag_j[jj3]; \n                   \n                   \n \n \n                  if (P_marker[i3] < jj_row_begin_diag) \n                  { \n                     P_marker[i3] = jj_count_diag; \n                     jj_count_diag++; \n                  } \n               } \n               for (jj3 = P_ext_offd_i[i2]; jj3 < P_ext_offd_i[i2+1]; jj3++) \n               { \n                  i3 = map_Pext_to_RAP[P_ext_offd_j[jj3]]+num_cols_diag_P; \n                   \n                   \n \n \n                  if (P_marker[i3] < jj_row_begin_offd) \n                  { \n                     P_marker[i3] = jj_count_offd; \n                     jj_count_offd++; \n                  } \n               } \n            } \n           } \n         } \n          \n \n          \n         for (jj2 = A_diag_i[i1]; jj2 < A_diag_i[i1+1]; jj2++) \n         { \n            i2 = A_diag_j[jj2]; \n  \n             \n \n  \n            if (A_marker[i2+num_cols_offd_A] != ic) \n            { \n  \n                \n \n  \n               A_marker[i2+num_cols_offd_A] = ic; \n                \n                \n \n  \n               for (jj3 = P_diag_i[i2]; jj3 < P_diag_i[i2+1]; jj3++) \n               { \n                  i3 = P_diag_j[jj3]; \n                   \n                   \n \n  \n                  if (P_marker[i3] < jj_row_begin_diag) \n                  { \n                     P_marker[i3] = jj_count_diag; \n                     jj_count_diag++; \n                  } \n               } \n                \n \n \n               if (num_cols_offd_P) \n               {  \n                 for (jj3 = P_offd_i[i2]; jj3 < P_offd_i[i2+1]; jj3++) \n                 { \n                  i3 = map_P_to_RAP[P_offd_j[jj3]] + num_cols_diag_P; \n                   \n                   \n \n  \n                  if (P_marker[i3] < jj_row_begin_offd) \n                  { \n                     P_marker[i3] = jj_count_offd; \n                     jj_count_offd++; \n                  } \n                 } \n               }  \n            } \n         } \n      } \n             \n       \n \n \n       \n    } \n    jj_cnt_diag[ii] = jj_count_diag; \n    jj_cnt_offd[ii] = jj_count_offd; \n   }", "pragma": "parallel for private(a_marker i i1 i2 i3 ic ii j jcol jj1 jj2 jj3 jj_count_diag jj_count_offd jj_row_begin_diag jj_row_begin_offd k ne ns p_marker rest size)", "hash": "69cba1f35b37488a715d8cb6e0ab92dc5546988f55499f1eaf82616704d04823"}
{"code": "for (int ii = 1; ii < segments.count(); ii++) { \n        SegmentInfo* Sprev, *S; \n#pragma omp critical \n        { \n            Sprev = &segments[ii - 1]; \n            S = &segments[ii]; \n        } \n        for (int k2 = 1; k2 <= S->K; k2++) { \n            QVector<bigint> event_inds_to_delete; \n            int k1 = find_matching_cluster(event_inds_to_delete, Sprev, S, k2, opts); \n            S->label_map_with_previous[k2] = k1; \n            for (bigint jj = 0; jj < event_inds_to_delete.count(); jj++) { \n                S->events_to_delete[event_inds_to_delete[jj]] = true; \n            } \n        } \n    }", "pragma": "for ", "hash": "923fb062869ff52462c1390d010755628ef192b9e65adf0ba950fa2931fdd96f"}
{"code": "for (i = 0; i < NEDGES; i++) { \n        v0 = gr.v0[i]; \n        v1 = gr.v1[i]; \n \n        gr.v0_data[i][0] = pt_data[v0][0]; \n        gr.v0_data[i][1] = pt_data[v0][1]; \n        gr.v0_data[i][2] = pt_data[v0][2]; \n \n        gr.v1_data[i][0] = pt_data[v1][0]; \n        gr.v1_data[i][1] = pt_data[v1][1]; \n        gr.v1_data[i][2] = pt_data[v1][2]; \n \n        gr.data[i] = edge_data[i]; \n    }", "pragma": "for private(   i j v0 v1)", "hash": "6a067547b5242d46700d21109c6b9eba215e7b84d2c30e92c577741d5689f716"}
{"code": "for (long i=0; i<NV_out; i++) { \n    long location = (i*(i+1))/2;  \n \n    for (long j=0; j<i; j++) { \n      if(i == j) \n\t     continue;  \n \n      if (tmpCounter[location+j] > 0) {\t \n\t     __sync_fetch_and_add(&vtxPtrOut[i+1], 1);  \n \n\t\t __sync_fetch_and_add(&vtxPtrOut[j+1], 1);  \n \n\t     __sync_fetch_and_add(&NE_out, 1);  \n \n      } \n    } \n \n  }", "pragma": "parallel for ", "hash": "ce7e961162238fc7654376a2d158015f94dda32f48f54427ee953ecee24b9ccb"}
{"code": "for (int i = 0; i < text.size(); ++i) \n\t\t{ \n\t\t\tprintf(\"ThreadID = %d, currentState = %d\",omp_get_thread_num(),currentState); \n\t\t\tcurrentState = findNextState(currentState, text[i]); \n \n \n\t \n \n\t \n \n\tfor (int i = 0; i < text.size(); ++i) \n\t{ \n\t\tcurrentState = findNextState(currentState, text[i]); \n \n \n \n\t\t\tprintf(\"out[currentState][0] = %d \\n\",out[currentState][0]); \n\t\t\t \n \n\t\t\tif (out[currentState][0] == 0) \n\t\t\tcontinue; \n \n \n\t\t \n \n\t\t \n \n\t\tint outSize = out[currentState][0]; \n \n\t\t \n \n\t\tfor (int j = 1; j <= outSize; ++j) \n\t\t{ \n\t\t\tint patIndex = out[currentState][j]; \n\t\t\t \n \n\t\t\t \n \n\t\t\tif(patIndex>=k || patIndex<0) continue; \n\t\t\tDEBUG2(\"In searchWords outIndex=%d currentState=%d patIndex=%d\",j,currentState,out[currentState][j]); \n\t\t\tlong start = (long) i - arr[patIndex].size() + 1; \n\t\t\tif(start >= text.size()) continue; \n\t\t\tprintf(\"Word %s appears from %d to %d\",arr[patIndex].c_str(),start,i); \n\t\t\t \n \n\t\t\t \n \n\t\t} \n\t} \n}", "pragma": "parallel for private(currentstate)", "hash": "f8532f4c6d9efcacfc535f0d708a21f48561527e710a58ab4668c94bac7ebbe2"}
{"code": "for (i__ = 1; i__ <= i__1; ++i__) \n\t{ \n\t\tif (wa1[i__] > 0.) \n\t\t{ \n\t\t\twa2[i__] = 1. / std::sqrt(wa1[i__]); \n\t\t} \n\t}", "pragma": "parallel for private(i__)", "hash": "578652fd3ca905c5e76b376adc68aeb71a75fa9dc8b4e5949bad773df555182a"}
{"code": "for( int planeNr=0; planeNr < nrOfPlanes; planeNr++ ) \n    { \n        IPLImagePlane* plane = image->plane( planeNr ); \n        IPLImagePlane* newplane = _result->plane( planeNr ); \n \n        int p[256] = { 0 }; \n \n        for( int y = 0; y < height; ++y ) \n        { \n            for( int x = 0; x < width; ++x ) \n            { \n                int index = plane->p(x,y) * 255; \n                p[index]++; \n            } \n        } \n \n         \n \n        int maxBin = 0; \n        int maxFrequency = 0; \n        for( int k=1; k<255; ++k ) \n        { \n            if( p[k] > maxFrequency ) \n            { \n                maxFrequency = p[k]; \n                maxBin = k; \n            } \n        } \n \n         \n \n        int zeroBin = 0; \n        int x0, x1; \n        if( maxBin >= 128 ) \n        { \n            zeroBin = 0; \n            while( p[zeroBin]==0 ) ++zeroBin; \n            x0 = zeroBin; \n            x1 = maxBin; \n        } \n        else \n        { \n            zeroBin = 255; \n            while( p[zeroBin]==0 ) --zeroBin; \n            x0 = maxBin; \n            x1 = zeroBin; \n        } \n \n        int y0 = p[x0]; \n        int y1 = p[x1]; \n        double a = y0 - y1; \n        double b = x1 - x0; \n        double c = x0*y1 - x1*y0; \n        double d = sqrt( a*a + b*b ); \n \n        int T = 0; \n        if( d != 0.0 ) \n        { \n            double maxDist = 0.0; \n            for( int k=x0; k<=x1; ++k ) \n            { \n                double distance = std::abs( ( a*k + b*p[k] + c ) / d ); \n                if( distance > maxDist ) \n                { \n                    maxDist = distance; \n                    T = k; \n                } \n            } \n        } \n \n        ipl_basetype threshold = T * FACTOR_TO_FLOAT; \n \n        std::stringstream s; \n        s << \"Automatic Threshold: \"; \n        s << threshold; \n        addInformation(s.str()); \n \n        for(int y = 0; y < height; y++) \n        {             \n \n            notifyProgressEventHandler(100*progress++/maxProgress); \n            for(int x = 0; x < width; x++) \n            { \n                newplane->p(x,y)= (plane->p(x,y) > threshold)? 1.0 : 0.0; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "6debe6b08ed58502aaaf0ec2c2f28848774135b6239dff2d718112bf8080a76f"}
{"code": "for( size_t i = 0; i < sample_set.size(); ++i ) { \n         \n \n        double const scaler = normalize \n            ? total_placement_mass_with_multiplicities( sample_set[i] ) \n            : 1.0 \n        ; \n \n         \n \n        double const pend_work = add_sample_to_mass_tree( \n            sample_set[i], +1.0, scaler, mass_trees[i] \n        ); \n \n         \n \n        pend_works[ i ] = pend_work; \n    }", "pragma": "parallel for ", "hash": "4f8cfe8b9412e3f9d2705792e9ae500e0a78e9ba75deddb348f1e1b572be8273"}
{"code": "for (int f = 1; f <= grid.NFM; f++) \n\t\t{ \n\t\t\tint N\t= grid.faces[f].geo.Neighbor_list.size(); \n\t\t\tvector< vector<double> >\tdi\t= Common::vector_2D(N, grid.ND, 0.0); \n\t\t\tvector<double>\tdi_abs2(N, 0.0); \n \n\t\t\tfor (int i = 0; i <= N-1; i++) \n\t\t\t{ \n\t\t\t\tfor (int k = 0; k <= grid.ND-1; k++) \n\t\t\t\t{ \n\t\t\t\t\tdi[i][k]\t= grid.faces[f].geo.Neighbor_list[i]->geo.x[k]\t- grid.faces[f].geo.x[k]; \n\t\t\t\t\tdi_abs2[i]\t+= di[i][k]*di[i][k]; \n\t\t\t\t} \n\t\t\t} \n \n\t\t\tdouble sum_u\t= 0.0; \n\t\t\tdouble sum_b\t= 0.0; \n\t\t\tfor (int i = 0; i <= N-1; i++) \n\t\t\t{ \n\t\t\t\tsum_u\t+= grid.faces[f].geo.Neighbor_list[i]->data1D.data[i_VAR1].data[i_VAR2] / di_abs2[i]; \n\t\t\t\tsum_b\t+= 1.0 / di_abs2[i]; \n\t\t\t} \n \n\t\t\tphi_f[f]\t= sum_u / sum_b; \n\t\t}", "pragma": "parallel for ", "hash": "85358898589b6351f23cf9cc0628c1df933236fbbf4382372ee9c4135e3d35d6"}
{"code": "for ( int j=0 ; j<n ; j++ ) \n                    for ( int i=0 ; i<n ; i++ ) \n                        B[i*n+j] = A[j*n+i];", "pragma": "parallel for ", "hash": "5b550f8b5a7aaca88688c225c09538873f39d230dcc8f2cfcbea76d790be59a1"}
{"code": "for (i = 0; i < n; ++i){ \n        ret_val += find_peaks(&arr[start_inds[i]], len, thresholds[i], &peak_positions[start_inds[i]]); \n    }", "pragma": "parallel for ", "hash": "4f5415e0ab7bd54ac7e3f1b8151c5c989acd6341330a13b2e8daab1723baa2a0"}
{"code": "for (uint samp=0; samp<number_of_samples; ++samp) \n\t{ \n\t\tuint chr_of_random_draw; \n\t\tuint chromo_position_of_random_draw; \n\t\t \n\t\tbool draw_is_acceptable = false; \n\t\tuint num_attempts = 0; \n\t\twhile (!draw_is_acceptable) \n\t\t{ \n \n \n\t\t\tconst uint cumulative_genome_position_random_draw = uniform_genome_dist(random_generator); \n \n \n\t\t \n\t\t\t++num_attempts; \n\t\t\tchr_of_random_draw = 0; \n\t\t\tchromo_position_of_random_draw = 0; \n\t\t\t \n \n\t\t\tfor (type_map_BI_to_uint::const_iterator it_cumu = map_cumulative_genome_position_to_chromo.begin(); \n\t\t\t\tit_cumu != map_cumulative_genome_position_to_chromo.end(); \n\t\t\t\t++it_cumu) \n\t\t\t{ \n\t\t\t\tif (BOOST_in(cumulative_genome_position_random_draw, it_cumu->first)) \n\t\t\t\t{ \n\t\t\t\t\tchr_of_random_draw = it_cumu->second; \n\t\t\t\t\tchromo_position_of_random_draw = cumulative_genome_position_random_draw - it_cumu->first.lower() + 1; \n\t\t\t\t\tbreak; \n\t\t\t\t} \n \n\t\t\t} \n \n\t\t\tassert(chr_of_random_draw > 0); \n\t\t\tassert(chromo_position_of_random_draw > 0); \n\t\t\t \n\t\t\tconst BOOST_Interval acceptable_p_arm(skip_amount_at_end_of_chromos, Event::centromere_coordinates.at(chr_of_random_draw).first - skip_amount_at_end_of_chromos); \n\t\t\t \n\t\t\tconst BOOST_Interval acceptable_q_arm(Event::centromere_coordinates.at(chr_of_random_draw).second + skip_amount_at_end_of_chromos, \n\t\t\t\t\t\t\t\t\t\t\tnon_sex_chromosome_lengths.at(chr_of_random_draw) - skip_amount_at_end_of_chromos); \n\t\t\t \n \n \n \n \n \n \n\t\t\t \n\t\t\tdraw_is_acceptable = (!check_if_position_is_in_NON_unique_region(NON_unique_regions_of_genome, chr_of_random_draw, chromo_position_of_random_draw) \n\t\t\t\t\t\tand (BOOST_in(chromo_position_of_random_draw, acceptable_p_arm) or BOOST_in(chromo_position_of_random_draw, acceptable_q_arm))); \n\t\t\t \n\t\t\tassert(num_attempts < 20); \n\t\t\t \n\t\t} \n \n\t\t\t \n\t\t \n\t\tconst std::string test_seq(map_chromo_to_seq.at(chr_of_random_draw).substr(chromo_position_of_random_draw-1, mean_frag_length)); \n\t\tconst uint gc_count__random = calculate_GC_content_of_sequence(test_seq);\t\t \n\t\t \n\t\t \n\t\tuint number_observed_reads; \n\t\t \n  #pragma omp critical(random_sample_matched_control_position_from_good_part_of_genome) \n\t\t{ \n\t\t\tmy_BAM_reader.SetRegion(create_BAM_region(chr_of_random_draw, BOOST_Interval(chromo_position_of_random_draw-1, chromo_position_of_random_draw+1), 2));\t \n\t\t\tnumber_observed_reads = count_decent_reads_with_left_endpoints_in_set_region(my_BAM_reader, BOOST_make_point(chromo_position_of_random_draw));\t\t \n\t\t}\t\t\t\t \n\t\t \n\t\tsampled_observed_counts_per_GC_content[gc_count__random].push_back(number_observed_reads); \n\t\t \n\t}", "pragma": "parallel for ", "hash": "0125b916c3ba6280bfed7f882bdc60953e91bca68c289a00129656157637e59a"}
{"code": "for (uint32_t i=0; i<(uint32_t)m_Height*m_Width; i++) {\r \n    for (short c=0; c<3; c++) {\r \n      PreFlip[i][c] = DcRawObject->m_Image_AfterPhase2[i][c];\r \n    }\r \n  }", "pragma": "parallel ", "hash": "6905bec5a8a988140b9eec7aa76ce15d5bf7e3f71186c11cd931f61a45867728"}
{"code": "for(std::size_t i = 0; i < this->nParticles; i++){ \n       \n \n      this->threeBodyChanDims[i].hppDim = 0; \n      this->threeBodyChanDims[i].phhDim = 0; \n    }", "pragma": "for ", "hash": "9eb72d0efdccfe5ea9d68ec80731e87213c619561bd18c1bfdc0c2b8c17a8c9e"}
{"code": "for (i=0; i<n; i++) \n\t\tsums[i] = da_vsum(ptr[i+1]-ptr[i], val+ptr[i], 1);", "pragma": "parallel for ", "hash": "b06a2ff15ab8b76869b7645ad19f789a47a7e1a8cc40e3c86bb6bfb22afdc3c4"}
{"code": "for (int i = 0; i < len; ++i) { \n        vec[i] = REAL(array)[i]; \n      }", "pragma": "parallel for ", "hash": "a51433dd9564e3fb94126adffdfe5e387e7395934b9b6a452b478714434424bb"}
{"code": "for(long i=t->id;i<t->n;i+=mglNumThr) \n\t\t{ \n\t\t\tregister long j = (i/nx)%ny; \n\t\t\tif(j>1 && j<ny-2)\tb[i] = (a[i-2*nx] + a[i-nx] + a[i] + a[i+nx] + a[i+2*nx])/5.; \n\t\t\telse if(j==1 || j==ny-2)\tb[i] = (a[i-nx] + a[i] + a[i+nx])/3.; \n\t\t\telse\tb[i] = a[i]; \n\t\t}", "pragma": "parallel for ", "hash": "ff4298d7eb560b892575028fb64f8763d42a85b36295c743002eb9b7ccddf51f"}
{"code": "for(size_t i=0;i<basis.size();i++) \n    for(size_t j=0;j<=i;j++) { \n      double el=overlap(basis[i].n,basis[j].n,basis[i].zeta,basis[j].zeta,basis[i].l,basis[i].m,basis[j].l,basis[j].m); \n      S(i,j)=el; \n      S(j,i)=el; \n    }", "pragma": "parallel for ", "hash": "57dd4af4741d06f02e3c4223aea8feb9be7f2d0359a8325ca5d72a880f587a6a"}
{"code": "for (size_t i = 0; i < sk.partsNum(); i++) \n            crtParts_.at(i).unpack(alphas.at(i), sk.get(i), false);", "pragma": "parallel for ", "hash": "0b16bd2e3dbe5967ce362b7ac6dc7ae97b94b850c4a542b849a65f24b4dc8915"}
{"code": "for (i = 0; i < gi.NHalo; i++) { \n\t\t \n \n\t\tcalculate_derived_properties(gi,&hd[i]); \n\t\t \n \n\t\tcalculate_overdensity_characteristics(gi,&hd[i]); \n\t\t \n \n\t\tcalculate_truncation_characteristics(gi,&hd[i]); \n\t\t \n \n\t\tremove_background(gi,&hd[i]); \n\t\t \n \n\t\tcalculate_halo_size(gi,&hd[i]); \n\t\t \n \n\t\tcalculate_velocity_characteristics(gi,&hd[i]); \n\t\t}", "pragma": "parallel for private(i)", "hash": "52077df376db167f392f8984346da6dbe2e63da57aa9b19a2d5b31bbe95f9d7c"}
{"code": "for( int i=0; i<nrecv_total; i++){ \n    int im = recvbuf_local_dest[i]; \n    mesh_density_local[im] = recvbuf[i]; \n  }", "pragma": "parallel for ", "hash": "cffd70cb93550dce5ad1c99aa5d7c897ff9cc7bd6d2ad1bd9a74d95cf9655a03"}
{"code": "for (i = 0; i < maxtriangles; i++) { \n           \n             \n \n            atomeffectssum[i] = 0; \n           \n            if (!((conjugate[i][atomnumber] == 0) && (cohabitant[i][atomnumber] == 0))) { \n \n               \n \n \n              if (i == 0) { \n                maxshow = 0; \n              } \n \n               \n \n              if (maxshow < 20) { \n                maxshow++; \n \n \n              if ((conjugate[i][3] < 0) && (cohabitant[i][3] < 0)) { \n \n                printf(\" __/CONJ:%-7d L:%-7d R:%-7d,VIC:%-+9d POS:%-7d EFCT:%-+6d\\n   \\\\COHB:%-7d L:%-7d R:%-7d`VIC:%-+9d POS:%-7d EFCT:%-+6d\", \n                      conjugate[i][0], conjugate[i][1], conjugate[i][2], conjugate[i][3], conjugate[i][4], conjugateeffects[i], \n                      cohabitant[i][0], cohabitant[i][1], cohabitant[i][2], cohabitant[i][3], cohabitant[i][4], cohabitanteffects[i]); \n \n \n              } else \n              if ((conjugate[i][3] >= 0) && (cohabitant[i][3] < 0)) { \n \n                printf(\" __/CONJ:%-7d L:%-7d R:%-7d,ANA:%-+9d POS:%-7d EFCT:%-+6d\\n   \\\\COHB:%-7d L:%-7d R:%-7d`VIC:%-+9d POS:%-7d EFCT:%-+6d\", \n                      conjugate[i][0], conjugate[i][1], conjugate[i][2], conjugate[i][3], conjugate[i][4], conjugateeffects[i], \n                      cohabitant[i][0], cohabitant[i][1], cohabitant[i][2], cohabitant[i][3], cohabitant[i][4], cohabitanteffects[i]); \n \n \n              } else \n              if ((conjugate[i][3] < 0) && (cohabitant[i][3] >= 0)) { \n \n                printf(\" __/CONJ:%-7d L:%-7d R:%-7d,VIC:%-+9d POS:%-7d EFCT:%-+6d\\n   \\\\COHB:%-7d L:%-7d R:%-7d`ANA:%-+9d POS:%-7d EFCT:%-+6d\", \n                      conjugate[i][0], conjugate[i][1], conjugate[i][2], conjugate[i][3], conjugate[i][4], conjugateeffects[i], \n                      cohabitant[i][0], cohabitant[i][1], cohabitant[i][2], cohabitant[i][3], cohabitant[i][4], cohabitanteffects[i]); \n \n \n              } else { \n \n                printf(\" __/CONJ:%-7d L:%-7d R:%-7d,ANA:%-+9d POS:%-7d EFCT:%-+6d\\n   \\\\COHB:%-7d L:%-7d R:%-7d`ANA:%-+9d POS:%-7d EFCT:%-+6d\", \n                      conjugate[i][0], conjugate[i][1], conjugate[i][2], conjugate[i][3], conjugate[i][4], conjugateeffects[i], \n                      cohabitant[i][0], cohabitant[i][1], cohabitant[i][2], cohabitant[i][3], cohabitant[i][4], cohabitanteffects[i]); \n \n \n              } \n \n                if (cohabitant[i][0] != 0) { \n                  printf(\"  [ADJUSTED] \"); \n                  if (((cohabitant[i][3]*conjugate[i][3] < 0) && (atoms[0][3] > 0)) || \n                      ((cohabitant[i][3]*conjugate[i][3] > 0) && (atoms[0][3] < 0))) { \n                    printf(\"-\\n\"); \n                  } else \n                  if ((cohabitant[i][3]*conjugate[i][3] == 0) || (atoms[0][3] == 0)) { \n                    printf(\"0\\n\"); \n                  } else { \n                    printf(\"+\\n\"); \n                  } \n                } else { \n                  printf(\"  [CONCLUDED] \\n\"); \n                } \n \n              } \n               \n \n           \n              atomeffectssum[i] = conjugateeffects[i] + atoms[conjugate[i][positioninatoms]][atomvalue]; \n           \n              if (atomeffectssum[i] < maxvic) { \n           \n                atomeffectssum[i] = maxvic; \n           \n              } else if (atomeffectssum[i] > maxana) { \n           \n                atomeffectssum[i] = maxana; \n           \n              } \n           \n              atoms[conjugate[i][positioninatoms]][atomvalue] = atomeffectssum[i]; \n           \n            } \n           \n          }", "pragma": "parallel for ", "hash": "3a60363de5177174fc76b69b59c830d8af6c2097866346aa87d7b67d6f323860"}
{"code": "for (int c = 0; c < 10; ++c)\r \n\t\t\tstd::cout << \"c = \" << c << std::endl;", "pragma": "parallel for ", "hash": "0e1017cc9c9ffba8d0f3ad59812a816b24fa67c644e9e5bc3440d594c6dd0990"}
{"code": "for (int i = 0; i <= n; i++) \n\t{ \n\t\tsum += i; \n\t}", "pragma": "parallel for reduction(+:sum) ", "hash": "196ba73ac33f00559416cba007062bc77602342412a9d2007a9e0bdf0f6290b7"}
{"code": "for (int i = 0; i < m_size; ++i) \n\t\t{ \n\t\t\tm_sd[i] = m_depCo* m_depCap[i]; \n\t\t\t \n \n\t\t\tm_sr[i] = 0.0f; \n\t\t}", "pragma": "parallel for ", "hash": "506991f55f2d08c38e67dd28ae903768d0cdac6692c1070f7ce0b8e8c2d7a01a"}
{"code": "for ( OMPInt i=0; i < nEl; ++i ) \n\tif ( (*right)[i] == zero ) (*res)[i] = zero; else (*res)[i] = (*this)[i];", "pragma": "for ", "hash": "5a4ddcabfe29c56fab14d5f80aeb04de6fbefff6886ed12ac1112bc27bb52682"}
{"code": "for (size_t j=0;j<SEQ_DIM_BITS_SIZE;j++){ \n         \n \n         \n \n        uint64_t mask = 1; \n        if (data[i].z & (mask << j)){ \n          tmp_centroid[j]++; \n        } \n        if (data[i].y & (mask << j)){ \n          tmp_centroid[SEQ_DIM_BITS_SIZE + j]++; \n        } \n        if (data[i].x & (mask << j)){ \n          tmp_centroid[(2 *SEQ_DIM_BITS_SIZE) + j]++; \n        } \n      }", "pragma": "parallel for ", "hash": "ce49913cd954713703af05d5b14919d2f9c901b882a0fe9c23be32a6cb19e21f"}
{"code": "for (i = 0; i < nelem; i++) \n    { \n         \n \n        DailyOper(year, doy, elem[i].mgmt.auto_n, &elem[i].weather, &elem[i].mgmt, elem[i].crop, &elem[i].soil, \n            &elem[i].ws, &elem[i].wf, &elem[i].es, &elem[i].cs, &elem[i].cf, &elem[i].ns, &elem[i].nf, &elem[i].ps); \n \n         \n \n        CalSnkSrc(elem[i].ps.nlayers, &elem[i].nf, elem[i].solute); \n    }", "pragma": "parallel for ", "hash": "dc0bb7da083d256eae6336eaeda312bcc8805a34e5d6487107e3354f9d5c03a1"}
{"code": "for(indiv = 0; indiv < popsize; indiv++) { \n\t\tint tocopy = indiv_to_copy[indiv]; \n \n\t\tfor(int locus = 0; locus < numloci; locus++) { \n\t\t\tpopulation_traits[indiv * numloci + locus] = prev_population_traits[tocopy * numloci + locus]; \n\t\t} \n \n\t}", "pragma": "for private(indiv)", "hash": "94e5d688801bc40445d90226827bf7c92d5177b3911b5601e60935157bd2dfaf"}
{"code": "for (int i=0; i<this->size_; ++i) \n      this->vec_[i] = ValueType(cast_vec->vec_[i]);", "pragma": "parallel for ", "hash": "5015371a0c2c3ea74c68cf8867843b00087fb988a1a1b16e96bdc67a2832b1b8"}
{"code": "for (ix=0; ix<nx; ix++) { \n\t    for (iz=0; iz<nz; iz++) { \n\t      j = (iz+geop->top)+(ix+geop->lft)*nz2;  \n \n\t      ccr[ix][iz] += conjf(wavfld[wfit][ix][iz])*curr[j]; \n\t      ccr[ix][iz] += sf_cmul(conjf(wavfld[wfit][ix][iz]),curr[j]); \n\t    } \n\t  }", "pragma": "parallel for private(ix iz j)", "hash": "ccb17724a7c3a34852a34334a102119ccd38a0b94bb904906e34bced4ec2037e"}
{"code": "for ( int ii = 0; ii < static_cast< int >( rows ); ++ii ) { \n \n\t\tfloat const* const pSourceBegin = &luminance[ 0 ] + ii * columns; \n\t\tfloat* pDestination = &temp[ 0 ] + ii * destinationColumns; \n\t\tfor ( unsigned int jj = 0; jj < destinationColumns; ++jj, ++pDestination ) { \n \n\t\t\tdouble numerator   = 0; \n\t\t\tdouble denominator = 0; \n \n\t\t\t{\tfloat const* pSource = pSourceBegin + ( jj * 2 ); \n\t\t\t\tfloat const* const pSourceEnd = pSourceBegin; \n\t\t\t\tfor ( unsigned int kk = 0; ( kk < size ) && ( pSource >= pSourceEnd ); ++kk, --pSource ) { \n \n\t\t\t\t\tnumerator += filter[ kk ] * *pSource; \n\t\t\t\t\tdenominator += filter[ kk ]; \n\t\t\t\t} \n\t\t\t} \n \n\t\t\t{\tfloat const* pSource = pSourceBegin + ( jj * 2 + 1 ); \n\t\t\t\tfloat const* const pSourceEnd = pSourceBegin + ( columns - 1 ); \n\t\t\t\tfor ( unsigned int kk = 1; ( kk < size ) && ( pSource <= pSourceEnd ); ++kk, ++pSource ) { \n \n\t\t\t\t\tnumerator += filter[ kk ] * *pSource; \n\t\t\t\t\tdenominator += filter[ kk ]; \n\t\t\t\t} \n\t\t\t} \n \n\t\t\tif ( denominator > 0 ) \n\t\t\t\tnumerator /= denominator; \n\t\t\t*pDestination = numerator; \n\t\t} \n\t\tassert( pDestination == &temp[ 0 ] + ( ii + 1 ) * destinationColumns ); \n\t}", "pragma": "parallel for ", "hash": "8cb396b33f0cf50f8af3ac3f06ffb85f8094bd710d09b556800fbe63db90ebf4"}
{"code": "for (size_t i = 0; i < seqs.size(); i++) { \n      int thread_idx = omp_get_thread_num(); \n      vector_t scale; \n      matrix_t f = compute_forward_scaled(seqs[i], scale); \n      matrix_t b = compute_backward_prescaled(seqs[i], scale); \n \n       \n \n      matrix_t T, E; \n      double logp = BaumWelchIteration_single(T, E, seqs[i], targets); \n \n      if (not targets.transition.empty()) \n         \n \n        t_g[thread_idx] += transition_gradient(T, targets.transition); \n \n      if (not targets.emission.empty()) \n         \n \n        e_g[thread_idx] += emission_gradient(E, targets.emission); \n \n      lp += logp; \n    }", "pragma": "for reduction(+ : lp) ", "hash": "5533aaf0db379642df58274c3683a9dafcc4608b7921c1adbe80223fd00ae2d9"}
{"code": "for(i=0; i<(a->nrows); i++){ \n        a->d[i] = a->d[i] - b->d[i]; \n    }", "pragma": "for ", "hash": "45db2825a1a8bcd30ad0edfab9e59cd6f04ae30da791da8a32c4d3855ed630dc"}
{"code": "for (int y = 0; y < height; y++) { \n            for (int x = 0; x < width; x++) { \n                 \n \n                const auto& p = srcSampler(x, y); \n                const real dc = depthSampler(x, y).w; \n \n                vec3 numer = vec3(1.0f, 1.0f, 1.0f); \n                vec3 denom = vec3(p.x, p.y, p.z); \n \n                vec3 denom2 = vec3(p.x * p.x, p.y * p.y, p.z * p.z); \n \n                 \n \n                 \n \n                for (int u = 1; u <= r; u++) { \n                    const auto& p0 = srcSampler(x - u, y); \n                    const auto& p1 = srcSampler(x + u, y); \n \n                    vec3 wr0 = vec3( \n                        kernelR(abs(p0.r - p.r), sigmaR), \n                        kernelR(abs(p0.g - p.g), sigmaR), \n                        kernelR(abs(p0.b - p.b), sigmaR)); \n                    vec3 wr1 = vec3( \n                        kernelR(abs(p1.r - p.r), sigmaR), \n                        kernelR(abs(p1.g - p.g), sigmaR), \n                        kernelR(abs(p1.b - p.b), sigmaR)); \n \n                    const auto& d0 = depthSampler(x - u, y); \n                    const auto& d1 = depthSampler(x + u, y); \n \n                    const real dd0 = kernelD(d0.w - dc, sigmaD); \n                    const real dd1 = kernelD(d1.w - dc, sigmaD); \n \n                    numer += kernelS(distW, u, 0) * (wr0 * dd0 + wr1 * dd1); \n                    auto d = kernelS(distW, u, 0) * (wr0 * vec3(p0) * dd0 + wr1 * vec3(p1) * dd1); \n                    denom += d; \n                    denom2 += d * d; \n                } \n \n                 \n \n                 \n \n                for (int v = 1; v <= r; v++) { \n                    const auto& p0 = srcSampler(x, y - v); \n                    const auto& p1 = srcSampler(x, y + v); \n \n                    vec3 wr0 = vec3( \n                        kernelR(abs(p0.r - p.r), sigmaR), \n                        kernelR(abs(p0.g - p.g), sigmaR), \n                        kernelR(abs(p0.b - p.b), sigmaR)); \n                    vec3 wr1 = vec3( \n                        kernelR(abs(p1.r - p.r), sigmaR), \n                        kernelR(abs(p1.g - p.g), sigmaR), \n                        kernelR(abs(p1.b - p.b), sigmaR)); \n \n                    const auto& d0 = depthSampler(x, y - v); \n                    const auto& d1 = depthSampler(x, y + v); \n \n                    const real dd0 = kernelD(d0.w - dc, sigmaD); \n                    const real dd1 = kernelD(d1.w - dc, sigmaD); \n \n                    numer += kernelS(distW, 0, v) * (wr0 * dd0 + wr1 * dd1); \n                    auto d = kernelS(distW, 0, v) * (wr0 * vec3(p0) * dd0 + wr1 * vec3(p1) * dd1); \n                    denom += d; \n                    denom2 += d * d; \n                } \n \n                for (int v = 1; v <= r; v++) { \n                    for (int u = 1; u <= r; u++) { \n                        const auto& p00 = srcSampler(x - u, y - v); \n                        const auto& p01 = srcSampler(x - u, y + v); \n                        const auto& p10 = srcSampler(x + u, y - v); \n                        const auto& p11 = srcSampler(x + u, y + v); \n \n                        vec3 wr00 = vec3( \n                            kernelR(abs(p00.r - p.r), sigmaR), \n                            kernelR(abs(p00.g - p.g), sigmaR), \n                            kernelR(abs(p00.b - p.b), sigmaR)); \n                        vec3 wr01 = vec3( \n                            kernelR(abs(p01.r - p.r), sigmaR), \n                            kernelR(abs(p01.g - p.g), sigmaR), \n                            kernelR(abs(p01.b - p.b), sigmaR)); \n                        vec3 wr10 = vec3( \n                            kernelR(abs(p10.r - p.r), sigmaR), \n                            kernelR(abs(p10.g - p.g), sigmaR), \n                            kernelR(abs(p10.b - p.b), sigmaR)); \n                        vec3 wr11 = vec3( \n                            kernelR(abs(p11.r - p.r), sigmaR), \n                            kernelR(abs(p11.g - p.g), sigmaR), \n                            kernelR(abs(p11.b - p.b), sigmaR)); \n \n                        const auto& d00 = depthSampler(x - u, y - v); \n                        const auto& d01 = depthSampler(x - u, y + v); \n                        const auto& d10 = depthSampler(x + u, y - v); \n                        const auto& d11 = depthSampler(x + u, y + v); \n \n                        const real dd00 = kernelD(d00.w - dc, sigmaD); \n                        const real dd01 = kernelD(d01.w - dc, sigmaD); \n                        const real dd10 = kernelD(d10.w - dc, sigmaD); \n                        const real dd11 = kernelD(d11.w - dc, sigmaD); \n \n                        numer += kernelS(distW, u, v) * (wr00 * dd00 + wr01 * dd01 + wr10 * dd10 + wr11 * dd11); \n                        auto d = kernelS(distW, u, v) * (wr00 * vec3(p00) * dd00 + wr01 * vec3(p01) * dd01 + wr10 * vec3(p10) * dd10 + wr11 * vec3(p11) * dd11); \n                        denom += d; \n                        denom2 += d * d; \n                    } \n                } \n \n                auto v = denom / numer; \n                dstSampler(x, y) = vec4(v, 1); \n \n                auto v2 = denom2 / (numer * numer); \n                v2 -= v * v; \n                varSampler.set(x, y, vec4(v2, 1)); \n            } \n        }", "pragma": "parallel for ", "hash": "17992d3d997d1933f95c50c6a13eda36027dda83b518b23b778b97b978aea574"}
{"code": "for (i = 0; i < npixels; i++) { \n\t\tdu[i] += ud[i]; \n\t}", "pragma": "parallel for ", "hash": "2a39eb2b71d1379eec224417ec8542e77ed4c2376d41786c6a9ebad0613d0189"}
{"code": "for(int j = 0; j < height; j++) \n  { \n    dt_aligned_pixel_t xp = {0.0f}; \n    dt_aligned_pixel_t yb = {0.0f}; \n    dt_aligned_pixel_t yp = {0.0f}; \n \n     \n \n    for(int k = 0; k < ch; k++) \n    { \n      xp[k] = CLAMPF(temp[(size_t)j * width * ch + k], Labmin[k], Labmax[k]); \n      yb[k] = xp[k] * coefp; \n      yp[k] = yb[k]; \n    } \n \n    dt_aligned_pixel_t xc = {0.0f}; \n    dt_aligned_pixel_t yc = {0.0f}; \n    dt_aligned_pixel_t xn = {0.0f}; \n    dt_aligned_pixel_t xa = {0.0f}; \n    dt_aligned_pixel_t yn = {0.0f}; \n    dt_aligned_pixel_t ya = {0.0f}; \n \n    for(int i = 0; i < width; i++) \n    { \n      size_t offset = ((size_t)j * width + i) * ch; \n \n      for(int k = 0; k < ch; k++) \n      { \n        xc[k] = CLAMPF(temp[offset + k], Labmin[k], Labmax[k]); \n        yc[k] = (a0 * xc[k]) + (a1 * xp[k]) - (b1 * yp[k]) - (b2 * yb[k]); \n \n        out[offset + k] = yc[k]; \n \n        xp[k] = xc[k]; \n        yb[k] = yp[k]; \n        yp[k] = yc[k]; \n      } \n    } \n \n     \n \n    for(int k = 0; k < ch; k++) \n    { \n      xn[k] = CLAMPF(temp[((size_t)(j + 1) * width - 1) * ch + k], Labmin[k], Labmax[k]); \n      xa[k] = xn[k]; \n      yn[k] = xn[k] * coefn; \n      ya[k] = yn[k]; \n    } \n \n    for(int i = width - 1; i > -1; i--) \n    { \n      size_t offset = ((size_t)j * width + i) * ch; \n \n      for(int k = 0; k < ch; k++) \n      { \n        xc[k] = CLAMPF(temp[offset + k], Labmin[k], Labmax[k]); \n \n        yc[k] = (a2 * xn[k]) + (a3 * xa[k]) - (b1 * yn[k]) - (b2 * ya[k]); \n \n        xa[k] = xn[k]; \n        xn[k] = xc[k]; \n        ya[k] = yn[k]; \n        yn[k] = yc[k]; \n \n        out[offset + k] += yc[k]; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "275bcc149d8115286f0fd23a54b8f26e23a0e45a6bb924f0d5d02cd576d75b96"}
{"code": "for (i = 0; i < gameStates.app.nThreads; i++) { \n\t\t\tComputeThreadRange (i, gameData.segData.nVertices, nStart, nEnd); \n\t\t\tlightManager.GatherStaticVertexLights (nStart, nEnd, i); \n\t\t\t}", "pragma": "parallel for private( nend nstart)", "hash": "1d984cf7a67b9d99baed1967a34daab583ac0fe7333d0e1d1799ebe34af053b6"}
{"code": "for (int j = 0; j < number_of_points; j++) { \n                 \n \n \n                double transformedPoint[3]; \n \n                double this_t = traj_vec_.at(this_traj).GetTimeAtIndex(j); \n \n                traj_vec_.at(this_traj).GetXyzYawTransformedPoint(this_t, body_to_local, transformedPoint); \n \n                 \n \n \n                point_distances.at(j) = octomap.NearestNeighbor(transformedPoint); \n \n                 \n \n \n            }", "pragma": "parallel for ", "hash": "fdbcb42e0e2d35ea977ae9fb1b359f183011e0e7e4283c2a178087d637d637cb"}
{"code": "for (int feature_index = 0; feature_index < num_features_; ++feature_index) { \n \n    if (smaller_is_feature_aggregated_[feature_index]) { \n       \n \n      smaller_leaf_histogram_array_global_[feature_index].FromMemory( \n        output_buffer_.data() + smaller_buffer_read_start_pos_[feature_index]); \n       \n \n      smaller_leaf_histogram_array_global_[feature_index].FindBestThreshold( \n        smaller_leaf_splits_global_->sum_gradients(), \n        smaller_leaf_splits_global_->sum_hessians(), \n        GetGlobalDataCountInLeaf(smaller_leaf_splits_global_->LeafIndex()), \n        &smaller_leaf_splits_global_->BestSplitPerFeature()[feature_index]); \n    } \n \n    if (larger_is_feature_aggregated_[feature_index]) { \n       \n \n      larger_leaf_histogram_array_global_[feature_index].FromMemory(output_buffer_.data() + larger_buffer_read_start_pos_[feature_index]); \n       \n \n      larger_leaf_histogram_array_global_[feature_index].FindBestThreshold( \n        larger_leaf_splits_global_->sum_gradients(), \n        larger_leaf_splits_global_->sum_hessians(), \n        GetGlobalDataCountInLeaf(larger_leaf_splits_global_->LeafIndex()), \n        &larger_leaf_splits_global_->BestSplitPerFeature()[feature_index]); \n    } \n  }", "pragma": "parallel for ", "hash": "1ec3710aa8df4a4795f488cc133757def3a86ae969d5fea3cebd4c19e69a1cdf"}
{"code": "for(int l = 0; l < loci; l++){ \n \n      #pragma omp critical \n      { \n        while(newVals[l] < 0 || newVals[l] > 1){ \n          newVals[l] = r->normalRv(vals[l], tune); \n        } \n      } \n \n      newLogLiks[l] = calcLogLik(gLiks, ind, l, ploidy, newVals[l]); \n \n       \n \n \n      lnMetropRatio = (newLogLiks[l] + (aa - 1)*log(newVals[l]) + (bb - 1)*log(1 - newVals[l])) \n                      - (currLogLiks[l]  + (aa - 1)*log(vals[l]) + (bb - 1)*log(1 - vals[l])); \n       \n \n      lnU = log(r->uniformRv()); \n \n       \n \n       \n \n      if(lnU < lnMetropRatio){ \n        vals[l] = newVals[l]; \n        currLogLiks[l] = newLogLiks[l]; \n        nAccepted[l]++; \n        nProposals[l]++; \n        acceptRatio[l] = nAccepted[l] / (double) nProposals[l]; \n      } else { \n        nProposals[l]++; \n        acceptRatio[l] = nAccepted[l] / (double) nProposals[l]; \n      } \n     \n \n \n    }", "pragma": "for ", "hash": "46a6b714fbb342d7ca6dd5fcee8a7a30b8a777cee5ce79e2a500edf0c5b0a458"}
{"code": "for (i = 0; i < row; i++) { \n            for (j = 0; j < col; j++) { \n                size_t index_in = i*col + j; \n                size_t index_out = j*row + i; \n                out_0[index_out] = in_0[index_in]; \n                out_1[index_out] = in_1[index_in]; \n            } \n        }", "pragma": "parallel for private(i j)", "hash": "4adf0a39cb0812b56eb42b99785a423d87806186cba2b5949d245a757cdb5120"}
{"code": "for (int i = 0; i < 10; i++) { \n    for (int j = 0; j < 10; j++) { \n      c[i] = a[i] + b[i]; \n      if (c[i] > 10) { \n        if (c[i] < 20) { \n          break;  \n \n        } \n      } \n    } \n  }", "pragma": "for simd ", "hash": "bfb334f6188b2dcb24b4e44626429b6fa89347f05d7324263b6cbb35fcc4e0ef"}
{"code": "for(int i = 0; i < totalSize;i++) { \n                        if(centerlines[i] == secondConnection) \n                            centerlines[i] = prevConnection; \n                    }", "pragma": "parallel for ", "hash": "3f980f251d2deb0f88263b7007287a3a2bc3b475a4736f5ac2fe89c2daf0cc7e"}
{"code": "for (i = 0; i < lnpoints; i++) \n\t{ \n\t\tdistance = vector_distance(CENTROID(map[i]), POINT(i)); \n\t\t \n\t\t \n \n\t\tfor (j = 0; j < ncentroids; j++) \n\t\t{ \n\t\t\t \n \n\t\t\tif (j == map[i]) \n\t\t\t\tcontinue; \n\t\t\t\t \n\t\t\ttmp = vector_distance(CENTROID(j), POINT(i)); \n\t\t\t \n\t\t\t \n \n\t\t\tif (tmp < distance) \n\t\t\t{ \n\t\t\t\tmap[i] = j; \n\t\t\t\tdistance = tmp; \n\t\t\t} \n\t\t} \n\t\t \n\t\t \n \n\t\tif (distance > mindistance) \n\t\t\ttoo_far[rank*NUM_THREADS + omp_get_thread_num()] = 1; \n\t}", "pragma": "parallel for private(   distance i j tmp)", "hash": "5ce0dca553c1726767ea10a927d2041deb5685d249faec5ee8aac51d0b739555"}
{"code": "for( i = 0 ; i < LCU ; i++ ) { \n\tconst size_t it = slice + i ;  \n\tsize_t mu , list_dirs[ directions - lev ] , d ; \n\tfor( mu = 0 ; mu < directions ; mu++ ) { \n\t  for( d = 0 ; d < directions-lev ; d++ ) { list_dirs[d] = mu ; } \n\t  recurse_staples( lat2[i].O[mu] , lat , it , lev ,  \n\t\t\t   directions , list_dirs , type , project ) ;  \n\t} \n      }", "pragma": "for private(i)", "hash": "74eb8c00c6dd2c5053d3825243efb493c18e269c10e625a95e9cbfa44402ae02"}
{"code": "for (phase = 0; phase < n; phase++) { \n      if (phase % 2 == 0) \n#        pragma omp for  \n         for (i = 1; i < n; i += 2) { \n            if (a[i-1] > a[i]) { \n               tmp = a[i-1]; \n               a[i-1] = a[i]; \n               a[i] = tmp; \n            } \n         } \n      else \n#        pragma omp for  \n         for (i = 1; i < n-1; i += 2) { \n            if (a[i] > a[i+1]) { \n               tmp = a[i+1]; \n               a[i+1] = a[i]; \n               a[i] = tmp; \n            } \n         } \n   }", "pragma": "parallel private(  i phase tmp)", "hash": "3485c07b53faa02d09042bb273de306b22522a043cff405cf1dbb9f610db2e97"}
{"code": "for (int iImageType=0; iImageType<3; iImageType++) { \n\t\t\t\t \n \n\t\t\t\tif (iImageType==0 && mUseHOG) { \n\t\t\t\t\tvector<Mat> hogIImage; \n\t\t\t\t\tmHog->calcHogIImage(grayPyramid[p], hogIImage); \n\t\t\t\t\thogIImagePyramid[p] = hogIImage; \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\tif (iImageType==1 && mUseHOF) { \n\t\t\t\t\tvector<Mat> hofIImage; \n\t\t\t\t\tmHof->calcHofIImage(flow, hofIImage); \n\t\t\t\t\thofIImagePyramid[p] = hofIImage; \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\tif (iImageType==2 && mUseMBH) { \n\t\t\t\t\tvector<Mat> mbhxIImage; \n\t\t\t\t\tvector<Mat> mbhyIImage; \n\t\t\t\t\tmMbh->calcMbhIImage(flow, mbhxIImage, mbhyIImage); \n\t\t\t\t\tmbhxIImagePyramid[p] = mbhxIImage; \n\t\t\t\t\tmbhyIImagePyramid[p] = mbhyIImage; \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "2bb50e7defef6cd6bf181aa795857e9d3e2a6c168433d86b46d954c6a2cce469"}
{"code": "for(size_t i=0; i<precomp->n; i++) { \n    fmpz_mul(rop->coeffs+i, precomp->phi->coeffs+i, op->coeffs+i); \n    fmpz_mod(rop->coeffs+i, rop->coeffs+i, q); \n  }", "pragma": "parallel for ", "hash": "1ecf16d95aa9db3e5b4ac79540ebe0db3a7284f22e5b0f8eae5302ac94cd5aeb"}
{"code": "for(L=0;L<N;L++){ \n\t \n\t\ttermo_linha[L] = A[L*N+0] * A[L*N+1]; \n\t\t \n\t\tfor(K=1;K<P;K++) \n\t\t\ttermo_linha[L]+= A[L*N+2*K] * A[L*N+2*K+1]; \n\t}", "pragma": "parallel for private(k l p)", "hash": "1bef069c6622b155cf06aa260b8a26bbc30a642f9e61704aaf3339037103e845"}
{"code": "for(int i = nmask_from; i < nmask_to; i++) \n  { \n    const int j0 = Aidx[i * 5 + 0]; \n    const int j1 = Aidx[i * 5 + 1]; \n    const int j2 = Aidx[i * 5 + 2]; \n    const int j3 = Aidx[i * 5 + 3]; \n    const int j4 = Aidx[i * 5 + 4]; \n    const float a = Adiag[i]; \n \n    for(int k = 0; k < ch1; k++) \n    { \n      const float diff \n          = w * (a * pixels[j0 + k] - (pixels[j1 + k] + pixels[j2 + k] + pixels[j3 + k] + pixels[j4 + k])); \n \n      pixels[j0 + k] -= diff; \n      err += diff * diff; \n    } \n  }", "pragma": "parallel for reduction(+ : err) ", "hash": "a65d09c996feaf0c637e7efd69cd3441a1d7dfbb07b4b6b957b9d5380ac81790"}
{"code": "for (ompIndexType k = 0; k < s; k++) { \n            ptrLength[k] = static_cast<double>(wstr[k].length()); \n        }", "pragma": "parallel for ", "hash": "b25115129e60088be7568a79cc5e4b6fc92d75b9af52bc28446c84c22b723adc"}
{"code": "for (int i = 0; i < Nv; i++) \n    { \n        assignment_locs[i] = regions[assignments[i]]; \n    }", "pragma": "parallel for ", "hash": "c19a2bd607c32f40b2aa2fca94a9e92024c5cacf1dfae5ac5367dea8744eb48a"}
{"code": "for (int t = cv * each_fold_num; \r \n                t < cv * each_fold_num + train_fold_num * each_fold_num; t ++) {\r \n                size_t j = t % _d_M;   \n \n                real_t prod_r0 = 0.0;\r \n                real_t prod_r1 = 0.0;\r \n                 \n \n                for (int k = 0; k < _d_J; k ++) {\r \n                    real_t beta_var = beta(_alpha[k], _data_labels[j][k]);\r \n                    prod_r0 += log(_Q[k][0] * beta_var + \r \n                        1 - _Q[k][0]);\r \n                    prod_r1 += log(_Q[k][1] * beta_var + \r \n                        1 - _Q[k][1]);\r \n\r \n                    RZ_0[j][k] = _Q[k][0] * beta_var / (_Q[k][0] * beta_var +\r \n                        1 - _Q[k][0]);\r \n                    RZ_1[j][k] = _Q[k][1] * beta_var / (_Q[k][1] * beta_var +\r \n                        1 - _Q[k][1]);\r \n                }\r \n                prod_r0 = (1 - pred_1[j]) * exp(prod_r0);\r \n                prod_r1 = pred_1[j] * exp(prod_r1);\r \n\r \n                R_1[j] = prod_r1 / (prod_r0 + prod_r1);\r \n                sum_r1 += R_1[j] * _data_mat_train->info.labels[j];\r \n                sum_weight_total += _data_mat_train->info.labels[j];\r \n\r \n                for (int k = 0; k < _d_J; k ++) {\r \n                    RZ_0[j][k] *= (1 - R_1[j]);\r \n                    RZ_1[j][k] *= R_1[j];\r \n                }\r \n            }", "pragma": "parallel for reduction(+:sum_r1 sum_weight_total) ", "hash": "3880712f62503f6efe24223ef44c155d122f7951dad980e0c7efae322e2ac91a"}
{"code": "for(int k=0; k<roi_out->width*roi_out->height; k++) \n  { \n    out[k*ch+0] = CLAMPF(out[k*ch+0]*data->contrast + 50.0f * (1.0f - data->contrast), Labmin[0], Labmax[0]); \n    out[k*ch+1] = CLAMPF(out[k*ch+1]*data->saturation, Labmin[1], Labmax[1]); \n    out[k*ch+2] = CLAMPF(out[k*ch+2]*data->saturation, Labmin[2], Labmax[2]); \n    out[k*ch+3] = CLAMPF(out[k*ch+3], Labmin[3], Labmax[3]); \n  }", "pragma": "parallel for ", "hash": "6e35e9b9e2d94cbef3a26a0b76f66e9c8571ce9b0deb67a0280317a0496354fc"}
{"code": "for (ix=ioZx; ix<nx+1; ix++) { \n#pragma ivdep \n\t\tfor (iz=ioZz; iz<nz+1; iz++) { \n\t\t\ttz[ix*n1+iz] -= mul[ix*n1+iz]*( \n\t\t\t\t\t\tc1*(vz[ix*n1+iz]   - vz[ix*n1+iz-1]) + \n\t\t\t\t\t\tc2*(vz[ix*n1+iz+1] - vz[ix*n1+iz-2])); \n\t\t} \n\t}", "pragma": "for private( ix iz)", "hash": "dceafce36a02b91f9ad7e33b0dcffdabe22c92328eecf3774f29702eb3fb703b"}
{"code": "for (int y = 0; y < sdf.height; ++y) { \n            int row = shape.inverseYAxis ? sdf.height-y-1 : y; \n            for (int col = 0; col < sdf.width; ++col) { \n                int x = rightToLeft ? sdf.width-col-1 : col; \n                if ((*stencil(x, row)&ERROR)) \n                    continue; \n                const float *c = sdf(x, row); \n                shapeDistanceChecker.shapeCoord = projection.unproject(Point2(x+.5, y+.5)); \n                shapeDistanceChecker.sdfCoord = Point2(x+.5, row+.5); \n                shapeDistanceChecker.msd = c; \n                shapeDistanceChecker.protectedFlag = (*stencil(x, row)&PROTECTED) != 0; \n                float cm = median(c[0], c[1], c[2]); \n                const float *l = NULL, *b = NULL, *r = NULL, *t = NULL; \n                 \n \n                *stencil(x, row) |= (byte) (ERROR*( \n                    (x > 0 && ((l = sdf(x-1, row)), hasLinearArtifact(shapeDistanceChecker.classifier(Vector2(-1, 0), hSpan), cm, c, l))) || \n                    (row > 0 && ((b = sdf(x, row-1)), hasLinearArtifact(shapeDistanceChecker.classifier(Vector2(0, -1), vSpan), cm, c, b))) || \n                    (x < sdf.width-1 && ((r = sdf(x+1, row)), hasLinearArtifact(shapeDistanceChecker.classifier(Vector2(+1, 0), hSpan), cm, c, r))) || \n                    (row < sdf.height-1 && ((t = sdf(x, row+1)), hasLinearArtifact(shapeDistanceChecker.classifier(Vector2(0, +1), vSpan), cm, c, t))) || \n                    (x > 0 && row > 0 && hasDiagonalArtifact(shapeDistanceChecker.classifier(Vector2(-1, -1), dSpan), cm, c, l, b, sdf(x-1, row-1))) || \n                    (x < sdf.width-1 && row > 0 && hasDiagonalArtifact(shapeDistanceChecker.classifier(Vector2(+1, -1), dSpan), cm, c, r, b, sdf(x+1, row-1))) || \n                    (x > 0 && row < sdf.height-1 && hasDiagonalArtifact(shapeDistanceChecker.classifier(Vector2(-1, +1), dSpan), cm, c, l, t, sdf(x-1, row+1))) || \n                    (x < sdf.width-1 && row < sdf.height-1 && hasDiagonalArtifact(shapeDistanceChecker.classifier(Vector2(+1, +1), dSpan), cm, c, r, t, sdf(x+1, row+1))) \n                )); \n            } \n        }", "pragma": "for ", "hash": "1507199d01658731510e887134552c258e9d555322bc471e81d0ee26169f5336"}
{"code": "for(long j=0;j<n;j++)\trk.dd->a[j] = rk.din.a[j] + hh*rk.d1.a[j];", "pragma": "parallel for ", "hash": "f904ad601ead5629f3fdae868e852118a98e4a78b095de34f878e971eb400727"}
{"code": "for(int y=0;y<rows;y++) \n\t\t\tfor (int x=0;x<cols;x++) \n\t\t\t{ \n\t\t\t\tfloat j0[4],j1[4];\t\t\t \n\t\t\t\tfloat vx_x,vy_x; \n\t\t\t\tfloat vx_y,vy_y; \n\t\t\t\tif(x==0) \n\t\t\t\t{ \n\t\t\t\t\tvx_x=_vector[z].at<Vec2f>(y,x+1)[0]-_vector[z].at<Vec2f>(y,x)[0]; \n\t\t\t\t\tvy_x=_vector[z].at<Vec2f>(y,x+1)[1]-_vector[z].at<Vec2f>(y,x)[1]; \n\t\t\t\t} \n\t\t\t\telse  \n\t\t\t\t{ \n\t\t\t\t\tvx_x=_vector[z].at<Vec2f>(y,x)[0]-_vector[z].at<cv::Vec2f>(y,x-1)[0]; \n\t\t\t\t\tvy_x=_vector[z].at<Vec2f>(y,x)[1]-_vector[z].at<cv::Vec2f>(y,x-1)[1]; \n\t\t\t\t} \n \n\t\t\t\tj0[0]=1.0f-vx_x; \n\t\t\t\tj0[2]=-vy_x; \n\t\t\t\tj1[0]=1.0f+vx_x; \n\t\t\t\tj1[2]=vy_x; \n \n\t\t\t\tif(y==0) \n\t\t\t\t{ \n\t\t\t\t\tvx_y=_vector[z].at<Vec2f>(y+1,x)[0]-_vector[z].at<Vec2f>(y,x)[0]; \n\t\t\t\t\tvy_y=_vector[z].at<Vec2f>(y+1,x)[1]-_vector[z].at<Vec2f>(y,x)[1]; \n \n\t\t\t\t} \n\t\t\t\telse  \n\t\t\t\t{ \n\t\t\t\t\tvx_y=_vector[z].at<Vec2f>(y,x)[0]-_vector[z].at<Vec2f>(y-1,x)[0]; \n\t\t\t\t\tvy_y=_vector[z].at<Vec2f>(y,x)[1]-_vector[z].at<Vec2f>(y-1,x)[1]; \n\t\t\t\t} \n \n \n\t\t\t\tj0[1]=-vx_y; \n\t\t\t\tj0[3]=1.0f-vy_y; \n\t\t\t\tj1[1]=vx_y; \n\t\t\t\tj1[3]=1.0f+vy_y; \n \n\t\t\t\t \n \n\t\t\t\tfloat nj0[4],nj1[4]; \n\t\t\t\tfloat la0,lb0,la1,lb1; \n\t\t\t\tla0=sqrt(j0[0]*j0[0]+j0[2]*j0[2]);\t \n\t\t\t\tlb0=sqrt(j0[1]*j0[1]+j0[3]*j0[3]); \n\t\t\t\tnj0[0]=j0[0]/la0; \n\t\t\t\tnj0[2]=j0[2]/la0; \n\t\t\t\tnj0[1]=j0[1]/lb0; \n\t\t\t\tnj0[3]=j0[3]/lb0; \n \n\t\t\t\tla1=sqrt(j1[0]*j1[0]+j1[2]*j1[2]);\t \n\t\t\t\tlb1=sqrt(j1[1]*j1[1]+j1[3]*j1[3]); \n\t\t\t\tnj1[0]=j1[0]/la1; \n\t\t\t\tnj1[2]=j1[2]/la1; \n\t\t\t\tnj1[1]=j1[1]/lb1; \n\t\t\t\tnj1[3]=j1[3]/lb1; \n \n\t\t\t\t \n \n\t\t\t\tfloat nj_opt[4]; \n\t\t\t\tfor(int i=0;i<4;i++) \n\t\t\t\t\tnj_opt[i]=nj0[i]+nj1[i]; \n\t\t\t\tfloat la_opt=sqrt(nj_opt[0]*nj_opt[0]+nj_opt[2]*nj_opt[2]); \n\t\t\t\tfloat lb_opt=sqrt(nj_opt[1]*nj_opt[1]+nj_opt[3]*nj_opt[3]);\t\t\t \n \n \n\t\t\t\tnj_opt[0]/=la_opt; \n\t\t\t\tnj_opt[2]/=la_opt; \n\t\t\t\tnj_opt[1]/=lb_opt; \n\t\t\t\tnj_opt[3]/=lb_opt; \n \n\t\t\t\t \n \n\t\t\t\tla_opt=sqrt(la0*la1); \n\t\t\t\tlb_opt=sqrt(lb0*lb1); \n \n\t\t\t\tint index=y*cols*4+x*4; \n\t\t\t\tj_opt[index+0]=nj_opt[0]*la_opt; \n\t\t\t\tj_opt[index+2]=nj_opt[2]*la_opt; \n\t\t\t\tj_opt[index+1]=nj_opt[1]*lb_opt; \n\t\t\t\tj_opt[index+3]=nj_opt[3]*lb_opt; \n\t\t\t}", "pragma": "parallel for ", "hash": "46158aec91bf7ef597e0ddd48b0d47ac3ebed5edcd87e0723ca9c51f02b27106"}
{"code": "for (ompIndexType k = 0; k < elementCount; k++) { \n            Cz[k] = Az[0] * Bz[k]; \n        }", "pragma": "parallel for ", "hash": "6a6cf70812dc073be0ee561b20d6645dc6951ef50cc59679427000077c4af53f"}
{"code": "for (p = 0; p < batchSize; p++) { \n\t\tnn_SpatialMaxPooling_updateOutput_frame(input_data+p*nslices*iwidth*iheight, \n\t\t\toutput_data+p*nslices*owidth*oheight, \n\t\t\tnslices, iwidth, iheight, owidth, oheight, \n\t\t\tkW, kH, dW, dH, padW, padH); \n\t}", "pragma": "parallel for private(p)", "hash": "a63534c74f12645a5ae007bb9d4c614b975ab0aa8d1b58890506a5399fc9b6af"}
{"code": "for (i = 0; i < ncols; i++) { \n                    cscale[i] = (collen[i] > 0 ? log(1.0 * (nrows + 2 * bgfreq) / (bgfreq + collen[i])) : 0.0); \n                }", "pragma": "for ", "hash": "0c14b29702cc3990d5e63c514c11479ca3e23679cfe8412e87352e60910230f1"}
{"code": "for         (iy=NOP; iy<fdm->nypad-NOP; iy++) {\t\t\t\t \n\t\t    for     (ix=NOP; ix<fdm->nxpad-NOP; ix++) { \n\t\t\tfor (iz=NOP; iz<fdm->nzpad-NOP; iz++) {\t \n\t\t\t     \n \n\t\t\t    ua[iy][ix  ][iz]  +=  \n\t\t\t\tf1x*(uat[iy][ix  ][iz]  -   \n\t\t\t\t     uat[iy][ix+1][iz]) +  \n\t\t\t\tf2x*(uat[iy][ix-1][iz] -  \n\t\t\t\t     uat[iy][ix+2][iz]);  \n\t\t\t} \n\t\t    } \n\t\t}", "pragma": "for ", "hash": "16063f1ae63c76d1bde089123c4f22c02c86793e386b5bbcd2c2dd3341bed84d"}
{"code": "for (i = 0; i < nelem; i++) \n    { \n        elem[i].wf.prcp         = 0.0; \n        elem[i].es.sfctmp       = 0.0; \n        elem[i].ps.rh           = 0.0; \n        elem[i].ps.sfcspd       = 0.0; \n        elem[i].ef.soldn        = 0.0; \n        elem[i].ef.longwave     = 0.0; \n        elem[i].ps.sfcprs       = 0.0; \n \n        elem[i].weather.tmp_max = -DBL_MAX; \n        elem[i].weather.tmp_min = DBL_MAX; \n        elem[i].weather.rh_min  = DBL_MAX; \n    }", "pragma": "parallel for ", "hash": "944761d939203887a4982f58f2c52a24125ec4d077dffcbb9ae6c60a391a72d8"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp target parallel  \n \n    ++a; \n  }", "pragma": "for simd ", "hash": "21fc9c0ce08c6348b11c5a96f75dd8cfef4328c5b048d2f7e590d53783d63d3e"}
{"code": "for (int t = 0; t < m_hp->m_num_trees; t++) \n\t\t\tm_trees[t]->UpdateLeafStatistics(outbag_dataset[t]);", "pragma": "parallel for ", "hash": "1da51aa945fe8d798e9af04601526cd2934d50fcce4737aeaab3ea9bf3a12682"}
{"code": "for(i=0; i<size; i++){ \n    result = result + v1[i] * v2[i]; \n  }", "pragma": "parallel for reduction(+:result) private(i)", "hash": "3b0b176f137f362667c1e5d2e58109e778405a2ccee0ce8cf827efab2772926a"}
{"code": "for (i = 0; i < sz; i++) \n        out_tensor[i] = in_tensor_l[i] + in_tensor_r[i];", "pragma": "parallel for private(i)", "hash": "0e12da118ab2f97cf1e6593205b6e2cbba258f6f89cf614ac061857da6868234"}
{"code": "for (j=0; j<array_elements; j++) \n    a[j] = b[j]+scalar*c[j];", "pragma": "parallel for ", "hash": "69eb3c781459773aa02319af5498addeeb8cf755bf8f35a14f8ebb062315fff9"}
{"code": "for (ii = 0; ii < (omp_size_t)( size / block_size ); ii ++) { \n        count = fun(&C, block_size, elem_size, option); \n        if (count < 0) err = count; \n        cum_count += count; \n    }", "pragma": "parallel for reduction(+ : cum_count) private(count)", "hash": "799f35e8a31dd1450f07e5a3dccc2ba4bf6deeb64c3086611817093df5eab5a9"}
{"code": "for(int x = 0; x < N*T; x++) \n\t\t{ \n\t\t\tint i = order[x%N]; \n\t\t\tint j = x/N; \n \n\t\t\twhile(Forest[i]->iteration < j); \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tForest[i]->next(); \n\t\t\tdouble metric = Forest[i]->calculateMetric(); \n\t\t\t \n \n\t\t\t \n \n\t\t\t\tmetrics[j][i] = metric; \n\t\t\t \n \n\t\t}", "pragma": "for ", "hash": "e41c53eeb3f26ee330673a275a41172adefa73cad11d9b9b93b74ee5df63fba6"}
{"code": "for (int ii = 0; ii < inum; ii++) { \n    const int tid = omp_get_thread_num(); \n    const int i = ilist[ii]; \n    if (mask[i] & groupbit) { \n \n      const double xtmp = x[i][0]; \n      const double ytmp = x[i][1]; \n      const double ztmp = x[i][2]; \n      const int itype = type[i]; \n      const double radi = radelem[itype]; \n \n      const int* const jlist = firstneigh[i]; \n      const int jnum = numneigh[i]; \n \n      const int typeoffset = sixncoeff*(atom->type[i]-1); \n      const int quadraticoffset = sixncoeff*atom->ntypes + \n        sixncoeffq*(atom->type[i]-1); \n \n       \n \n \n          snaptr[tid]->grow_rij(jnum); \n \n       \n \n       \n \n       \n \n       \n \n \n      int ninside = 0; \n      for (int jj = 0; jj < jnum; jj++) { \n        int j = jlist[jj]; \n        j &= NEIGHMASK; \n \n        const double delx = x[j][0] - xtmp; \n        const double dely = x[j][1] - ytmp; \n        const double delz = x[j][2] - ztmp; \n        const double rsq = delx*delx + dely*dely + delz*delz; \n        int jtype = type[j]; \n        if (rsq < cutsq[itype][jtype]&&rsq>1e-20) { \n          snaptr[tid]->rij[ninside][0] = delx; \n          snaptr[tid]->rij[ninside][1] = dely; \n          snaptr[tid]->rij[ninside][2] = delz; \n          snaptr[tid]->inside[ninside] = j; \n          snaptr[tid]->wj[ninside] = wjelem[jtype]; \n          snaptr[tid]->rcutij[ninside] = (radi+radelem[jtype])*rcutfac; \n          ninside++; \n        } \n      } \n \n      snaptr[tid]->compute_ui(ninside); \n      snaptr[tid]->compute_zi(); \n      if (quadraticflag) { \n        snaptr[tid]->compute_bi(); \n        snaptr[tid]->copy_bi2bvec(); \n      } \n \n      for (int jj = 0; jj < ninside; jj++) { \n        const int j = snaptr[tid]->inside[jj]; \n \n        snaptr[tid]->compute_duidrj(snaptr[tid]->rij[jj], \n                                    snaptr[tid]->wj[jj], \n                                    snaptr[tid]->rcutij[jj]); \n        snaptr[tid]->compute_dbidrj(); \n        snaptr[tid]->copy_dbi2dbvec(); \n \n         \n \n \n        double *snavi = snav[i]+typeoffset; \n        double *snavj = snav[j]+typeoffset; \n \n        for (int icoeff = 0; icoeff < ncoeff; icoeff++) { \n          snavi[icoeff]             += snaptr[tid]->dbvec[icoeff][0]*xtmp; \n          snavi[icoeff+ncoeff]      += snaptr[tid]->dbvec[icoeff][1]*ytmp; \n          snavi[icoeff+twoncoeff]   += snaptr[tid]->dbvec[icoeff][2]*ztmp; \n          snavi[icoeff+threencoeff] += snaptr[tid]->dbvec[icoeff][1]*ztmp; \n          snavi[icoeff+fourncoeff]  += snaptr[tid]->dbvec[icoeff][0]*ztmp; \n          snavi[icoeff+fivencoeff]  += snaptr[tid]->dbvec[icoeff][0]*ytmp; \n          snavj[icoeff]             -= snaptr[tid]->dbvec[icoeff][0]*x[j][0]; \n          snavj[icoeff+ncoeff]      -= snaptr[tid]->dbvec[icoeff][1]*x[j][1]; \n          snavj[icoeff+twoncoeff]   -= snaptr[tid]->dbvec[icoeff][2]*x[j][2]; \n          snavj[icoeff+threencoeff] -= snaptr[tid]->dbvec[icoeff][1]*x[j][2]; \n          snavj[icoeff+fourncoeff]  -= snaptr[tid]->dbvec[icoeff][0]*x[j][2]; \n          snavj[icoeff+fivencoeff]  -= snaptr[tid]->dbvec[icoeff][0]*x[j][1]; \n        } \n \n        if (quadraticflag) { \n          double *snavi = snav[i]+quadraticoffset; \n          double *snavj = snav[j]+quadraticoffset; \n          int ncount = 0; \n          for (int icoeff = 0; icoeff < ncoeff; icoeff++) { \n            double bi = snaptr[tid]->bvec[icoeff]; \n            double bix = snaptr[tid]->dbvec[icoeff][0]; \n            double biy = snaptr[tid]->dbvec[icoeff][1]; \n            double biz = snaptr[tid]->dbvec[icoeff][2]; \n \n             \n \n \n            for (int jcoeff = icoeff; jcoeff < ncoeff; jcoeff++) { \n              double dbxtmp = bi*snaptr[tid]->dbvec[jcoeff][0] \n                + bix*snaptr[tid]->bvec[jcoeff]; \n              double dbytmp = bi*snaptr[tid]->dbvec[jcoeff][1] \n                + biy*snaptr[tid]->bvec[jcoeff]; \n              double dbztmp = bi*snaptr[tid]->dbvec[jcoeff][2] \n                + biz*snaptr[tid]->bvec[jcoeff]; \n              snavi[ncount] +=               dbxtmp*xtmp; \n              snavi[ncount+ncoeffq] +=      dbytmp*ytmp; \n              snavi[ncount+twoncoeffq] +=   dbztmp*ztmp; \n              snavi[ncount+threencoeffq] += dbytmp*ztmp; \n              snavi[ncount+fourncoeffq] +=  dbxtmp*ztmp; \n              snavi[ncount+fivencoeffq] +=  dbxtmp*ytmp; \n              snavj[ncount] -=               dbxtmp*x[j][0]; \n              snavj[ncount+ncoeffq] -=      dbytmp*x[j][1]; \n              snavj[ncount+twoncoeffq] -=   dbztmp*x[j][2]; \n              snavj[ncount+threencoeffq] -= dbytmp*x[j][2]; \n              snavj[ncount+fourncoeffq] -=  dbxtmp*x[j][2]; \n              snavj[ncount+fivencoeffq] -=  dbxtmp*x[j][1]; \n              ncount++; \n            } \n          } \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "e83b4a6a3a80509a5e4bf36eefd0bf3b31b31754a6047d1ba97c8b2a87bd0d92"}
{"code": "for (size_t i = 0; i < dataset.set_size; i++) { \n      int thread_idx = omp_get_thread_num(); \n \n       \n \n \n      matrix_t t, e; \n      posterior_gradient_t res \n          = posterior_gradient(dataset.sequences[i], task, present, t, e); \n      double p = res.posterior; \n      double x = 0; \n      if (log_class_prior != 0) \n        x = log_class_prior \n            + log(p * class_cond / marginal_motif_prior \n                  + (1 - p) * (1 - class_cond) / (1 - marginal_motif_prior)); \n      if (verbosity >= Verbosity::verbose) \n        cout << \"Sequence \" << dataset.sequences[i].definition << \" p = \" << p \n             << \" class log likelihood = \" << x << \" exp -> \" << exp(x) << endl; \n      double term_a = class_cond / marginal_motif_prior - 1; \n      double term_b = exp(-x) * current_class_prior \n                      / (1 - marginal_motif_prior); \n      double term_c = term_a * term_b; \n \n       \n \n \n      if (not task.targets.transition.empty()) \n        t_g[thread_idx] += term_c * t; \n      if (not task.targets.emission.empty()) \n        e_g[thread_idx] += term_c * e; \n \n      if (task.measure == Measure::ClassificationLikelihood) { \n        if (not task.targets.transition.empty()) { \n           \n \n           \n \n          t_g[thread_idx] \n              += transition_gradient(res.T, task.targets.transition); \n        } \n        if (not task.targets.emission.empty()) { \n           \n \n           \n \n          e_g[thread_idx] += emission_gradient(res.E, task.targets.emission); \n        } \n        x += res.log_likelihood; \n      } \n      if (not isfinite(x)) \n        throw Exception::HMM::Calculation::Infinity(); \n      l += x; \n    }", "pragma": "for reduction(+ : l) ", "hash": "016b7ec478de445371359cb5b8c442f28a933d2f3b6e3aee2a1bc0bed5fca6a6"}
{"code": "for (int i = 0; i < (signed)num_fluid_bodies; i++) { \n        real3 vel; \n        int original_index = data_manager->host_data.particle_indices_3dof[i]; \n         \n \n        vel.x = data_manager->host_data.v[num_rigid_bodies * 6 + num_shafts + i * 3 + 0]; \n        vel.y = data_manager->host_data.v[num_rigid_bodies * 6 + num_shafts + i * 3 + 1]; \n        vel.z = data_manager->host_data.v[num_rigid_bodies * 6 + num_shafts + i * 3 + 2]; \n \n        real speed = Length(vel); \n        if (speed > max_velocity) { \n            vel = vel * max_velocity / speed; \n        } \n        vel_fluid[original_index] = vel; \n        pos_fluid[original_index] += vel * data_manager->settings.step_size; \n         \n \n    }", "pragma": "parallel for ", "hash": "2effacd307691f0136e6f82708da7ffe788383d9c010791c13fff62722cc2d81"}
{"code": "for (t2=lbp;t2<=ubp;t2++) { \n  mean[t2] /= float_n;; \n}", "pragma": "parallel for private(lbv t3 t4 ubv)", "hash": "7c90ecae040c318d0895568a739c61f299e1fe60dd47c7952054d14b020ff34a"}
{"code": "for (data_size_t i = 0; i < num_data; ++i) { \n        score[used_data_indices[i]] += leaf_value_[0]; \n      }", "pragma": "parallel for ", "hash": "c98075566eebfb78922d25329d1d31e6f9fbda8140f2400dc49d866c79e20207"}
{"code": "for (k = 0; k < *ngram_length; ++k) { \n\t\tpercent_complete = 100 * (double)counter/(*ngram_length); \n#pragma omp parallel for \n\t\tfor (j = k; j < *ngram_length; ++j) { \n\t\t\tif (verbose_mode == ON) \n\t\t\t\tprintf(\"Processing Similar Ngrams in Parallel: %d%s complete | Target: %d/%d| Similar: %d/%d     \\r     \", percent_complete, \"%\", k, *ngram_length, j, *ngram_length); \n\t\t\tif (j - k < NGRAM_SIZE) \n\t\t\t\tcontinue; \n\t\t\tif (ng[j]->word.word != NULL && ng[k]->word.word != NULL && strcmp(ng[j]->word.word, ng[k]->word.word) != 0 && ngrams_similar(*ng[k], *ng[j])) \n\t\t\t\tadd_similar_ngram_ref(&ng[k], &ng[j]); \n\t\t} \n\t\t++counter; \n\t}", "pragma": "parallel for ", "hash": "400091e180020ed1af9064fca3bd48212f889844e7225f2f99d227452dc6730d"}
{"code": "for (row=4; row < m_Height-4; row++) { \n    for (col=4, indx=row*m_Width+col; col < m_Width-4; col++, indx++) { \n \n      c =  FC(row,col); \n \n      if (c != 1) { \n        current = 4*m_Image[indx][3] + \n                2*(m_Image[indx+u][3] + m_Image[indx-u][3] + m_Image[indx+1][3] + m_Image[indx-1][3]) + \n                m_Image[indx+v][3] + m_Image[indx-v][3] + m_Image[indx+2][3] + m_Image[indx-2][3]; \n \n        m_Image[indx][1] = ((16-current)*(m_Image[indx-1][1] + m_Image[indx+1][1])/2.0 + current*(m_Image[indx-u][1] + m_Image[indx+u][1])/2.0)/16.0; \n      } \n \n    } \n  }", "pragma": "parallel for private(    c col current indx row)", "hash": "a0a45edf308ecb60d5b1b01aba6631dc5fe9808517e9bac83b059026d5a7d8ac"}
{"code": "for (unsigned int y = 0; y < data_height; y++) { \n        for (unsigned int x = 0; x < data_width; x++) { \n\t\t\t\t\tconst datum class_weight = class_weights_[label_tensor.PixelMaximum(x, y, sample)]; \n          *weight_tensor.data_ptr (x, y, 0, sample) = error_function_ (x, y, data_width, data_height) * class_weight; \n        } \n      }", "pragma": "parallel for ", "hash": "eb31ff1ee8566d0444487360c82c6832dd75cff1dd31dc2e2f064a6e7fc188e0"}
{"code": "for (int i = 0; i < area.cols(); ++i) \n        for (int j = 0; j < area.rows(); ++j) \n        { \n            X(i + j*area.cols(), 0) = 1; \n            X(i + j*area.cols(), 1) = i; \n            X(i + j*area.cols(), 2) = j; \n        }", "pragma": "parallel for ", "hash": "560615899ca56f36f6fd5711e73dccff2fe355e851e02d439a0c40d910adaf24"}
{"code": "for (int64_t i = 0; i < size; ++i) { \n        updateSpectrumDefinitionIfNecessary(i); \n      }", "pragma": "parallel for ", "hash": "f8253338f689420a47f02534efd24e3a94083d7d0200702a54aa08881ed04188"}
{"code": "for (int k = 0; k < argc; ++k) \n    foo();", "pragma": "for private(i)", "hash": "e5c33d370057e295410ea779d2164e062d656b1705e9aa278cf4cf88cd1bc371"}
{"code": "for (row = FC(1,0) >> 1; row < m_Height; row+=2)\r \n        for (col = FC(row,1) & 1; col < m_Width; col+=2)\r \n          m_Image[row*m_Width+col][1] = m_Image[row*m_Width+col][3];", "pragma": "parallel for private( col row)", "hash": "f78a51fd509947485de870b9d54495e98b552c20908c85aecd8417def68d9c4a"}
{"code": "for (ompIndexType i = 0; i < planes; i++) { \n            for (ompIndexType j = 0; j < planesize; j++) { \n                accum_r = 1; \n                accum_i = 0; \n                if (reverse) { \n                    for (ompIndexType k = linesize - 1; k >= 0; --k) { \n                        T el_r = sp[2 * (i * planesize * linesize + j + k * planesize)]; \n                        if (std::isnan(el_r)) { \n                            el_r = 1; \n                        } \n                        T el_i = sp[2 * (i * planesize * linesize + j + k * planesize) + 1]; \n                        if (std::isnan(el_i)) { \n                            el_i = 0; \n                        } \n                        T tmp_r = accum_r * el_r - accum_i * el_i; \n                        T tmp_i = accum_r * el_i + accum_i * el_r; \n                        dp[2 * (i * planesize * linesize + j + k * planesize)] = tmp_r; \n                        dp[2 * (i * planesize * linesize + j + k * planesize) + 1] = tmp_i; \n                        accum_r = tmp_r; \n                        accum_i = tmp_i; \n                    } \n                } else { \n                    for (ompIndexType k = 0; k < linesize; k++) { \n                        T el_r = sp[2 * (i * planesize * linesize + j + k * planesize)]; \n                        if (std::isnan(el_r)) { \n                            el_r = 1; \n                        } \n                        T el_i = sp[2 * (i * planesize * linesize + j + k * planesize) + 1]; \n                        if (std::isnan(el_i)) { \n                            el_i = 0; \n                        } \n                        T tmp_r = accum_r * el_r - accum_i * el_i; \n                        T tmp_i = accum_r * el_i + accum_i * el_r; \n                        dp[2 * (i * planesize * linesize + j + k * planesize)] = tmp_r; \n                        dp[2 * (i * planesize * linesize + j + k * planesize) + 1] = tmp_i; \n                        accum_r = tmp_r; \n                        accum_i = tmp_i; \n                    } \n                } \n            } \n        }", "pragma": "parallel for reduction( * : accum_i accum_r) ", "hash": "0be68372bed3ec34a961d3a8bb89b027fbfbfd210f8f19f830f040eb01375f72"}
{"code": "for (int i = num_no_in_vs; i < num_vs - num_no_out_vs; ++i) { \n            double new_val = 0; \n            const int start_j = tails[i]; \n            const int end_j = (i + 1 != num_vs) ? tails[i + 1] : num_es; \n            if (weighted) { \n                for (int j = start_j; j < end_j; ++j) \n                     \n \n                    new_val += x[heads[j]]*vals[j]; \n                COMPENSATED_SUM(err, fabs(uv[uv_exists*i] + alpha*new_val - (1 - alpha*ii[i])*x[i]), c); \n                new_val = (alpha*new_val + uv[uv_exists*i])/(1 - alpha*ii[i]); \n                x[i] = new_val; \n            } else { \n                for (int j = start_j; j < end_j; ++j) \n                     \n \n                    new_val += x[heads[j]]; \n                COMPENSATED_SUM(err, fabs(uv[uv_exists*i] + alpha*new_val - (1 - alpha*ii[i])*x[i]*num_outlinks[i]), c); \n                new_val = (alpha*new_val + uv[uv_exists*i])/(1 - alpha*ii[i]); \n                x[i] = new_val/num_outlinks[i]; \n            } \n            num_es_touched += end_j - start_j; \n        }", "pragma": "parallel for reduction( +:err num_es_touched) private(c)", "hash": "af1cd20c9f02c3929458c99355a6d4a9e634528cd9bf5a9002585c73c66ef8e6"}
{"code": "for(int i=0;i<totalRecv;i++){ \n      TreeNode* a=std::lower_bound(&nodes[0],&nodes[nodes.size()],recvK[i]); \n      TreeNode* b=(i<totalRecv-1?std::lower_bound(&nodes[0],&nodes[nodes.size()],recvK[i+1]):&nodes[nodes.size()]); \n \n \n \n \n \n \n \n \n      wts[i]=b-a; \n    }", "pragma": "parallel for ", "hash": "cdeaf1f53f319b15043ee49c6bcca360135c1780084a21c5cc60798c7bfe620a"}
{"code": "for( int64_t l=0; l<interpolft.Get_Dim_RS(); l++ ) \n    { \n      if( fabs(interpol_in[l]) > maxval2 ) maxval2 = fabs(interpol_in[l]); \n    }", "pragma": "parallel for reduction(max:maxval2) ", "hash": "a5c23a81859cb00d6d068943c6211149da1b639cda27bccf0bb90fba8a8cd164"}
{"code": "for(long i0=t->id;i0<nn;i0+=mglNumThr)\r \n\t{\r \n\t\tlong i=i0%nx, j=((i0/nx)%ny), i1 = same ? i0 : i0%(nx*ny);\r \n\t\tmreal xu,xv,yu,yv;\r \n\t\tif(i==0)\r \n\t\t{\r \n\t\t\tau = mreal(3)*a[i0]-mreal(4)*a[i0+1]+a[i0+2];\r \n\t\t\txu = 3*x->vthr(i1)-4*x->vthr(i1+1)+x->vthr(i1+2);\r \n\t\t\tyu = 3*y->vthr(i1)-4*y->vthr(i1+1)+y->vthr(i1+2);\r \n\t\t}\r \n\t\telse if(i==nx-1)\r \n\t\t{\r \n\t\t\tau = mreal(3)*a[i0]-mreal(4)*a[i0-1]+a[i0-2];\r \n\t\t\txu = 3*x->vthr(i1)-4*x->vthr(i1-1)+x->vthr(i1-2);\r \n\t\t\tyu = 3*y->vthr(i1)-4*y->vthr(i1-1)+y->vthr(i1-2);\r \n\t\t}\r \n\t\telse\r \n\t\t{\r \n\t\t\tau = a[i0+1]-a[i0-1];\r \n\t\t\txu = x->vthr(i1+1)-x->vthr(i1-1);\r \n\t\t\tyu = y->vthr(i1+1)-y->vthr(i1-1);\r \n\t\t}\r \n\t\tif(j==0)\r \n\t\t{\r \n\t\t\tav = mreal(3)*a[i0]-mreal(4)*a[i0+nx]+a[i0+2*nx];\r \n\t\t\txv = 3*x->vthr(i1)-4*x->vthr(i1+nx)+x->vthr(i1+2*nx);\r \n\t\t\tyv = 3*y->vthr(i1)-4*y->vthr(i1+nx)+y->vthr(i1+2*nx);\r \n\t\t}\r \n\t\telse if(j==ny-1)\r \n\t\t{\r \n\t\t\tav = mreal(3)*a[i0]-mreal(4)*a[i0-nx]+a[i0-2*nx];\r \n\t\t\txv = 3*x->vthr(i1)-4*x->vthr(i1-nx)+x->vthr(i1-2*nx);\r \n\t\t\tyv = 3*y->vthr(i1)-4*y->vthr(i1-nx)+y->vthr(i1-2*nx);\r \n\t\t}\r \n\t\telse\r \n\t\t{\r \n\t\t\tav = a[i0+nx]-a[i0-nx];\r \n\t\t\txv = x->vthr(i1+nx)-x->vthr(i1-nx);\r \n\t\t\tyv = y->vthr(i1+nx)-y->vthr(i1-nx);\r \n\t\t}\r \n\t\tb[i0] = (av*yu-au*yv)/(xv*yu-xu*yv);\r \n\t}", "pragma": "parallel for private(au av)", "hash": "7c981baa35ec341c031ea574e688d0e2e53b7b451eec6fd246b8c15cb849fe3b"}
{"code": "for (i = 0; i < nprocs; ++i) { \n        psgstrf_thread( &(psgstrf_threadarg[i]) ); \n    }", "pragma": "parallel for private(i)", "hash": "0866faf45e4996cd110c478cd7f2cb7b1a69992b473462e03553f54c1881bbbc"}
{"code": "for (size_t j = 0; j < n; j++) { \n          for (size_t k = 0; k < m; k++) { \n            if (B[j * ldb + k] != zero) { \n              register double temp = alpha * B[j * ldb + k]; \n              for (size_t i = 0; i < k; i++) \n                B[j * ldb + i] += temp * A[k * lda + i]; \n              if (diag == CBlasNonUnit) temp *= A[k * lda + k]; \n              B[j * ldb + k] = temp; \n            } \n          } \n        }", "pragma": "parallel for ", "hash": "944269c794e2816277b176286d1c5067d4c1a7ff109f1ef1617b41fa3f3dbe37"}
{"code": "for (int i = 0; i < NumThreads; i += 2) { \n      Merge(V, IndV[i], IndV[i+1], IndV[i+2], SortByTypes, SortByIndices, Asc); \n    }", "pragma": "parallel for ", "hash": "d53f22b36e6012ac07e5a783c41024ae99a9447f0bd07bf59d935cacdc8b224b"}
{"code": "for(k = 1;k < SIZE - 1;k++) \n\t\t\t\t{ \n\t\t\t\t\tdiff = u_new[i][j][k] - u_old[i][j][k]; \n\t\t\t\t\terr += fabs(diff*diff); \n\t\t\t\t}", "pragma": "parallel for reduction(+:err) private( diff k)", "hash": "3d67de7a88729f601c3e33f46faf7304fe603a4f016845be1236dfdbd06f2b73"}
{"code": "for (int32_t i = 0; i < m_Width*m_Height; i++) {\r \n    m_Image[i][0] = CLIP((int32_t)(out[i]*0xffff));\r \n  }", "pragma": "parallel for ", "hash": "a203a4c898d17342bae72f1941e17dadfcb9c3d8226910ba95ba50ee51948159"}
{"code": "for( BFsize t=0; t<nthread; ++t ) { \n\t\tint tid = omp_get_thread_num(); \n\t\tbfAffinitySetCore(thread_cores[tid]); \n\t}", "pragma": "parallel for ", "hash": "9ad9bbfe2488418b1bbde8e4b74818a0aa194526c8f24f46712d7d19688ffbe9"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      #pragma omp ordered depend (sink: i - 1) \n      #pragma omp ordered depend (source) \n    }", "pragma": "for ", "hash": "9d2fd0cb0961d6447b4abb14fa550062f21a4a8291716b6dceed9cd245d11f30"}
{"code": "for (i=0;i<numThreads;i++){ \n        int InitCol=round(i*size/numThreads); \n        int FinalCol=round((i+1)*size/numThreads)-1;             \n        int lenghtCol=FinalCol-InitCol+1; \n        if(lenghtCol>0){ \n            dgemm_(&transN, &transY, &aux, &(lenghtCol), &(size),&factor, m1, &aux, &m2[size*InitCol], &size, &aux2, &result[InitCol], &aux); \n        } \n    }", "pragma": "for ", "hash": "3e9fde2886c165be339d777c0d5c12228af4c82b05e3e6191c58d97f0a53b4cb"}
{"code": "for (int ai=0; ai<this->get_nrow(); ++ai) \n    for (int aj=this->mat_.row_offset[ai]; aj<this->mat_.row_offset[ai+1]; ++aj) \n      if (ai == this->mat_.col[aj]) { \n         \n \n        ind_diag[ai] = aj; \n        break;         \n      }", "pragma": "parallel for ", "hash": "033fbff1196cede8b9b2330de4e2e272ee3bdf8442ac503cc1e08d4f21da6cee"}
{"code": "for (i = 1; i <= MapSize; i++) { \n\t\t\tk = 0; \n\t\t\twhile (++k <= MapSize) { \n\t\t\t\tMap[i][k] += Vel[i][k]; \n\t\t\t\tif (Switch.Boat && i == itp1 && k == itp2) { \n\t\t\t\t\tMap[i][k] -= MassBoat*(height+Foundering_height<Map[i][k]); \n\t\t\t\t\tif (Switch.Foundering) Map[i][k] += rand()/(1.0+RAND_MAX)*4.0-2.0; \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "parallel for private(k)", "hash": "b02ab3f0653f87051d24d48e1545c6e1f36f89ddb17f752e87ce7ef47b37eb19"}
{"code": "for(int y=0; y<blockSize.m_y; y++)\r \n\t\t{\r \n\t\t\tfor(int x=0; x<blockSize.m_x; x++)\r \n\t\t\t{\r \n\t\t\t\t \n \n\t\t\t\tCGeoExtents blockExtents = extents.GetBlockExtents(xBlock,yBlock);\r \n\t\t\t\tCGeoPoint coordinate = blockExtents.XYPosToCoord( CGeoPointIndex(x,y) );\r \n\t\t\t\t \n \n\t\t\t\t \n \n\r \n\t\t\t\t \n \n\t\t\t\tCMDPoint pt(KNN.GetNbDimension());\r \n\t\t\t\t\r \n\t\t\t\tbool bValid = true;\r \n\t\t\t\tfor(int z=0; z<KNN.GetNbDimension()&&bValid; z++)\r \n\t\t\t\t{\r \n\t\t\t\t\tpt[z] = input[z]->at(x,y);\r \n\t\t\t\t\tbValid = !_isnan(pt[z]) && _finite(pt[z]) && bandHolder.IsValid(z, (DataType)pt[z]);\r \n\t\t\t\t}\r \n\r \n\t\t\t\tif( bValid )\r \n\t\t\t\t{\r \n\t\t\t\t\t \n \n\t\t\t\t\tCSearchResultVector result;\r \n\t\t\t\t\tKNN.Search(pt, m_options.m_K, result);\r \n\r \n\t\t\t\t\tASSERT(result.size() == m_options.m_K);\r \n\r \n\t\t\t\t\t \n \n\t\t\t\t\tfor( int p=0; p<KNN.GetNbPredictor(); p++)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\r \n\t\t\t\t\t\tdouble predictor = KNN(p).GetValue(result, m_options.m_T, m_options.m_bGeoWeight);\r \n\t\t\t\t\t\t\r \n\t\t\t\t\t\toutput[p][y][x] = (float)predictor;\r \n\r \n\t\t\t\t\t\tif( m_options.m_bCreateError )\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\tdouble sum\u00b2=0;\r \n\t\t\t\t\t\t\tfor(size_t k=0; k<result.size(); k++)\r \n\t\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\t\tsum\u00b2+=Square(KNN(p).at(result[k].m_index)-output[p][y][x]);\r \n\t\t\t\t\t\t\t}\r \n\r \n\t\t\t\t\t\t\tdouble stdDev = sqrt(sum\u00b2/max(1ull,result.size()-1));\r \n\t\t\t\t\t\t\tif( output[p][y][x]!= 0)\r \n\t\t\t\t\t\t\t\terror[p][y][x] = (float)(stdDev/output[p][y][x]*100);\r \n\t\t\t\t\t\t\telse error[p][y][x] = 0;\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t} \n \n\t\t\t\t\t\r \n\t\t\t\t\tif( m_options.m_bCreateNearestNeighbor )\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tvector<double> weight = result.GetWeight(m_options.m_T, m_options.m_bGeoWeight);\r \n\t\t\t\t\t\tASSERT( weight.size() == result.size() );\r \n\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tfor(int k=0; k<result.size(); k++)\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\tNN[k*NB_NN][y][x] = (float)result[k].m_index+1;\r \n\t\t\t\t\t\t\t\t\t\t\t\r \n\t\t\t\t\t\t\tif( KNN.HaveGeoCoordinates() )\r \n\t\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\tNN[k*NB_NN + 1][y][x] = (float)result[k].m_geoDistance;\r \n\t\t\t\t\t\t\t}\r \n\r \n\t\t\t\t\t\t\tNN[k*NB_NN+2][y][x] = (float)result[k].m_distance;\r \n\t\t\t\t\t\t\tNN[k*NB_NN+3][y][x] = (float)weight[k]*100;\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t}\r \n\t\t\t\r \n\t\t\t\t\tif(m_options.m_bCreateGeoDistanceStat)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tCStatistic stat;\r \n\t\t\t\t\t\t\t\t\t\t\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\t\t\r \n\t\t\t\t\t\tfor(int k=0; k<result.size(); k++)\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tstat += result[k].m_geoDistance;\r \n\t\t\t\t\t\t}\r \n\r \n\t\t\t\t\t\tfor(int i=0; i<NB_STAT; i++)\r \n\t\t\t\t\t\t\tgeoDistance[i][y][x] = (float)stat[COORDINATE_STAT[i]];\r \n\t\t\t\t\t}\r \n\r \n\t\t\t\t} \n \n\r \n    #pragma omp atomic\r \n\t\t\t\t\tm_options.m_xx++;\r \n\t\t\t} \n \n\r \n\t\t\tm_options.UpdateBar();\r \n\t\t}", "pragma": "parallel for ", "hash": "02028303e4f2395dcd9917a7f60c8355184e4baf7e032b56725b5d4e39e111fe"}
{"code": "for(ImpInt i = 0; i < m; i++ ) { \n            w_p[i] = param->w; \n        }", "pragma": "parallel for ", "hash": "8692726ae576a14d2189f00f7751749ff259110cbfcda37392992e9adc66c9ca"}
{"code": "for (uint ec=0; ec < number_of_coloring_sets; ++ec) \n\t\t    { \n\t\t\tfor (type_set_uint::const_iterator it_ins = insertions_relative_to_other_LCR.begin(); \n\t\t\t\tit_ins != insertions_relative_to_other_LCR.end(); \n\t\t\t\t++it_ins) \n\t\t\t{ \n\t\t\t    if (  coloring_of_sets___loop[ec]->first.count(*it_ins) > 0  ) \n\t\t\t    { \n    #pragma omp critical (add_color_to_coloring_of_sets_and_current_colors_in_use_when_looping_over_insertions_of_Events_LCRs_in_partition_DAR) \n\t\t\t\t{ \n\t\t\t\t    coloring_of_sets___loop[ec]->second += newest_color; \n\t\t\t\t    current_colors_in_use.insert( coloring_of_sets___loop[ec]->second ); \n\t\t\t\t    newest_color = sum_over_set<uint>(current_colors_in_use) + 1; \n\t\t\t\t} \n\t\t\t\tbreak;\t\t\t \n\t\t\t    }\t\t     \n\t\t\t} \n \n\t\t    }", "pragma": "parallel for ", "hash": "eb60baf6b5000a75df591de0102346d12679bb86cc63967b355ab93cb3e6d4f9"}
{"code": "for (int i1 = j + 1; i1 < N; i1++) \n        { \n            int k; \n            float a_ij = a[i1][j]; \n \n#pragma omp simd reduction(-:a_ij) aligned(a:64) suitable(N) \n            for (k = 0; k < j; k++) \n            { \n                a_ij -=  a[i1][k] * a[j][k]; \n            } \n \n            a[i1][j] = a_ij; \n        }", "pragma": "for ", "hash": "9fc080d36a178b07d923e818fb0d07555f31d56041b4b58db62c0b81cfa3dbe4"}
{"code": "for(i=0;i<tlines;++i) \n\t\tfor(j=0;j<trows;++j) { \n\t\t\tworld[i*trows+j] = (rand()%prob)?0:1 ; \n\t\t}", "pragma": "parallel for private(j)", "hash": "fbcab9f1b978667079353f55632072384e0a78b0849a0b8327a0e907e4be6b0b"}
{"code": "for (int r = minrow; r <= maxrow; r++)\r \n\t\tfor (int c = mincol; c <= maxcol; c++){\r \n\t\tconst int dist = (box.y - r)*(box.y - r) + (box.x - c)*(box.x - c);\r \n\t\tif (randfloat()<prob && dist < inradsq && dist >= outradsq){\r \n\t\t\tsamples[i].x = c;\r \n\t\t\tsamples[i].y = r;\r \n\t\t\tsamples[i].height = box.height;\r \n\t\t\tsamples[i].width = box.width;\r \n\t\t\ti++;\r \n\t\t}\r \n\t\t}", "pragma": "parallel ", "hash": "54fca105fd1a16fa0283e1e0f16f8479f71dad72a96d9e4d29341826f3e3e233"}
{"code": "for(size_t u = 0; u < num_columns; u += 1) \n        {  \n \n \n            const_data_2d_view_t rows_disparities_slice = \n                    pixels_cost_volume_p->rows_disparities_slice(u); \n \n            for(size_t d = 0; d < num_disparities; d += 1) \n            { \n                const_data_1d_view_t rows_slice = \n                        rows_disparities_slice[ boost::indices[range_t()][d] ]; \n \n                 \n \n                const int minimum_v_for_disparity = top_v_for_stixel_estimation_given_disparity[d]; \n                const size_t ground_obstacle_v_boundary = v_given_disparity[d]; \n                 \n \n \n                 \n \n                float &object_cost = object_u_disparity_cost(d, u); \n                for(size_t v=minimum_v_for_disparity; v < ground_obstacle_v_boundary; v+=1) \n                { \n                    object_cost += rows_slice[v]; \n                } \n \n                 \n \n                object_cost /= (ground_obstacle_v_boundary - minimum_v_for_disparity); \n                assert(object_cost >= 0); \n \n                 \n \n                float &ground_cost = ground_u_disparity_cost(d, u); \n                for(std::size_t v=ground_obstacle_v_boundary; v < rows_slice.size(); v+=1) \n                { \n                    const int d_at_v = disparity_given_v[v]; \n \n                    if(search_nearby_disparities) \n                    { \n                         \n \n                        const size_t d_min_one = std::max(d_at_v - 1, 0); \n                        const size_t d_plus_one = std::min(d_at_v + 1, static_cast<int>(num_disparities) - 1); \n \n                        ground_cost += std::min( std::min( \n                                                     rows_disparities_slice[v][d_at_v], \n                                                     rows_disparities_slice[v][d_min_one]), \n                                                 rows_disparities_slice[v][d_plus_one]); \n                    } \n                    else \n                    { \n                        ground_cost += rows_disparities_slice[v][d_at_v]; \n                    } \n                }  \n \n \n                 \n \n                if (ground_obstacle_v_boundary < rows_slice.size()) \n                { \n                    ground_cost /= (rows_slice.size() - ground_obstacle_v_boundary); \n                } \n \n                assert(ground_cost >= 0); \n \n            }  \n \n        }", "pragma": "parallel for ", "hash": "154d88afd8c3633c73c5b8483ec86c314b68211f7b9be98ea53e81fb907c3752"}
{"code": "for(int y = 0; y < sf->h; y++) \n\t{ \n\t\tUint32 *line = SDL_GetPixelPtr32(sf, 0, y); \n\t\tfor(int x = 0; x < sf->w; x++) \n\t\t{ \n\t\t\tUint8 r, g, b, a; \n\t\t\tSDL_GetRGBA32(line[x], &r, &g, &b, &a); \n\t\t\tif(r != 0 && g == 0 && r == b) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tUint8 r2 = r * nc_r / 0xff; \n\t\t\t\tUint8 g2 = r * nc_g / 0xff; \n\t\t\t\tUint8 b2 = r * nc_b / 0xff; \n\t\t\t\tline[x] = SDL_MapRGBA32(r2, g2, b2, a); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "fc20db7fe1a74197b7de9dfc3cda8e76a6d58fa3bc9be12453e4f62ccfbd4da7"}
{"code": "for ( ix = 0; ix < nx; ix++) { \n\t        for ( iz = 0; iz < nz; iz++ ) {  \n\t\t    wvfld[wfit][ix][iz] = curr[ix+nb+2][iz+nb+2]; \n\t\t} \n\t    }", "pragma": "parallel for private(ix iz)", "hash": "8f89ef72389c3118d3a09ea81d8ea1fa28d5dcc76af4e32e64d8b57f6b7711fa"}
{"code": "for (int i = 0; i < sim_data.get_N(); ++i) { \n\t\t\ttheta = this->kinetic_energy[i] * sim_data.get_dt();\t \n\t\t\tthis->mom_time_evolution[i].real = exp(-1.0 * theta); \n\t\t\tthis->mom_time_evolution[i].imag = 0;\t \n\t\t}", "pragma": "parallel for private(theta)", "hash": "5ddf3445141420d6bdf91eb742feb04696553ed9aeb57d631ae04efd53f6943e"}
{"code": "for (iz=0; iz<nz; iz++) { \n\tfor (ix=0; ix<nx; ix++) { \n\t    vp[nbx+ix][nbz+iz] = vv[ix][iz] * vv[ix][iz]; \n\t    ro[nbx+ix][nbz+iz] = ee[ix][iz]; \n\t} \n    }", "pragma": "parallel for private(ix iz)", "hash": "a4f77b81e4c6ed82c57c79b92f6f4cb9b94235f989580c984986bf6666e76f99"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t    (*res)[i] = ((*this)[i] == s);", "pragma": "for ", "hash": "bb5eda1128b22a544e68bf2491a9ddc8c25212f400d22a699919d28ccc6fe07f"}
{"code": "for ( i = 0; i < nx; i++ ) \n    { \n      # pragma omp simd aligned(udiff:ALIGNMENT, unew:ALIGNMENT, u:ALIGNMENT) \n      for ( j = 0; j < ny; j++ ) \n      { \n        udiff[i*npadded+j] = unew[i*npadded+j] - u[i*npadded+j]; \n      } \n    }", "pragma": "parallel for private( i j)", "hash": "c2ecb89c210a432e091b560287f9b73e4c03f1af63bc53d6b4021c60e79649ca"}
{"code": "for (cc = 0; cc < chunk_count * chunk_count; cc++) { \n        int cx = cc % chunk_count, cy = cc / chunk_count; \n \n         \n \n        struct bl_data **bl_bin = bins[cy*chunk_count + cx]; \n        int bl_count = bins_count[cy*chunk_count + cx]; \n        if (bl_count == 0) { continue; } \n         \n \n \n         \n \n        int x_min = chunk_size*cx - grid_size/2; \n        int y_min = chunk_size*cy - grid_size/2; \n        double u_min = ((double)x_min - 0.5) / theta; \n        double v_min = ((double)y_min - 0.5) / theta; \n        double u_max = u_min + chunk_size / theta; \n        double v_max = v_min + chunk_size / theta; \n \n         \n \n         \n \n         \n \n        double u_mid = (double)(x_min + chunk_size / 2) / theta; \n        double v_mid = (double)(y_min + chunk_size / 2) / theta; \n \n         \n \n        memset(subgrid, 0, subgrid_mem_size); \n        memset(subimg, 0, subgrid_mem_size); \n \n         \n \n        int have_vis = 0; \n        int last_wp = wp_min; \n        int wp; \n        for (wp = wp_min; wp <= wp_max; wp++) { \n            double w_mid = (double)wp * wincrement; \n            double w_min = ((double)wp - 0.5) * wincrement; \n            double w_max = ((double)wp + 0.5) * wincrement; \n \n             \n \n            uint64_t bin_flops = w_project_bin(subgrid, subgrid_size, theta, bl_bin, bl_count, wkern, \n                                               u_min, u_max, u_mid, \n                                               v_min, v_max, v_mid, \n                                               w_min, w_max, w_mid); \n \n             \n \n            if (bin_flops == 0) { continue; } \n            flops += bin_flops; \n            have_vis = 1; \n \n             \n \n            fftw_execute(ifft_plan); \n            flops += subgrid_fft_flops; \n \n             \n \n             \n \n            int x, y; \n            for (y = 0; y < subgrid_size; y++) { \n                for (x = 0; x < subgrid_size; x++) { \n                    double complex wtrans = cipow(wtransfer[y*subgrid_size + x], wp-last_wp); \n                    subimg[y*subgrid_size + x] = \n                        wtrans * subimg[y*subgrid_size + x] + subgrid[y*subgrid_size + x]; \n                    subgrid[y*subgrid_size + x] = 0; \n                } \n            } \n            flops += subgrid_cells * (8 + cipow_flops(wp-last_wp)); \n            last_wp = wp; \n \n        } \n \n         \n \n        if (!have_vis) { continue; } \n \n         \n \n        if (last_wp != 0) { \n            int x, y; \n            for (y = 0; y < subgrid_size; y++) { \n                for (x = 0; x < subgrid_size; x++) { \n                    subimg[y*subgrid_size + x] /= cipow(wtransfer[y*subgrid_size + x], last_wp); \n                } \n            } \n            flops += subgrid_cells * (8 + cipow_flops(wp-last_wp)); \n        } \n \n         \n \n        fftw_execute(fft_plan); \n        flops += subgrid_fft_flops; \n \n         \n \n         \n \n        int x0 = x_min - subgrid_margin/2, x1 = x0 + subgrid_size; \n        int y0 = y_min - subgrid_margin/2, y1 = y0 + subgrid_size; \n        if (x0 < -grid_size/2) { x0 = -grid_size/2; } \n        if (y0 < -grid_size/2) { y0 = -grid_size/2; } \n        if (x1 > grid_size/2) { x1 = grid_size/2; } \n        if (y1 > grid_size/2) { y1 = grid_size/2; } \n        double complex *uvgrid_mid = uvgrid + (grid_size+1)*grid_size/2; \n        int x, y; \n        for (y = y0; y < y1; y++) { \n            for (x = x0; x < x1; x++) { \n                uvgrid_mid[x + y*grid_size] += subimg[(x-x_min+subgrid_margin/2) + \n                                                      (y-y_min+subgrid_margin/2)*subgrid_size] / subgrid_size / subgrid_size; \n            } \n        } \n        flops += 2 * (y1 - y0) * (x1 - x0); \n    }", "pragma": "for ", "hash": "df8f74e62558d19c6ea4bf93b12a0c1c26e1215fd91d7e6b6b4be99822df2f76"}
{"code": "for ( long long k = 0; k < static_cast<long long>( eclipseCase->mainGrid()->globalCellArray().size() ); k++ ) \n    { \n        values->at( k ) = ( k * 2 ) % eclipseCase->mainGrid()->globalCellArray().size(); \n    }", "pragma": "parallel for ", "hash": "2d9acac8e39acd4d7f61afd2b09b9e2ece4dee0a4b4ec05d66c02ff0b45c46c4"}
{"code": "for (uint32 i = 0; i < l; ++i) { \n    for (uint32 j = 0; j < m; ++j) { \n      mat sum = 0; \n      for (uint32 k = 0; k < n; k++) { \n         \n \n        sum += A.entries[k+i*n] * B.entries[k+j*n]; \n      } \n      C.entries[j+i*m]  = (mat) (sum); \n    } \n  }", "pragma": "for ", "hash": "88c4763bb45f2228adc0b18167f1ff0ba5bcef156eaae141369f0cc3fc68f8c9"}
{"code": "for (size_t i = 0; i < temp_input.size(); i++) { \n             \n \n            std::pair<size_t, size_t> snif_res; \n             \n \n            snif_res.first = 50000000;  \n \n             \n \n            if (! temp_input[i].empty() ) \n                 \n \n                snif_res = io_utils::fastq_sniff(temp_input[i]); \n \n            std::ifstream istream;  \n \n            boost::iostreams::filtering_stream<boost::iostreams::input> inputfile; \n             \n \n            { \n            if (temp_input[i].find(\".gz\") != std::string::npos) {  \n \n                istream.open(temp_input[i].c_str()); \n                if (!istream) ngs::ioerror(temp_input[i]); \n                inputfile.push(boost::iostreams::gzip_decompressor()); \n                inputfile.push(istream); \n            } \n            else if ( temp_input[i].empty()  ) { \n                inputfile.push(std::cin); \n            } \n            else { \n                istream.open(temp_input[i].c_str()); \n                if (!istream) ngs::ioerror(temp_input[i]); \n                inputfile.push(istream); \n            } \n            }  \n \n             \n \n            vr.reserve(snif_res.first); \n \n            nreads = 0; \n \n             \n \n            while (true) { \n                std::getline(inputfile, id_line); \n                std::getline(inputfile, seq_line); \n                 \n \n                std::getline(inputfile, comment_line); \n                std::getline(inputfile, quality_line); \n                if (inputfile.eof()) break; \n\t\t \n \n                if (nreads++ >= vr.capacity()) vr.resize(vr.size()+5000000); \n                vr.push_back( ngs::Read(id_line, \n                                        seq_line, \n                                        comment_line, \n                                        quality_line)); \n \n \n            } \n            vr.shrink_to_fit(); \n            if (i == 0 ) forward.swap(vr); \n            else if (i == 1) reverse.swap(vr); \n        }", "pragma": "parallel for private(comment_line id_line nreads quality_line seq_line vr)", "hash": "b5df4bfc2ab8d9c216264d4669aa328f93692fef8edac6716f2d207d18529080"}
{"code": "for(i = 0; i < (int)data->num_data; i++) \n\t\t\t{ \n\t\t\t\tj=omp_get_thread_num(); \n \n\t\t\t\tfann_type* temp_predicted_output; \n\t\t\t\tif (ann->do_dropout) { \n\t\t\t\t\ttemp_predicted_output=fann_run_dropout(ann_vect[j], data->input[i]); \n\t\t\t\t} \n\t\t\t\telse { \n\t\t\t\t\ttemp_predicted_output=fann_run(ann_vect[j], data->input[i]); \n\t\t\t\t} \n \n\t\t\t\tfor(unsigned int k=0;k<data->num_output;++k) \n\t\t\t\t{ \n\t\t\t\t\tpredicted_outputs[i][k]=temp_predicted_output[k]; \n\t\t\t\t} \n \n\t\t\t\t \n\t\t\tfann_compute_MSE(ann_vect[j], data->output[i]); \n\t\t\tfann_backpropagate_MSE(ann_vect[j]); \n\t\t\tfann_update_slopes_batch(ann_vect[j], ann_vect[j]->first_layer + 1, ann_vect[j]->last_layer - 1); \n\t\t}", "pragma": "for ", "hash": "38d94b41255e532126428945c984391d49ccd4e9faf0c4eee53ec275d741d097"}
{"code": "for (i=0; i<img_h; ++i) \n\t{ \n\t\tfor (j=0; j<img_w; ++j) \n\t\t{ \n\t\t\t \n \n\t\t\tttime=minus_img_w_2+j; \n\t\t\tt=minus_img_h_2+i; \n\t\t\tray_dir_x=ttime*ox_x+t*ox_y+ray_dir_z_init*ox_z; \n\t\t\tray_dir_y=ttime*oy_x+t*oy_y+ray_dir_z_init*oy_z; \n\t\t\tray_dir_z=ttime*oz_x+t*oz_y+ray_dir_z_init*oz_z; \n\t\t\tt=sqrtf(ray_dir_x*ray_dir_x+ray_dir_y*ray_dir_y+ray_dir_z*ray_dir_z); \n\t\t\tray_dir_x/=t; \n\t\t\tray_dir_y/=t; \n\t\t\tray_dir_z/=t; \n \n\t\t\tttime=1.0e+30f; \n \n\t\t\t \n \n\t\t\tif ((ray_dir_z<-0.001f) || (ray_dir_z>0.001f)) \n\t\t\t{ \n\t\t\t\tt=-ray_pos_z_const/ray_dir_z; \n\t\t\t\tcoord1=ray_pos_x_const+t*ray_dir_x; \n\t\t\t\tcoord2=ray_pos_y_const+t*ray_dir_y; \n\t\t\t\tttime=((coord1>=0.0f) && (coord2>=0.0f) && (t<ttime) && (coord1<=x_size) && (coord2<=y_size))? t : ttime; \n\t\t\t\tt+=(z_size/ray_dir_z); \n\t\t\t\tcoord1=ray_pos_x_const+t*ray_dir_x; \n\t\t\t\tcoord2=ray_pos_y_const+t*ray_dir_y; \n\t\t\t\tttime=((t<ttime) && (coord1>=0.0f) && (coord2>=0.0f) && (coord1<=x_size) && (coord2<=y_size))? t : ttime; \n\t\t\t} \n\t\t\tif ((ray_dir_y<-0.001f) || (ray_dir_y>0.001f)) \n\t\t\t{ \n\t\t\t\tt=-ray_pos_y_const/ray_dir_y; \n\t\t\t\tcoord1=ray_pos_x_const+t*ray_dir_x; \n\t\t\t\tcoord2=ray_pos_z_const+t*ray_dir_z; \n\t\t\t\tttime=((coord1>=0.0f) && (coord2>=0.0f) && (t<ttime) && (coord1<=x_size) && (coord2<=z_size))? t : ttime; \n\t\t\t\tt+=(y_size/ray_dir_y); \n\t\t\t\tcoord1=ray_pos_x_const+t*ray_dir_x; \n\t\t\t\tcoord2=ray_pos_z_const+t*ray_dir_z; \n\t\t\t\tttime=((t<ttime) && (coord1>=0.0f) && (coord2>=0.0f) && (coord1<=x_size) && (coord2<=z_size))? t : ttime; \n\t\t\t} \n\t\t\tif ((ray_dir_x<-0.001f) || (ray_dir_x>0.001f)) \n\t\t\t{ \n\t\t\t\tt=-ray_pos_x_const/ray_dir_x; \n\t\t\t\tcoord1=ray_pos_y_const+t*ray_dir_y; \n\t\t\t\tcoord2=ray_pos_z_const+t*ray_dir_z; \n\t\t\t\tttime=((coord1>=0.0f) && (coord2>=0.0f) && (t<ttime) && (coord1<=y_size) && (coord2<=z_size))? t : ttime; \n\t\t\t\tt+=(x_size/ray_dir_x); \n\t\t\t\tcoord1=ray_pos_y_const+t*ray_dir_y; \n\t\t\t\tcoord2=ray_pos_z_const+t*ray_dir_z; \n\t\t\t\tttime=((t<ttime) && (coord1>=0.0f) && (coord2>=0.0f) && (coord1<=y_size) && (coord2<=z_size))? t : ttime; \n\t\t\t} \n \n\t\t\tif (ttime>1.0e+29f) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tpixels[i*img_w+j]=0xff969696; \n\t\t\t\tcontinue; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tttime=(ttime>0.0f)? ttime : 0.0f; \n\t\t\tray_pos_x=ray_pos_x_const+ttime*ray_dir_x; \n\t\t\tray_pos_y=ray_pos_y_const+ttime*ray_dir_y; \n\t\t\tray_pos_z=ray_pos_z_const+ttime*ray_dir_z; \n \n\t\t\tif ((ray_pos_x<-0.01f) || (ray_pos_x>x_size+0.01f) || \n\t\t\t\t(ray_pos_y<-0.01f) || (ray_pos_y>y_size+0.01f) || \n\t\t\t\t(ray_pos_z<-0.01f) || (ray_pos_z>z_size+0.01f)) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tpixels[i*img_w+j]=0xff969696; \n\t\t\t\tcontinue; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tind_k=(ray_pos_x<point_step)? 0 : (((ray_pos_x+point_step)>=x_size)? (x_num-1) : (int)floor(ray_pos_x/point_step)); \n\t\t\tind_l=(ray_pos_y<point_step)? 0 : (((ray_pos_y+point_step)>=y_size)? (y_num-1) : (int)floor(ray_pos_y/point_step)); \n\t\t\tind_m=(ray_pos_z<point_step)? 0 : (((ray_pos_z+point_step)>=z_size)? (z_num-1) : (int)floor(ray_pos_z/point_step)); \n \n\t\t\tind_k_init=ind_k; \n\t\t\tind_l_init=ind_l; \n\t\t\tind_m_init=ind_m; \n \n\t\t\t \n \n\t\t\tind_k_step=((int)(ray_dir_x>=0.0f)<<1)-1; \n\t\t\tind_l_step=((int)(ray_dir_y>=0.0f)<<1)-1; \n\t\t\tind_m_step=((int)(ray_dir_z>=0.0f)<<1)-1; \n\t\t\tto_centre_x=point_step*(0.5f+(float)ind_k)-ray_pos_x_const; \n\t\t\tto_centre_y=point_step*(0.5f+(float)ind_l)-ray_pos_y_const; \n\t\t\tto_centre_z=point_step*(0.5f+(float)ind_m)-ray_pos_z_const; \n\t\t\tind_step_flt_x=point_step*static_cast<float>(ind_k_step); \n\t\t\tind_step_flt_y=point_step*static_cast<float>(ind_l_step); \n\t\t\tind_step_flt_z=point_step*static_cast<float>(ind_m_step); \n\t\t\tt_max_x=(to_centre_x+0.5f*ind_step_flt_x)/ray_dir_x; \n\t\t\tt_max_y=(to_centre_y+0.5f*ind_step_flt_y)/ray_dir_y; \n\t\t\tt_max_z=(to_centre_z+0.5f*ind_step_flt_z)/ray_dir_z; \n\t\t\tt_delta_x=ind_step_flt_x/ray_dir_x; \n\t\t\tt_delta_y=ind_step_flt_y/ray_dir_y; \n\t\t\tt_delta_z=ind_step_flt_z/ray_dir_z; \n \n\t\t\txy_num=x_num*y_num*ind_m_step; \n\t\t\tyl_num=x_num*ind_l_step; \n \n\t\t\tmtr_indx=(ind_m*y_num+ind_l)*x_num+ind_k; \n \n\t\t\tmain_color_g=0.0f; \n\t\t\tmain_color_r=0.0f; \n\t\t\tthis_point_intense_g=1.0f; \n\t\t\tthis_point_intense_r=1.0f; \n \n\t\t\t \n \n\t\t\tfor ( ; ; ) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tttime=to_centre_x*ray_dir_x+to_centre_y*ray_dir_y+to_centre_z*ray_dir_z; \n\t\t\t\tt=to_centre_x*to_centre_x+to_centre_y*to_centre_y+(to_centre_z-ttime)*(to_centre_z+ttime); \n\t\t\t\tif (t<point_radius_sqr) \n\t\t\t\t{ \n\t\t\t\t\tt=(point_radius_sqr-t)/point_radius_sqr;  \n \n\t\t\t\t\tself_intense=((float)GET_G(matrix[mtr_indx]))*t; \n\t\t\t\t\tmain_color_g+=(this_point_intense_g*self_intense); \n\t\t\t\t\tthis_point_intense_g*=((255.0f-self_intense)*0.0039216f); \n\t\t\t\t\tself_intense=((float)GET_R(matrix[mtr_indx]))*t; \n\t\t\t\t\tmain_color_r+=(this_point_intense_r*self_intense); \n\t\t\t\t\tthis_point_intense_r*=((255.0f-self_intense)*0.0039216f); \n\t\t\t\t\tif ((main_color_g>253.0f) && (main_color_r>253.0f)) break; \n\t\t\t\t} \n \n\t\t\t\t \n \n\t\t\t\tif (t_max_x<=t_max_y) \n\t\t\t\t{ \n\t\t\t\t\tif (t_max_x<=t_max_z) \n\t\t\t\t\t{ \n\t\t\t\t\t\tind_k+=ind_k_step; \n\t\t\t\t\t\tif ((ind_k>=x_num) || (ind_k<0) || (ind_k_init>ind_k+depth_constraint) || \n\t\t\t\t\t\t\t(ind_k_init+depth_constraint<ind_k)) break; \n\t\t\t\t\t\tt_max_x+=t_delta_x; \n\t\t\t\t\t\tmtr_indx+=ind_k_step; \n\t\t\t\t\t\tto_centre_x+=ind_step_flt_x; \n\t\t\t\t\t} \n\t\t\t\t\telse \n\t\t\t\t\t{ \n\t\t\t\t\t\tind_m+=ind_m_step; \n\t\t\t\t\t\tif ((ind_m>=z_num) || (ind_m<0) || (ind_m_init>ind_m+depth_constraint) || \n\t\t\t\t\t\t\t(ind_m_init+depth_constraint<ind_m)) break; \n\t\t\t\t\t\tt_max_z+=t_delta_z; \n\t\t\t\t\t\tmtr_indx+=xy_num; \n\t\t\t\t\t\tto_centre_z+=ind_step_flt_z; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{ \n\t\t\t\t\tif (t_max_y<=t_max_z) \n\t\t\t\t\t{ \n\t\t\t\t\t\tind_l+=ind_l_step; \n\t\t\t\t\t\tif ((ind_l>=y_num) || (ind_l<0) || (ind_l_init>ind_l+depth_constraint) || \n\t\t\t\t\t\t\t(ind_l_init+depth_constraint<ind_l)) break; \n\t\t\t\t\t\tt_max_y+=t_delta_y; \n\t\t\t\t\t\tmtr_indx+=yl_num; \n\t\t\t\t\t\tto_centre_y+=ind_step_flt_y; \n\t\t\t\t\t} \n\t\t\t\t\telse \n\t\t\t\t\t{ \n\t\t\t\t\t\tind_m+=ind_m_step; \n\t\t\t\t\t\tif ((ind_m>=z_num) || (ind_m<0) || (ind_m_init>ind_m+depth_constraint) || \n\t\t\t\t\t\t\t(ind_m_init+depth_constraint<ind_m)) break; \n\t\t\t\t\t\tt_max_z+=t_delta_z; \n\t\t\t\t\t\tmtr_indx+=xy_num; \n\t\t\t\t\t\tto_centre_z+=ind_step_flt_z; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n \n\t\t\tpixels[i*img_w+j]=0xff000000 | \n\t\t\t\t\t\t\t((main_color_g<255.0f)? (((unsigned int)floor(main_color_g+0.5f))<<8u) : 0x0000ff00) | \n\t\t\t\t\t\t\t((main_color_r<255.0f)? (((unsigned int)floor(main_color_r+0.5f))<<16u) : 0x00ff0000); \n\t\t} \n\t}", "pragma": "for ", "hash": "071a36c457156446f3fc2d29b9b766e0cff02e41033efcd925a897c1ceeb1974"}
{"code": "for (long i = 0; i < total_iterations; i++) { \n \n\t\tgpu_threads_enter(gpu_stat); \n \n\t\t \n \n\t\tlong iter_i[D]; \n\t\tlong ii = i; \n \n\t\tfor (int p = nparallel - 1; p >= 0; p--) { \n \n\t\t\titer_i[p] = ii % parallel_dim[p]; \n\t\t\tii /= parallel_dim[p]; \n\t\t} \n \n\t\tvoid* moving_ptr[C]; \n \n\t\tfor (int j = 0; j < C; j++) { \n \n\t\t\tmoving_ptr[j] = ptr[j]; \n \n\t\t\tfor(int p = 0; p < nparallel; p++) \n\t\t\t\tmoving_ptr[j] += iter_i[p] * str[j][parallel_b[p]]; \n\t\t} \n \n\t\tmd_nary(C, D, dimc, str, moving_ptr, fun); \n \n\t\tgpu_threads_leave(gpu_stat); \n\t}", "pragma": "parallel for ", "hash": "5a2b6e798c543c10fbbd604115366a27f141e1d98a80c9afec7c35873f2e68ae"}
{"code": "for (int i = 1; i <= m_nReaches; i++) \n    { \n        m_qsTemp[i] = 0.f; \n        m_qiTemp[i] = 0.f; \n    }", "pragma": "parallel for ", "hash": "7bad3e89085ace088add729a6566ed359830ba8dc9520f18f12d4eda54a8b9eb"}
{"code": "for (int i = 0; i < n3; i++) \n    if (!std::isfinite(coord[i])) flag = 1;", "pragma": "parallel for reduction(+:flag) ", "hash": "9c0fa33d9ab2282051592aa88b834271e536c36bf9c19c36696e639a007b6fd8"}
{"code": "for (int cc = 0; cc < relevant_class_count; cc++) \n\t{ \n\t\tconst int thread_id = omp_get_thread_num(); \n \n\t\tif (thread_id == 0) \n\t\t{ \n\t\t\tLog::updateProgress(cc); \n\t\t} \n \n\t\tconst int class_id = classes_to_consider[cc]; \n \n\t\tRawImage<float> slice = class_averages.getSliceRef(class_id); \n\t\tconst d2Vector initial_centre(box_size/2, box_size/2 + (flip_y? radius : -radius)); \n \n\t\tBlobFit2D blob_fit( \n\t\t\tslice, initial_centre, radius/2, 0, 0, num_threads); \n \n\t\tfor (int y = 0; y < blob_fit.weight.ydim; y++) \n\t\tfor (int x = 0; x < blob_fit.weight.xdim; x++) \n\t\t{ \n\t\t\tconst double dx = x - box_size/2; \n\t\t\tconst double dy = y - box_size/2; \n\t\t\tconst double r = sqrt(dx*dx + dy*dy); \n \n\t\t\tif (r < box_size/2 - edge_padding) \n\t\t\t{ \n\t\t\t\tblob_fit.weight(x,y) = 1; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tblob_fit.weight(x,y) = 0; \n\t\t\t} \n\t\t} \n \n \n\t\tstd::vector<double> initial_parameters(num_frequencies + 2, 0.0); \n\t\tinitial_parameters[0] = initial_centre.x; \n\t\tinitial_parameters[1] = initial_centre.y; \n \n\t\tstd::vector<double> optimal_parameters = NelderMead::optimize( \n\t\t\t\tinitial_parameters, blob_fit, 2, 0.001, max_iterations, 1.0, 2.0, 0.5, 0.5, false); \n \n\t\tall_optimal_parameters[cc] = optimal_parameters; \n \n \n\t\tBlob2D blob(optimal_parameters, radius + 2*box_size); \n \n\t\tstd::vector<double> radial_average = blob.radialAverage(slice, blob_fit.weight); \n\t\tBufferedImage<float> projection = blob.radialAverageProjection(slice, radial_average); \n \n\t\tblob_fits.copySliceFrom(cc, projection); \n \n\t\t \n \n\t\t \n \n\t}", "pragma": "parallel for ", "hash": "85f5fb2daea7a991c2db45e09c7998c34a95ee15266d71e746b1aab82af17cc0"}
{"code": "for (int i = 0; i < tree->num_leaves(); ++i) { \n    OMP_LOOP_EX_BEGIN(); \n    data_size_t cnt_leaf_data = 0; \n    auto tmp_idx = data_partition_->GetIndexOnLeaf(i, &cnt_leaf_data); \n    double sum_grad = 0.0f; \n    double sum_hess = kEpsilon; \n    for (data_size_t j = 0; j < cnt_leaf_data; ++j) { \n      auto idx = tmp_idx[j]; \n      sum_grad += gradients[idx]; \n      sum_hess += hessians[idx]; \n    } \n    double output = FeatureHistogram::CalculateSplittedLeafOutput(sum_grad, sum_hess, \n                                                                  tree_config_->lambda_l1, tree_config_->lambda_l2); \n    tree->SetLeafOutput(i, output* tree->shrinkage()); \n    OMP_LOOP_EX_END(); \n  }", "pragma": "parallel for ", "hash": "3126c7a65ea838beed52dd7f99bd691b154e7595d4f0cd512a30aa13557bbd47"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr) \n\t{ \n\t\tb[i] = a[i]; \n\t\tfor(long j=1;j<nz;j++)\tb[i+j*nn] = b[i+j*nn-nn] + a[i+j*nn]; \n\t}", "pragma": "parallel for ", "hash": "dda0464ecfd475417db110d9ced26b299d8d967c9583b3e57e36793ae8be26f0"}
{"code": "for ( int i = 0; i < ( int )corres_traj_.data_.size(); i++ ) {\r \n\t\tif ( blacklist_.find( corres_traj_.data_[ i ].id1_ ) != blacklist_.end() || blacklist_.find( corres_traj_.data_[ i ].id2_ ) != blacklist_.end() ) {\r \n   #pragma omp atomic\r \n\t\t\tnprocessed++;\r \n\t\t\tcorres_traj_.data_[ i ].frame_ = -1;\r \n\t\t\tPCL_INFO( \"Blacklist pair <%d, %d> ... \\n\", corres_traj_.data_[ i ].id1_, corres_traj_.data_[ i ].id2_ );\r \n\t\t\tPCL_WARN( \"%d / %d\\n\", nprocessed, corres_traj_.data_.size() );\r \n\t\t\tcontinue;\r \n\t\t}\r \n\t\tif ( corres_traj_.data_[ i ].frame_ == -1 ) {\r \n   #pragma omp atomic\r \n\t\t\tnprocessed++;\r \n\t\t\tcontinue;\t\t\t \n \n\t\t}\r \n\r \n\t\tstd::vector< CorrespondencePair > corres;\r \n\t\tint old_id = -1;\r \n\t\tpcl::KdTreeFLANN< pcl::PointXYZRGBNormal > tree;\r \n\t\tconst int K = 1;\r \n\t\tstd::vector< int > pointIdxNKNSearch(K);\r \n\t\tstd::vector< float > pointNKNSquaredDistance(K);\r \n\r \n\t\tPCL_INFO( \"Align pair <%d, %d> ... \\n\", corres_traj_.data_[ i ].id1_, corres_traj_.data_[ i ].id2_ );\r \n\r \n\t\tcorres.clear();\r \n\t\tpcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr pcd0 = pointclouds_[ corres_traj_.data_[ i ].id1_ ];\r \n\t\tpcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr pcd1 = pointclouds_[ corres_traj_.data_[ i ].id2_ ];\r \n\r \n\t\tpcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr transformed( new pcl::PointCloud<pcl::PointXYZRGBNormal> );\r \n\t\tpcl::transformPointCloudWithNormals( *pcd1, *transformed, corres_traj_.data_[ i ].transformation_ );\r \n\r \n\t\tif ( old_id != corres_traj_.data_[ i ].id1_ ) {\r \n\t\t\ttree.setInputCloud( pcd0 );\r \n\t\t\told_id = corres_traj_.data_[ i ].id1_;\r \n\t\t}\r \n\r \n\t\tint cnt = 0;\r \n\t\tfor ( int k = 0; k < ( int )transformed->size(); k++ ) {\r \n\t\t\tif ( tree.nearestKSearch( transformed->points[ k ], K, pointIdxNKNSearch, pointNKNSquaredDistance ) > 0 ) {\r \n\t\t\t\tif ( pointNKNSquaredDistance[ 0 ] < reg_dist_ * reg_dist_ ) {\r \n\t\t\t\t\tcnt++;\r \n\t\t\t\t}\r \n\t\t\t}\r \n\t\t}\r \n\r \n\t\tdouble r1 = ( double )cnt / ( double )pcd0->size();\r \n\t\tdouble r2 = ( double )cnt / ( double )transformed->size();\r \n\t\tPCL_INFO( \"    <%d, %d> : %d inliers with ratio %.2f(%d) and %.2f(%d) ... \", corres_traj_.data_[ i ].id1_, corres_traj_.data_[ i ].id2_, cnt, r1, pcd0->size(), r2, transformed->size() );\r \n \n \n\t\tbool accept = ( cnt >= reg_num_ || ( r1 > reg_ratio_ && r2 > reg_ratio_ ) );\r \n\t\tif ( accept ) {\r \n\t\t\tPCL_INFO( \"accept.\\n\" );\r \n\t\t\tcorres_traj_.data_[ i ].frame_ = cnt;\r \n\t\t} else {\r \n\t\t\tPCL_INFO( \"reject.\\n\" );\r \n\t\t\tcorres_traj_.data_[ i ].frame_ = -1;\r \n   #pragma omp atomic\r \n\t\t\tnprocessed++;\r \n\t\t\tPCL_WARN( \"%d / %d\\n\", nprocessed, corres_traj_.data_.size() );\r \n\t\t\tcontinue;\r \n\t\t}\r \n\r \n\t\tif ( redux_ ) {\r \n\t\t\tstdext::hash_map< int, int >::iterator it = redux_map_.find( GetReduxIndex( corres_traj_.data_[ i ].id1_, corres_traj_.data_[ i ].id2_ ) );\r \n\r \n\t\t\tif ( it != redux_map_.end() ) {\r \n\t\t\t\tcorres_traj_.data_[ i ].transformation_ = redux_traj_.data_[ it->second ].transformation_;\r \n    #pragma omp atomic\r \n\t\t\t\tnprocessed++;\r \n\t\t\t\tPCL_WARN( \"%d / %d\\n\", nprocessed, corres_traj_.data_.size() );\r \n\t\t\t\tcontinue;\r \n\t\t\t}\r \n\t\t}\r \n\r \n\t\tpcl::IterativeClosestPoint< pcl::PointXYZRGBNormal, pcl::PointXYZRGBNormal > icp;\t\t\t\t\r \n\t\ttypedef pcl::registration::TransformationEstimationPointToPlaneLLS<pcl::PointXYZRGBNormal, pcl::PointXYZRGBNormal> PointToPlane;\r \n\t\tboost::shared_ptr<PointToPlane> point_to_plane(new PointToPlane);\r \n\r \n\t\ticp.setInputCloud( pcd1 );\r \n\t\ticp.setInputTarget( pcd0 );\r \n\t\ticp.setMaxCorrespondenceDistance( reg_dist_ );\r \n\t\ticp.setMaximumIterations( 20 );\r \n\t\ticp.setTransformationEpsilon( 1e-6 );\r \n\t\ticp.setTransformationEstimation( point_to_plane );\r \n\r \n\t\ticp.align( *transformed, corres_traj_.data_[ i ].transformation_.cast<float>() );\r \n\t\tPCL_INFO( \"    <%d, %d> : ICP fitness score is %.6f\\n\", corres_traj_.data_[ i ].id1_, corres_traj_.data_[ i ].id2_, icp.getFitnessScore() );\r \n\t\tPCL_INFO( \"    Matrix from : \\n\" );\r \n\t\tcout << corres_traj_.data_[ i ].transformation_ << endl;\r \n\t\tPCL_INFO( \"    To : \\n\" );\r \n\t\tcout << icp.getFinalTransformation() << endl;\r \n\t\tcorres_traj_.data_[ i ].transformation_ = icp.getFinalTransformation().cast<double>();\r \n\r \n  #pragma omp atomic\r \n\t\tnprocessed++;\r \n\r \n\t\tPCL_WARN( \"%d / %d\\n\", nprocessed, corres_traj_.data_.size() );\r \n\t}", "pragma": "parallel for ", "hash": "0edc1a344842ef47a192263899d8c748a18dfb25865e2c80195faab6c6b3974b"}
{"code": "for (int e = 0; e < tadsIn->size(); e++) \n                _adjust_saturation_single(tadsIn->at(e), tadsOut->at(e), delta, isNHWC);", "pragma": "parallel for ", "hash": "30254963c37b6629535e5d260acd102918157acef7b7020e99f954c9085910ed"}
{"code": "for (int i = 0; i < wcCount; i++) \n  { \n    if (trainedWcCount % 100 == 0) \n    { \n      int progress = 100 * trainedWcCount / wcCount; \n      ObjedConsole::printProgress(progressLabel, progress); \n    } \n \n    zList[i] = trainWcReal(wcList[i].data(), positiveSamples, negativeSamples); \n \n#pragma omp atomic \n    trainedWcCount++; \n  }", "pragma": "parallel for ", "hash": "d262ebb3eb98944b4c734190fe0afa2692e79da45b99d88cd43879a8a6edb610"}
{"code": "for(int i = 0; i < src.num_elements(); ++i) \n        { \n            result[i] = src[i] << shift; \n        }", "pragma": "parallel for ", "hash": "eb1f75381c7fe2dfbd386cf2ed26b03ad238bd77fa02cea7a2ce7b38f6d456a3"}
{"code": "for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i) { \n\t\tfor (int j = 0; j < iwidth; ++j) { \n\t\t\tint x = j + nr_leftmargin; \n\t\t\tint y = i + nr_topmargin; \n\t\t\tif (ndir[nr_offset(y, x)] & HOT) { \n\t\t\t\tint l = libraw.COLOR(i, j); \n\t\t\t\tnraw[nr_offset(i + nr_topmargin, j + nr_leftmargin)][l] = libraw.imgdata.image[i \n\t\t\t\t\t\t* iwidth + j][l]; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(iwidth)", "hash": "6bffab9021c803382820fd39d2753c2c9b1a208f3db94be54a3c40440b6a181f"}
{"code": "for(iz=0; iz<nzpad; iz++) \n\t{ \n\t  for(ix=0;ix<nb;ix++){\t \n \n\t    p0[ix][iz]=bndr[ix]*p0[ix][iz]; \n\t    p1[ix][iz]=bndr[ix]*p1[ix][iz]; \n\t  }\t \n\t  for(ix=nx+nb;ix<nxpad;ix++){ \n \n\t    p0[ix][iz]=bndr[nxpad-ix-1]*p0[ix][iz]; \n\t    p1[ix][iz]=bndr[nxpad-ix-1]*p1[ix][iz]; \n\t  }\t \n\t}", "pragma": "parallel for private(ix iz)", "hash": "a3f34a5e80ef976b80548b4988e65d85866a56d67ff62c0b6122492f8a8c6da2"}
{"code": "for (k = 0; k < ths->M_total; k++) \n  { \n    int u[ths->d], o[ths->d];  \n \n    int t, t2;  \n \n    int l_L;  \n \n    int l[ths->d];  \n \n    int lj[ths->d];  \n \n    int ll_plain[ths->d+1];  \n \n    R phi_prod[ths->d+1];  \n \n    int j = (ths->nfft_flags & NFFT_SORT_NODES) ? ths->index_x[2*k+1] : k; \n \n    phi_prod[0] = K(1.0); \n    ll_plain[0] = 0; \n \n    MACRO_init_uo_l_lj_t; \n \n    for (l_L = 0; l_L < lprod; l_L++) \n    { \n      C *lhs; \n      R *lhs_real; \n      C val; \n \n      MACRO_update_phi_prod_ll_plain(without_PRE_PSI); \n \n      lhs = ths->g + ll_plain[ths->d]; \n      lhs_real = (R*)lhs; \n      val = phi_prod[ths->d] * ths->f[j]; \n \n      #pragma omp atomic \n      lhs_real[0] += creal(val); \n \n      #pragma omp atomic \n      lhs_real[1] += cimag(val); \n \n      MACRO_count_uo_l_lj_t; \n    }  \n \n  }", "pragma": "parallel for private(k)", "hash": "ec276b1bcb77df8cae89bacc42f81473edb385cacd1f5e1d28cd5cbfbeeb91ab"}
{"code": "for (int64_t i = 0; i < n_particles; i++) { \n    Particle& p = simulation::particles[i]; \n    p.event_death(); \n  }", "pragma": "parallel for ", "hash": "feb3d87e6475cc9a4eef41f8f4736ad8c6e00589b1f3e6a020ecc9c9ba1f09c8"}
{"code": "for(long i=0;i<4*nx*ny;i++)\ta[i] *= exp(huy[i]);", "pragma": "for ", "hash": "0359f7b9c185c5bdbd4e2efbe612ed045fbc7b04217f88a5d54813f3f8ec2a7a"}
{"code": "for (ImpLong idx = 0; idx < l; idx++) \n        loss += R.val[idx]*R.val[idx];", "pragma": "parallel for reduction(+:loss) ", "hash": "f0e69602a1d7af049c6d67492abdc0abd3d300dec03170a4c8c5fbf99c90ed8d"}
{"code": "for (int th = 0; th < FLAGS_n_threads; ++th) {\r \n            UpdatePhi_th(FLAGS_n_sgld_phi * n_iter + _, th, FLAGS_n_threads);\r \n        }", "pragma": "parallel for ", "hash": "b1fd4f54f2bd0342e4417080770c8dfe1a1a9ed615803be02f6e630704a9c532"}
{"code": "for (int i = 0; i < m_subbasinNum + 1; i++) \n\t{ \n\t\tm_surfqToCh[i] = 0.f; \n\t\tm_sedToCh[i] = 0.f; \n\t\tm_surNO3ToCh[i] = 0.f; \n\t\tm_surNH4ToCh[i] = 0.f; \n\t\tm_surSolPToCh[i] = 0.f; \n\t\tm_surCodToCh[i] = 0.f; \n\t\tm_sedOrgNToCh[i] = 0.f; \n\t\tm_sedOrgPToCh[i] = 0.f; \n\t\tm_sedMinPAToCh[i] = 0.f; \n\t\tm_sedMinPSToCh[i] = 0.f; \n\t}", "pragma": "parallel for ", "hash": "6c6ee8ff9600d3ea71aeaee166dd3b4f454fe08ea9f62366b5b999a5fb4136a7"}
{"code": "for(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t}", "pragma": "parallel for ", "hash": "cc306f8d3839b163e78b599eb61f5cd03fdfec2b3fe4f0ebdbf0e28f73650881"}
{"code": "for (ompIndexType i = 0; i < static_cast<ompIndexType>(evals.rows()); ++i) { \n        evals(i) = cos(evals(i)); \n    }", "pragma": "parallel for ", "hash": "40209a4f548e6691a6805c4090c67fd24230dda23f4cf2e95c1941e5067a0e5e"}
{"code": "for (j=0; j < (long) distort_image->rows; j++) \n  { \n    long \n      y; \n \n    MagickPixelPacket \n      pixel,     \n \n      invalid;   \n \n \n    PointInfo \n      point;     \n \n \n    register IndexPacket \n      *indexes; \n \n    register long \n      i, \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    double \n      validity; \n \n    id=GetCacheViewThreadId(); \n    q=SetCacheViewPixels(distort_view[id],0,j,distort_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(distort_view[id]); \n \n    GetMagickPixelPacket(distort_image,&pixel); \n \n     \n \n    switch (method) \n    { \n      case AffineDistortion: \n      case AffineProjectionDistortion: \n        ScaleResampleFilter( resample_filter[id], \n          coefficients[0], coefficients[2], \n          coefficients[1], coefficients[3] ); \n        break; \n      default: \n        break; \n    } \n \n     \n \n    validity = 1.0; \n \n    GetMagickPixelPacket(distort_image,&invalid); \n    SetMagickPixelPacket(distort_image,&distort_image->matte_color, \n      (IndexPacket *) NULL, &invalid); \n    if (distort_image->colorspace == CMYKColorspace) \n      ConvertRGBToCMYK(&invalid);    \n \n    point.x=0; \n    point.y=0; \n    y = j+geometry.y;    \n \n    for (i=0; i < (long) distort_image->columns; i++) \n    { \n      x = i+geometry.x;  \n \n      switch (method) \n      { \n        case AffineDistortion: \n        case AffineProjectionDistortion: \n        { \n          point.x=coefficients[0]*x+coefficients[2]*y+coefficients[4]; \n          point.y=coefficients[1]*x+coefficients[3]*y+coefficients[5]; \n           \n \n          break; \n        } \n        case PerspectiveDistortion: \n        case PerspectiveProjectionDistortion: \n        { \n          double \n            p,q,r,abs_r,abs_c6,abs_c7,scale; \n           \n \n          p=coefficients[0]*x+coefficients[1]*y+coefficients[2]; \n          q=coefficients[3]*x+coefficients[4]*y+coefficients[5]; \n          r=coefficients[6]*x+coefficients[7]*y+1.0; \n           \n \n          validity = (r*coefficients[8] < 0.0) ? 0.0 : 1.0; \n           \n \n          abs_r = fabs(r)*2; \n          abs_c6 = fabs(coefficients[6]); \n          abs_c7 = fabs(coefficients[7]); \n          if ( abs_c6 > abs_c7 ) { \n            if ( abs_r < abs_c6 ) \n              validity = 0.5 - coefficients[8]*r/coefficients[6]; \n          } \n          else if ( abs_r < abs_c7 ) \n            validity = .5 - coefficients[8]*r/coefficients[7]; \n           \n \n          if ( validity > 0.0 ) { \n            scale = 1.0/r; \n            point.x = p*scale; \n            point.y = q*scale; \n             \n \n            scale *= scale; \n            ScaleResampleFilter( resample_filter[id], \n              (r*coefficients[0] - p*coefficients[6])*scale, \n              (r*coefficients[1] - p*coefficients[7])*scale, \n              (r*coefficients[3] - q*coefficients[6])*scale, \n              (r*coefficients[4] - q*coefficients[7])*scale ); \n          } \n          break; \n        } \n        case BilinearDistortion: \n        { \n          point.x=coefficients[0]*x+coefficients[1]*y+coefficients[2]*x*y+ \n            coefficients[3]; \n          point.y=coefficients[4]*x+coefficients[5]*y+coefficients[6]*x*y+ \n            coefficients[7]; \n           \n \n          ScaleResampleFilter( resample_filter[id], \n              coefficients[0] + coefficients[2]*y, \n              coefficients[1] + coefficients[2]*x, \n              coefficients[4] + coefficients[6]*y, \n              coefficients[5] + coefficients[6]*x ); \n          break; \n        } \n        case PolynomialDistortion: \n        { \n          register long \n            k; \n          long \n            nterms=(long)coefficients[1]; \n \n          double \n            dudx,dudy,dvdx,dvdy; \n \n          point.x=point.y=dudx=dudy=dvdx=dvdy=0.0; \n          for(k=0; k < nterms; k++) { \n            point.x += poly_term(k,x,y)*coefficients[k+2]; \n            dudx += poly_term_dx(k,x,y)*coefficients[k+2]; \n            dudy += poly_term_dy(k,x,y)*coefficients[k+2]; \n            point.y += poly_term(k,x,y)*coefficients[k+2+nterms]; \n            dvdx += poly_term_dx(k,x,y)*coefficients[k+2+nterms]; \n            dvdy += poly_term_dy(k,x,y)*coefficients[k+2+nterms]; \n          } \n          ScaleResampleFilter( resample_filter[id], dudx,dudy,dvdx,dvdy ); \n          break; \n        } \n        case ArcDistortion: \n        { \n           \n \n          point.x = (atan2((double)y,(double)x) - coefficients[0])/(2*MagickPI); \n          point.x -= MagickRound(point.x);      \n \n          point.y = sqrt((double) x*x+y*y);     \n \n \n           \n \n          if ( point.y > MagickEpsilon ) \n            ScaleResampleFilter( resample_filter[id], \n                coefficients[1]/(2*MagickPI)/point.y, 0, 0, coefficients[3] ); \n               \n \n          else \n            ScaleResampleFilter( resample_filter[id], \n                 MagickHuge, 0, 0, coefficients[3] ); \n \n           \n \n          point.x = point.x*coefficients[1] + coefficients[4]; \n          point.y = (coefficients[2] - point.y) * coefficients[3]; \n          break; \n        } \n        default: \n        { \n           \n \n          point.x=(double) i; \n          point.y=(double) j; \n          break; \n        } \n      } \n       \n \n      if ( bestfit && method != ArcDistortion ) { \n        point.x -= image->page.x; \n        point.y -= image->page.y; \n      } \n \n      if ( validity <= 0.0 ) { \n         \n \n        SetPixelPacket(distort_image,&invalid,q,indexes); \n      } \n      else { \n         \n \n        pixel=ResamplePixelColor(resample_filter[id],point.x,point.y); \n         \n \n        if ( validity < 1.0 ) { \n           \n \n           \n \n          MagickPixelCompositeBlend(&pixel, validity, \n               &invalid, (1.0-validity), &pixel); \n        } \n        SetPixelPacket(distort_image,&pixel,q,indexes); \n      } \n      q++; \n      indexes++; \n    } \n    if (SyncCacheView(distort_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,DistortImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  }", "pragma": "parallel for ", "hash": "d14c3194c179c397c74db3895993b0ff5e676c705abcb685eb80ee0d08191415"}
{"code": "for (y = 0; y < height; y++) { \n        for (int tile = 0; tile < count; tile++) { \n            copy_row(images[tile], result, tile * width, y); \n        } \n    }", "pragma": "parallel for ", "hash": "62477ff4d51559643ffd435725b83d841aef9aba8fa9cc63b5c1a4b7a84def57"}
{"code": "for (i=0; i < P_offd_size; i++) \n      {   P_offd_j[i] = permute[P_offd_j[i]]; }", "pragma": "parallel for private(i)", "hash": "c6891a35e7dfca054daca72c6506bf68d461adad6bad1af48b3a4da5a585178c"}
{"code": "for(usint i = 0; i < sequences; i++) \n  { \n    usint begin = (i > 0 ? end_markers[i - 1] + 1 : 0); \n    this->index->reportPositions(sequence + begin, end_markers[i] - begin, ranks + begin); \n  }", "pragma": "parallel for ", "hash": "3c9c3d4825b941b987ef191aed80f2b1b6b77fccb472402c1a068cd617b688f2"}
{"code": "for (i=0; i<n; ++i) { \n    y[i] = alpha*x[i] + y[i]; \n  }", "pragma": "parallel for private(  alpha i x y)", "hash": "5528c33983d527596fbdc8e0ad6931902f5533c8d12a015cea178b8d67271afc"}
{"code": "for (int i = 0; i < npixels; i++) \n            hloc[pixels[i]]++;", "pragma": "for ", "hash": "8e55e9ccc73470b46113e13e28c9c1a242e789bb315c68d152719e1164bb1386"}
{"code": "for (int j = 0; j < img_row; j++) \n\t{ \n\t\tfloat* I_p1 = I.ptr<float>(j); \n\t\tfloat* p_p1 = p.ptr<float>(j); \n\t\tfloat* I_p2 = I.ptr<float>(j) + 1; \n\t\tfloat* p_p2 = p.ptr<float>(j) + 1; \n \n\t\tfloat* v0_p = tempVec[0].ptr<float>(0) + 4 * j;  \n \n\t\tfloat* v1_p = tempVec[1].ptr<float>(0) + 4 * j;  \n \n \n\t\tfloat sum[2] = { 0.f }; \n\t\tsum[0] += *p_p1 * (r + 1); \n\t\tsum[1] += (*I_p1 * *p_p1) * (r + 1); \n\t\tfor (int i = 1; i <= r; i++) \n\t\t{ \n\t\t\tsum[0] += *p_p2; \n\t\t\tsum[1] += *I_p2 * *p_p2; \n\t\t\tI_p2++; \n\t\t\tp_p2++; \n\t\t} \n\t\t*v0_p = sum[0]; \n\t\tv0_p++; \n\t\t*v1_p = sum[1]; \n\t\tv1_p++; \n \n\t\tfor (int i = 1; i <= r; i++) \n\t\t{ \n\t\t\tsum[0] += *p_p2 - *p_p1; \n\t\t\tsum[1] += (*I_p2 * *p_p2) - (*I_p1 * *p_p1); \n\t\t\tI_p2++; \n\t\t\tp_p2++; \n \n\t\t\t*v0_p = sum[0]; \n\t\t\t*v1_p = sum[1]; \n \n\t\t\tif ((i & 3) == 3) \n\t\t\t{ \n\t\t\t\tv0_p += step; \n\t\t\t\tv1_p += step; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tv0_p++; \n\t\t\t\tv1_p++; \n\t\t\t} \n\t\t} \n\t\tfor (int i = r + 1; i < img_col - r - 1; i++) \n\t\t{ \n\t\t\tsum[0] += *p_p2 - *p_p1; \n\t\t\tsum[1] += (*I_p2 * *p_p2) - (*I_p1 * *p_p1); \n\t\t\tI_p1++; \n\t\t\tp_p1++; \n\t\t\tI_p2++; \n\t\t\tp_p2++; \n \n\t\t\t*v0_p = sum[0]; \n\t\t\t*v1_p = sum[1]; \n \n\t\t\tif ((i & 3) == 3) \n\t\t\t{ \n\t\t\t\tv0_p += step; \n\t\t\t\tv1_p += step; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tv0_p++; \n\t\t\t\tv1_p++; \n\t\t\t} \n\t\t} \n\t\tfor (int i = img_col - r - 1; i < img_col; i++) \n\t\t{ \n\t\t\tsum[0] += *p_p2 - *p_p1; \n\t\t\tsum[1] += (*I_p2 * *p_p2) - (*I_p1 * *p_p1); \n\t\t\tI_p1++; \n\t\t\tp_p1++; \n \n\t\t\t*v0_p = sum[0]; \n\t\t\t*v1_p = sum[1]; \n \n\t\t\tif ((i & 3) == 3) \n\t\t\t{ \n\t\t\t\tv0_p += step; \n\t\t\t\tv1_p += step; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tv0_p++; \n\t\t\t\tv1_p++; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "755602abccf8745bdced15016f3a81f3d24565969b18706dd16bd17f11ad64fe"}
{"code": "for( int i=0; i<nqueries; i++ ) {        \n \n \n\t\t\t \n \n      float* query  = queries + i*d;      \t\t      \n \n      float* tentry = new float[ total_cb_entries ]();  \n \n \n      for( int j=0; j<total_cb_entries; j++ ) {   \t \n \n          float* centry = codebooks + j*d; \t\t\t \n \n \n          for ( int k=0; k<d; k++) {              \n \n              tentry[ j ] -= 2*query[k]*centry[k];  \n \n          } \n      } \n \n\t\t\tpair<float,int> * pairs = new pair<float,int>[ npairs ](); \n \n       \n \n \n\t\t\t \n \n\t\t\tunsigned char* code = codes; \n \n\t\t\tint from = 0; \n\t\t\tint normidx = 0; \n\t\t\twhile (from < ncodes) { \n\t\t\t\tint offset = 0; \n\t\t\t\tif (from > 0) { \n\t\t\t\t\toffset = nn; \n\t\t\t\t} \n \n        for (long j=0 + offset;                 \n \n\t\t\t\t\t\tj< min(ncodes, from + buffer_size + (nn - offset)) - from + offset; \n\t\t\t\t\t\tj++, code += m, normidx++) { \n \n\t\t\t\t\tpairs[j].first  = 0; \n          for (int k=0; k<m; k++) {   \n \n            pairs[j].first += tentry[ h*k + code[k] ]; \n \n          } \n          pairs[j].first += dbnorms[ normidx ];  \n \n \n\t\t\t\t\tpairs[j].second = j + 1  + from - offset;  \n \n        } \n \n\t\t\t\tfrom = min(ncodes, from + buffer_size + (nn - offset)); \n \n\t\t\t\t \n \n        partial_sort(pairs, pairs + nn, pairs + npairs); \n\t\t\t} \n \n      for (long j=0; j<nn; j++) { \n          dists[i*nn + j] = pairs[j].first; \n          idx  [i*nn + j] = pairs[j].second; \n      } \n      delete [] pairs; \n      delete [] tentry; \n    }", "pragma": "parallel for ", "hash": "07d4e30ac5ed1d686e13a84efb3e3ae7a9f94c267e1c820745c978bc51556bb1"}
{"code": "for (int cellIdx = 0; cellIdx < static_cast<int>(cellVisibility->size()); ++cellIdx) \n            { \n                (*cellVisibility)[cellIdx] = (*visibleWellCells)[cellIdx] && !(*rangeFilteredWellCells)[cellIdx]; \n            }", "pragma": "parallel for ", "hash": "c3192e57e00a739c5f367b551311b6ab13a5b615634244c73357c193b89baed6"}
{"code": "for (int64_t edge_idx = 0; edge_idx < sdbg_->size; ++edge_idx) { \n        if (sdbg_->IsValidEdge(edge_idx) && sdbg_->NextSimplePathEdge(edge_idx) == -1 && marked.try_lock(edge_idx)) { \n            bool will_be_added = true; \n            int64_t cur_edge = edge_idx, prev_edge; \n            int64_t depth = sdbg_->EdgeMultiplicity(edge_idx); \n            uint32_t length = 1; \n \n            while ((prev_edge = sdbg_->PrevSimplePathEdge(cur_edge)) != -1) { \n                cur_edge = prev_edge; \n \n                if (!marked.try_lock(cur_edge)) { \n                    will_be_added = false; \n                    break; \n                } \n \n                depth += sdbg_->EdgeMultiplicity(cur_edge); \n                ++length; \n            } \n \n            if (!will_be_added) { \n                continue; \n            } \n \n            int64_t rc_start = sdbg_->EdgeReverseComplement(edge_idx); \n            int64_t rc_end = -1; \n            assert(rc_start != -1); \n \n            if (!marked.try_lock(rc_start)) { \n                rc_end = sdbg_->EdgeReverseComplement(cur_edge); \n \n                if (std::max(edge_idx, cur_edge) < std::max(rc_start, rc_end)) { \n                    will_be_added = false; \n                } \n            } \n            else { \n                 \n \n                int64_t rc_cur_edge = rc_start; \n                rc_end = rc_cur_edge; \n                bool extend_full = true; \n \n                while ((rc_cur_edge = sdbg_->NextSimplePathEdge(rc_cur_edge)) != -1) { \n                    rc_end = rc_cur_edge; \n \n                    if (!marked.try_lock(rc_cur_edge)) { \n                        extend_full = false; \n                        break; \n                    } \n                } \n \n                if (!extend_full) { \n                    rc_end = sdbg_->EdgeReverseComplement(cur_edge); \n                } \n            } \n \n            if (!will_be_added) { \n                continue; \n            } \n \n            omp_set_lock(&path_lock); \n            vertices_.push_back(UnitigGraphVertex(cur_edge, edge_idx, rc_start, rc_end, depth, length)); \n            omp_unset_lock(&path_lock); \n        } \n    }", "pragma": "parallel for ", "hash": "cebb6de16d84aed902f03315b81fd53dc346ebb22d22a5b8a7f96ec5491d7129"}
{"code": "for ( int cellIdx = 0; cellIdx < static_cast<int>( cellVisibility->size() ); ++cellIdx ) \n            { \n                ( *cellVisibility )[cellIdx] = ( *visibleWellCells )[cellIdx] && !( *rangeFilteredWellCells )[cellIdx]; \n            }", "pragma": "parallel for ", "hash": "5074c9ac20262b85ec7548e809a86725de1689330c4e413f5dd40dbe9d2f55c4"}
{"code": "for(long i=0;i<31;i++)\tfor(long j=0;j<31;j++) \n\t\t\t{ \n\t\t\t\tlong i0=kq+3*(i+31*j); \n\t\t\t\tAddPntQ(i0,  mglPoint(oo[im].x,Min.y+dy*i,Min.z+dz*j)); \n\t\t\t\tAddPntQ(i0+1,mglPoint(Min.x+dx*i,oo[im].y,Min.z+dz*j)); \n\t\t\t\tAddPntQ(i0+2,mglPoint(Min.x+dx*i,Min.y+dy*j,oo[im].z)); \n\t\t\t}", "pragma": "parallel for ", "hash": "07a871b62ad6f8883dd762e989527ba836108af947aa2acc5ebae57cb19dee02"}
{"code": "for(INMOST_DATA_INTEGER_TYPE k = wbeg; k < static_cast<INMOST_DATA_INTEGER_TYPE>(wend); ++k) \n\t\t{ \n\t\t\t \n \n\t\t\tG_Address[k].thr = Thread(); \n\t\t\tG_Address[k].first = (INMOST_DATA_ENUM_TYPE)G_Entries[G_Address[k].thr].size(); \n\t\t\tfor (INMOST_DATA_ENUM_TYPE it = Address[k].first; it < Address[k].last; ++it)  \n \n\t\t\t\tG_Entries[G_Address[k].thr].push_back(Entries[Address[k].thr][it].first); \n\t\t\t\t \n \n\t\t\tG_Address[k].last = (INMOST_DATA_ENUM_TYPE)G_Entries[G_Address[k].thr].size(); \n\t\t}", "pragma": "parallel for ", "hash": "11ad34464d372ec8cab84b802937a9dd7c0e272161bf82388c6043e405b55344"}
{"code": "for(unsigned x = 0; x < volume_res.x; ++x) { \n      for(unsigned y = 0; y < volume_res.y; ++y) { \n        for(unsigned z = 0; z < volume_res.z; ++z) { \n          glm::fvec3 sample_pos = sample_start + glm::fvec3{x,y,z} * sample_step; \n           \n \n          if (!m_frustums[i].inside(sample_pos)) { \n            curr_volume_inv[z * volume_res.x * volume_res.y + y * volume_res.x + x] = glm::fvec4{-1.0f}; \n            continue; \n          } \n \n           \n           \n \n          auto samples = curr_calib_search.search(sample_pos, 8); \n          auto weighted_index = inverseDistance(sample_pos, samples); \n           \n \n          auto nearestD = curr_calib_search.search(sample_pos, 1)[0]; \n          auto weighted_index = calcuateDepthToWorldCoordinate(sample_pos, nearestD, calib); \n          curr_volume_inv[z * volume_res.x * volume_res.y + y * volume_res.x + x] = glm::fvec4{(weighted_index + glm::fvec3{0.5f}) / curr_calib_dims, 1.0f}; \n \n          sample_pos.z += sample_step.z; \n        } \n         \n \n        sample_pos.y += sample_step.y; \n        sample_pos.z = sample_start.z; \n      } \n       \n \n      sample_pos.x += sample_step.x; \n      sample_pos.y = sample_start.y; \n    }", "pragma": "parallel for ", "hash": "e6963bc3fbe8f31927b7aff095f51aa72816d8a398b3ebc1f9ba97d9984ba9f7"}
{"code": "for (l_z = 0; l_z < l_n; l_z+=l_n_block) { \n      libxsmm_dfsspmdm_execute( gemm_op_betazero, l_b+l_z, l_c_betazero+l_z ); \n    }", "pragma": "parallel for private(l_z)", "hash": "611090fb732b8c969314bfafaf95b9a855dd4767949ac72c72a8e473175c2ba0"}
{"code": "for (ix = 0; ix < nxb; ix++) { \n\tfor (iz = 0; iz < nzb; iz++) { \n\t    txxn0[ix][iz] = 0.0; \n\t} \n    }", "pragma": "parallel for private( ix iz)", "hash": "5d3234c1d1f3ac65bb26f87ec9628afecc13bdb97bb6dc27c58c90bb274c491a"}
{"code": "for(long i=0;i<n;i++)\t{\txc[i]=xx[1]*(x->a[i]-xx[0]);\tyc[i]=xx[3]*(y->a[i]-xx[2]);\t}", "pragma": "parallel for ", "hash": "2d8f9485799e96234b1b7a046bfcb59d38b4349771b4df0e0e8145bc21a64731"}
{"code": "for (size_t x = 0; x < N; x++) { \n    for (size_t y = 0; y < N; y++) { \n      for (size_t k = 0; k < N; k++) { \n        C[x * N + y] += A[x * N + k] * B[k * N + y]; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "ea734fdbcfee69b499f48ec438aa1152c116ba0b0e7b6f08b33be8bd7db2fc62"}
{"code": "for(long i=0;i<nx;i++)\tfor(long j=0;j<ny;j++)\tfor(long k=0;k<nz;k++) \n\t\t\tb[k+nz*(i+nx*j)] = a[i+nx*(j+ny*k)];", "pragma": "parallel for ", "hash": "7d2ddfbc273050dcd8692e457f738d78a3d1db9d601d30b3395778f3f51d55ad"}
{"code": "for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif (inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n \n\t    LOOP( weop->ww[ompith][ihx][imy][imx] = sf_cmplx(0,0); );   \n\t     \n\t     \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,cub->amz.n-1,slo->so[ompith][0]); \n\t    for (imz=cub->amz.n-1; imz>0; imz--) { \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d) ... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n \n#pragma omp critical \n\t\t{ \n\t\tsf_fslice_get(imag,imz,weop->qq[0][0]);  \n \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx] += \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx].r +=  \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\t} \n#pragma omp critical \n\t\tsf_fslice_get(slo->slice,imz-1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith);\t \n\t\tslow3_advance(cub,slo,ompith); \n\t    } \n \n\t     \n \n#pragma omp critical \n\t    { \n\t\tsf_fslice_get(imag,0,weop->qq[0][0]); \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx]  +=  \n\t\t      weop->qq        [ihx][imy][imx]; );\t \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx].r  +=  \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\ttaper3d(weop->ww[ompith],tap); \n\t\tsf_fslice_put(data,iw,weop->ww[ompith][0][0]);     \n \n\t    } \n\t     \n\t} else {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,-(cub->aw.o+iw*cub->aw.d));  \n \n \n\t     \n \n#pragma omp critical \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t     \n#pragma omp critical \n\t    { \n\t\tsf_fslice_get(imag,0,weop->qq[0][0]); \n\t\tLOOP(;      weop->qq        [ihx][imy][imx] +=  \n\t\t     crealf(weop->ww[ompith][ihx][imy][imx] ); ); \n\t\tsf_fslice_put(imag,0,weop->qq[0][0]); \n\t    } \n\t     \n\t     \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,0,slo->so[ompith][0]);\t \n\t    for (imz=0; imz<cub->amz.n-1; imz++) { \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d) ... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n#pragma omp critical \n\t\tsf_fslice_get(slo->slice,imz+1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith); \n\t\tslow3_advance(cub,slo,ompith); \n \n#pragma omp critical \n\t\t{ \n\t\t    sf_fslice_get(imag,imz+1,weop->qq[0][0]);  \n \n\t\t    LOOP(;      weop->qq        [ihx][imy][imx] +=  \n\t\t\t crealf(weop->ww[ompith][ihx][imy][imx] ); ); \n\t\t    sf_fslice_put(imag,imz+1,weop->qq[0][0]); \n\t\t} \n \n\t    }  \n \n \n\t}  \n \n    }", "pragma": "parallel for private(ihx imx imy imz iw ompith w)", "hash": "5ff7d937ee6aba76cebc887a7d824392ea06d3d029a5793dd08222058778721b"}
{"code": "for(ic=0; ic<nc; ic++) { \n\t\tif(ccin[ic]) { \n\t\t     \n\t\t    for        (iht=0; iht<nht2; iht++) { mct=mctall    [iht]; pct=pctall    [iht]; \n\t\t\tfor    (ihx=0; ihx<nhx2; ihx++) { mcx=mcxall[ic][ihx]; pcx=pcxall[ic][ihx]; \n\t\t\t    for(ihz=0; ihz<nhz2; ihz++) { mcz=mczall[ic][ihz]; pcz=pczall[ic][ihz]; \n\t\t\t\t \n\t\t\t\tii[ic][iht][ihx][ihz] += us[mct][mcx][mcz]*ur[pct][pcx][pcz]; \n\t\t\t\t \n\t\t\t    }  \n \n\t\t\t}      \n \n\t\t    }          \n \n\t\t     \n\t\t} \n\t    }", "pragma": "parallel for private(                                      ic iht ihx ihz mct mcx mcz pct pcx pcz)", "hash": "7f2ecb74798f806deec38f637d46d26f0f30b09f0cb191e4987559a4cddc6c38"}
{"code": "for(i = 0; i < THTensor_(nElement)(output); i++) \n    { \n      if (output_data[i] == 0.0) \n        gradInput_data[i] = 0.0; \n      else \n        gradInput_data[i] = 0.5 * (gradOutput_data[i] / output_data[i]); \n    }", "pragma": "parallel for private(i)", "hash": "6a6994d649349e704c5388280e09c6e725e1f47ee2e4df8591b7bf6c0d3d7325"}
{"code": "for(long j=0;j<nx*ny;j++)\tfor(long i=0;i<mx;i++) \n\t\t\t\tb[i+mx*j] = d->a[j];", "pragma": "parallel for ", "hash": "6d4b477c2b55a2101fb5dbcef60d07f6eeb60ac9f521a1256570155700739b75"}
{"code": "for (int j = 0; j < img_row; j++) \n\t{ \n\t\tfloat* I_p1 = I.ptr<float>(j); \n\t\tfloat* p_p1 = p.ptr<float>(j); \n\t\tfloat* I_p2 = I.ptr<float>(j) + 1; \n\t\tfloat* p_p2 = p.ptr<float>(j) + 1; \n \n\t\tfloat* v0_p = tempVec[0].ptr<float>(0) + 4 * j;  \n \n\t\tfloat* v1_p = tempVec[1].ptr<float>(0) + 4 * j;  \n \n\t\tfloat* v2_p = tempVec[2].ptr<float>(0) + 4 * j;  \n \n\t\tfloat* v3_p = tempVec[3].ptr<float>(0) + 4 * j;  \n \n \n\t\tfloat* It_p = I.ptr<float>(j); \n\t\tfloat* v4_p = I_t.ptr<float>(0) + 4 * j; \n \n\t\tfloat sum[4] = { 0.f }; \n\t\tsum[0] += *I_p1 * (r + 1); \n\t\tsum[1] += *p_p1 * (r + 1); \n\t\tsum[2] += (*I_p1 * *I_p1) * (r + 1); \n\t\tsum[3] += (*I_p1 * *p_p1) * (r + 1); \n\t\tfor (int i = 1; i <= r; i++) \n\t\t{ \n\t\t\tsum[0] += *I_p2; \n\t\t\tsum[1] += *p_p2; \n\t\t\tsum[2] += *I_p2 * *I_p2; \n\t\t\tsum[3] += *I_p2 * *p_p2; \n\t\t\tI_p2++; \n\t\t\tp_p2++; \n\t\t} \n\t\t*v0_p = sum[0]; \n\t\tv0_p++; \n\t\t*v1_p = sum[1]; \n\t\tv1_p++; \n\t\t*v2_p = sum[2]; \n\t\tv2_p++; \n\t\t*v3_p = sum[3]; \n\t\tv3_p++; \n \n\t\t*v4_p = *It_p; \n\t\tv4_p++; \n\t\tIt_p++; \n \n\t\tfor (int i = 1; i <= r; i++) \n\t\t{ \n\t\t\tsum[0] += *I_p2 - *I_p1; \n\t\t\tsum[1] += *p_p2 - *p_p1; \n\t\t\tsum[2] += (*I_p2 * *I_p2) - (*I_p1 * *I_p1); \n\t\t\tsum[3] += (*I_p2 * *p_p2) - (*I_p1 * *p_p1); \n\t\t\tI_p2++; \n\t\t\tp_p2++; \n \n\t\t\t*v0_p = sum[0]; \n\t\t\t*v1_p = sum[1]; \n\t\t\t*v2_p = sum[2]; \n\t\t\t*v3_p = sum[3]; \n \n\t\t\t*v4_p = *It_p; \n\t\t\tIt_p++; \n \n\t\t\tif ((i & 3) == 3) \n\t\t\t{ \n\t\t\t\tv0_p += step; \n\t\t\t\tv1_p += step; \n\t\t\t\tv2_p += step; \n\t\t\t\tv3_p += step; \n \n\t\t\t\tv4_p += step; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tv0_p++; \n\t\t\t\tv1_p++; \n\t\t\t\tv2_p++; \n\t\t\t\tv3_p++; \n \n\t\t\t\tv4_p++; \n\t\t\t} \n\t\t} \n\t\tfor (int i = r + 1; i < img_col - r - 1; i++) \n\t\t{ \n\t\t\tsum[0] += *I_p2 - *I_p1; \n\t\t\tsum[1] += *p_p2 - *p_p1; \n\t\t\tsum[2] += (*I_p2 * *I_p2) - (*I_p1 * *I_p1); \n\t\t\tsum[3] += (*I_p2 * *p_p2) - (*I_p1 * *p_p1); \n\t\t\tI_p1++; \n\t\t\tp_p1++; \n\t\t\tI_p2++; \n\t\t\tp_p2++; \n \n\t\t\t*v0_p = sum[0]; \n\t\t\t*v1_p = sum[1]; \n\t\t\t*v2_p = sum[2]; \n\t\t\t*v3_p = sum[3]; \n \n\t\t\t*v4_p = *It_p; \n\t\t\tIt_p++; \n \n\t\t\tif ((i & 3) == 3) \n\t\t\t{ \n\t\t\t\tv0_p += step; \n\t\t\t\tv1_p += step; \n\t\t\t\tv2_p += step; \n\t\t\t\tv3_p += step; \n \n\t\t\t\tv4_p += step; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tv0_p++; \n\t\t\t\tv1_p++; \n\t\t\t\tv2_p++; \n\t\t\t\tv3_p++; \n \n\t\t\t\tv4_p++; \n\t\t\t} \n\t\t} \n\t\tfor (int i = img_col - r - 1; i < img_col; i++) \n\t\t{ \n\t\t\tsum[0] += *I_p2 - *I_p1; \n\t\t\tsum[1] += *p_p2 - *p_p1; \n\t\t\tsum[2] += (*I_p2 * *I_p2) - (*I_p1 * *I_p1); \n\t\t\tsum[3] += (*I_p2 * *p_p2) - (*I_p1 * *p_p1); \n\t\t\tI_p1++; \n\t\t\tp_p1++; \n \n\t\t\t*v0_p = sum[0]; \n\t\t\t*v1_p = sum[1]; \n\t\t\t*v2_p = sum[2]; \n\t\t\t*v3_p = sum[3]; \n \n\t\t\t*v4_p = *It_p; \n\t\t\tIt_p++; \n \n\t\t\tif ((i & 3) == 3) \n\t\t\t{ \n\t\t\t\tv0_p += step; \n\t\t\t\tv1_p += step; \n\t\t\t\tv2_p += step; \n\t\t\t\tv3_p += step; \n \n\t\t\t\tv4_p += step; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tv0_p++; \n\t\t\t\tv1_p++; \n\t\t\t\tv2_p++; \n\t\t\t\tv3_p++; \n \n\t\t\t\tv4_p++; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "edd5a2aa5b948a16e176bfa2a3691abc690e1bffb7e270cab717e908dd7180e9"}
{"code": "for (index = 0; index < count; index++) \n\t{ \n\t\tunsigned char hash[16]; \n\t\tMD5_CTX ctx; \n\t\tMD5_Init(&ctx); \n\t\tMD5_Update(&ctx, saved_key[index], strlen(saved_key[index])); \n\t\tMD5_Final(hash, &ctx); \n\t\thex_encode(hash, 16, (unsigned char*)crypt_out[index]); \n\t}", "pragma": "parallel for ", "hash": "452ec9d98fc6b3ec7fac4a3dd9891730497469b563f2dd3fddb6606e4c658c55"}
{"code": "for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      offset; \n \n    HaldInfo \n      point; \n \n    MagickPixelPacket \n      pixel, \n      pixel1, \n      pixel2, \n      pixel3, \n      pixel4; \n \n    register IndexPacket \n      *magick_restrict indexes; \n \n    register PixelPacket \n      *magick_restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewAuthenticIndexQueue(hald_view); \n    pixel=zero; \n    pixel1=zero; \n    pixel2=zero; \n    pixel3=zero; \n    pixel4=zero; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      point.x=QuantumScale*(level-1.0)*GetPixelRed(q); \n      point.y=QuantumScale*(level-1.0)*GetPixelGreen(q); \n      point.z=QuantumScale*(level-1.0)*GetPixelBlue(q); \n      offset=(double) (point.x+level*floor(point.y)+cube_size*floor(point.z)); \n      point.x-=floor(point.x); \n      point.y-=floor(point.y); \n      point.z-=floor(point.z); \n      (void) InterpolateMagickPixelPacket(image,hald_view, \n        UndefinedInterpolatePixel,fmod(offset,width),floor(offset/width), \n        &pixel1,exception); \n      (void) InterpolateMagickPixelPacket(image,hald_view, \n        UndefinedInterpolatePixel,fmod(offset+level,width),floor((offset+level)/ \n        width),&pixel2,exception); \n      MagickPixelCompositeAreaBlend(&pixel1,pixel1.opacity,&pixel2, \n        pixel2.opacity,point.y,&pixel3); \n      offset+=cube_size; \n      (void) InterpolateMagickPixelPacket(image,hald_view, \n        UndefinedInterpolatePixel,fmod(offset,width),floor(offset/width), \n        &pixel1,exception); \n      (void) InterpolateMagickPixelPacket(image,hald_view, \n        UndefinedInterpolatePixel,fmod(offset+level,width),floor((offset+level)/ \n        width),&pixel2,exception); \n      MagickPixelCompositeAreaBlend(&pixel1,pixel1.opacity,&pixel2, \n        pixel2.opacity,point.y,&pixel4); \n      MagickPixelCompositeAreaBlend(&pixel3,pixel3.opacity,&pixel4, \n        pixel4.opacity,point.z,&pixel); \n      if ((channel & RedChannel) != 0) \n        SetPixelRed(q,ClampToQuantum(pixel.red)); \n      if ((channel & GreenChannel) != 0) \n        SetPixelGreen(q,ClampToQuantum(pixel.green)); \n      if ((channel & BlueChannel) != 0) \n        SetPixelBlue(q,ClampToQuantum(pixel.blue)); \n      if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse)) \n        SetPixelOpacity(q,ClampToQuantum(pixel.opacity)); \n      if (((channel & IndexChannel) != 0) && \n          (image->colorspace == CMYKColorspace)) \n        SetPixelIndex(indexes+x,ClampToQuantum(pixel.index)); \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor != (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_HaldClutImageChannel) \n        proceed=SetImageProgress(image,HaldClutImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  }", "pragma": "parallel for ", "hash": "7f31b945b1e336447e2de4e0ece57efc751b4fdb4513559a7f3c3459ca87f1b2"}
{"code": "for (int  _i0 = 2; (_i0 < R); _i0 = (_i0 + 1)) \n  { \n    #pragma ivdep \n    for (int  _i1 = 2; (_i1 < C); _i1 = (_i1 + 1)) \n    { \n      trace[((_i0 * (2 + C)) + _i1)] = (Sxx[((_i0 * (2 + C)) + _i1)] + Syy[((_i0 * (2 + C)) + _i1)]); \n      det[((_i0 * (2 + C)) + _i1)] = ((Sxx[((_i0 * (2 + C)) + _i1)] * Syy[((_i0 * (2 + C)) + _i1)]) - (Sxy[((_i0 * (2 + C)) + _i1)] * Sxy[((_i0 * (2 + C)) + _i1)])); \n    } \n  }", "pragma": "parallel for ", "hash": "294989bcc6387bd30b11089d5ceb4da42ddfd9ea9051ef9e3cb1ed8770b00028"}
{"code": "for( unsigned iy=0; iy<get_height(); iy++ ){ \n\t\tauto out = (QRgb*)img.scanLine( iy ); \n\t\tauto r = planar[0].scan_line( iy ); \n\t\tauto g = planar[1].scan_line( iy ); \n\t\tauto b = planar[2].scan_line( iy ); \n\t\tauto a = planar[3].scan_line( iy );  \n \n\t\t \n\t\tfor( unsigned ix=0; ix<get_width(); ix++ ) \n\t\t\tout[ix] = qRgba( r[ix], g[ix], b[ix], a[ix] ); \n\t}", "pragma": "parallel for ", "hash": "c2512b0109753bf389d84fc9808d9ddde321b924cb948bcf8c02626845d0957b"}
{"code": "for (size_t id = 0; id < reader.getSize(); ++id) { \n            char *seqData = reader.getData(id, thread_idx); \n            unsigned int seqLen = 0; \n            while (seqData[seqLen] != '\\0') { \n                charSequence[seqLen] = (char) subMat->aa2num[static_cast<int>(seqData[seqLen])]; \n                seqLen++; \n            } \n            tantan::maskSequences(charSequence, \n                                  charSequence + seqLen, \n                                  50  \n, \n                                  probMatrix.probMatrixPointers, \n                                  0.005  \n, \n                                  0.05  \n, \n                                  0.9  \n, \n                                  0, 0, \n                                  0.5  \n, \n                                  probMatrix.hardMaskTable); \n \n            for (unsigned int pos = 0; pos < seqLen; pos++) { \n                char aa = seqData[pos]; \n                charSequence[pos] = (charSequence[pos] == probMatrix.hardMaskTable[0]) ? tolower(aa) : toupper(aa); \n            } \n            writer.writeData(charSequence, seqLen, reader.getDbKey(id), thread_idx); \n        }", "pragma": "for ", "hash": "8119a47f65a96ef80257136aab3ebbcc4983d019a4df7b9657dcc5aeefd93f7c"}
{"code": "for (unsigned i = 0; i < n; i++) { \n\t\tii = gsl_permutation_get(indicesRight, i); \n \n\t\tgsl_matrix_set(hess, 2 * n + 1, i, - \n\t\t\t\t0.5 * (gsl_vector_get(ty, i) + gsl_vector_get(ty, ii))); \n \n\t\tgsl_matrix_set(hess, 2 * n + 1,  n + i,  \n\t\t\t\t0.5 * (gsl_vector_get(tx, i) + gsl_vector_get(tx, ii))); \n\t}", "pragma": "parallel for private(ii)", "hash": "ac88cd81d3a54cb7faab5804592941226a85809660c27dbfe7a4d5253adc42af"}
{"code": "for(int g = 0; g < (int)genes_.size(); ++g){ \n        vector<double> new_grid_wts_tmp(grid_size_, NaN); \n        genes_[g].em_update_grid(type_prior_, subgroup_prior_, new_grid_wts_tmp); \n        for(size_t l = 0; l < grid_size_; ++l) \n          grid_genes_[l][g] = new_grid_wts_tmp[l]; \n      }", "pragma": "parallel for ", "hash": "5c037434750e262a6a825cdc7aae05a25493043815eba1ea4745b67c21e23333"}
{"code": "for(i2=nb; i2<nx+nb; i2++) \n\tfor(i1=nb; i1<nz+nb; i1++) \n\t{ \n\t\ttmp=vv[i2][i1]; tmp=tmp*tmp; \n\t\tdiff1=1.125*(vz[i2][i1]-vz[i2][i1-1])-0.041666666666667*(vz[i2][i1+1]-vz[i2][i1-2]); \n\t\tdiff2=1.125*(vx[i2][i1]-vx[i2-1][i1])-0.041666666666667*(vx[i2+1][i1]-vx[i2-2][i1]); \n\t\ttmp=tmp*(_dz*diff1+_dx*diff2); \n\t\tp[i2][i1]-=dt*tmp; \n\t}", "pragma": "parallel for private(  diff1 diff2 i1 i2 tmp)", "hash": "779563b2a7cdd9cda28fe0868d07fd1b760888b410f1b589da8a4c74aba6e8dd"}
{"code": "for (int i=0; i<this->get_nrow(); ++i) { \n \n      row_offset[i+1] = 0; \n       \n      for (int j=this->mat_.row_offset[i]; j<this->mat_.row_offset[i+1]; ++j) \n        if (( paralution_abs(this->mat_.val[j]) > drop_off )  || \n            ( this->mat_.col[j] == i)) \n          row_offset[i+1] += 1; \n    }", "pragma": "parallel for ", "hash": "de1c05d01a1d13f5999ccb71f6c467690f8ebe77eaa3dde55b389ba12d389c26"}
{"code": "for(long i=0;i<fd->n;i++) \n\t\t{ \n\t\t\tval['x'-'a'] = fd->x[i]; \n\t\t\tval['y'-'a'] = fd->y ? fd->y[i] : 0; \n\t\t\tval['z'-'a'] = fd->z ? fd->z[i] : 0; \n\t\t\tgsl_vector_set (f, i, (fd->eq->Calc(val) - fd->a[i])/fd->s[i]); \n\t\t}", "pragma": "for ", "hash": "ce6db27c6beca3267fbb964f723ab67dd985990c6fefc255f09f3674d763834f"}
{"code": "for (int i = 0; i < unit_cell_.symmetry().num_mag_sym(); i++) { \n            auto& spgR = unit_cell_.symmetry().magnetic_group_symmetry(i).spg_op.R; \n            bool found{false}; \n            for (size_t i = 0; i < lat_sym.size(); i++) { \n                auto latR = lat_sym[i]; \n                found     = true; \n                for (int x : {0, 1, 2}) { \n                    for (int y : {0, 1, 2}) { \n                        found = found && (spgR(x, y) == latR(x, y)); \n                    } \n                } \n                if (found) { \n                    break; \n                } \n            } \n            if (!found) { \n                TERMINATE(\"spglib lattice symetry was not found in the list of SIRIUS generated symmetries\"); \n            } \n        }", "pragma": "parallel for ", "hash": "4dab058f2ccfc7e24f7e8e312e4828edd20334ac0be7a0673eb05daf4a143819"}
{"code": "for (index_mu=0;index_mu<num_mu-1;index_mu++) { \n \n    for (l=2;l<=ple->l_unlensed_max;l++) { \n \n      ll = (double)l; \n \n      fac = ll*(ll+1)/4.; \n      fac1 = (2*ll+1)/(4.*_PI_); \n \n       \n \n \n      X_000 = exp(-fac*sigma2[index_mu]); \n      X_p000 = -fac*X_000; \n       \n \n      X_220 = 0.25*sqrt1[l] * X_000;  \n \n       \n \n      X_242=0.; \n      X_132=0.; \n      X_121=0.; \n      X_p022=0.; \n      X_022=0.; \n \n      if (ple->has_te==_TRUE_ || ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) { \n         \n \n        X_022 = X_000 * (1+sigma2[index_mu]*(1+0.5*sigma2[index_mu]));  \n \n        X_p022 = (fac-1.)*X_022; \n         \n \n        X_242 = 0.25*sqrt4[l] * X_000;  \n \n        if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) { \n \n           \n \n          X_121 = -0.5*sqrt2[l] * X_000 * (1+2./3.*sigma2[index_mu]);  \n \n          X_132 = -0.5*sqrt3[l] * X_000 * (1+5./3.*sigma2[index_mu]);  \n \n        } \n      } \n \n \n      if (ple->has_tt==_TRUE_) { \n \n        res = fac1*cl_tt[l]; \n \n        lens = (X_000*X_000*d00[index_mu][l] + \n                X_p000*X_p000*d1m1[index_mu][l] \n                *Cgl2[index_mu]*8./(ll*(ll+1)) + \n                (X_p000*X_p000*d00[index_mu][l] + \n                 X_220*X_220*d2m2[index_mu][l]) \n                *Cgl2[index_mu]*Cgl2[index_mu]); \n        if (ppr->accurate_lensing == _FALSE_) { \n           \n \n          lens -= d00[index_mu][l]; \n        } \n        res *= lens; \n        ksi[index_mu] += res; \n      } \n \n      if (ple->has_te==_TRUE_) { \n \n        resX = fac1*cl_te[l]; \n \n \n        lens = ( X_022*X_000*d20[index_mu][l] + \n                 Cgl2[index_mu]*2.*X_p000/sqrt5[l] * \n                 (X_121*d11[index_mu][l] + X_132*d3m1[index_mu][l]) + \n                 0.5 * Cgl2[index_mu] * Cgl2[index_mu] * \n                 ( ( 2.*X_p022*X_p000+X_220*X_220 ) * \n                   d20[index_mu][l] + X_220*X_242*d4m2[index_mu][l] ) ); \n        if (ppr->accurate_lensing == _FALSE_) { \n          lens -= d20[index_mu][l]; \n        } \n        resX *= lens; \n        ksiX[index_mu] += resX; \n      } \n \n      if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) { \n \n        resp = fac1*(cl_ee[l]+cl_bb[l]); \n        resm = fac1*(cl_ee[l]-cl_bb[l]); \n \n        lensp = ( X_022*X_022*d22[index_mu][l] + \n                  2.*Cgl2[index_mu]*X_132*X_121*d31[index_mu][l] + \n                  Cgl2[index_mu]*Cgl2[index_mu] * \n                  ( X_p022*X_p022*d22[index_mu][l] + \n                    X_242*X_220*d40[index_mu][l] ) ); \n \n        lensm = ( X_022*X_022*d2m2[index_mu][l] + \n                  Cgl2[index_mu] * \n                  ( X_121*X_121*d1m1[index_mu][l] + \n                    X_132*X_132*d3m3[index_mu][l] ) + \n                  0.5 * Cgl2[index_mu] * Cgl2[index_mu] * \n                  ( 2.*X_p022*X_p022*d2m2[index_mu][l] + \n                    X_220*X_220*d00[index_mu][l] + \n                    X_242*X_242*d4m4[index_mu][l] ) ); \n        if (ppr->accurate_lensing == _FALSE_) { \n          lensp -= d22[index_mu][l]; \n          lensm -= d2m2[index_mu][l]; \n        } \n        resp *= lensp; \n        resm *= lensm; \n        ksip[index_mu] += resp; \n        ksim[index_mu] += resm; \n      } \n    } \n  }", "pragma": "parallel for private(                       fac fac1 index_mu l lens lensm lensp ll res resm resp resx x_000 x_022 x_121 x_132 x_220 x_242 x_p000 x_p022)", "hash": "e59226ddb16c18f2ecf51314f5621484768d0ffebc4b9243cf40bf1a07505e9e"}
{"code": "for(size_t k = 0; k < (size_t)ch * roi_in->width * roi_out->height; k += ch) \n      { \n        float *in = ((float *)ivoid) + k; \n        float *out = ((float *)ovoid) + k; \n \n         \n \n         \n \n        __m128 XYZ = dt_Lab_to_XYZ_sse2(_mm_load_ps(in)); \n         \n \n        __m128 rgb = dt_XYZ_to_prophotoRGB_sse2(XYZ); \n \n        __m128 luma; \n \n         \n \n        if (run_saturation) \n        { \n          luma = _mm_set1_ps(XYZ[1]);  \n \n          rgb = luma + saturation * (rgb - luma); \n        } \n \n         \n \n        rgb = rgb * gain + lift; \n \n         \n \n        rgb = _mm_max_ps(rgb, zero); \n        rgb = _mm_pow_ps(rgb, gamma); \n \n         \n \n        if (run_saturation_out) \n        { \n          XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb); \n          luma = _mm_set1_ps(XYZ[1]);  \n \n          rgb = luma + saturation_out * (rgb - luma); \n        } \n \n         \n \n        if (run_contrast) \n        { \n          rgb = _mm_max_ps(rgb, zero); \n          rgb = _mm_pow_ps(rgb / grey, contrast) * grey; \n        } \n \n         \n \n         \n \n        XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb); \n         \n \n        _mm_stream_ps(out, dt_XYZ_to_Lab_sse2(XYZ)); \n      }", "pragma": "parallel for simd ", "hash": "b2bd68b813c4d6ab27ecbefa2b1ad3b8294215b8bd1166a5e161fdf442bca7b0"}
{"code": "for (i = 0; i < sz; i++) \n        out_tensor[i] = in_tensor_l[i] - in_tensor_r[i];", "pragma": "parallel for private(i)", "hash": "5502999ddf0389032ae09d4258b7c40fecf1576e33d82ca57624a5dd62171a68"}
{"code": "for(i=0;i<n;i++) \n            p[i] += x[i] - z[i];", "pragma": "parallel for private(i)", "hash": "8889dfec1f3c40a35b1054f702392d720ca1873c0ec4aee5af54838151d2459a"}
{"code": "for(size_t i = 0; i < numImisSamples + StepSamples; i++) \n      gaussian_sum[i] += tmp_MVNpdf[i];", "pragma": "parallel for ", "hash": "64b75b7591500052ad463280909b034746f69ca9e26a7b731769378cc1c4550a"}
{"code": "for (int i = 0; i < n; i++) \n\t    { \n\t      p[i]  =  z[i] + bk *  p[i]; \n\t      pp[i] = zz[i] + bk * pp[i]; \n\t    }", "pragma": "parallel for ", "hash": "4f9030a9044fb517447755b378f0b0fe9454cd3b3b556ee5c3267db65fc50461"}
{"code": "for (size_t i = 0; i < resultSize; ++i) { \n            progress.updateProgress(); \n            const unsigned int resultId = resultDbr.getDbKey(i); \n            char queryKeyStr[1024]; \n            char *tmpBuff = Itoa::u32toa_sse2((uint32_t) resultId, queryKeyStr); \n            *(tmpBuff) = '\\0'; \n            char *data = resultDbr.getData(i, thread_idx); \n            char dbKeyBuffer[255 + 1]; \n            while (*data != '\\0') { \n                Util::parseKey(data, dbKeyBuffer); \n                size_t targetKeyLen = strlen(dbKeyBuffer); \n                const unsigned int dbKey = (unsigned int) strtoul(dbKeyBuffer, NULL, 10); \n                char *nextLine = Util::skipLine(data); \n                size_t lineLen = nextLine - data; \n                lineLen -= (targetKeyLen + 1); \n                __sync_fetch_and_add(&(targetElementSize[dbKey]), lineLen); \n                data = nextLine; \n            } \n        }", "pragma": "for ", "hash": "58ddb9e4b9472937f5541431f52e05e777a438632a91b4c890fcc1b12af2fca9"}
{"code": "for (jj = numpts - dind; jj < numpts; jj++) \n            sub[jj] += chan[jj];", "pragma": "parallel for private(jj)", "hash": "168f5626c5c4f397ad64dd0a014a398183467f2b863c23e7f3e09ef73ea4c015"}
{"code": "for (i = 0; i < 33; i += 3) \n    ;", "pragma": "for simd ", "hash": "97f519cf9c52eb6e8f87c9aed61a1d0d09ec646e0518199f83e9c163cb3189ab"}
{"code": "for(int i = 0; i < Frows;i++) \n  { \n    const Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v1 = V.row(F(i,1)) - V.row(F(i,0)); \n    const Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v2 = V.row(F(i,2)) - V.row(F(i,0)); \n    N.row(i) = v1.cross(v2); \n \n    typename DerivedV::Scalar r = N.row(i).norm(); \n    if(r == 0) \n    { \n      N.row(i) = Z; \n    }else \n    { \n      N.row(i) /= r; \n    } \n  }", "pragma": "parallel for ", "hash": "a5b55e928f82e80fce0c040c9123408113b709680bbfa29c79408e783c84069e"}
{"code": "for (int iy_b=0; iy_b<ny; iy_b+=YBF){ \n\tfor (int iz=0; iz<nz; iz++){ \n\t\tint nymax = iy_b + YBF; \n\t\tif(iy_b >= nx) nymax = ny; \n    \tfor (int iy=iy_b; iy<nymax; iy++){ \n \n\t\t\tint ix = 0; \n            int id_c0_c0_c0 = nx*ny*iz + nx*iy +  ix ; \n            int id_c0_m1_c0 = (iy == 0   ) ? id_c0_c0_c0 : id_c0_c0_c0 -nx; \n            int id_c0_p1_c0 = (iy == ny-1) ? id_c0_c0_c0 : id_c0_c0_c0 +ny; \n            int id_c0_c0_m1 = (iz == 0   ) ? id_c0_c0_c0 : id_c0_c0_c0 -nx*ny; \n            int id_c0_c0_p1 = (iz == nz-1) ? id_c0_c0_c0 : id_c0_c0_c0 +nx*ny; \n \n\t\t\t\t\tfor(int ix=0; ix<nx; ix+=8) \n            { \n            \t__m512d _a, _b, _c, _fn; \n \n            \t_fn = _mm512_setzero_pd(); \n            \t_a = _mm512_load_pd(f + id_c0_c0_c0); \n            \t_b = _mm512_set1_pd(cc); \n \n            \t_fn = _mm512_fmadd_pd(_a, _b, _fn); \n            \tif(ix == 0) \n            \t{ \n            \t\tFLOAT tem = f[id_c0_c0_c0 - 1]; \n            \t\tf[id_c0_c0_c0 - 1] = f[id_c0_c0_c0]; \n        \t\t\t_a = _mm512_loadunpacklo_pd(_a, f + id_c0_c0_c0 - 1); \n        \t\t\t_a = _mm512_loadunpackhi_pd(_a, f + id_c0_c0_c0 + 7); \n            \t\tf[id_c0_c0_c0 - 1] = tem; \n            \t} \n            \telse \n            \t{ \n        \t\t\t_a = _mm512_loadunpacklo_pd(_a, f + id_c0_c0_c0 - 1); \n        \t\t\t_a = _mm512_loadunpackhi_pd(_a, f + id_c0_c0_c0 + 7); \n            \t} \n            \t_b = _mm512_set1_pd(cw); \n             \t_fn = _mm512_fmadd_pd(_a, _b, _fn); \n \n             \tif(ix + 8 == nx) \n             \t{ \n            \t\tFLOAT tem = f[id_c0_c0_c0 + 8]; \n            \t\tf[id_c0_c0_c0 + 8] = f[id_c0_c0_c0 + 7]; \n        \t\t\t_a = _mm512_loadunpacklo_pd(_a, f + id_c0_c0_c0 + 1); \n        \t\t\t_a = _mm512_loadunpackhi_pd(_a, f + id_c0_c0_c0 + 9); \n            \t\tf[id_c0_c0_c0 + 8] = tem; \n             \t} \n            \telse \n            \t{ \n        \t\t\t_a = _mm512_loadunpacklo_pd(_a, f + id_c0_c0_c0 + 1); \n        \t\t\t_a = _mm512_loadunpackhi_pd(_a, f + id_c0_c0_c0 + 9); \n            \t} \n            \t_b = _mm512_set1_pd(ce); \n             \t_fn = _mm512_fmadd_pd(_a, _b, _fn); \n \n            \t_a = _mm512_load_pd(f + id_c0_m1_c0); \n            \t_b = _mm512_set1_pd(cs); \n            \t_fn = _mm512_fmadd_pd(_a, _b, _fn); \n \n            \t_a = _mm512_load_pd(f + id_c0_p1_c0); \n            \t_b = _mm512_set1_pd(cn); \n            \t_fn = _mm512_fmadd_pd(_a, _b, _fn); \n \n            \t_a = _mm512_load_pd(f + id_c0_c0_m1); \n            \t_b = _mm512_set1_pd(cb); \n            \t_fn = _mm512_fmadd_pd(_a, _b, _fn); \n \n            \t_a = _mm512_load_pd(f + id_c0_c0_p1); \n            \t_b = _mm512_set1_pd(cu); \n            \t_fn = _mm512_fmadd_pd(_a, _b, _fn); \n \n\t\t\t    _mm512_store_pd(fn + id_c0_c0_c0, _fn); \n\t\t\t\tid_c0_c0_c0 += 8; \n\t\t\t\tid_c0_m1_c0 += 8; \n\t\t\t\tid_c0_p1_c0 += 8; \n\t\t\t\tid_c0_c0_m1 += 8; \n\t\t\t\tid_c0_c0_p1 += 8; \n \n            } \n\t\t} \n\t} \n\t}", "pragma": "for ", "hash": "13e03e9700eae5ed93aaf3be54e7be0b48dc33041472858e0cf4428e3b73dfc0"}
{"code": "for ( int id = 0; id < settings.N_SCC; ++id ) { \n \n    #pragma omp critical (output) \n    { cout << id << \": Calculation started!\" << endl; } \n \n    SCCResults results = run_scc( settings, id ); \n \n    if ( results.exit_code != 0 ) { \n      #pragma omp critical (output) \n      { cout << id << \": Calculation failed!\" << endl; } \n      exit( 1 ); \n    } else { \n      #pragma omp critical (output) \n      { cout << id << \": Calculation finished!\" << endl; } \n      if ( !results.converged ) { \n        #pragma omp critical (output) \n        { cout << id << \": Calculation did not converge!\" << endl; } \n      } else { \n        #pragma omp critical (output) \n        { \n          cout << id << \": Calculation converged!\" << endl; \n \n           \n \n          cout << id << \": iterations_to_convergence = \" \n                     << results.iterations_to_convergence << endl; \n          cout << id << \": Delta_n_up = \" << results.Delta_n_up << endl; \n          cout << id << \": Delta_n_down = \" << results.Delta_n_down << endl; \n          cout << id << \": energy = \" << results.energy << endl; \n          cout << id << \": gap = \" << results.gap << endl; \n          cout << id << \": m_z = \" << results.m_z << endl; \n          cout << id << \": filling = \" << results.filling << endl; \n        } \n \n        #pragma omp critical (gsupdate) \n        { \n           \n \n          if ( !some_gsc_found || \n               ( some_gsc_found && results.energy < gs_candidate.energy ) ) { \n            #pragma omp critical (output) \n            { cout << id << \": Best estimate of the ground state!\" << endl; } \n            some_gsc_found = true; \n            gs_candidate = results; \n          } \n        } \n \n        if ( settings.plotmode == 2 ) { \n          #pragma omp critical (output) \n          { cout << id << \": Plotting started!\" << endl; } \n \n          if ( plot( settings, results, dir, id ) != 0 ) { \n            #pragma omp critical (output) \n            { cerr << id << \": ERROR while plotting the results!\" << endl; } \n            exit( 1 ); \n          } \n          #pragma omp critical (output) \n          { \n            cout << id << \": Plotting finished!\" << endl; \n          } \n        } \n      } \n    } \n  }", "pragma": "parallel for private( dir settings)", "hash": "c4049fe209598f21009b7c71db172e9105597b15ecec94517b7a8ac71dd7f869"}
{"code": "for (int i = 0; i < (int) numFaces; i++) \n\t\t{ \n\t\t\t \n \n\t\t\tconst Vector3r &a = vertices[faces[3 * i]]; \n\t\t\tconst Vector3r &b = vertices[faces[3 * i + 1]]; \n\t\t\tconst Vector3r &c = vertices[faces[3 * i + 2]]; \n \n\t\t\t \n \n\t\t\tVector3r v1 = b - a; \n\t\t\tVector3r v2 = c - a; \n \n\t\t\tm_faceNormals[i] = v1.cross(v2); \n\t\t\tm_faceNormals[i].normalize(); \n\t\t}", "pragma": "for ", "hash": "263a3f796c04c6f24884303f73fd5d3b653d15ee81075fd543df406a953bd370"}
{"code": "for (j = 0; j < n; j++) { \n      acc = 0; \n      for (k = 0; k < j - 1; k++) { \n        C[k][j] += alpha * A[k][i] * B[i][j]; \n        acc += B[k][j] * A[k][i]; \n      } \n      C[i][j] = beta * C[i][j] + alpha * A[i][i] * B[i][j] + alpha * acc; \n    }", "pragma": "parallel for private(k)", "hash": "3f4c3ea844bfebd00a1045085cdf6d1ad648884f209dbec8a86929eb68a87020"}
{"code": "for (int iBox=0; iBox<s->boxes->nLocalBoxes; iBox++) \n   { \n      int nIBox = s->boxes->nAtoms[iBox]; \n \n       \n \n      for (int jTmp=0; jTmp<nNbrBoxes; jTmp++) \n      { \n         int jBox = s->boxes->nbrBoxes[iBox][jTmp]; \n         int nJBox = s->boxes->nAtoms[jBox]; \n \n          \n \n         for (int iOff=MAXATOMS*iBox; iOff<(iBox*MAXATOMS+nIBox); iOff++) \n         { \n             \n \n            for (int jOff=MAXATOMS*jBox; jOff<(jBox*MAXATOMS+nJBox); jOff++) \n            { \n \n               real3 dr; \n               real_t r2 = 0.0; \n               for (int k=0; k<3; k++) \n               { \n                  dr[k]=s->atoms->r[iOff][k]-s->atoms->r[jOff][k]; \n                  r2+=dr[k]*dr[k]; \n               } \n \n               if(r2 <= rCut2 && r2 > 0.0) \n               { \n \n                  real_t r = sqrt(r2); \n \n                  real_t phiTmp, dPhi, rhoTmp, dRho; \n                  interpolate(pot->phi, r, &phiTmp, &dPhi); \n                  interpolate(pot->rho, r, &rhoTmp, &dRho); \n \n                  for (int k=0; k<3; k++) \n                  { \n                     s->atoms->f[iOff][k] -= dPhi*dr[k]/r; \n                  } \n \n                   \n \n                  s->atoms->U[iOff] += 0.5*phiTmp; \n                  etot += 0.5*phiTmp; \n \n                   \n \n                  pot->rhobar[iOff] += rhoTmp; \n               } \n \n            }  \n \n         }  \n \n      }  \n \n   }", "pragma": "parallel for reduction(+:etot) ", "hash": "4803cb71ce9e60e1bca01fa5757ec11273eba2f0fad83c6cecec09a10ca2fdb9"}
{"code": "for(j=0; j<NumberOfPanels; j++) \n    { \n \n        for(Vortex Considered : Flow) \n        { \n            VelocityProjInControlPoint[j] += \n                    (PanelNorms[j][0]*Considered.inducedXVelocity(PanelMids[j][0],PanelMids[j][1]) \n                    +PanelNorms[j][1]*Considered.inducedYVelocity(PanelMids[j][0],PanelMids[j][1])); \n        } \n        gsl_vector_set(VelocityProjections,j,-VelocityProjInControlPoint[j]); \n    }", "pragma": "parallel for private(j)", "hash": "187cbdf941d44c8ae22b6b9952d778ebd43fd2a8ac27fcd8677c7e4a4ce03b33"}
{"code": "for (i = 0; i < (int)n_b; i++) {\r \n            result[i] = *a + b[i];\r \n        }", "pragma": "parallel for private(i)", "hash": "0ae4a16625231945b78dc0aa3b1757a7c4415ebd63a93fc70b2d518f533733a7"}
{"code": "for (int kExt = 0; kExt < nExt; kExt++) { \n            updateInd_dW(arborID, b, preactbufHead, postactbufHead, kExt); \n         }", "pragma": "parallel for ", "hash": "be7cac813b9a5b61810e54a731400e5c96e9af3b185e74bb02839e75770c2c69"}
{"code": "for(idx q = 0; q < m->CellLastLocalID(); ++q) if( m->isValidCell(q) ) \n\t\t\t{ \n\t\t\t\tCell n = m->CellByLocalID(q); \n\t\t\t\tif( n->GetStatus() != Element::Ghost ) total_points++; \n\t\t\t}", "pragma": "parallel for reduction(+:total_points) ", "hash": "90f7a9503f8ba27e59630beb35743387ac110a6dd957fca9b95a9dd911cbf3b9"}
{"code": "for (i = 0; i < count; i++) \n      new_map[i] = sin_op((T2)map[i]);", "pragma": "parallel for ", "hash": "17377aeb10351a8341ee73c119e2080aa89c4b1e40a3f74fff28ce2e6c320009"}
{"code": "for(uint i = 0; i < unsorted.size(); i++) \n    { \n       \n \n      short_pair* limit = pairs + unsorted[i].second; \n      for(short_pair* curr = pairs + unsorted[i].first; curr <= limit; ++curr) \n      { \n        curr->second = keys[curr->first + h]; \n      } \n      sequentialSort(pairs + unsorted[i].first, pairs + unsorted[i].second + 1, key_comparator); \n    }", "pragma": "parallel for ", "hash": "f3b7418dd5511c491d9110a8ab8a2e58ec9f67dc575ff90b23e3f5f72f70bc78"}
{"code": "for (int i = 0; i < nn_num_particles(); i++) { \n            int ll = i * nn_get_lmax(); \n            int l = NBLIST[ll]; \n            if (l < 0) { \n                nn_error(\"Too many neighbours\"); \n                exit(1); \n            } \n            gpuirr_set_list(i, l, &NBLIST[ll+1]); \n        }", "pragma": "parallel for ", "hash": "1c980f42cef87d36f08db629c0234de0b9d9d83933339ddbd66be5492b46ae04"}
{"code": "for (ompIndexType i = 0; i < (ompIndexType)(len); i++) { \n        if (std::isfinite((T)pIn[i])) { \n            pOut[i] = std::floor((T)pIn[i]); \n        } else { \n            pOut[i] = (T)pIn[i]; \n        } \n    }", "pragma": "parallel for ", "hash": "1dc1c19071022e4032098ed5778d4c10231a47efd1a7a2499ca22edf7942475b"}
{"code": "for ( int y = 0; y < ny; y++ ) \n    { \n        for ( size_t x = 0; x < numSamplesX; x++ ) \n        { \n            size_t idx = y * numSamplesX + x; \n \n             \n \n            std::vector<double> values = removeNonPositiveValues( samples[idx] ); \n \n            double min; \n            double max; \n            double sum; \n            double range; \n            double mean; \n            double dev; \n            RigStatisticsMath::calculateBasicStatistics( values, &min, &max, &sum, &range, &mean, &dev ); \n            setValueNoInf( meanGrid, x, y, mean ); \n \n             \n \n            occurrenceGrid.setValue( x, y, values.size() ); \n        } \n    }", "pragma": "parallel for ", "hash": "762269b5297ac5c9bd8c74c7af1f3c5bf36d01ee3a77829b69ee511a6b5d8e95"}
{"code": "for(int x=0; x<Get_NX(); x++) \n\t\t\t{ \n\t\t\t\tpReferenced->Set_Value(x, y, pGrid->asDouble(x, y)); \n\t\t\t}", "pragma": "parallel for ", "hash": "b49453862aaf1e74283142a5bbd19bcfea45107194ff85eba0e6c5a18016426a"}
{"code": "for (unsigned int i = 0; i < iteration_n; ++i){  \n \n\t\tdepth_one[i] = new float [atom_number];  \n \n\t\tx[i] = new float [atom_number]; memcpy(x[i], x_static, atom_number*sizeof(float));  \n \n\t\ty[i] = new float [atom_number]; memcpy(y[i], y_static, atom_number*sizeof(float)); \n\t\tz[i] = new float [atom_number]; memcpy(z[i], z_static, atom_number*sizeof(float)); \n\t\tinstance[i].get_depth(depth_one[i], x[i],y[i],z[i],xw[i],yw[i],zw[i]);  \n \n\t\tfor (unsigned int a = 0; a < atom_number; ++a){  \n \n\t\t\tave_depth[a] = ave_depth[a] + depth_one[i][a]; \n\t\t\tstd_depth[a] = std_depth[a] + depth_one[i][a]*depth_one[i][a]; \n\t\t}  \n \n\t\tdelete[] x[i]; delete[] y[i]; delete[] z[i]; delete[] depth_one[i];  \n \n\t}", "pragma": "parallel for ", "hash": "b438d4f1e6fe7757fe25b43222e063cb6eafb47ddec3844f6b054de797b83bef"}
{"code": "for (index = 0; index < count; index++) \n\t{ \n\t\t \n \n\t\tunsigned char hexhash[40]; \n\t\tunsigned char buf[20]; \n \n\t\tSHA_CTX sctx; \n\t\tMD5_CTX mctx; \n \n\t\tSHA1_Init(&sctx); \n\t\tSHA1_Update(&sctx, saved_key[index], strlen(saved_key[index])); \n\t\tSHA1_Final(buf, &sctx); \n\t\thex_encode(buf, 20, hexhash); \n \n\t\tMD5_Init(&mctx); \n\t\tMD5_Update(&mctx, cur_salt->salt, 8); \n\t\tMD5_Update(&mctx, hexhash, 40); \n\t\tMD5_Final(buf, &mctx); \n\t\thex_encode(buf, 16, hexhash); \n \n\t\tSHA1_Init(&sctx); \n\t\tSHA1_Update(&sctx, hexhash, 32); \n\t\tSHA1_Final(buf, &sctx); \n\t\thex_encode(buf, 20, hexhash); \n \n\t\tMD5_Init(&mctx); \n\t\tMD5_Update(&mctx, hexhash, 40); \n\t\tMD5_Final((unsigned char*)crypt_out[index], &mctx); \n\t}", "pragma": "parallel for ", "hash": "56e340890272b2e2b3eec0a38035916a20edf9b7725ddc2cb7d77ab95bf0a9a1"}
{"code": "for (j=0; j<array_elements; j++) \n          b[j] = scalar*c[j];", "pragma": "parallel for ", "hash": "570c9eb9e9f723cb09c2d7768bc8d46e6cd94cd54c727d31d4f5777cb529edaa"}
{"code": "for(int idxTarget = 0 ; idxTarget < nbParticles ; ++idxTarget){ \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                for(int idxOther = 0; idxOther < nbParticles ; ++idxOther){ \n                    if( idxOther != idxTarget ){ \n                        FP2P::NonMutualParticles( \n                                    particles[idxOther].getPosition().getX(), particles[idxOther].getPosition().getY(), \n                                    particles[idxOther].getPosition().getZ(),particles[idxOther].getPhysicalValue(), \n                                    particles[idxTarget].getPosition().getX(), particles[idxTarget].getPosition().getY(), \n                                    particles[idxTarget].getPosition().getZ(),particles[idxTarget].getPhysicalValue(), \n                                    &particles[idxTarget].setForces()[0],&particles[idxTarget].setForces()[1], \n                                &particles[idxTarget].setForces()[2],particles[idxTarget].setPotential(),&MatrixKernel); \n                    } \n                } \n            }", "pragma": "for ", "hash": "e0f5cd8fa81b54b885d343cf51cfee24b03c053ebf927c2c8a8f073c57931515"}
{"code": "for (i=0; i<sizeofBuffer; i++){ \n\t\t\t\tpongSendBuf[i] = pingRecvBuf[i]; \n\t\t\t}", "pragma": "parallel for private(i)", "hash": "115c8595079cf5567bc600da67ab486f9c4b6fc803065c85883039efb143bddd"}
{"code": "for (i=0; i < new_num_cols_offd; i++) \n      {   P_marker_offd[i] = 0; }", "pragma": "parallel for private(i)", "hash": "d51d110e6da1126ba6ef5b9bfa2694ec917b2aa64047452a7c196e9965088c22"}
{"code": "for(int i=0; i<allLines.size(); ++i)\t{  \n \n\t\tdouble len = cv::norm(allLines[i].p - allLines[i].q);\t\t\r \n\t\t \n \n\t\tdouble numSmp = min(max(len/sysPara.line_sample_interval, (double)sysPara.line_sample_min_num), (double)sysPara.line_sample_max_num);   \n \n   \t\tvector<cv::Point3d> pts3d; pts3d.reserve(numSmp);\r \n\t\tfor(int j=0; j<=numSmp; ++j) {\r \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tcv::Point2d pt = allLines[i].p * (1-j/numSmp) + allLines[i].q * (j/numSmp);\r \n\t\t\tif(pt.x<0 || pt.y<0 || pt.x >= depth_float.cols || pt.y >= depth_float.rows ) continue;\r \n\t\t\tint row, col;  \n \n\t\t\tif((floor(pt.x) == pt.x) && (floor(pt.y) == pt.y)) { \n \n\t\t\t\tcol = max(int(pt.x-1),0);\r \n\t\t\t\trow = max(int(pt.y-1),0);\r \n\t\t\t} else {\r \n\t\t\t\tcol = int(pt.x);\r \n\t\t\t\trow = int(pt.y);\r \n\t\t\t}\r \n\t\t\tdouble zval = -1;\r \n\t\t\tdouble depval;\r \n\t\t\tif(depth_CVMatDepth == CV_32F) \r \n\t\t\t\tdepval = depth_float.at<float>(row,col);\r \n\t\t\telse if (depth_CVMatDepth == CV_64F) \r \n\t\t\t\tdepval = depth_float.at<double>(row,col);\r \n\t\t\telse {\r \n\t\t\t\tcerr<<\"Node::extractLineDepth: depth image matrix type is not float/double\\n\";\r \n\t\t\t\texit(0);\t\r \n\t\t\t}\t\r \n\t\t\tif(depval < EPS || isnan((float)depval)) {  \n \n\r \n\t\t\t} else {\r \n\t\t\t\tzval = depval/depth_scaling;  \n \n\t\t\t}\r \n\r \n\t\t\tif (zval > 0 ) {\r \n\t\t\t\tEigen::Vector3d ept(pt.x, pt.y, 1);\r \n\t\t\t\tEigen::Vector3d xy3d = Kinv * ept;\r \n\t\t\t\txy3d = xy3d/xy3d(2);\r \n\t\t\t\tpts3d.push_back(cv::Point3d(xy3d(0)*zval, xy3d(1)*zval, zval));\t\t\t\t\t\t\t\t\r \n\t\t\t}\r \n\t\t}\r \n\t\tif (pts3d.size() < max(10.0, numSmp *ratio_of_collinear_pts))\r \n\t\t\tcontinue;\r \n\r \n\t\tRandomLine3d tmpLine;\t\t\r \n\t\tvector<RandomPoint3d> rndpts3d;\r \n\t\trndpts3d.reserve(pts3d.size());\r \n\t\t \n \n\t\tfor(int j=0; j<pts3d.size();++j) {\r \n\t\t\trndpts3d.push_back(compPt3dCov(pts3d[j], K, asynch_time_diff_sec_));\r \n\t\t}\r \n\t\t \n \n\t\ttmpLine = extract3dline_mahdist(rndpts3d);\r \n\t\t\r \n\t\tif(tmpLine.pts.size()/numSmp > ratio_of_collinear_pts\t&&\r \n\t\t\tcv::norm(tmpLine.A - tmpLine.B) > line_3d_len_thres_m) {\r \n\t\t\t\tallLines[i].haveDepth = true;\r \n\t\t\t\tallLines[i].line3d = tmpLine;\r \n\t\t\t\t\r \n\t\t}\t\t\r \n\t}", "pragma": "parallel ", "hash": "d347c2cdf561a58ba234de6e9773399a3c7ec8fb6eb8cf55bcdd2b1b67ab2b46"}
{"code": "for ( unsigned int i = 0;i<in.n_rows*in.n_cols;i++ ) \n  { \n    unsigned int row = i%in.n_rows; \n    unsigned int col = i/in.n_rows; \n    out(row,col) = value*in(row,col); \n  }", "pragma": "parallel for ", "hash": "d8ffd9b43b64efd777908d8d87d18cf3436e67d3543514cc7b37d054f0c5004f"}
{"code": "for (size_t j = 0; j < n; j++) { \n          size_t i = m - 1; \n          do { \n            register double temp = B[j * ldb + i]; \n            if (diag == CBlasNonUnit) temp *= A[i * lda + i]; \n            for (size_t k = 0; k < i; k++) \n              temp += A[i * lda + k] * B[j * ldb + k]; \n            X[j * ldx + i] = alpha * temp; \n          } while (i-- > 0); \n        }", "pragma": "parallel for ", "hash": "797cb0b8d078a505c8d2cb581c1573ba512f952cb3ab3bb5e90453b9f156dc95"}
{"code": "for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    MagickBooleanType \n      sync; \n \n    register const Quantum \n      *p, \n      *pixels; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *q; \n \n    size_t \n      width; \n \n    if (status == MagickFalse) \n      continue; \n    pixels=GetCacheViewVirtualPixels(texture_view,texture_image->tile_offset.x, \n      (y+texture_image->tile_offset.y) % texture_image->rows, \n      texture_image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if ((pixels == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns) \n    { \n      register ssize_t \n        j; \n \n      p=pixels; \n      width=texture_image->columns; \n      if ((x+(ssize_t) width) > (ssize_t) image->columns) \n        width=image->columns-x; \n      for (j=0; j < (ssize_t) width; j++) \n      { \n        register ssize_t \n          i; \n \n        if (GetPixelMask(image,p) != 0) \n          { \n            p+=GetPixelChannels(texture_image); \n            q+=GetPixelChannels(image); \n            continue; \n          } \n        for (i=0; i < (ssize_t) GetPixelChannels(texture_image); i++) \n        { \n          PixelChannel \n            channel; \n \n          PixelTrait \n            texture_traits, \n            traits; \n \n          channel=GetPixelChannelChannel(texture_image,i); \n          texture_traits=GetPixelChannelTraits(texture_image,channel); \n          traits=GetPixelChannelTraits(image,channel); \n          if ((traits == UndefinedPixelTrait) || \n              (texture_traits == UndefinedPixelTrait)) \n            continue; \n          SetPixelChannel(image,channel,p[i],q); \n        } \n        p+=GetPixelChannels(texture_image); \n        q+=GetPixelChannels(image); \n      } \n    } \n    sync=SyncCacheViewAuthenticPixels(image_view,exception); \n    if (sync == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor != (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_TextureImage) \n        proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType) y, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  }", "pragma": "parallel for ", "hash": "35135205686a18663bad7e537041cdba01fa28e799738557ac7fc8574ca00f28"}
{"code": "for (int c = 1; c <= grid.NCM; c++) \n\t{ \n#pragma ivdep \n\t\tfor (int i = 0; i <= grid.cells[c].data1D(indexS).numData-1; i++) \n\t\t{ \n\t\t\tgrid.cells[c].data1D(indexS)(i)\t= 0.0; \n\t\t} \n\t}", "pragma": "parallel ", "hash": "da9e2d506b3dbb6535c2692a213df2918d4473bfc313289e71198fa63f50f7a0"}
{"code": "for (i = 0; i < n_out; i++) { \n\t    r = i * (double) n_in / (double) (n_out); \n\t    j = floor(r); \n\t    r = r - j; \n \n\t    jp1 = j + 1; \n\t    if (j >= n_in) j -= n_in; \n\t    if (jp1 >= n_in) jp1 -= n_in; \n\t    def_j = DEFINED_VAL(in[j]); \n\t    def_jp1 = DEFINED_VAL(in[jp1]); \n \n\t    if (r <= 0.0) { \n\t\tout[i] = in[j]; \n\t    } \n\t    else if (r >= 1.0) { \n\t\tout[i] = in[jp1]; \n\t    } \n\t    else if (def_j && def_jp1) { \n\t        if (interpolation == linear || interpolation == linear_extrapolate) {\t\t\t \n \n\t            out[i] = (1.0-r)*in[j] + r*in[jp1]; \n\t        } \n\t\telse { \n\t\t    out[i] =  (r < 0.5) ? in[j] : in[jp1]; \n\t\t} \n\t    } \n\t    else if (interpolation == linear || interpolation == neighbor) { \n\t\tout[i] = UNDEFINED; \n\t    } \n\t    else { \n\t\tout[i] = def_j ? in[j] : in[jp1]; \n\t    } \n\t}", "pragma": "parallel for private(  def_j def_jp1 i j jp1 r)", "hash": "57bcd0320b727cc20307b9c68402645f8200ff65f089b28965f6cd88319a85cb"}
{"code": "for(fint i = 0; i < (m->gnelem()+m->gnConnFace())*nvars; i++) { \n\t\t\t\trarr[i] = 0; \n\t\t\t}", "pragma": "parallel for simd ", "hash": "87a90cf83161ae5df6c80991cdfd342a8451c05a133d9d311883b3089b2bf26d"}
{"code": "for (i = 0; i < len; i++) \n        { \n            fmpz_multi_mod_ui(tmp, poly + i, comb, comb_temp); \n            for (j = 0; j < num_primes; j++) \n                residues[j][i] = tmp[j]; \n        }", "pragma": "for ", "hash": "e37230ab696e8edf5057a2fc780f9a3fcbec8cff9937b9c5a91fbd2118141d84"}
{"code": "for (i=0; i<sz; i++) { \n      rp[i] = tp[i] / powf(2, sp[i]); \n      rp[i] = tp[i] / pow(2, sp[i]); \n      rp[i] = ((real) tp[i]) >> sp[i]; \n      rp[i] = ((unsigned real) tp[i]) >> sp[i]; \n    }", "pragma": "parallel for private(i)", "hash": "7e7f364ad57c33578168ec9635d7bd268e8be06789beb60ee9cfce99c494f66e"}
{"code": "for (i = 1; i < 3; i++)  \n \n    for (j = 2u; j < 5u; j++)  \n \n      for (int k = 3; k <= 6; k++)  \n \n        for (l = 4; l < 9; ++l)  \n \n        { \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    float res = b[j] * c[k]; \n    a[i] = res * d[l]; \n \n \n \n \n \n \n \n \n \n \n  }", "pragma": "parallel for simd ", "hash": "f95386f96e26e9f5623e55eb0236f8923ae7e0eed54a5d88de9e2b5a8f65ac59"}
{"code": "for(i=0; i<size; i++){ \n    v[i] = a * v[i]; \n  }", "pragma": "parallel for private(i)", "hash": "ee1e0d600b8aed7659721df008ebf197d8aa6c27ca65a46bb7f7b5c23b753e9f"}
{"code": "for( i = 0 ; i < LCU ; i ++  ) { \n      free( G.g[i]     ) ;  \n    }", "pragma": "parallel for private(i)", "hash": "fdf33b41dee5791719f42a3bed434b986eddae07855888089ba3c9f2209eb11e"}
{"code": "for (count i = 0; i < getDimension(); i++) { \n\t\tvalues[i] *= scalar; \n\t}", "pragma": "parallel for ", "hash": "7c8e589433b3733cea6518b172446a54302e29fbfefa205b619cf8b7bae9127b"}
{"code": "for(int k = 0; k < res; k++) table[k] = (table[k] + table_temp[k]) / 2.0f;", "pragma": "parallel for simd ", "hash": "4bc5d3568b3999ca13414a261b5ae30b121ffa03fef3c61abd2ec43f34e95996"}
{"code": "for (int i = 0; i < omega.theta.size(); i++) \n\t\t\t_y_vec[i] = std::accumulate(y_mat.begin()+i*omega.beta.size(),y_mat.begin()+(i+1)*omega.beta.size(),0.0);", "pragma": "parallel for ", "hash": "262078811e4a814e3694b16a7ce9c748c940f852231fb3fc0274c813a708d0ff"}
{"code": "for(int i = 0; i < n; ++i)\r \n    {\r \n        for(int j = 0; j < n; ++j)\r \n        {\r \n            index = (i * n) + j;\r \n\r \n            m_xCoord[index] = half_n + i * 2 ;\r \n            m_zCoord[index] = half_n + j * 2 ;\r \n\r \n            uID = (unsigned int)generateUID((float)m_xCoord[index], (float)m_zCoord[index]);\r \n\r \n            StochasticLib1 sto(uID + (unsigned int)m_seed);\r \n            m_rand1[index] = (float)sto.Normal(0.0, 1.0);\r \n            m_rand2[index] = (float)sto.Normal(0.0, 1.0);\r \n        }\r \n    }", "pragma": "parallel for private( index uid)", "hash": "a23cd64341743e4043828c25e8e5b655cead301e899ac66b214817bd1b8433d7"}
{"code": "for (index_type i = 0; i < numOf_G_cols; ++i) { \n            const index_type pivot_i = pivot[(numOfCDVcts + 1) + i];   \n \n            if (L.getSubunitID(pivot_i) == myRank) { \n                TlDenseVector_Lapack L_pi = L.getVector(pivot_i); \n                const double sum_ll = (L_pi.dotInPlace(L_pm)).sum(); \n                 \n \n                const double l_m_pi = (output_G_pm[i] - sum_ll) * inv_l_m_pm; \n \n#pragma omp atomic \n                L_xm[i] += l_m_pi; \n \n#pragma omp atomic \n                update_diagonals[pivot_i] -= l_m_pi * l_m_pi; \n            } \n        }", "pragma": "parallel for ", "hash": "558602763c18a08da3dfa459f1b5f36c18e06a7dcd6035247182f519ce4127b8"}
{"code": "for (int z = -1; z < nz+1; ++z) { \n        for (int y = -1; y < ny+1; ++y) { \n            for (int x = -1; x < nx+1; ++x) { \n \n                int cx = std::min( std::max(x,0), nx-1 ); \n                int cy = std::min( std::max(y,0), ny-1 ); \n                int cz = std::min( std::max(z,0), nz-1 ); \n \n                Phi[gIndex(x,y,z,ny,nx,1)] = Phi[gIndex(cx,cy,cz,ny,nx,1)]; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "ae7bcae94f656dbf3a6f5429c70ab046215c78d97acfe8066d44f73d88f61fa4"}
{"code": "for (Slicei=0; Slicei<SpinMxSliceNum; Slicei++){                                                             \r \n                        \r \n                         \n\r \n\t\t\t\t\t\t\r \n                         \n\r \n                        Mz\t\t\t= MzBase + (Typei*(*SpinNum)*SpinMxSliceNum*SpinMxNum + Spini*SpinMxSliceNum*SpinMxNum + Slicei*SpinMxNum);\r \n                        My\t\t\t= MyBase + (Typei*(*SpinNum)*SpinMxSliceNum*SpinMxNum + Spini*SpinMxSliceNum*SpinMxNum + Slicei*SpinMxNum);\r \n                        Mx\t\t\t= MxBase + (Typei*(*SpinNum)*SpinMxSliceNum*SpinMxNum + Spini*SpinMxSliceNum*SpinMxNum + Slicei*SpinMxNum);\r \n                        dWRnd\t\t= dWRndBase + (Typei*(*SpinNum)*SpinMxSliceNum*SpinMxNum + Spini*SpinMxSliceNum*SpinMxNum + Slicei*SpinMxNum);\r \n                        \r \n                        Rho\t\t\t= RhoBase+(Typei*SpinMxSliceNum*SpinMxNum + Slicei*SpinMxNum);\r \n                        T1\t\t\t= T1Base+ (Typei*SpinMxSliceNum*SpinMxNum + Slicei*SpinMxNum);\r \n                        T2\t\t\t= T2Base+ (Typei*SpinMxSliceNum*SpinMxNum + Slicei*SpinMxNum);\r \n                        \r \n                        dB0\t\t\t= dB0Base + Slicei*SpinMxNum;\r \n                        Gzgrid\t\t= GzgridBase + Slicei*SpinMxNum;\r \n                        Gygrid\t\t= GygridBase + Slicei*SpinMxNum;\r \n                        Gxgrid\t\t= GxgridBase + Slicei*SpinMxNum;\r \n                        TxCoilmg\t= TxCoilmgBase + Slicei*SpinMxNum;\r \n                        TxCoilpe\t= TxCoilpeBase + Slicei*SpinMxNum;\r \n                        \r \n                         \n\r \n                        BlochKernelNormalCPU((float)*Gyro, CS, SpinNum, Rho, T1, T2, Mz, My, Mx,\r \n\t\t\t\t\t\t\t\t\t\t\t dB0, dWRnd, Gzgrid, Gygrid, Gxgrid, TxCoilmg, TxCoilpe,\r \n\t\t\t\t\t\t\t\t\t\t\t (float)*dt, rfAmp, rfPhase, rfFreq, (float)*GzAmp, (float)*GyAmp, (float)*GxAmp,\r \n\t\t\t\t\t\t\t\t\t\t\t Typei, SpinMxNum, SpinMxSliceNum, *TxCoilNum);\r \n                        \r \n                        \r \n                    }", "pragma": "for private(             db0 dwrnd gxgrid gygrid gzgrid mx my mz rho slicei t1 t2 txcoilmg txcoilpe)", "hash": "a8c26a35cb60a111e728169de183f0ba1564b9d976e7b74e72fe528a4dad677f"}
{"code": "for(fakev = 1; fakev < n; fakev++){  \n \n                v = sorted_indices[fakev].first; \n                 \n \n                nv = g->get_node(v); \n                const list<int> &nbrs_v = nv->get_nbrs_ref(); \n                for(std::list<int>::const_iterator cit = nbrs_v.begin(); cit != nbrs_v.end(); ++cit){  \n \n                    u = *cit; \n                     \n \n                     \n \n                    if(revmap[u] > revmap[v]){  \n \n                        nu = g->get_node(u); \n                        const list<int> &nbrs_u = nu->get_nbrs_ref(); \n                        list<int>::const_iterator upit = nbrs_u.begin();  \n \n                        list<int>::const_iterator vpit = nbrs_v.begin();  \n \n                        uprime = *upit; \n                        vprime = *vpit; \n                         \n \n                         \n \n                        while((upit != nbrs_u.end()) && (vpit != nbrs_v.end() && \n                                                         (revmap[uprime] < revmap[v]) && (revmap[vprime] < revmap[v]))){  \n \n                            uprime = *upit; \n                            vprime = *vpit; \n                             \n \n                             \n \n                            if(revmap[uprime] < revmap[vprime]){  \n \n                                upit++; \n                                 \n \n                            } \n                            else if(revmap[uprime] > revmap[vprime]){  \n \n                                vpit++; \n                                 \n \n                            } \n                            else {  \n \n                                    \n \n                                local_t[omp_tid][v]++; \n                                local_t[omp_tid][u]++; \n                                local_t[omp_tid][uprime]++; \n                                upit++; \n                                vpit++; \n                            } \n                        } \n                    }  \n \n                }  \n \n            }", "pragma": "for ", "hash": "6345e5e61d9006b44476468e303cac074aab683c6891642291dfec0883d182ab"}
{"code": "for(long k=0;k<l;k++)\tfor(long j=0;j<m;j++)\tfor(long i=0;i<n;i++) \n\t\t\tr->a[i+n*(j+m*k)] = d->v(xx+dx*i, yy+dy*j, zz+dz*k);", "pragma": "parallel for ", "hash": "dd937e10df9ac83af5c7db8152f8b8976727d13f57febaf2b2aaf7e1e4f51100"}
{"code": "for (ib = 0; ib < ns2; ++ib) { \n \n                is = ib / ns; \n                js = ib % ns; \n \n                arr[0] = ns * knum_minus + snum; \n                arr[1] = ns * kpairs[ik_now][0] + is; \n                arr[2] = ns * kpairs[ik_now][1] + js; \n \n                v3_arr_loc[ib] = std::norm(V3(arr, \n                                              kmesh_in->xk, \n                                              eval_in, \n                                              evec_in, \n                                              phase_storage_dos)); \n            }", "pragma": "parallel for private(  arr is js)", "hash": "3f1abb463ccac6327bd3bf3f2da1c618960bb3568c7248e8924e28a95c41b218"}
{"code": "for (k = 0; k < info -> num_clusters; k++) { \n    norm = GET_PROBZ_CURR (k); \n \n     \n \n    for (i = 0; i < info -> m; i++) { \n      GET_PROBW1_Z_CURR (k, i) = GET_PROBW1_Z_CURR (k, i) - norm; \n    } \n \n     \n \n    for (j = 0; j < info -> n; j++) { \n      GET_PROBW2_Z_CURR (k, j) = GET_PROBW2_Z_CURR (k, j) - norm; \n    } \n  }", "pragma": "parallel for private(i j norm)", "hash": "db11c79082f851cead097404817eb826363a126d39c4aaac72ae7e7ed0e64c29"}
{"code": "for(i=0; i<img1->nvox;++i) \n                res[i] += lie_bracket_img2_lie1Ptr[i]/12.0;", "pragma": "parallel for private(i)", "hash": "24f1bf42ed022da6cee3e0de3d3cd3bdace6ede249408d4f4c4ca85e8d268fe7"}
{"code": "for (i = 0; i < N; i++) {\r \n    for (int j = 0; j < innerLoop; j++) {\r \n      a[i] += 2 * i * i * i * i * i * i * i * i * i * i; \r \n       \n \n    }\r \n  }", "pragma": "parallel ", "hash": "0aa911a5e066337c421bcce9f7fc80d784cccbf21bd6160d6aab6c6fc42f9d7c"}
{"code": "for (auto p = 0; p < particles.size(); p++) \n        { \n            auto particle = particles[p]; \n \n            auto particleCell = grid->GetCellAtCoordinate(Coordinate{ particle->X, particle->Y, particle->Z }); \n \n            if (particleCell == cell) \n                isFull = true; \n        }", "pragma": "parallel for ", "hash": "a2daccf84995341dd05fbe35f853f0a2cb74476dc7d7dfac6108e5bf5c6c1d31"}
{"code": "for (size_t p = 0; p < batch_sz * dim; p += 1) { \n    float x = in_buf[p]; \n    out_buf[p] = x * (x > 0.0f); \n  }", "pragma": "parallel for ", "hash": "4a0f1604aef5485c9690509adab1331e1ee4b0380ce84fb1ecdec2c287058c81"}
{"code": "for(y=0; y<m_pGrid->Get_NY(); y++) \n\t{ \n\t\tfor(x=0; x<m_pGrid->Get_NX(); x++) \n\t\t{ \n\t\t\tm_Edge.Set_Value(x, y, is_Edge(x, y) && zMin <= m_pGrid->asDouble(x, y) && m_pGrid->asDouble(x, y) <= zMax ? EDGE_LINE : 0); \n\t\t} \n\t}", "pragma": "parallel for private( x y)", "hash": "cf5cb433a5227226c19d71f5b6670ce14254456d8d0ae0c1b1dbc21b535d32df"}
{"code": "for (int i = 0; i < vertices.size() / 3; i++) \n      { \n        UINT loc = i * 3; \n \n        auto p1 = vertices[loc]; \n        auto p2 = vertices[loc + 1]; \n        auto p3 = vertices[loc + 2]; \n \n        auto aP1 = XMVectorSetW(XMVector3Normalize(XMVector3Avg(p1.pos, p2.pos)), 0.0f); \n        auto aP2 = XMVectorSetW(XMVector3Normalize(XMVector3Avg(p2.pos, p3.pos)), 0.0f); \n        auto aP3 = XMVectorSetW(XMVector3Normalize(XMVector3Avg(p3.pos, p1.pos)), 0.0f); \n \n        auto aC1 = XMVector3Avg(p1.col, p2.col); \n        auto aC2 = XMVector3Avg(p2.col, p3.col); \n        auto aC3 = XMVector3Avg(p3.col, p1.col); \n \n        VertPosColor aPC1 = { aP1, aC1 }; \n        VertPosColor aPC2 = { aP2, aC2 }; \n        VertPosColor aPC3 = { aP3, aC3 }; \n \n        loc = (i * 12); \n \n        newPoUINTs[loc++] = (aPC3); \n        newPoUINTs[loc++] = (p1); \n        newPoUINTs[loc++] = (aPC1); \n \n        newPoUINTs[loc++] = (aPC2); \n        newPoUINTs[loc++] = (aPC1); \n        newPoUINTs[loc++] = (p2); \n \n        newPoUINTs[loc++] = (p3); \n        newPoUINTs[loc++] = (aPC3); \n        newPoUINTs[loc++] = (aPC2); \n \n        newPoUINTs[loc++] = (aPC3); \n        newPoUINTs[loc++] = (aPC1); \n        newPoUINTs[loc++] = (aPC2); \n      }", "pragma": "for ", "hash": "e871b82d97b65d35f2af25372827de200226a97fb159df9604e2f72edd85db2b"}
{"code": "for(cid_t i = 1; i < wcc_group; ++i) { \n            tt = cid[i- 1]; \n            count += (tt != cid[i]); \n        }", "pragma": "parallel for reduction(+:count) private(tt)", "hash": "cd8c07cdf2bcf1c2dcfd6922eda3c54e1f20db82640876e8a4348296377b5aa0"}
{"code": "for (i = 0; i < j; i++)  \n \n    for (j = 0; j < 16; j++) \n      ;", "pragma": "for ", "hash": "c8f35a92c6c890e38a2aadbd714e0a3ba8bd2a93d711f89c32d6effa48b3652d"}
{"code": "for (uint32_t i = 0; i < vertices_.size(); ++i) { \n        if (!vertices_[i].is_deleted) { \n            start_node_map_[vertices_[i].rev_start_node] = i; \n        } \n    }", "pragma": "parallel for ", "hash": "b9576a82e72fcbe5f639d65912753d55379a3ceb0bdccb7645b5a74f8db9a3c7"}
{"code": "for (j = 1; j <= ndelta; j++) { \n    for (k = 0; k <= nly; k++) { \n      new_dw = ((ETA * delta[j] * ly[k]) + (MOMENTUM * oldw[k][j])); \n\t  w[k][j] += new_dw; \n\t  oldw[k][j] = new_dw; \n    } \n  }", "pragma": "parallel for private(    j k momentum ndelta new_dw nly)", "hash": "5ce3ceb47ef8e1a85d6df06d7db97f0b717d4ca6a23991faa9362cccb4f6b2ff"}
{"code": "for (data_size_t i = 0; i < num_data; ++i) { \n        score[i] += leaf_value_[0]; \n      }", "pragma": "parallel for ", "hash": "8a89934b0fca286bfaf969d12ab7af28382fb8e13a3441e9fd1063036a6a8706"}
{"code": "for ( unsigned long i = 0; i < insertions; ++i ) { \n           map[i]++; \n       }", "pragma": "parallel for ", "hash": "7dfb8eb9b43ed046233fd3e02b250976e41495b489426e762ea34c8e9c623647"}
{"code": "for(x = 1; x < w1; x++){ \n    ix = 0.5f*(fabs(Ix[x]) + fabs(Ix[x - 1])); \n    iy = fabs(Iy[x]); \n    MoG[x] = powf(ix*ix + iy*iy,0.5f); \n \n    ix = 0.5f*(fabs(Ix[x + y]) + fabs(Ix[x - 1 + y])); \n    iy = fabs(Iy[x + y - w]); \n    MoG[x + y] = powf(ix*ix + iy*iy,0.5f); \n  }", "pragma": "for private(  ix iy x)", "hash": "9a6c32e5734f647b0e653997a8e4f8725cc83a7c51ad7646a7ddd9375abea738"}
{"code": "for(long i=0;i<nx*vy;i++)\tb[k+i] = v->vthr(i);", "pragma": "parallel for ", "hash": "c112e7eff2871e055ffb6fb5d8f6960e334a325359e7505dda046ed3d123652c"}
{"code": "for(int i=0;i<a;++i) \n\t  for(int j=0;j<b;++j) \n\t    ptr2(i,j)=sqrt(ptr2(i,j));", "pragma": "parallel for ", "hash": "c9e389f9ac7af212a7b24777cfdf96cfd86a396d70e3a50474df4a43e6aebfdb"}
{"code": "for(size_t ri = 0; ri < input.size(); ++ri) { \n        for(size_t hi = 0; hi < haplotypes.size(); ++hi) { \n            const auto& current = haplotypes[hi]; \n \n             \n \n            std::vector<HMMInputSequence> sequences = generate_methylated_alternatives(current.first.get_sequence(), methylation_types); \n            double score = profile_hmm_score_set(sequences, input[ri], alignment_flags); \n \n            #pragma omp critical \n            { \n                variant_group.set_combination_read_score(current.second, read_ids[ri], score); \n \n \n \n \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "58666b58b01657470384f1f3619917ecb7078edd666e62449bc83b65b58e080d"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      #pragma omp atomic write   \n \n      v = a[i];\t\t\t\t \n \n    }", "pragma": "for simd ", "hash": "288f910d7c8b9dbe272faba6b356bdd797292431f8bc9ae06db473a0ed3fdf15"}
{"code": "for (int n = 0 ; n < N ; n++) { \n        for (int j = 0 ; j < J ; j++) { \n            if (y(n, j) == 1) { \n                 \n \n                probobs(n, j) = probs1(n, j) ; \n            } else if (y(n, j) == -1) { \n                 \n \n                probobs(n, j) = 1 - probs1(n, j) ; \n            } else { \n                 \n \n                probobs(n, j) = 1 ; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "3e599428385817e7daca7980f26e0f3061ad64e20e83a226bbae760e5eb76d88"}
{"code": "for (t2=lbp;t2<=ubp;t2++) { \n  mean[t2] = SCALAR_VAL(0.0);; \n  stddev[t2] = SCALAR_VAL(0.0);; \n  corr[t2][t2] = SCALAR_VAL(1.0);; \n}", "pragma": "parallel for private(lbv t3 t4 ubv)", "hash": "5e34e88804be2720c5e32fde23a1e66604bd9de4f25ed2170110562b1e7c2e95"}
{"code": "for (uint s=0; s < number_of_samples; ++s) \n\t    {  samples_from_posterior.at(s) = get_a_single_sample();  }", "pragma": "for ", "hash": "8abfa3891519821371d3bb204e9620e98669c8b9ca06d0c172f0281b8d63ac5e"}
{"code": "for (i2=0; i2<n2; i2++) { \n\tfor (i1=0; i1<n1; i1++) { \n\t\tcc[i2][i1] = ((i2%2==0)==(i1%2==0))? inp[i2*n1+i1]:-inp[i2*n1+i1]; \n\t\tcc[i2][i1] = ((i2%2==0)==(i1%2==0))? inp[i2*n1+i1]:sf_cneg(inp[i2*n1+i1]); \n\t} \n    }", "pragma": "parallel for private(i1 i2)", "hash": "7636bcb798e166eaef5d893acc761ec4798a95f279a60161412b09f71ca81ede"}
{"code": "for(int y = 0; y < height; ++y) { \n            for (int x = 0; x < width; ++x) { \n                Imf::Rgba out; \n                float totWeight = 0; \n                const float invdx2 = 1.0/(width*width); \n                float w; \n                for(int j = y - BLUR_N; j <= y+BLUR_N; ++j) { \n                    if (j>=0 &&  j < height) { \n                        w = exp(-invdx2*((j-y)*(j-y))); \n                        out.r += w*B[x + width * j].r; \n                        out.g += w*B[x + width * j].g; \n                        out.b += w*B[x + width * j].b; \n                        out.a += w*B[x + width * j].a; \n                        totWeight += w; \n                    } \n                } \n                C[x + width * y].r = out.r / totWeight; \n                C[x + width * y].g = out.g / totWeight; \n                C[x + width * y].b = out.b / totWeight; \n                C[x + width * y].a = out.a / totWeight; \n            } \n        }", "pragma": "parallel for ", "hash": "25a9f82f6ee14cc3c9936bdb3bb33dda0190b9a19275e7f7e2748dfb2dca426b"}
{"code": "for(ie=0;ie<=NNUCREAC+1;ie++) \n        { \n\t\t\tint je; \n\t\t\tdouble ratioH_tmp[NNUC+1]; \n  \n            if(optfail==0) \n            { \n\t\t\t\tstruct errorparam paramerror; \n\t\t\t\tparamerror.errnumber=ie; \n\t\t\t\t \n\t\t\t\tfor(je=1;je<=NNUC;je++) ratioH_tmp[je]=0.; \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\tif(nucl_single(paramrelic,ratioH_tmp,&paramerror)>0) optfail=1; \n \n\t\t\t\tif(ratioH_tmp[3]*ratioH_tmp[6]==0.) checkzeros+=1; \n \n\t\t\t\tfor(je=1;je<=NNUC;je++) ratioH_all[ie][je]=ratioH_tmp[je]; \n \n\t\t\t\tfor(je=1;je<=NNUC;je++) optfail+=isnan(ratioH_tmp[je]); \n            } \n        }", "pragma": "parallel for ", "hash": "a71e3299ed1d3ba2f99b8dfd8a42514e50bb8aa47a80eaf29311fec047393dff"}
{"code": "for(k=0;k<nypad;k++) \n\tfor(i=0;i<nxpad;i++) \n\t    for(j=0;j<nzpad;j++) \n\t\tfor(l=-_mix;l<=_mix;l++) \n\t\t{ \n\t\t    if(i+l>=0&&i+l<nxpad) \n\t\t\tpx_tmp[k][i][j]+=coeff_1dx[l+_mix]*p2[k][i+l][j]/2.0/dx; \n\t\t    if(k+l>=0&&k+l<nypad) \n\t\t\tqy_tmp[k][i][j]+=coeff_1dy[l+_mix]*q2[k+l][i][j]/2.0/dy; \n\t\t    if(j+l>=0&&j+l<nzpad) \n\t\t\trz_tmp[k][i][j]+=coeff_1dz[l+_mix]*r2[k][i][j+l]/2.0/dz; \n\t\t}", "pragma": "parallel for private(i j k l)", "hash": "27006d97e189716e0b53ea45b18c721da515004ebf2339dbd4c9a5e210ff80e6"}
{"code": "for (j = 1; j <= grid_points[1]-2; j++) { \n      for (k = 1; k <= grid_points[2]-2; k++) { \n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp *  \n\t  (-4.0*u[m][i-1][j][k] + 6.0*u[m][i][j][k] - \n\t   4.0*u[m][i+1][j][k] + u[m][i+2][j][k]); \n      } \n    }", "pragma": "for ", "hash": "303ba416f4a7201443af2425ec5f35be9266f87d8f940940df8b9d8947e2c89c"}
{"code": "for(int t=0; t < nTrees; ++t) \n\t\t{ \n\t\t  trees[t].RefineLeafNodes(data, nPoints, i);\t   \n\t\t}", "pragma": "for ", "hash": "bfaeb8c528b132c44a62caf0ee0571df133049fc3c7a4667c18a1fe094958471"}
{"code": "for (i = 0; i < Vz.nx; i++) { \n            for (j = 0; j < Vz.ny; j++) { \n                for (k = 0; k < Vz.nz; k++) { \n                    Vz.p[i][j][k] = Cvzvz.p[i][j][k] * Vz.p[i][j][k] - Cvzez.p[i][j][k] * (Ezn.p[i][j][k] + Ez.p[i][j][k]); \n                } \n            } \n        }", "pragma": "parallel for private(i j k)", "hash": "446ca88ed7fe82c8390e9731cecbf92e57b4cb7d81afff35356ededfd35edcb4"}
{"code": "for (int ix = 0; ix < static_cast<int>(numInputs - 1); ix++) \n\t\t{ \n\t\t\tfor (size_t iy = ix + 1; iy < numInputs; iy++) \n\t\t\t{ \n\t\t\t\tinnerProd[ix][iy] = innerProd[iy][ix]; \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "833917806545169318102bffbabc8073fae388749634cbbce6eee7d5d2f3aaa3"}
{"code": "for(size_t ui=0; ui<dataIn.size(); ui++) \n\t{ \n\t\tif(spin) \n\t\t\tcontinue; \n \n\t\t \n \n\t\tif(((this->*cropFunc)(dataIn[ui].getPosRef())) ^ invertedClip) \n\t\t\tinside[omp_get_thread_num()].push_back(ui); \n\t\t \n\t\t \n \n\t\tif(!curProg--) \n\t\t{ \n#pragma omp critical \n\t\t\t{ \n\t\t\tn+=PROGRESS_REDUCE; \n\t\t\tprog = (float)n/(float)dataIn.size() * (maxProg-minProg)+minProg; \n\t\t\t \n\t\t\tif(*Filter::wantAbort) \n\t\t\t\tspin=true; \n\t\t\t} \n\t\t\tcurProg=PROGRESS_REDUCE; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "320b4a6ba9ec4e7c275c7751fe1d2a145b5baad4d65faff4516f3c8c92d31620"}
{"code": "for(th=0;th<nth;th++) { \n    state[th] = 1; \n    for(;;) { \n      int i; \n      for(i=0;i<nth;i++) if (state[i] == 0) break; \n      if (i == nth) break; \n    } \n  }", "pragma": "parallel for ", "hash": "d29d2c304e0db0b649745d4233ea50bf58f9f10f95c5b1c90f9581801e489bdf"}
{"code": "for (ompIndexType k = 0; k < elementCount; k++) { \n                    data[k] = pDouble[k]; \n                }", "pragma": "parallel for ", "hash": "fceb25ddc5f34c47c98300db2cc4d8acb33e5ffb6bddb5742aadbd7586aee518"}
{"code": "for        (iy=0; iy<fdm->nypad; iy++) { \n\t    for    (ix=0; ix<fdm->nxpad; ix++) { \n\t\tfor(iz=0; iz<fdm->nzpad; iz++) { \n\t\t     \n\t\t    sxx = c11[iy][ix][iz] * txx[iy][ix][iz] \n\t\t\t+ c12[iy][ix][iz] * tyy[iy][ix][iz] \n\t\t\t+ c13[iy][ix][iz] * tzz[iy][ix][iz]; \n\t\t    syy = c12[iy][ix][iz] * txx[iy][ix][iz] \n\t\t\t+ c22[iy][ix][iz] * tyy[iy][ix][iz] \n\t\t\t+ c23[iy][ix][iz] * tzz[iy][ix][iz]; \n\t\t    szz = c13[iy][ix][iz] * txx[iy][ix][iz] \n\t\t\t+ c23[iy][ix][iz] * tyy[iy][ix][iz] \n\t\t\t+ c33[iy][ix][iz] * tzz[iy][ix][iz]; \n\t\t     \n\t\t    sxy = c66[iy][ix][iz] * txy[iy][ix][iz]; \n\t\t    syz = c44[iy][ix][iz] * tyz[iy][ix][iz]; \n\t\t    szx = c55[iy][ix][iz] * tzx[iy][ix][iz]; \n\t\t     \n\t\t    txx[iy][ix][iz] = sxx; \n\t\t    tyy[iy][ix][iz] = syy; \n\t\t    tzz[iy][ix][iz] = szz; \n \n\t\t    txy[iy][ix][iz] = sxy; \n\t\t    tyz[iy][ix][iz] = syz; \n\t\t    tzx[iy][ix][iz] = szx; \n\t\t} \n\t    } \n\t}", "pragma": "parallel for private(ix iy iz sxx sxy syy syz szx szz)", "hash": "d226aab1664537e5e2201df46fa3160bde8824fcdec4bd0d23481adcdcffb30a"}
{"code": "for (i = 0; i < col; i++) { \n            sum = 0.0f; \n            for (j = 0; j < row; j++) { \n                size_t index = j * col + i; \n                sum += in_tensor[index]; \n            } \n            out_tensor[i] = sum; \n        }", "pragma": "parallel for private(i)", "hash": "7b07fc00fe8277e0312ce65f058ba3ccb08cd703b36e4fd87547ed4a016d3e96"}
{"code": "for(i = 0; i < (int)data->num_data; i++) \n\t\t{ \n\t\t\tj=omp_get_thread_num(); \n \n\t\t\tfann_type* temp_predicted_output; \n\t\t\tif (ann->do_dropout) { \n\t\t\t\ttemp_predicted_output=fann_run_dropout(ann_vect[j], data->input[i]); \n\t\t\t} \n\t\t\telse { \n\t\t\t\ttemp_predicted_output=fann_run(ann_vect[j], data->input[i]); \n\t\t\t} \n\t\t\tfor(unsigned int k=0;k<data->num_output;++k) \n\t\t\t{ \n\t\t\t\tpredicted_outputs[i][k]=temp_predicted_output[k]; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tfann_compute_MSE(ann_vect[j], data->output[i]); \n\t\t\tfann_backpropagate_MSE(ann_vect[j]); \n\t\t\tfann_update_slopes_batch(ann_vect[j], ann_vect[j]->first_layer + 1, ann_vect[j]->last_layer - 1); \n\t\t}", "pragma": "for ", "hash": "20ee018e883ba12516ad2ea0933f9560b0bea1ed20d057528d468821bef0b28f"}
{"code": "for (int i = 1;i < 51;++i) \n\t{ \n\t\tfor (int j = 1;j < 51;++j) \n\t\t{ \n\t\t\tint count =  \n\t\t\t\tdata[i - 1][j - 1] + \n\t\t\t\tdata[i - 1][j] + \n\t\t\t\tdata[i - 1][j + 1] + \n\t\t\t\tdata[i][j - 1] + \n\t\t\t\tdata[i][j + 1] + \n\t\t\t\tdata[i + 1][j - 1] + \n\t\t\t\tdata[i + 1][j] + \n\t\t\t\tdata[i + 1][j + 1]; \n \n\t\t\tif (count == burn) \n\t\t\t{ \n\t\t\t\tbuffer[i][j] = 1; \n\t\t\t} \n\t\t\telse if (count == live) \n\t\t\t{ \n\t\t\t\tbuffer[i][j] = data[i][j];  \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tbuffer[i][j] = 0; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "49bd86eee91a3950908d47a737bfc90f402854d2015bee996299b7803e17af17"}
{"code": "for (size_t y = 0; y < m_cvts.ymax; y++) { \n        size_t x = 0; \n        for (; x < m_cvts.xmax - 3; x+=4) { \n            sumthrv += xlogf(c1v + LVFU(m_image[y][x])); \n        } \n        for (; x < m_cvts.xmax; x++) { \n            sumthr += xlogf(0.00001f + m_image[y][x]); \n        } \n    }", "pragma": "for ", "hash": "944a3d9ea9e62acd450b47ff5f445bbcb9663c62ca3960f182317430c4b4bf1d"}
{"code": "for(int n=0; n<N; n++) \n    { \n\tidx0 = work->idx[n]; \n\tqn = st->q[n]; \n\t \n \n\tfor(i = 0; i<p; i++) \n\t{ \n\t    for(j = 0; j<p; j++) \n\t    { \n\t\tcij0 = qn*zx[p*n+i]*zy[p*n+j]; \n\t\tidxzz=p*n; \n\t\tfor(k = 0; k<p; k++) \n\t\t{ \n\t\t    H[idx0] += zz[idxzz]*cij0; \n\t\t    idx0++; idxzz++; \n\t\t} \n\t\tidx0 += incrj;  \n\t    } \n\t    idx0 += incri;  \n\t} \n    }", "pragma": "for ", "hash": "6b2d7dd89eb66089d90798a3fcdb1248c29e2363fc04c2745a3cb8cc47c8b804"}
{"code": "for (int i = 0; i < NUM_TRAJECTORIES; i++) { \n    std::stack<std::tuple<int, int, int, float>> traj; \n     \n \n    int tlen = 0; \n    int cx = x, cy = y; \n    int nx = x, ny = y; \n     \n \n    float cur_reward = 0; \n    for (int tlen = 0; !(cx == tx && cy == ty); tlen++) { \n       \n \n       \n \n       \n \n      int caction = get_best_action(env, emask, cx, cy, w, h); \n       \n \n \n      nx += actions[caction][0]; \n      ny += actions[caction][1]; \n      cur_reward = -1; \n \n       \n \n      if (nx < 0 || nx >= w) { \n        cur_reward = outside_penalty; \n        nx = (nx < 0 ? 0 : w - 1); \n      } else if (ny < 0 || ny >= h) { \n        cur_reward = outside_penalty; \n        ny = (ny < 0 ? 0 : h - 1); \n      } else if (env[nx][ny] && emask[nx][ny]) { \n        cur_reward = -10; \n        nx = cx; \n        ny = cy; \n \n      } else if (env[nx][ny] && !emask[nx][ny]) { \n        cur_reward = -200; \n         \n \n         \n \n      } \n \n      if (tlen == max_tlen) { \n         \n \n        int nnaction = rand() % 5 + 0; \n        int nnx = nx + actions[nnaction][0]; \n        int nny = ny + actions[nnaction][1]; \n        nnx = (nnx < 0 ? 0 : nnx >= w ? w - 1 : nnx); \n        nny = (nny < 0 ? 0 : nny >= h ? h - 1 : nny); \n \n        traj.push(std::make_tuple(nx, ny, caction, cur_reward + GAMMA * vfuncs[nnx][nny][nnaction])); \n        break; \n      } \n \n      if ((nx == tx) && (ny == ty)) \n        cur_reward = 1000; \n \n      traj.push(std::make_tuple(cx, cy, caction, cur_reward)); \n      cx = nx; \n      cy = ny; \n    } \n     \n \n    int sx, sy, sa; \n    float sr, pval = 0.0f, target, td_error; \n \n     \n \n     \n \n    while (traj.size()) { \n       \n \n      std::tie(sx, sy, sa, sr) = traj.top(); \n \n#pragma omp critical \n      { \n        vfuncs[sx][sy][sa] += ALPHA * (sr + GAMMA * pval - vfuncs[sx][sy][sa]); \n        pval = *std::max_element(vfuncs[sx][sy], vfuncs[sx][sy] + 5); \n      } \n \n      traj.pop(); \n \n    } \n \n  }", "pragma": "parallel for ", "hash": "62e7c4ad5d6af3e8a6697af74797b00fca4525ceecfa4e08c99575a895ad149a"}
{"code": "for (i = 0; i < sz; i++) \n        out_tensor[i] = exp(in_tensor[i]);", "pragma": "parallel for private(i)", "hash": "a4d0ee6fce6bb5fdc9fedcd27f67b5b8ea9de031148259db3c739bcee0839269"}
{"code": "for(int i=0; i<gparams_.batch_size; i++) \n      toplabel[i] = labels_[mbslot][i];", "pragma": "parallel for ", "hash": "9c2e89a1a259660a8a25c976e3574dfbd5de014593a6fe39a26c7c84749d9ac5"}
{"code": "for (int i = 0; i < values.size(); i++) { \n    se += square(values(i) - mean_value); \n  }", "pragma": "parallel for reduction(+:se) ", "hash": "6944f482dbc0f5463555dabacfebf44416b35c1e2a84194c17c0be1075192b64"}
{"code": "for(j=2;j<height-2;j++)\r \n        for(i=2,offset=j*width+i;i<width-2;i++,offset++){\r \n           \n \n          wH=fabsf(L[offset+1]-L[offset-1]);\r \n          wV=fabsf(L[offset+width]-L[offset-width]);\r \n\r \n          s=1.0+fabs(wH-wV)/2.0;\r \n          wD1=fabsf(L[offset+width+1]-L[offset-width-1])/s;\r \n          wD2=fabsf(L[offset+width-1]-L[offset-width+1])/s;\r \n          s=wD1;\r \n          wD1/=wD2;\r \n          wD2/=wD1;\r \n\r \n           \n \n          lumH=lumV=lumD1=lumD2=v=ToFloatTable[m_Image[offset][c]];\r \n\r \n           \n \n          contrast=sqrtf(fabsf(L[offset+1]-L[offset-1])*fabsf(L[offset+1]-L[offset-1])+fabsf(L[offset+width]-L[offset-width])*fabsf(L[offset+width]-L[offset-width]))/chmax[c];\r \n          if(contrast>1.0) contrast=1.0;\r \n\r \n           \n \n          if(((L[offset]<L[offset-1])&&(L[offset]>L[offset+1])) ||\r \n             ((L[offset]>L[offset-1])&&(L[offset]<L[offset+1]))){\r \n            f1=fabsf(L[offset-2]-L[offset-1]);\r \n            f2=fabsf(L[offset-1]-L[offset]);\r \n            f3=fabsf(L[offset-1]-L[offset-width])*fabsf(L[offset-1]-L[offset+width]);\r \n            f4=sqrtf(fabsf(L[offset-1]-L[offset-width2])*fabsf(L[offset-1]-L[offset+width2]));\r \n            difL=f1*f2*f2*f3*f3*f4;\r \n            f1=fabsf(L[offset+2]-L[offset+1]);\r \n            f2=fabsf(L[offset+1]-L[offset]);\r \n            f3=fabsf(L[offset+1]-L[offset-width])*fabsf(L[offset+1]-L[offset+width]);\r \n            f4=sqrtf(fabs(L[offset+1]-L[offset-width2])*fabsf(L[offset+1]-L[offset+width2]));\r \n            difR=f1*f2*f2*f3*f3*f4;\r \n            if((difR!=0)&&(difL!=0)){\r \n              lumH=(L[offset-1]*difR+L[offset+1]*difL)/(difL+difR);\r \n              lumH=v*(1-contrast)+lumH*contrast;\r \n            }\r \n          }\r \n\r \n          if(((L[offset]<L[offset-width])&&(L[offset]>L[offset+width])) ||\r \n             ((L[offset]>L[offset-width])&&(L[offset]<L[offset+width]))){\r \n            f1=fabsf(L[offset-width2]-L[offset-width]);\r \n            f2=fabsf(L[offset-width]-L[offset]);\r \n            f3=fabsf(L[offset-width]-L[offset-1])*fabsf(L[offset-width]-L[offset+1]);\r \n            f4=sqrtf(fabsf(L[offset-width]-L[offset-2])*fabsf(L[offset-width]-L[offset+2]));\r \n            difT=f1*f2*f2*f3*f3*f4;\r \n            f1=fabsf(L[offset+width2]-L[offset+width]);\r \n            f2=fabsf(L[offset+width]-L[offset]);\r \n            f3=fabsf(L[offset+width]-L[offset-1])*fabsf(L[offset+width]-L[offset+1]);\r \n            f4=sqrtf(fabsf(L[offset+width]-L[offset-2])*fabsf(L[offset+width]-L[offset+2]));\r \n            difB=f1*f2*f2*f3*f3*f4;\r \n            if((difB!=0)&&(difT!=0)){\r \n              lumV=(L[offset-width]*difB+L[offset+width]*difT)/(difT+difB);\r \n              lumV=v*(1-contrast)+lumV*contrast;\r \n            }\r \n          }\r \n\r \n          if(((L[offset]<L[offset-1-width])&&(L[offset]>L[offset+1+width])) ||\r \n             ((L[offset]>L[offset-1-width])&&(L[offset]<L[offset+1+width]))){\r \n            f1=fabsf(L[offset-2-width2]-L[offset-1-width]);\r \n            f2=fabsf(L[offset-1-width]-L[offset]);\r \n            f3=fabsf(L[offset-1-width]-L[offset-width+1])*fabsf(L[offset-1-width]-L[offset+width-1]);\r \n            f4=sqrtf(fabsf(L[offset-1-width]-L[offset-width2+2])*fabsf(L[offset-1-width]-L[offset+width2-2]));\r \n            difLT=f1*f2*f2*f3*f3*f4;\r \n            f1=fabsf(L[offset+2+width2]-L[offset+1+width]);\r \n            f2=fabsf(L[offset+1+width]-L[offset]);\r \n            f3=fabsf(L[offset+1+width]-L[offset-width+1])*fabsf(L[offset+1+width]-L[offset+width-1]);\r \n            f4=sqrtf(fabsf(L[offset+1+width]-L[offset-width2+2])*fabsf(L[offset+1+width]-L[offset+width2-2]));\r \n            difRB=f1*f2*f2*f3*f3*f4;\r \n            if((difLT!=0)&&(difRB!=0)){\r \n              lumD1=(L[offset-1-width]*difRB+L[offset+1+width]*difLT)/(difLT+difRB);\r \n              lumD1=v*(1-contrast)+lumD1*contrast;\r \n            }\r \n          }\r \n\r \n          if(((L[offset]<L[offset+1-width])&&(L[offset]>L[offset-1+width])) ||\r \n             ((L[offset]>L[offset+1-width])&&(L[offset]<L[offset-1+width]))){\r \n            f1=fabsf(L[offset-2+width2]-L[offset-1+width]);\r \n            f2=fabsf(L[offset-1+width]-L[offset]);\r \n            f3=fabsf(L[offset-1+width]-L[offset-width-1])*fabsf(L[offset-1+width]-L[offset+width+1]);\r \n            f4=sqrtf(fabsf(L[offset-1+width]-L[offset-width2-2])*fabsf(L[offset-1+width]-L[offset+width2+2]));\r \n            difLB=f1*f2*f2*f3*f3*f4;\r \n            f1=fabsf(L[offset+2-width2]-L[offset+1-width]);\r \n            f2=fabsf(L[offset+1-width]-L[offset])*fabsf(L[offset+1-width]-L[offset]);\r \n            f3=fabsf(L[offset+1-width]-L[offset+width+1])*fabsf(L[offset+1-width]-L[offset-width-1]);\r \n            f4=sqrtf(fabsf(L[offset+1-width]-L[offset+width2+2])*fabsf(L[offset+1-width]-L[offset-width2-2]));\r \n            difRT=f1*f2*f2*f3*f3*f4;\r \n            if((difLB!=0)&&(difRT!=0)){\r \n              lumD2=(L[offset+1-width]*difLB+L[offset-1+width]*difRT)/(difLB+difRT);\r \n              lumD2=v*(1-contrast)+lumD2*contrast;\r \n            }\r \n          }\r \n\r \n          s=Strength;\r \n\r \n           \n \n          if(((fabsf(wH/wV)<0.45)&&(fabsf(wH/wV)>0.05))||((fabsf(wV/wH)<0.45)&&(fabsf(wV/wH)>0.05)))\r \n            s=Strength/3.0;\r \n\r \n           \n \n          if((wH!=0)&&(wV!=0)&&(wD1!=0)&&(wD2!=0))\r \n            m_Image[offset][c]= CLIP((int32_t) ((v*(1-s)+(lumH*wH+lumV*wV+lumD1*wD1+lumD2*wD2)/(wH+wV+wD1+wD2)*s)*0xffff));\r \n        }", "pragma": "parallel for private(contrast difb difl diflb diflt difr difrb difrt dift f1 f2 f3 f4 i j lumd1 lumd2 lumh lumv offset s v wd1 wd2 wh wv)", "hash": "85697c4898b67666764703d34a5bcfa4c22373fdf78cadc73b30325e2da32165"}
{"code": "for (i = 0; i < mesh[0] * mesh[1] * mesh[2]; i++) { \n    if (ir_mapping_table[i] == i) { \n      num_ir++; \n    } \n  }", "pragma": "parallel for reduction(+:num_ir) ", "hash": "0a8222f77d840b0a4b61beb38fc19d734aaa8a7703f86214ad6a97cc10447be0"}
{"code": "for (e = 0; e < E; e++){ \n        u = Eu[e]*K; \n        v = Ev[e]*K; \n        i = e*K; \n        for (k = 0; k < K; k++){ \n            Zu[i] = P[u]; \n            Zv[i] = P[v]; \n            i++; u++; v++; \n        } \n    }", "pragma": "parallel for private(    e i k u v)", "hash": "89bfa970c3ee32fd43330985b54d832beff8a367e4e98e0dfbdbe9a81d1f927a"}
{"code": "for (int j = 0; j < dy; j++) \n\t{ \n\t\tunsigned char* p = cr + (j * stride); \n\t\tint ya = j * oy / dy; \n\t\tint yb = (j + 1) * oy / dy; \n\t\tif (yb >= oy) \n\t\t\tyb = oy - 1; \n\t\tfor (int i = 0; i < dx; i++, p += 3) \n\t\t{ \n\t\t\tint xa = i * ox / dx; \n\t\t\tint xb = (i + 1) * ox / dx; \n\t\t\tif (xb >= ox) \n\t\t\t\txb = ox - 1; \n\t\t\tint r = 0; \n\t\t\tint g = 0; \n\t\t\tint b = 0; \n\t\t\tint sq = 0; \n\t\t\tfor (int l = ya; l <= yb; l++) \n\t\t\t{ \n\t\t\t\tconst unsigned char* q = orgin + ((l * ox + xa) * 3); \n\t\t\t\tfor (int k = xa; k <= xb; k++, q += 3, sq++) \n\t\t\t\t{ \n\t\t\t\t\tr += q[0]; \n\t\t\t\t\tg += q[1]; \n\t\t\t\t\tb += q[2]; \n\t\t\t\t} \n\t\t\t} \n\t\t\tp[0] = r / sq; \n\t\t\tp[1] = g / sq; \n\t\t\tp[2] = b / sq; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "0af5218aa6c713834dfac465fe2110d7a0850f291d3172b9a6c5928534877cb9"}
{"code": "for(int p = 0; p < n_panels; p++){ \n        surface_potential[p] = compute_surface_potential(p); \n         \n \n    }", "pragma": "parallel for ", "hash": "497e06f5e0156fe6453ffe61bbb158a53ff1a18d36a207d9d6ce9881c1f8b074"}
{"code": "for(i = data_offset; i < SourceSize_in_bytes; i = i + rec_size)\r \n\t\t\t{\r \n\t\t\t\tbyteValue = *(&char_ptr_tempSource[i] + ByteIndex);\r \n\t\t\t\t\r \n\t\t\t\t++privateByteCounter[byteValue];\r \n\t\t\t}", "pragma": "for private(i)", "hash": "7f55c55ad9fbeb2f77dbd3def2a48a1d3ee1962cde3db4f22094cfb8d0ecdac3"}
{"code": "for (int i = 0; i < numParticles; i++)\r \n\t\t\t{\r \n\t\t\t\tconst Vector3r accel = m_model->getAcceleration(i) + m_simulationData.getPressureAccel(i);\r \n\t\t\t\tconst Vector3r &lastX = m_simulationData.getLastPosition(i);\r \n\t\t\t\tconst Vector3r &lastV = m_simulationData.getLastVelocity(i);\r \n\t\t\t\tVector3r &x = m_model->getPosition(0, i);\r \n\t\t\t\tVector3r &v = m_model->getVelocity(0, i);\r \n\t\t\t\tv = lastV + h*accel;\r \n\t\t\t\tx = lastX + h*v;\r \n\t\t\t}", "pragma": "for ", "hash": "b795440f51127d2a74cc735af5ac3fea7a289f35eb4ab36d02ae896204047a5e"}
{"code": "for (j = jst; j < jend; j++) { \n    for (i = ist; i < iend; i++) { \n      for (k = 0; k < nz; k++) { \n        utmp[k][0] = u[k][j][i][0]; \n        utmp[k][1] = u[k][j][i][1]; \n        utmp[k][2] = u[k][j][i][2]; \n        utmp[k][3] = u[k][j][i][3]; \n        utmp[k][4] = u[k][j][i][4]; \n        utmp[k][5] = rho_i[k][j][i]; \n      } \n      for (k = 0; k < nz; k++) { \n        flux[k][0] = utmp[k][3]; \n        u41 = utmp[k][3] * utmp[k][5]; \n \n        q = qs[k][j][i]; \n \n        flux[k][1] = utmp[k][1] * u41; \n        flux[k][2] = utmp[k][2] * u41; \n        flux[k][3] = utmp[k][3] * u41 + C2 * (utmp[k][4]-q); \n        flux[k][4] = ( C1 * utmp[k][4] - C2 * q ) * u41; \n      } \n \n      for (k = 1; k < nz - 1; k++) { \n        for (m = 0; m < 5; m++) { \n          rtmp[k][m] =  rsd[k][j][i][m] \n            - tz2 * ( flux[k+1][m] - flux[k-1][m] ); \n        } \n      } \n \n      for (k = 1; k < nz; k++) { \n        tmp = utmp[k][5]; \n \n        u21k = tmp * utmp[k][1]; \n        u31k = tmp * utmp[k][2]; \n        u41k = tmp * utmp[k][3]; \n        u51k = tmp * utmp[k][4]; \n \n        tmp = utmp[k-1][5]; \n \n        u21km1 = tmp * utmp[k-1][1]; \n        u31km1 = tmp * utmp[k-1][2]; \n        u41km1 = tmp * utmp[k-1][3]; \n        u51km1 = tmp * utmp[k-1][4]; \n \n        flux[k][1] = tz3 * ( u21k - u21km1 ); \n        flux[k][2] = tz3 * ( u31k - u31km1 ); \n        flux[k][3] = (4.0/3.0) * tz3 * (u41k-u41km1); \n        flux[k][4] = 0.50 * ( 1.0 - C1*C5 ) \n          * tz3 * ( ( u21k*u21k     + u31k*u31k     + u41k*u41k ) \n                  - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) ) \n          + (1.0/6.0) \n          * tz3 * ( u41k*u41k - u41km1*u41km1 ) \n          + C1 * C5 * tz3 * ( u51k - u51km1 ); \n      } \n \n      for (k = 1; k < nz - 1; k++) { \n        rtmp[k][0] = rtmp[k][0] \n          + dz1 * tz1 * (         utmp[k-1][0] \n                          - 2.0 * utmp[k][0] \n                          +       utmp[k+1][0] ); \n        rtmp[k][1] = rtmp[k][1] \n          + tz3 * C3 * C4 * ( flux[k+1][1] - flux[k][1] ) \n          + dz2 * tz1 * (         utmp[k-1][1] \n                          - 2.0 * utmp[k][1] \n                          +       utmp[k+1][1] ); \n        rtmp[k][2] = rtmp[k][2] \n          + tz3 * C3 * C4 * ( flux[k+1][2] - flux[k][2] ) \n          + dz3 * tz1 * (         utmp[k-1][2] \n                          - 2.0 * utmp[k][2] \n                          +       utmp[k+1][2] ); \n        rtmp[k][3] = rtmp[k][3] \n          + tz3 * C3 * C4 * ( flux[k+1][3] - flux[k][3] ) \n          + dz4 * tz1 * (         utmp[k-1][3] \n                          - 2.0 * utmp[k][3] \n                          +       utmp[k+1][3] ); \n        rtmp[k][4] = rtmp[k][4] \n          + tz3 * C3 * C4 * ( flux[k+1][4] - flux[k][4] ) \n          + dz5 * tz1 * (         utmp[k-1][4] \n                          - 2.0 * utmp[k][4] \n                          +       utmp[k+1][4] ); \n      } \n \n       \n \n       \n \n       \n \n      for (m = 0; m < 5; m++) { \n        rsd[1][j][i][m] = rtmp[1][m] \n          - dssp * ( + 5.0 * utmp[1][m] \n                     - 4.0 * utmp[2][m] \n                     +       utmp[3][m] ); \n        rsd[2][j][i][m] = rtmp[2][m] \n          - dssp * ( - 4.0 * utmp[1][m] \n                     + 6.0 * utmp[2][m] \n                     - 4.0 * utmp[3][m] \n                     +       utmp[4][m] ); \n      } \n \n      for (k = 3; k < nz - 3; k++) { \n        for (m = 0; m < 5; m++) { \n          rsd[k][j][i][m] = rtmp[k][m] \n            - dssp * (         utmp[k-2][m] \n                       - 4.0 * utmp[k-1][m] \n                       + 6.0 * utmp[k][m] \n                       - 4.0 * utmp[k+1][m] \n                       +       utmp[k+2][m] ); \n        } \n      } \n \n      for (m = 0; m < 5; m++) { \n        rsd[nz-3][j][i][m] = rtmp[nz-3][m] \n          - dssp * (         utmp[nz-5][m] \n                     - 4.0 * utmp[nz-4][m] \n                     + 6.0 * utmp[nz-3][m] \n                     - 4.0 * utmp[nz-2][m] ); \n        rsd[nz-2][j][i][m] = rtmp[nz-2][m] \n          - dssp * (         utmp[nz-4][m] \n                     - 4.0 * utmp[nz-3][m] \n                     + 5.0 * utmp[nz-2][m] ); \n      } \n    } \n  }", "pragma": "for ", "hash": "1a3879ebb38091dde3121db8f0163285b5f9ac474d1a2e66389d91976daa5295"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k) { \n        #pragma omp ordered \n        { \n          debug_printf(\"Thread %d: captured affinity = %s\\n\", \n                       omp_get_thread_num(), buf); \n          for (j = 0; j < num_procs; ++j) { \n            debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", \n                         omp_get_thread_num(), j, ids[j], j, ids2[j]); \n            check(ids[j] == ids2[j]); \n          } \n        } \n      }", "pragma": "for ", "hash": "f54dbbb2ed4735d3d4354cfe0860e1173c718338eb538266686e1d931f8f6144"}
{"code": "for (index_l = 0; index_l < pbs->l_size; index_l++) { \n \n      class_call_parallel(bessel_j_for_l(ppr,pbs,index_l), \n\t\t\t  pbs->error_message, \n\t\t\t  pbs->error_message); \n \n#pragma omp flush(abort) \n \n    }", "pragma": "for ", "hash": "021923079e6dc076754fbdb554c5b31090c11bdf34c5e10243ddee1c31e78b98"}
{"code": "for (size_t t = 0; t < nr; ++t) \n        Tester<T, I>::template singlerun<false>(ws, algo);", "pragma": "parallel for ", "hash": "d74597a72a673a4e28bbdec56416c9d7ed299c9c64aa6f491576a842df9104b0"}
{"code": "for (count k = 0; k < matrix.numberOfColumns(); ++k) { \n\t\tVector column = matrix.column(k); \n\t\tresult[k] = (*this) * column; \n\t}", "pragma": "parallel for ", "hash": "3f2c356e3fee010b468da2d71678340cd29688196708d94f64615f44376769ea"}
{"code": "for (i=0; i<coords_data->num_coords; ++i)  \n  { \n    if (eval_amber_forces_single_struct(global_options, parm_data, coords_data, eval[i], i) != SUCCESS) { \n      printf(\"*** ERROR evaluating forces for structure %i\\n\", i); \n      exit(FAILURE); \n    } \n  }", "pragma": "parallel for ", "hash": "394b88b01e10c412649f1e8c6add7d882fd83a1d8d33e1b430f187d195306aa8"}
{"code": "for (int k = 0; k < K; k++) { \n    for (int n = 0; n < TNfp; n++) { \n      const size_t sk = k * TNfp + n; \n \n      const double nx = solver.nx[sk]; \n      const double ny = solver.ny[sk]; \n \n      double qnM, qnP, qvM, qvP; \n      RotateFluxToNormal2d(solver.huM[sk], solver.hvM[sk], nx, ny, &qnM, &qvM); \n      RotateFluxToNormal2d(solver.huP[sk], solver.hvP[sk], nx, ny, &qnP, &qvP); \n      double Fqns, Fqvs; \n      evaluateHLLFunc(solver.hmin, solver.gra, solver.hM[sk], qnM, qvM, \n                      solver.hP[sk], qnP, qvP, Fh + sk, &Fqns, &Fqvs); \n \n      RotateNormalFluxToCoordinate2d(Fqns, Fqvs, nx, ny, Fqx + sk, Fqy + sk); \n    } \n  }", "pragma": "parallel for ", "hash": "22bed57c832818ba1e131871ea5e2bdfee040b0adba69ca5dc77d33ac9b6a4ac"}
{"code": "for (j=0; j<N; j++){ \n      for (k=0; k<N; k++){ \n        c[i][j] += a[i][k] * b[k][j]; \n      } \n    }", "pragma": "parallel for private(k)", "hash": "3bc8aac23fc4cd3dd694ee58d2972afa053689864d6cc82ed7117bc6bce58209"}
{"code": "for(y=0; y<m_pGrid->Get_NY(); y++)\t \n \n\t{ \n\t\tfor(x=0; x<m_pGrid->Get_NX(); x++) \n\t\t{ \n\t\t\tif( !m_pGrid->is_NoData(x, y) ) \n\t\t\t{ \n\t\t\t\tif( m_pGrid->asDouble(x, y) >= z ) \n\t\t\t\t{ \n\t\t\t\t\tif( m_pGrid->is_InGrid(x + 1, y    ) && m_pGrid->asDouble(x + 1, y    ) <  z ) Set_Row(x, y, true); \n\t\t\t\t\tif( m_pGrid->is_InGrid(x    , y + 1) && m_pGrid->asDouble(x    , y + 1) <  z ) Set_Col(x, y, true); \n\t\t\t\t} \n\t\t\t\telse  \n \n\t\t\t\t{ \n\t\t\t\t\tif( m_pGrid->is_InGrid(x + 1, y    ) && m_pGrid->asDouble(x + 1, y    ) >= z ) Set_Row(x, y, true); \n\t\t\t\t\tif( m_pGrid->is_InGrid(x    , y + 1) && m_pGrid->asDouble(x    , y + 1) >= z ) Set_Col(x, y, true); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n \t}", "pragma": "parallel for private( x y)", "hash": "dd28f3da64ad4242b612917b16790d832821e91ed7163b8c649d149d82457b29"}
{"code": "for (is=0; is < ns; is++) { \n\t\tfor (ip=0; ip < ns; ip++) { \n\t\t     \n \n\t\t    stemp[is][ip] = -omega*omega/conjf(f[ip][iw]) \n\t\t\t*rwave[is][pp[ip][1]][pp[ip][0]]; \n\t\t     \n\t\t     \n \n\t\t    rtemp[is][ip] = -omega*omega/conjf(f[ip][iw]) \n\t\t\t*conjf(swave[is][pp[ip][1]][pp[ip][0]]); \n\t\t} \n\t    }", "pragma": "for ", "hash": "9747f9b1df3c72133291ca15945bedbe6f6ca7e7e187bc1bcf7c2f7d8031f0c9"}
{"code": "for (libxsmm_blasint i = 0; i < s; ++i) { \n            const ITYPE *const ai = a + static_cast<size_t>(asize) * helper.shuffle(i), *const bi = b + static_cast<size_t>(bsize) * helper.shuffle(i); \n            OTYPE *const ci = c + static_cast<size_t>(csize) * i; \n            smm_xsmm_specialized<ITYPE,OTYPE>(xmm, ai, bi, ci, \n              LIBXSMM_GEMM_PREFETCH_A(ai + asize), LIBXSMM_GEMM_PREFETCH_B(bi + bsize), \n              LIBXSMM_GEMM_PREFETCH_C(ci + csize)); \n          }", "pragma": "parallel for ", "hash": "14ebda14155b067fcfba39d9999afe0db2ada35543c5a9d7cf8b181710f693c9"}
{"code": "for (i = 0 ; i < dd ; i++) \n\t\t\t{ \n\t\t\t\tacc       += w[i]*ptX[i]; \n\t\t\t}", "pragma": "parallel for reduction(+:acc) private(i)", "hash": "73a002ec543a9d6070a3fdc2b35d38caaeedd9092b835782a7b5f8b2cad6c3d4"}
{"code": "for( OMPInt ix=i; ix < nEl; ++ix) \n\t    if( (*right)[ix] != this->zero) \n\t      (*res)[ix] = (*this)[ix] % (*right)[ix]; \n\t    else \n\t      (*res)[ix] = this->zero;", "pragma": "for ", "hash": "d2e8c3fef88de35f04a8124a2892a5f4ce99d850c738dd1b7949ff8575b2459b"}
{"code": "for (int j = 0; j < ndata; j++) \n    { \n      if (!seq) \n        for (int k = 0; k < 2; k++) \n        { \n          auto inew = idx[min(j+k,ndata-1)]; \n          auto hint = _MM_HINT_T0; \n          auto ptr = (char*)&x[inew-1]; \n          for (int kk = 0; kk < sizeof(data_type)*3; kk += 64) \n            _mm_prefetch(ptr+kk, hint); \n          if (k == 1) \n            for (int kk = 0; kk < sizeof(data_type); kk += 64) \n              _mm_prefetch(((char*)&y[j+k])+kk,_MM_HINT_T0); \n        } \n      auto i = idx[j]; \n      auto im1 = max(i-1,0); \n      auto ip1 = min(i+1,ndata-1); \n      auto const & xim = x[im1]; \n      auto const & xi  = x[i]; \n      auto const & xip = x[ip1]; \n#pragma simd \n      for (size_t k = 0; k < N; k++) \n        y[j].data[k] += -2.0*xi.data[k]+ xip.data[k] + xim.data[k]; \n    }", "pragma": "parallel for ", "hash": "68a714e9b34cc596989f8fc4ce97e85c10cf7454b53ddb19e54903daf481b643"}
{"code": "for (int det=0;det<tod->ndet;det++) { \n          int row=tod->rows[det]; \n          int col=tod->cols[det]; \n          mbUncut *uncut=tod->uncuts[row][col]; \n          for (int region=0;region<uncut->nregions;region++) \n            for (int j=uncut->indexFirst[region];j<uncut->indexLast[region];j++) \n#pragma omp atomic \n\t      map->map[tod->pixelization_saved[det][j]+cur_pol*map->npix]+=tod->data[det][j]*cos(tod->twogamma_saved[det][j]); \n\t}", "pragma": "parallel ", "hash": "74b2c03df154af166ed087775d359630e3f21bde92f3ced6534300a0d811a5ee"}
{"code": "for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 0.0; \n                fjac[i][j][k][0][2] = 1.0; \n                fjac[i][j][k][0][3] = 0.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * u[i][j][k][2]) * tmp2; \n                fjac[i][j][k][1][1] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][1][2] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][1][3] = 0.0; \n                fjac[i][j][k][1][4] = 0.0; \n                fjac[i][j][k][2][0] = - (u[i][j][k][2] * u[i][j][k][2] * tmp2) + 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][2][1] = - c2 * u[i][j][k][1] * tmp1; \n                fjac[i][j][k][2][2] = (2.0 - c2) * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][3] = - c2 * u[i][j][k][3] * tmp1; \n                fjac[i][j][k][2][4] = c2; \n                fjac[i][j][k][3][0] = - (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][3][1] = 0.0; \n                fjac[i][j][k][3][2] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][3][3] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][3][4] = 0.0; \n                fjac[i][j][k][4][0] = (c2 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2 - c1 * u[i][j][k][4] * tmp1) * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][4][1] = - c2 * u[i][j][k][1] * u[i][j][k][2] * tmp2; \n                fjac[i][j][k][4][2] = c1 * u[i][j][k][4] * tmp1 - 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + 3.0 * u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][4][3] = - c2 * (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][4] = c1 * u[i][j][k][2] * tmp1; \n                njac[i][j][k][0][0] = 0.0; \n                njac[i][j][k][0][1] = 0.0; \n                njac[i][j][k][0][2] = 0.0; \n                njac[i][j][k][0][3] = 0.0; \n                njac[i][j][k][0][4] = 0.0; \n                njac[i][j][k][1][0] = - c3c4 * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][1][1] = c3c4 * tmp1; \n                njac[i][j][k][1][2] = 0.0; \n                njac[i][j][k][1][3] = 0.0; \n                njac[i][j][k][1][4] = 0.0; \n                njac[i][j][k][2][0] = - con43 * c3c4 * tmp2 * u[i][j][k][2]; \n                njac[i][j][k][2][1] = 0.0; \n                njac[i][j][k][2][2] = con43 * c3c4 * tmp1; \n                njac[i][j][k][2][3] = 0.0; \n                njac[i][j][k][2][4] = 0.0; \n                njac[i][j][k][3][0] = - c3c4 * tmp2 * u[i][j][k][3]; \n                njac[i][j][k][3][1] = 0.0; \n                njac[i][j][k][3][2] = 0.0; \n                njac[i][j][k][3][3] = c3c4 * tmp1; \n                njac[i][j][k][3][4] = 0.0; \n                njac[i][j][k][4][0] = - (c3c4 - c1345) * tmp3 * (((u[i][j][k][1]) * (u[i][j][k][1]))) - (con43 * c3c4 - c1345) * tmp3 * (((u[i][j][k][2]) * (u[i][j][k][2]))) - (c3c4 - c1345) * tmp3 * (((u[i][j][k][3]) * (u[i][j][k][3]))) - c1345 * tmp2 * u[i][j][k][4]; \n                njac[i][j][k][4][1] = (c3c4 - c1345) * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][4][2] = (con43 * c3c4 - c1345) * tmp2 * u[i][j][k][2]; \n                njac[i][j][k][4][3] = (c3c4 - c1345) * tmp2 * u[i][j][k][3]; \n                njac[i][j][k][4][4] = (c1345) * tmp1; \n            } \n        } \n    }", "pragma": "for ", "hash": "1fd10487903848b863db2cf0a5a3fbe05bb58a7569ce3404b819a0d32b2e6242"}
{"code": "for(int i=0; i<gatindex.size(); i++) localForces[i] = forces[gatindex[i]];", "pragma": "parallel for ", "hash": "cd6e0f3c8609d9463aa393894a70e341135e06c9f59cea36377c30b44ef90630"}
{"code": "for (int site = 0; site < 4; ++site) { \n      for (int uc_row_index = -1; uc_row_index < 2; ++uc_row_index) { \n         for (int uc_col_index = -1; uc_col_index < 2; ++uc_col_index) { \n            (*hole)[current_index].x = r0 * holes_in_uc[site][0] + r0 * 1.5 * uc_col_index; \n            (*hole)[current_index].y = r0 * holes_in_uc[site][1] + r0 * 1.5 * sqrt3 * uc_row_index; \n            (*up)[current_index].x = r0 * ups_in_uc[site][0] + r0 * 1.5 * uc_col_index; \n            (*up)[current_index].y = r0 * ups_in_uc[site][1] + r0 * 1.5 * sqrt3 * uc_row_index; \n            (*down)[current_index].x = r0 * downs_in_uc[site][0] + r0 * 1.5 * uc_col_index; \n            (*down)[current_index].y = r0 * downs_in_uc[site][1] + r0 * 1.5 * sqrt3 * uc_row_index; \n            current_index += 1; \n         } \n      } \n   }", "pragma": "parallel for ", "hash": "01ac3641356a3bb158873402f1026b72836633f8a7747adbb7472eb5b74568d8"}
{"code": "for (int iblock = 0; iblock < n_block; iblock++) { \n\t \n \n\tuIndex i_independent =  MULTIPASS_SIZE * iblock; \n\t \n\tuIndex block_size = MULTIPASS_SIZE; \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\tif (iblock == n_block-1 && n_extra > 0) { \n\t  block_size = n_extra; \n\t} \n\t \n\t \n \n\tfor (uIndex i = 0; i < gradient_multipass_size; i++) { \n\t  gradient_multipass_b[i] = 0.0; \n\t} \n\t \n \n\tfor (uIndex i = 0; i < block_size; i++) { \n\t  gradient_multipass_b[independent_index_[i_independent+i]*MULTIPASS_SIZE+i] = 1.0; \n\t} \n \n\tjacobian_forward_kernel(gradient_multipass_b); \n \n\t \n \n\t \n \n\tif (indep_offset == 1) { \n\t  for (uIndex idep = 0; idep < n_dependent(); idep++) { \n\t    for (uIndex i = 0; i < block_size; i++) { \n\t      jacobian_out[idep*dep_offset+i_independent+i] \n\t\t= gradient_multipass_b[dependent_index_[idep]*MULTIPASS_SIZE+i]; \n\t    } \n\t  } \n\t} \n\telse { \n\t  for (uIndex idep = 0; idep < n_dependent(); idep++) { \n\t    for (uIndex i = 0; i < block_size; i++) { \n\t      jacobian_out[(i_independent+i)*indep_offset+idep*dep_offset] \n\t\t= gradient_multipass_b[dependent_index_[idep]*MULTIPASS_SIZE+i]; \n\t    } \n\t  } \n\t} \n      }", "pragma": "for ", "hash": "0de67528d44c315e5a8e4b9a673d33362485d8900aa560075c8a1439926c393e"}
{"code": "for ( k=1; k<n_descendant; k++ ) { \n                Next[scores[k-1].d] = scores[k].d; \n            }", "pragma": "parallel for ", "hash": "26c86fb3e1abac172ab14ec8020ef1e8acda74e02d688918b2dcbb47f43d0d8a"}
{"code": "for(size_type i = 0; i < paths.size(); i++) \n  { \n    size_type thread = omp_get_thread_num(); \n    if(paths[i].sorted()) \n    { \n         \n \n      temp_nodes[thread].push_back(PathNode(paths[i], labels, temp_labels[thread])); \n    } \n    else \n    { \n      size_type first = from_index.find(paths[i].to); \n      for(size_type j = first; j < paths.size() && paths[j].from == paths[i].to; j++) \n      { \n        temp_nodes[thread].push_back(PathNode(paths[i], paths[j], labels, temp_labels[thread])); \n      } \n    } \n     \n \n  }", "pragma": "parallel for ", "hash": "34f7886623d5581a55f4d1b122f333ccab9835a1a2849a3f68c3fd2664c4fbf3"}
{"code": "for(int i = 0 ; i < (int)m_geometries.size() ; i++) \n        { \n          QSharedPointer<HCGeometry> &linkGeom = m_geometries[i]; \n          TLink &link = m_SWMMComponent->project()->Link[linkGeom->marker()]; \n \n          double value = xsect_getWofY(m_SWMMComponent->project(), &link.xsect, link.newDepth) * UCF(m_SWMMComponent->project(), LENGTH); \n          setValue(currentTimeIndex,i,&value); \n        }", "pragma": "parallel for ", "hash": "c942745787830128f4b0f0655d2732a97e46064414108eb908e460b160810520"}
{"code": "for (p = 0; p < npoints; p++) { \n\t\t \n\t\trx1 = pointx[p]; \n\t\try1 = pointy[p]; \n\t\t \n\t\t \n \n\t\t \n\t\tcart_velocity(rx1, ry1, s0, xsize, ysize, &v1x, &v1y); \n\t\tk1x = 2*h*v1x; \n\t\tk1y = 2*h*v1y; \n\t\tcart_velocity(rx1+0.5*k1x, ry1+0.5*k1y, s2, xsize, ysize, &v2x, &v2y); \n\t\tk2x = 2*h*v2x; \n\t\tk2y = 2*h*v2y; \n\t\tcart_velocity(rx1+0.5*k2x, ry1+0.5*k2y, s2, xsize, ysize, &v3x, &v3y); \n\t\tk3x = 2*h*v3x; \n\t\tk3y = 2*h*v3y; \n\t\tcart_velocity(rx1+k3x, ry1+k3y, s4, xsize, ysize, &v4x, &v4y); \n\t\tk4x = 2*h*v4x; \n\t\tk4y = 2*h*v4y; \n\t\t \n\t\tdx12 = (k1x+k4x+2.0*(k2x+k3x))/6.0; \n\t\tdy12 = (k1y+k4y+2.0*(k2y+k3y))/6.0; \n\t\t \n\t\t \n \n\t\t \n\t\tk1x = h*v1x; \n\t\tk1y = h*v1y; \n\t\tcart_velocity(rx1+0.5*k1x, ry1+0.5*k1y, s1, xsize, ysize, &v2x, &v2y); \n\t\tk2x = h*v2x; \n\t\tk2y = h*v2y; \n\t\tcart_velocity(rx1+0.5*k2x, ry1+0.5*k2y, s1, xsize, ysize, &v3x, &v3y); \n\t\tk3x = h*v3x; \n\t\tk3y = h*v3y; \n\t\tcart_velocity(rx1+k3x, ry1+k3y, s2, xsize, ysize, &v4x, &v4y); \n\t\tk4x = h*v4x; \n\t\tk4y = h*v4y; \n\t\t \n\t\tdx1 = (k1x+k4x+2.0*(k2x+k3x))/6.0; \n\t\tdy1 = (k1y+k4y+2.0*(k2y+k3y))/6.0; \n\t\t \n\t\t \n \n\t\t \n\t\trx2 = rx1 + dx1; \n\t\try2 = ry1 + dy1; \n\t\t \n\t\tcart_velocity(rx2,ry2,s2,xsize,ysize,&v1x,&v1y); \n\t\tk1x = h*v1x; \n\t\tk1y = h*v1y; \n\t\tcart_velocity(rx2+0.5*k1x,ry2+0.5*k1y,s3,xsize,ysize,&v2x,&v2y); \n\t\tk2x = h*v2x; \n\t\tk2y = h*v2y; \n\t\tcart_velocity(rx2+0.5*k2x,ry2+0.5*k2y,s3,xsize,ysize,&v3x,&v3y); \n\t\tk3x = h*v3x; \n\t\tk3y = h*v3y; \n\t\tcart_velocity(rx2+k3x,ry2+k3y,s4,xsize,ysize,&v4x,&v4y); \n\t\tk4x = h*v4x; \n\t\tk4y = h*v4y; \n\t\t \n\t\tdx2 = (k1x+k4x+2.0*(k2x+k3x))/6.0; \n\t\tdy2 = (k1y+k4y+2.0*(k2y+k3y))/6.0; \n\t\t \n\t\t \n \n\t\t \n\t\tex = (dx1+dx2-dx12)/15; \n\t\tey = (dy1+dy2-dy12)/15; \n\t\tesq = ex*ex + ey*ey; \n\t\tif (esq > esqmax) { \n\t\t\tesqmax = esq; \n\t\t} \n\t\t \n\t\t \n \n\t\t \n\t\tdxtotal = dx1 + dx2 + ex;    \n \n\t\tdytotal = dy1 + dy2 + ey;    \n \n\t\tdrsq = dxtotal*dxtotal + dytotal*dytotal; \n\t\tif (drsq > drsqmax) { \n\t\t\tdrsqmax = drsq; \n\t\t} \n\t\t \n\t\trx3 = rx1 + dxtotal; \n\t\try3 = ry1 + dytotal; \n\t\t \n\t\tif (rx3<0) { \n\t\t\trx3 = 0; \n\t\t} \n\t\telse if (rx3>xsize) { \n\t\t\trx3 = xsize; \n\t\t} \n\t\tif (ry3<0) { \n\t\t\try3 = 0; \n\t\t} \n\t\telse if (ry3>ysize) { \n\t\t\try3 = ysize; \n\t\t} \n\t\t \n\t\tpointx[p] = rx3; \n\t\tpointy[p] = ry3; \n\t\t \n\t}", "pragma": "parallel for private(                                  drsq dx1 dx12 dx2 dxtotal dy1 dy12 dy2 dytotal esq ex ey k1x k1y k2x k2y k3x k3y k4x k4y p rx1 rx2 rx3 ry1 ry2 ry3 v1x v1y v2x v2y v3x v3y v4x v4y)", "hash": "6b14971ec1547eac08f9978e7aed0bea1bc2f5c7ed059d3ab67cc3c450ec9c99"}
{"code": "for(size_t iat=0;iat<N;iat++) { \n     \n \n    arma::cx_mat qw=get_charge(iat)*W; \n    for(size_t io=0;io<W.n_cols;io++) { \n      std::complex<double> Qa=std::real(arma::as_scalar(arma::trans(W.col(io))*qw.col(io))); \n      Dinv+=std::real(std::pow(Qa,p)); \n    } \n  }", "pragma": "parallel for reduction(+:dinv) ", "hash": "29b641cfc94f826bdb149c17aacae85b58bd69076c406a3629d3b295b4dec55a"}
{"code": "for(int iit=0; iit<objects.size(); iit++) { \n     Object **it= &(objects[iit]); \n      (*it)->doubleProperty[ckey] = (*f)((*it)->doubleProperty[a1], (*it)->doubleProperty[a2], (*it)->doubleProperty[a3]); \n    }", "pragma": "parallel for ", "hash": "61dd3736ad039ec3951cb5adcb609d7041f1337c298c0101eeb20aef8e08bda6"}
{"code": "for(ix=0; ix<nx; ix++) \n\t\t\tfor(iz=0; iz<nz; iz++) \n\t\t\t\tnxt[ix+pad][iz+pad]=dd[itau][ix][iz];", "pragma": "parallel for private( ix iz)", "hash": "78b14492b1144cd80bec3afa802f95568828d8a883cb2c1e43bd94409fe7f5f5"}
{"code": "for (uint_t i=0; i < n_draws; i++) \n    { \n        arma::mat chol_Sigma = arma::chol(Sigma_draws.slice(i),\"lower\"); \n        arma::mat chol_alpha_pt_var = arma::kron(chol_Sigma,chol_invQa_hat);  \n \n \n        arma::mat beta_draw = arma::reshape( stats::rmvnorm<arma::mat>(alpha_hat, chol_alpha_pt_var, true), K,M); \n \n         \n \n \n        if (only_stationary_draws) \n        { \n            bool loop_flag = true; \n \n            while (loop_flag) \n            { \n                 \n \n                 \n \n                 \n \n                 \n \n \n                 \n \n \n                arma::cx_vec eigvals = arma::eig_gen(companion_form_matrix(beta_draw,c_int,K_adj)); \n \n                if (arma::abs(eigvals).max() < 1.0) { \n                    loop_flag = false;  \n \n                } \n                else { \n                    beta_draw = arma::reshape( stats::rmvnorm<arma::mat>(alpha_hat, chol_alpha_pt_var, true), K,M); \n                } \n            } \n        } \n \n         \n \n \n        beta_draws.slice(i) = beta_draw; \n    }", "pragma": "parallel for ", "hash": "d694c529e1b49551b86ed9170698802dd45b53e492944575910d458a720d99ae"}
{"code": "for (usint ri = 0; ri < ringDim; ri++) { \n        std::vector<DoubleNativeInt> sum(sizeP); \n        for (usint i = 0; i < sizeQ; i++) { \n            const NativeInteger& xi     = m_vectors[i][ri]; \n            const NativeInteger& qi     = m_vectors[i].GetModulus(); \n            NativeInteger xQHatInvModqi = xi.ModMulFastConst(QHatInvModq[i], qi, QHatInvModqPrecon[i]); \n            for (usint j = 0; j < sizeP; j++) { \n                sum[j] += Mul128(xQHatInvModqi.ConvertToInt(), QHatModp[i][j].ConvertToInt()); \n            } \n        } \n \n        for (usint j = 0; j < sizeP; j++) { \n            const NativeInteger& pj = ans.m_vectors[j].GetModulus(); \n            ans.m_vectors[j][ri]    = BarrettUint128ModUint64(sum[j], pj.ConvertToInt(), modpBarrettMu[j]); \n        } \n    }", "pragma": "parallel for ", "hash": "b7ebd9e0bfa9460a209fe8dfcbdf83e8175e7b351cf5337520d8905e538d5790"}
{"code": "for(rocsparse_int i = 0; i < M; ++i) \n    { \n        for(rocsparse_int p = 0; p < ell_width; ++p) \n        { \n            rocsparse_int idx = p * M + i; \n            rocsparse_int col = ell_col_ind[idx] - ell_base; \n \n            if(col >= 0 && col < N) \n            { \n                ++csr_row_ptr[i]; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "40deda8c30855b5fe2d91c81f4c62c16d7c17accc0656c067626236e782184a2"}
{"code": "for( std::size_t ichan = 0; ichan < this->nChannels; ichan++){ \n      this->chanModDims[ichan].ppDim = 0; \n      this->chanModDims[ichan].hhDim = 0; \n      this->chanModDims[ichan].hpDim = 0; \n      this->chanModDims[ichan].phDim = 0; \n    }", "pragma": "for ", "hash": "9d69e634f3c51ca12f934e37c02790f022adae06c793e07a8acab5d42df626d4"}
{"code": "for( int planeNr=0; planeNr < nrOfPlanes; planeNr++ ) \n    { \n        IPLImagePlane* plane = image->plane( planeNr ); \n        IPLImagePlane* newplane = _result->plane( planeNr ); \n \n        for(int x=w2; x<width-w2; x++) \n        { \n             \n \n            notifyProgressEventHandler(100*progress++/maxProgress); \n \n            for(int y=w2; y<height-w2; y++) \n            { \n                ipl_basetype fmin = 1.0; \n                ipl_basetype fmax = 0.0; \n                ipl_basetype average  = 0; \n                ipl_basetype img0 = plane->p( x, y ); \n                for( int ky=-w2; ky <= w2; ky++ ) \n                { \n                    for( int kx=-w2; kx <= w2; kx++ ) \n                    { \n                        ipl_basetype img = plane->p(x+kx, y+ky); \n \n                        if(fmax < img) fmax = img; \n                        if(fmin > img) fmin = img; \n                        average += img; \n                    } \n                } \n                average = average/area; \n                ipl_basetype res = ( (img0 - fmin) > (fmax -img0) ) ? fmax : fmin; \n                if( abs( average - img0 ) <= abs( res -img0 ) ) res = average; \n                newplane->p(x,y) = res; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "d4429c7745af32b8899afdc612ad049920419e1121e18ff8dacefea28bc9dbfe"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tlong k = i*nx;\r \n\t\tb[k] = -(3*a[k]-4*a[k+1]+a[k+2])*dd;\r \n\t\tb[k+nx-1] = (3*a[k+nx-1]-4*a[k+nx-2]+a[k+nx-3])*dd;\r \n\t\tfor(long j=1;j<nx-1;j++)\tb[j+k] = (a[j+k+1]-a[j+k-1])*dd;\r \n\t}", "pragma": "parallel ", "hash": "8782d9bf0c3e858d3152ba74f1d2f530434a72e9825498c3527077a974abc967"}
{"code": "for(long i0=t->id;i0<nn;i0+=mglNumThr)\r \n\t{\r \n\t\tlong i=i0%nx, i1 = same ? i0 : i;\r \n\t\tmreal xu;\r \n\t\tif(i==0)\r \n\t\t{\r \n\t\t\tau = mreal(3)*a[i0]-mreal(4)*a[i0+1]+a[i0+2];\r \n\t\t\txu = 3*x->vthr(i1)-4*x->vthr(i1+1)+x->vthr(i1+2);\r \n\t\t}\r \n\t\telse if(i==nx-1)\r \n\t\t{\r \n\t\t\tau = mreal(3)*a[i0]-mreal(4)*a[i0-1]+a[i0-2];\r \n\t\t\txu = 3*x->vthr(i1)-4*x->vthr(i1-1)+x->vthr(i1-2);\r \n\t\t}\r \n\t\telse\r \n\t\t{\r \n\t\t\tau = a[i0+1]-a[i0-1];\r \n\t\t\txu = x->vthr(i1+1)-x->vthr(i1-1);\r \n\t\t}\r \n\t\tb[i0] = au/xu;\r \n\t}", "pragma": "parallel for private(au)", "hash": "312e1eda649837bb7ee0c8d428f23df64076a742cffd2d1fbbe012e5b0aa7908"}
{"code": "for(int j = 0; j < roi_out->height; j++) \n  { \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      for(int c = 0; c < 3; c++) \n      { \n        out[(size_t)4 * ((size_t)j * roi_out->width + i) + c] \n            = in[(size_t)((size_t)j + roi_out->y) * roi_in->width + i + roi_out->x]; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "6ec1a12866d3c5cb58ae19ee8997271306531215c2781d2a419cc49491aac860"}
{"code": "for (ij = 0; ij < naod*naod; ij++) { \n                i = ij / naod; \n                j = ij % naod; \n                ip = ao_idx[i]; \n                jp = ao_idx[j]; \n                off_in = (i * naod + j) * Ngrids; \n                off_out = (ip * Nao + jp) * Ngrids; \n                for (n = 0; n < Ngrids; n++) { \n                        outR[off_out+n] += pqG_ddR[off_in+n]; \n                        outI[off_out+n] += pqG_ddI[off_in+n]; \n                } \n        }", "pragma": "for ", "hash": "81eea76135632eddc8b4b1221cd9f4529fe2e3acddb417c6f5ada8e9ed218335"}
{"code": "for (i=0; i<ndata; i++){ \n       tmp=0.0; \n       for(j = ptr[i];j<ptr[i+1];j++) \n       { \n        tmp+=val[j]*pvec[col[j]]; \n        apvec[i]=tmp; \n       } \n     }", "pragma": "parallel for reduction(+:tmp) private(  apvec apvec j pvec val)", "hash": "9234bbda06683e419cd0dd79e26348b83d7999bb415e6b730b609d058100eea9"}
{"code": "for(int i=0; i < i_MaxNumThreads; i++) { \n\t\t\tint i_thread_num; \n\t\t\ti_thread_num = omp_get_thread_num(); \n\t\t\ti_thread_num = 0; \n\t\t\tB[i_thread_num] = new vector<int>[i_MaxDegree+1]; \n\t\t}", "pragma": "parallel for ", "hash": "a38e8d4e5ef546a3d26e9c67d8ead203f78169250457646ae291461e782c9b51"}
{"code": "for (idx_t q0 = 0; q0 < n; q0 += bs) { \n             \n \n            size_t q1 = q0 + bs; \n            if (q1 > n) \n                q1 = n; \n \n            hammings( \n                    q_codes + q0 * pq.code_size, \n                    b_codes, \n                    q1 - q0, \n                    nb, \n                    pq.code_size, \n                    distances); \n \n            for (size_t i = 0; i < nb * (q1 - q0); i++) \n                histi[distances[i]]++; \n        }", "pragma": "for ", "hash": "dc792f9286ddbc458e0718b426f6c7934d2069e1bbee927f426bceccf1e6dc5c"}
{"code": "for (i=0; i < 100; ++i) \n    for (j=0; j < 100; ++j) \n      { \n \n \n#pragma omp ordered depend(source) \n#pragma omp ordered depend(source) \n      }", "pragma": "parallel for ", "hash": "507013423dc4cfa78e1e79a1fc97b978730608f705478fc5d63a496bf3932c49"}
{"code": "for (k = 0; k < _nz; k++){ \n\t\t\t\tfor (j = 0; j < _ny; j++){ \n\t\t\t\t\tfor (i = 0; i < _nx; i++){ \n\t\t\t\t\t\tdata3D[nx-1-j][i][k] = pmtmp->data3D[i][j][k]; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for private(i j k)", "hash": "fbacec77783f82847afd876d813c1a9932dc45fbea91d4afde35192a5b6cf557"}
{"code": "for (int i = 0; i < n; i++) { \n        estimate_code( \n                x + i * index.d, \n                ntotal + i, \n                codes.data() + (ntotal + i) * code_size); \n    }", "pragma": "parallel for ", "hash": "884bb0b43285804e44a5cfc0f2a5edcf0dac82b0bc83bfad9d863c8235bf641e"}
{"code": "for(long i0=t->id;i0<t->n;i0+=mglNumThr)\r \n\t{\r \n\t\tmreal i=(i0%nx), j=((i0/nx)%ny), k=(i0/(nx*ny));\r \n\t\tb[i0] = mglSpline3Cs(a,n1,n2,n3, c[0]+i*c[1], c[2]+j*c[3], c[4]+k*c[5]);\r \n\t}", "pragma": "parallel ", "hash": "c4fc35cd37301583695c9a30936f1305ecc4668c75d852993a586d8df8b4148e"}
{"code": "for(unsigned i=0; i<output_permutations.size2(); ++i) \n    { \n        blas_vector permuted_vec(vector.size()); \n        copy(vector.begin(), vector.end(), permuted_vec.begin()); \n        random_shuffle(permuted_vec.begin(), permuted_vec.end()); \n \n        blas_column column(output_permutations, i); \n        for(unsigned j=0; j<column.size(); j++) \n            column(j) = permuted_vec(j); \n    }", "pragma": "parallel for ", "hash": "f0d825fed6f9e7d3dedf17a30dbaa1f0c3cfe3c677dc05848af839bb46145715"}
{"code": "for (i=0; i<m; i++) { \n        wt[i] = 1 + MaxIntWeight * sprng(stream); \n    }", "pragma": "for ", "hash": "08ef46a6001f7b5961e8ab5b7992675278122bd2410c1a8553ab899b6c00c752"}
{"code": "for(int it=0; it<objects.size(); it++) { \n \n \n        double r2=0.; \n\tfor(int i=0; i<ecolnames.size(); i++) { \n\t r2 += pow2_filter((centers[i]-objects[it]->doubleProperty[vkeys[i]])/radii[i]); \n\t if(r2>=1) break; \n\t} \n       \n        if(r2<1) { \n#pragma omp critical \n\t  vc++; \n\t} \n    }", "pragma": "parallel for ", "hash": "d9f787df9a819c4ac2b0c23d030170caa5f4b6d4d043be7b103b073d6cc0893a"}
{"code": "for (j = 0; j < d[1]; j++) { \n        for (ii = 0; ii <= d[0] - fftblock; ii+=fftblock) { \n \n \n\t    for (k = 0; k < d[2]; k++) { \n\t\tfor (i = 0; i < fftblock; i++) { \n\t\t    y0[k][i].real = x[k][j][i+ii].real; \n\t\t    y0[k][i].imag = x[k][j][i+ii].imag; \n\t\t} \n\t    } \n \n \n \n \n \n           cfftz (is, logd[2], \n\t\t  d[2], y0, y1); \n \n \n \n \n           for (k = 0; k < d[2]; k++) { \n\t       for (i = 0; i < fftblock; i++) { \n\t\t   xout[k][j][i+ii].real = y0[k][i].real; \n\t\t   xout[k][j][i+ii].imag = y0[k][i].imag; \n\t       } \n\t   } \n \n \n\t} \n    }", "pragma": "for ", "hash": "78d02fa22dfb3efaed876c46066f38594cc18c48bf76fef3aca41c8578dee02c"}
{"code": "for (i = 0; i < LOOPCOUNT; i++) { \n      while (!omp_test_lock (&lck)) \n      {}; \n      #pragma omp flush \n      nr_threads_in_single++; \n      #pragma omp flush \n      nr_iterations++; \n      nr_threads_in_single--; \n      result = result + nr_threads_in_single; \n      omp_unset_lock (&lck); \n    }", "pragma": "for ", "hash": "d5a68855ffe79d1c0320c28de0b230e6f946d460ebafdbb09e1b176cabec8905"}
{"code": "for (local_int_t i=0; i< localNumberOfRows; i++) { \n    int cur_nnz = nonzerosInRow[i]; \n    for (int j=0; j<cur_nnz; j++) mtxIndL[i][j] = mtxIndG[i][j]; \n  }", "pragma": "parallel for ", "hash": "590a8ca1e17b74e5477de7cde6c181eb41fa256db2a5f5a08f02629cdb0bc7a6"}
{"code": "for (int p = 0; p < num_boundary_tets; p++) { \n            int start = contact_counts[p]; \n            int end = contact_counts[p + 1]; \n            for (int index = start; index < end; index++) { \n                int i = index - start;                                         \n \n                int rigid = neighbor_rigid_tet[p * max_rigid_neighbors + i];   \n \n                real rigid_coh = data_manager->host_data.cohesion_data[rigid]; \n                real rigid_mu = data_manager->host_data.fric_data[rigid].x; \n                real cohesion = data_manager->composition_strategy->CombineCohesion(rigid_coh, coh); \n                real friction = data_manager->composition_strategy->CombineFriction(rigid_mu, mu); \n \n                real3 gam; \n                gam.x = gamma[start_boundary + index]; \n                gam.y = gamma[start_boundary + num_rigid_tet_contacts + index * 2 + 0]; \n                gam.z = gamma[start_boundary + num_rigid_tet_contacts + index * 2 + 1]; \n \n                gam.x += cohesion; \n \n                if (friction == 0) { \n                    gam.x = gam.x < 0 ? 0 : gam.x - cohesion; \n                    gam.y = gam.z = 0; \n \n                    gamma[start_boundary + index] = gam.x; \n                    gamma[start_boundary + num_rigid_tet_contacts + index * 2 + 0] = gam.y; \n                    gamma[start_boundary + num_rigid_tet_contacts + index * 2 + 1] = gam.z; \n                    continue; \n                } \n \n                if (Cone_generalized_rnode(gam.x, gam.y, gam.z, friction)) { \n                } \n \n                gamma[start_boundary + index] = gam.x - cohesion; \n                gamma[start_boundary + num_rigid_tet_contacts + index * 2 + 0] = gam.y; \n                gamma[start_boundary + num_rigid_tet_contacts + index * 2 + 1] = gam.z; \n            } \n        }", "pragma": "parallel for ", "hash": "5a9b471ce5eec64ccea2e792838b4258275fc5dd122586744c12c4b9432e0b81"}
{"code": "for(int i=0; i<m_particleNumber; ++i) \n        { \n            computeSumDijPj(i); \n        }", "pragma": "parallel for ", "hash": "37b13998625c3168d3069d6c810771af29b6fc070d0c9d28ab63e438d0c9aae6"}
{"code": "for (int j=0; j< myLength; j++) localasum += std::abs(from[j]);", "pragma": "for ", "hash": "1a13c93fcb52973389750e3029c4a2be51d5235df5f95eda7be9185b4f02fd72"}
{"code": "for (i = 0; i < 3; i++) { \n\t\tBMIter iter; \n\t\tBMElem *ele; \n \n\t\tBM_ITER_MESH (ele, &iter, em->bm, iter_types[i]) { \n\t\t\tBM_elem_flag_set(ele, BM_ELEM_TAG, BM_elem_flag_test(ele, BM_ELEM_HIDDEN)); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "3fd9c063d5850c8c18093b421f4a34e1c69dc672c83ecf5c1dfc91878329fd56"}
{"code": "for (__int64 i=0; i<nbCandidates; i++) \n\t{ \n\t\tcurrentI = candidates_array[i]; \n\t\tdistIK = my_distance(data, dimension, currentI, pointID); \n\t\tedge = true; \n\t\tfor (__int64 j=0; j<nbCandidates; j++) \n\t\t{ \n\t\t\tcurrentJ = candidates_array[j]; \n\t\t\tdistIJ = my_distance(data, dimension, currentI, currentJ); \n\t\t\tdistJK = my_distance(data, dimension, currentJ, pointID); \n\t\t\tif ( distIJ < distIK && distJK < distIK  ) \n\t\t\t{ \n\t\t\t\tedge = false; \n\t\t\t\tbreak; \n\t\t\t} \n\t\t} \n\t\tif (edge) \n\t\t{ \n\t\t\t \n \n   #pragma omp critical(add_neighbor) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tresultsCPU[currentI].insert(std::pair<__int64, float>(pointID,distIK)); \n\t\t\t\tresultsCPU[pointID].insert(std::pair<__int64, float>(currentI,distIK)); \n\t\t\t\t \n \n\t\t\t\tif (farthest[currentI] == -1) \n\t\t\t\t\tfarthest[currentI] = pointID; \n\t\t\t\telse if (distIK > my_distance(data, dimension, currentI, farthest[currentI])) \n\t\t\t\t\tfarthest[currentI] = pointID; \n\t\t\t\t \n \n\t\t\t\tif (farthest[pointID] == -1) \n\t\t\t\t\tfarthest[pointID] = currentI; \n\t\t\t\telse if (distIK > my_distance(data, dimension, pointID, farthest[pointID])) \n\t\t\t\t\t\tfarthest[pointID] = currentI; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(currenti currentj distij distik distjk edge)", "hash": "d583cbfb5ccb3c25e7d5da489a926456e7454b27f34f73247dae99d9cf6c7903"}
{"code": "for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1-4,6),ceild(8*t2-Nz-11,24));t3<=min(floord(4*Nt+Ny-9,24),floord(4*t1+Ny-1,24));t3++) { \n        for (t4=max(max(ceild(t1-254,256),ceild(8*t2-Nz-1011,1024)),ceild(24*t3-Ny-1011,1024));t4<=min(min(floord(4*Nt+Nx-9,1024),floord(4*t1+Nx-1,1024)),floord(24*t3+Nx+11,1024));t4++) { \n          for (t5=max(max(max(max(0,ceild(8*t2-Nz+5,4)),ceild(24*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4)),t1);t5<=min(min(min(Nt-1,t1+1),6*t3+4),256*t4+254);t5++) { \n            for (t6=max(max(8*t2,4*t5+4),-8*t1+8*t2+8*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(24*t3,4*t5+4);t7<=min(24*t3+23,4*t5+Ny-5);t7++) { \n                lbv=max(1024*t4,4*t5+4); \n                ubv=min(1024*t4+1023,4*t5+Nx-5); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 1][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 1]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 1]))) + (coef2 * (((((A[ t5 % 2][ (-4*t5+t6) - 2][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 2][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 2][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 2][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 2]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 2]))) + (coef3 * (((((A[ t5 % 2][ (-4*t5+t6) - 3][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 3][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 3][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 3][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 3]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 3]))) + (coef4 * (((((A[ t5 % 2][ (-4*t5+t6) - 4][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 4][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 4][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 4][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 4]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 4])))));; \n                } \n              } \n            } \n          } \n        } \n      } \n    }", "pragma": "parallel for private(lbv t3 t4 t5 t6 t7 t8 ubv)", "hash": "8bee5d62b8af5ef1f0d786969ae757a80d1d4373362a3edfdd96b5b2d1573136"}
{"code": "for (int i = 0; i < numImages; ++i) { \n            if (!error) {  \n \n                QString name = options.fileNames[i]; \n                #pragma omp critical \n                progress.advance(p += step, \"Loading %1\", name.toLocal8Bit().constData()); \n                unique_ptr<RawParameters> params(new RawParameters(name)); \n                Image image = loadRawImage(*params); \n                #pragma omp critical \n                if (!error) {  \n \n                    if (!image.good()) { \n                        error = 1; \n                        failedImage = i; \n                    } else if (stack.size() && !params->isSameFormat(*rawParameters.front())) { \n                        error = 2; \n                        failedImage = i; \n                    } else { \n                        int pos = stack.addImage(std::move(image)); \n                        rawParameters.emplace_back(std::move(params)); \n                        for (int j = rawParameters.size() - 1; j > pos; --j) \n                            rawParameters[j - 1].swap(rawParameters[j]); \n                    } \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "5d35d82326f75532f3a8e9534923d329e4180a2b95d4650cbe9b2e0a757a8bdd"}
{"code": "for(long j=0;j<z->GetNz();j++)\tfor(long i=0;i<v->GetNx();i++) \n\t\t{ \n\t\t\tif(gr->Stop)\tcontinue; \n\t\t\tmreal v0 = v->v(i), z0 = fixed ? gr->Min.z : v0; \n\t\t\tif(z->GetNz()>1) \n\t\t\t\tz0 = gr->Min.z+(gr->Max.z-gr->Min.z)*mreal(j)/(z->GetNz()-1); \n\t\t\tzz.Fill(z0,z0); \n\t\t\tmgl_cont_gen(gr,v0,z,x,y,&zz,gr->GetC(s,v0),text,j); \n\t\t}", "pragma": "for ", "hash": "319a70381238c06fb54649e21aaa24e21e4875522fd7cb919c4e1209010f05de"}
{"code": "for(int i=0; i<objects.size(); i++) { \n      double phi=objects[i]->doubleProperty[phikey]; \n      double c=cos(2.*phi); double s=sin(2.*phi); \n      double g1=objects[i]->doubleProperty[g1key]; \n      double g2=objects[i]->doubleProperty[g2key]; \n \n      objects[i]->doubleProperty[gtkey]=-g1*c-g2*s; \n      objects[i]->doubleProperty[gxkey]=-g1*s+g2*c; \n \n \n \n \n \n \n    }", "pragma": "parallel for ", "hash": "c5616a099eb109618adacc88eca22a475d19a1e3801e20c4df0d2b88345558f9"}
{"code": "for (i=0; i<scale; i++) \n            for (j=0; j<scale; j++) \n                c[i][j]= 0;", "pragma": "for ", "hash": "e216c3d4cf2a70adc7f1a7d9fc437fa6ba8a7fc3928361879ed373f5ef0503d0"}
{"code": "for (i = 1; i <= grid_points[0]-2; i++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (k = 0; k <= grid_points[2]-3; k++) { \n\tk1 = k  + 1; \n\tk2 = k  + 2; \n\tfac1               = 1./lhs[n+2][i][j][k]; \n\tlhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k]; \n\tlhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k]; \n\tfor (m = 0; m < 3; m++) { \n\t  rhs[m][i][j][k] = fac1*rhs[m][i][j][k]; \n\t} \n\tlhs[n+2][i][j][k1] = lhs[n+2][i][j][k1] - \n\t  lhs[n+1][i][j][k1]*lhs[n+3][i][j][k]; \n\tlhs[n+3][i][j][k1] = lhs[n+3][i][j][k1] - \n\t  lhs[n+1][i][j][k1]*lhs[n+4][i][j][k]; \n\tfor (m = 0; m < 3; m++) { \n\t  rhs[m][i][j][k1] = rhs[m][i][j][k1] - \n\t    lhs[n+1][i][j][k1]*rhs[m][i][j][k]; \n\t} \n\tlhs[n+1][i][j][k2] = lhs[n+1][i][j][k2] - \n\t  lhs[n+0][i][j][k2]*lhs[n+3][i][j][k]; \n\tlhs[n+2][i][j][k2] = lhs[n+2][i][j][k2] - \n\t  lhs[n+0][i][j][k2]*lhs[n+4][i][j][k]; \n\tfor (m = 0; m < 3; m++) { \n\t  rhs[m][i][j][k2] = rhs[m][i][j][k2] - \n\t    lhs[n+0][i][j][k2]*rhs[m][i][j][k]; \n\t} \n      } \n    } \n  }", "pragma": "for ", "hash": "0ddc1987e695f8842010728c8b9dba8dc03ce59d6f7fd1b15686a0773c03384d"}
{"code": "for(id=0;id<par->pIntensity;id++){ \n#pragma omp atomic \n          ++nVerticesDone; \n \n          if (threadI == 0){  \n \n            if(!silent) progressbar((double)nVerticesDone/par->pIntensity,10); \n          } \n          if(g[id].dens[0] > 0 && g[id].t[0] > 0){ \n            photon(id,g,m,0,threadRans[threadI],par,matrix,mp,halfFirstDs); \n            for(ispec=0;ispec<par->nSpecies;ispec++) stateq(id,g,m,ispec,par,mp,halfFirstDs); \n          } \n          if (threadI == 0){  \n \n            if(!silent) warning(\"\"); \n          } \n        }", "pragma": "for ", "hash": "2d81406eafde6891f0dfd0318904e30d616f7418ef844c6f447f36a3a06430c6"}
{"code": "for(int j=0; j<roi_out->height; j++) \n    { \n \n      float *in  = (float*)ivoid + ch*roi_in->width *j; \n      float *out = (float*)ovoid + ch*roi_out->width*j; \n      const __m128 m0 = _mm_set_ps(0.0f,d->cmatrix[6],d->cmatrix[3],d->cmatrix[0]); \n      const __m128 m1 = _mm_set_ps(0.0f,d->cmatrix[7],d->cmatrix[4],d->cmatrix[1]); \n      const __m128 m2 = _mm_set_ps(0.0f,d->cmatrix[8],d->cmatrix[5],d->cmatrix[2]); \n   \n      for(int i=0; i<roi_out->width; i++, in+=ch, out+=ch ) \n      { \n        const __m128 xyz = dt_Lab_to_XYZ_SSE(_mm_load_ps(in)); \n        const __m128 t = _mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m1,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(1,1,1,1))),_mm_mul_ps(m2,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(2,2,2,2))))); \n \n        _mm_stream_ps(out,t); \n      } \n    }", "pragma": "parallel for ", "hash": "fa29f3c465e2e307e112d48c911ca31e9b539782921b08224c20ff4bbf6b7d52"}
{"code": "for(c = 0; c < FIDUCIAL_STEREO_NUM_CAMERAS; c++) \n  { \n     \n \n    err[c] = fiducial_detector_match(self->fiducial_detector[c], image_data[c], cols[c], rows[c], channels[c], initial_fd_pose[c], &score[c]); \n  }", "pragma": "parallel for ", "hash": "dde87048dc916ad7eee9cfd6e8fe07a9f4163dd04da10f42045827b7514c4cd5"}
{"code": "for (int r = 0; r < numTads; r++) { \n \n                auto offset = tadOffsets[r]; \n                auto offsetZ = tadOffsetsZ[r]; \n                T scalar = scalars[r]; \n \n                if (tadEWS >= 1 && zEWS >= 1) { \n                    T *oZ = z + offsetZ; \n                    T *oX = x + offset; \n \n                    if (tadEWS == 1 && zEWS == 1) { \n \n#pragma omp simd \n                        for (int f = 0; f < tadLength; f++) { \n                            oZ[f] = OpType::op(oX[f], scalar, extraParams); \n                        } \n                    } else { \n \n \n \n#pragma omp simd \n                        for (int f = 0; f < tadLength; f++) { \n                            oZ[f * zEWS] = OpType::op(oX[f * tadEWS], scalar, extraParams); \n                        } \n                    } \n \n                } else { \n                     \n \n                    printf(\"Super-bad loop visited. Shouldn't ever happen\\n\"); \n                } \n            }", "pragma": "parallel for ", "hash": "426a864b4c7bded7120fb1661fe3925af0a36bd99178fe78a962ccb8cef2c268"}
{"code": "for (int i = myStart; i < myEnd; i++)\r \n{\r \n    for (j = 0; j < i; j++)\r \n        {\r \n            pythagorean = 0;\r \n            for(k = 0; k < DIM; k++)\r \n            {\r \n                vectors[k] = determineVectorFlat(position[i][k], position[j][k]);\r \n                 \n \n                pythagorean += vectors[k]*vectors[k];\r \n            }\r \n\r \n            if (pythagorean < 16.0)\r \n            {\r \n                 \n \n                sigma = 1.0; \n \n                sigmaPow6 = sigma*sigma; \n \n                sigmaPow6 = sigmaPow6*sigmaPow6*sigmaPow6;\r \n                sigmaPow12 = sigmaPow6*sigmaPow6;\r \n                invPy = 1.0 / pythagorean;\r \n                invPyPow3 = invPy*invPy*invPy;\r \n                invPyPow4 = invPyPow3*invPy;\r \n                invPyPow6 = invPyPow3*invPyPow3;\r \n                pe += 2 * ((sigmaPow12 * invPyPow6) - (sigmaPow6 * invPyPow3));\r \n                forceCoeff = (sigmaPow6 * invPyPow4) * ((48.0 * sigmaPow6 * invPyPow3) - 24.0);\r \n\r \n                for(k = 0; k < DIM; k++)\r \n                {\r \n                    acceleration[i][k] += vectors[k]*forceCoeff;\r \n                }\r \n            }\r \n        }\r \n        for (j = i + 1; j < totalParticles; j++)\r \n        {\r \n            pythagorean = 0;\r \n            for(k = 0; k < DIM; k++)\r \n            {\r \n                vectors[k] = determineVectorFlat(position[i][k], position[j][k]);\r \n                 \n \n                pythagorean += vectors[k]*vectors[k];\r \n            }\r \n\r \n            if (pythagorean < 16.0)\r \n            {\r \n                 \n \n                sigma = 1.0; \n \n                sigmaPow6 = sigma*sigma; \n \n                sigmaPow6 = sigmaPow6*sigmaPow6*sigmaPow6;\r \n                sigmaPow12 = sigmaPow6*sigmaPow6;\r \n                invPy = 1.0 / pythagorean;\r \n                invPyPow3 = invPy*invPy*invPy;\r \n                invPyPow4 = invPyPow3*invPy;\r \n                invPyPow6 = invPyPow3*invPyPow3;\r \n                pe += 2 * ((sigmaPow12 * invPyPow6) - (sigmaPow6 * invPyPow3));\r \n                forceCoeff = (sigmaPow6 * invPyPow4) * ((48.0 * sigmaPow6 * invPyPow3) - 24.0);\r \n\r \n                for(k = 0; k < DIM; k++)\r \n                {\r \n                    acceleration[i][k] += vectors[k]*forceCoeff;\r \n                }\r \n            }\r \n        }\r \n    }", "pragma": "parallel for reduction(+:pe) private(                forcecoeff invpy invpypow3 invpypow4 invpypow6 j k pythagorean sigma sigmapow12 sigmapow6 vectors)", "hash": "13596442752b2f1103ab23c8c13c70cbde56db2a6d3caa4c0d600a48cc633811"}
{"code": "for(int k=0;k<K->a;++k) { \n    for(int z=0;z<K->b;++z) { \n      int b=z*(K->c*K->d); \n      for(int i=0;i<K->c;++i) \n\tfor(int j=0;j<K->d;++j,++b) \n\t  Kn->ptr2(k,b)=K->ptr[k]->ptr[z]->ptr2(i,j); \n    } \n  }", "pragma": "parallel for ", "hash": "360cb8d7177cc86f593026bce1f5ecfb90e61eeee0b7d55f1d596c29b0953877"}
{"code": "for(int j = 0; j < height; j += tile_width) \n  { \n    for(int i = 0; i < width; i += tile_width) \n    { \n      tile target = { i, min_i(i + tile_width, width), j, min_i(j + tile_width, height) }; \n      guided_filter_tiling(img_in, c_trans_map, c_trans_map_filtered, target, w2, eps); \n    } \n  }", "pragma": "parallel for ", "hash": "deea6c25e458ac023d00527eb1e579c366a0c3cb6218427c23a7ac60e7653b15"}
{"code": "for(i = 0; i < 256; ++i)\r \n\t\t\t{\r \n\t\t\t\tprevSum = 0; \r \n\t\t\t\tfor(n = 0; n < n_threads; n++)\r \n\t\t\t\t{\r \n\t\t\t\t\ttemp = ByteCounter[n][i];\r \n\t\t\t\t\tByteCounter[n][i] = prevSum;\r \n\t\t\t\t\tprevSum += temp; \r \n\t\t\t\t}\r \n\t\t\t\tglobalHisto[i] = prevSum;\r \n\t\t\t}", "pragma": "for ", "hash": "a8e729a7679efda576594e0c57ffe2496520e836b51d5a394ec432d9a5d04284"}
{"code": "for (int i = 0; i < 10; i++) { \n\t\t\t\t\tcapture_exceptions { \n\t\t\t\t\t\tif (i % 2 == 0) \n\t\t\t\t\t\t\tthrowf(Value, \"oops 9 in loop %d, thread %lu\", i, pthread_self()); \n\t\t\t\t\t\tprintf(\"loop %d was OK in thread %lu\\n\", i, pthread_self()); \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "parallel for ", "hash": "63ca1694352eba7c01ea435c2a59afa396023444e3b350fb2a0a24853a70780e"}
{"code": "for(int z=0;z<gK->b;++z) { \n      int q=z*(gK->c*gK->d); \n      for(int i=0;i<gK->c;++i) \n\tfor(int j=0;j<gK->d;++j,q++) { \n\t  int p=0; \n\t  for(int b=0;b<D->a;++b) { \n\t    for(int i2=0;i2<D->c;++i2) \n\t      for(int j2=0;j2<D->d;++j2,p++) { \n\t\tint si=((i2*stride)-kr2)+i; \n\t\tint sj=((j2*stride)-kc2)+j; \n\t\tif ((si<0)||(si>=inr)||(sj<0)||(sj>=inc)) I->ptr2(q,p)=0.0; \n\t\telse I->ptr2(q,p)=N->ptr[b]->ptr[z]->ptr2(si,sj); \n\t      } \n\t  } \n\t} \n    }", "pragma": "parallel for ", "hash": "e579b3595e55f283caa69a8b91e4b1eb64406abd5908b03db54f06807dfacfc9"}
{"code": "for (int pair = 0; pair < num_pairs; pair++) { \n             \n \n            ModelPair cur_pair; \n            cur_pair.part1 = distID[pair].first; \n            cur_pair.part2 = distID[pair].second; \n            ASSERT(cur_pair.part1 < cur_pair.part2); \n            cur_pair.merged_set.insert(gene_sets[cur_pair.part1].begin(), gene_sets[cur_pair.part1].end()); \n            cur_pair.merged_set.insert(gene_sets[cur_pair.part2].begin(), gene_sets[cur_pair.part2].end()); \n            for (auto it = cur_pair.merged_set.begin(); it != cur_pair.merged_set.end(); it++) { \n                if (it != cur_pair.merged_set.begin()) \n                    cur_pair.set_name += \"+\"; \n                cur_pair.set_name += in_tree->at(*it)->aln->name; \n            } \n            ModelInfo best_model; \n            bool done_before = false; \n#pragma omp critical \n            { \n                 \n \n                model_info.startStruct(cur_pair.set_name); \n                if (model_info.getBestModel(best_model.name)) { \n                    best_model.restoreCheckpoint(&model_info); \n                    done_before = true; \n                } \n                model_info.endStruct(); \n            } \n            ModelCheckpoint part_model_info; \n            if (!done_before) { \n                Alignment *aln = super_aln->concatenateAlignments(cur_pair.merged_set); \n                PhyloTree *tree = in_tree->extractSubtree(cur_pair.merged_set); \n                tree->setAlignment(aln); \n                extractModelInfo(cur_pair.set_name, model_info, part_model_info); \n                tree->num_precision = in_tree->num_precision; \n                tree->setParams(&params); \n                tree->sse = params.SSE; \n                tree->optimize_by_newton = params.optimize_by_newton; \n                tree->num_threads = params.model_test_and_tree ? num_threads : 1; \n                 \n \n                { \n                    tree->setCheckpoint(&part_model_info); \n                     \n \n                    tree->restoreCheckpoint(); \n                    tree->saveCheckpoint(); \n                } \n                best_model.name = testModel(params, tree, part_model_info, models_block, \n                    params.model_test_and_tree ? num_threads : 1, params.partition_type, cur_pair.set_name); \n                best_model.restoreCheckpoint(&part_model_info); \n                 \n \n                delete tree; \n                delete aln; \n            } \n            cur_pair.logl = best_model.logl; \n            cur_pair.df = best_model.df; \n            cur_pair.model_name = best_model.name; \n            cur_pair.tree_len = best_model.tree_len; \n            double lhnew = lhsum - lhvec[cur_pair.part1] - lhvec[cur_pair.part2] + best_model.logl; \n            int dfnew = dfsum - dfvec[cur_pair.part1] - dfvec[cur_pair.part2] + best_model.df; \n            cur_pair.score = computeInformationScore(lhnew, dfnew, ssize, params.model_test_criterion); \n#pragma omp critical \n\t\t\t{ \n\t\t\t\tif (!done_before) { \n\t\t\t\t\treplaceModelInfo(cur_pair.set_name, model_info, part_model_info); \n                    model_info.dump(); \n                    num_model++; \n\t\t\t\t\tcout.width(4); \n\t\t\t\t\tcout << right << num_model << \" \"; \n\t\t\t\t\tcout.width(12); \n\t\t\t\t\tcout << left << best_model.name << \" \"; \n\t\t\t\t\tcout.width(11); \n\t\t\t\t\tcout << cur_pair.score << \" \" << cur_pair.set_name; \n                    if (num_model >= 10) { \n                        double remain_time = max(total_num_model-num_model, (int64_t)0)*(getRealTime()-start_time)/num_model; \n                        cout << \"\\t\" << convert_time(getRealTime()-start_time) << \" (\"  \n                            << convert_time(remain_time) << \" left)\"; \n                    } \n                    cout << endl; \n\t\t\t\t} \n                if (cur_pair.score < inf_score) \n                    better_pairs.insertPair(cur_pair); \n\t\t\t} \n \n        }", "pragma": "parallel for private(i)", "hash": "87095b88122a2c37642fb88e540a5a3cbca5d5f1466327212a66d93400e07421"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t(*this)[i] = (*this)[i] | (*right)[i];", "pragma": "for ", "hash": "a44ffdee6ed59b187e0d58d12d6075cc8775664b2aeb304ca556f6c28216002d"}
{"code": "for (uint16_t Row=0; Row<Image->m_Height; Row++) { \n    Temp = Row*Width; \n    for (uint16_t Col=0; Col<Image->m_Width; Col++) { \n        Image->m_Image[Temp+Col][0] = CImage(Col,Row); \n    } \n  }", "pragma": "parallel for private(temp)", "hash": "7aff296cae7bc5a73ddffc11e2579a2f3c40ab04efbd26cf7f94d8f041b4c59f"}
{"code": "for(unsigned i=0; i<narg; ++i) { \n      const double dev = scale*mean[i]-parameters[i]+offset; \n      const double a2 = 0.5*dev*dev + ss2; \n      if(sm2 > 0.0) { \n        ene += std::log(2.0*a2/(1.0-std::exp(-a2/sm2))); \n      } \n      else { \n        ene += std::log(2.0*a2); \n      } \n    }", "pragma": "for reduction( + : ene) ", "hash": "c17c367b08d2a8d90888179f1696cd897ad8fb63fa41ddcc77f5584660a30a7b"}
{"code": "for(    il=0;il<2*nl+1;il++) { \n\t    for(ic=0;ic<4;     ic++) { \n\t\tj1=k1[ia][il][ic]; h1 = SF_ABS(j1); \n\t\tj2=k2[ia][il][ic]; h2 = SF_ABS(j2); \n \n\t\tfor(    i2=h2; i2<n2-h2; i2++) { \n\t\t    for(i1=h1; i1<n1-h1; i1++) { \n\t\t\tss[i2][i1] += ww[ia][il][ic] * dd[i2+j2][i1+j1]; \n\t\t    }  \n \n\t\t}      \n \n\t\t \n\t    }          \n \n\t}", "pragma": "parallel for private(h1 h2 i1 i2 ic il j1 j2)", "hash": "79dd4aaccc12996fd8d40c0b8e945723b36d1d437218b0c628e0245ee83234dc"}
{"code": "for(    ix=0; ix<nx2; ix++) { \n\t    for(iz=0; iz<nz2; iz++) { \n \n\t\t \n \n\t\tup[ix][iz] = 2*uo[ix][iz] -  \n\t\t               um[ix][iz] +  \n\t\t               ud[ix][iz] * vp[ix][iz] * dt2;  \n\t    } \n\t}", "pragma": "parallel for private(ix iz)", "hash": "e9942184536fe4a0b2b497320ad996382d544e3e8f9e7db7cf31992efff0265c"}
{"code": "for(size_t k = 0; k < (size_t)processed_width * processed_height; k++) \n        { \n          uint8_t tmp = buf8[4 * k + 0]; \n          buf8[4 * k + 0] = buf8[4 * k + 2]; \n          buf8[4 * k + 2] = tmp; \n        }", "pragma": "parallel for ", "hash": "1029a5cd7ec20e12633edb71665ce83c7c3cb644b80658c88d23d136a6b410f5"}
{"code": "for (miel = 0; miel < nelt; miel++) { \n    iel = mt_to_id_old[miel]; \n    if (ich[iel] == 4) { \n      ntemp = (front[miel]-1)*7; \n      mielnew = miel+ntemp; \n    } else { \n      ntemp = front[miel]*7; \n      mielnew = miel+ntemp; \n    } \n \n    mt_to_id[mielnew] = iel; \n    ref_front_id[iel] = nelt+ntemp; \n  }", "pragma": "parallel for private(iel miel mielnew ntemp)", "hash": "f2245344affcc6f8c6bc75c4bce85c55a673c4610ae1585e38f2cc93fdc8a597"}
{"code": "for (size_t id = queryFrom; id < queryFrom + querySize; id++) { \n            progress.updateProgress(); \n             \n \n            char *seqData = qdbr->getData(id, thread_idx); \n            unsigned int qKey = qdbr->getDbKey(id); \n            seq.mapSequence(id, qKey, seqData, qdbr->getSeqLen(id)); \n            size_t targetSeqId = UINT_MAX; \n            if (sameQTDB || includeIdentical) { \n                targetSeqId = tdbr->getId(seq.getDbKey()); \n                 \n \n                if (targetSeqId >= dbFrom && targetSeqId < (dbFrom + dbSize) && targetSeqId != UINT_MAX) { \n                    targetSeqId = targetSeqId - dbFrom; \n                    if(targetSeqId > tdbr->getSize()){ \n                        Debug(Debug::ERROR) << \"targetSeqId: \" << targetSeqId << \" > target database size: \"  << tdbr->getSize() <<  \"\\n\"; \n                        EXIT(EXIT_FAILURE); \n                    } \n                }else{ \n                    targetSeqId = UINT_MAX; \n                } \n            } \n             \n \n            if (taxonomyHook != NULL) { \n                taxonomyHook->setDbFrom(dbFrom); \n            } \n            std::pair<hit_t *, size_t> prefResults = matcher.matchQuery(&seq, targetSeqId, targetSeqType==Parameters::DBTYPE_NUCLEOTIDES); \n            size_t resultSize = prefResults.second; \n            const float queryLength = static_cast<float>(qdbr->getSeqLen(id)); \n            for (size_t i = 0; i < resultSize; i++) { \n                hit_t *res = prefResults.first + i; \n                 \n \n                size_t targetSeqId1 = res->seqId + dbFrom; \n                 \n \n                res->seqId = tdbr->getDbKey(targetSeqId1); \n                if (UNLIKELY(targetSeqId1 >= tdbr->getSize())) { \n                    Debug(Debug::WARNING) << \"Wrong prefiltering result for query: \" << qdbr->getDbKey(id) << \" -> \" << targetSeqId1 << \"\\t\" << res->prefScore << \"\\n\"; \n                } \n \n                 \n \n                if (covThr > 0.0 && (covMode == Parameters::COV_MODE_BIDIRECTIONAL \n                                               || covMode == Parameters::COV_MODE_QUERY \n                                               || covMode == Parameters::COV_MODE_LENGTH_SHORTER )) { \n                    const float targetLength = static_cast<float>(tdbr->getSeqLen(targetSeqId1)); \n                    if (Util::canBeCovered(covThr, covMode, queryLength, targetLength) == false) { \n                        continue; \n                    } \n                } \n \n                 \n \n                int len = QueryMatcher::prefilterHitToBuffer(buffer, *res); \n                result.append(buffer, len); \n            } \n            tmpDbw.writeData(result.c_str(), result.length(), qKey, thread_idx); \n            result.clear(); \n \n             \n \n            if (resultSize != 0) { \n                notEmpty[id - queryFrom] = 1; \n            } \n \n            if (Debug::debugLevel >= Debug::INFO) { \n                kmersPerPos += matcher.getStatistics()->kmersPerPos; \n                dbMatches += matcher.getStatistics()->dbMatches; \n                doubleMatches += matcher.getStatistics()->doubleMatches; \n                querySeqLenSum += seq.L; \n                diagonalOverflow += matcher.getStatistics()->diagonalOverflow; \n                trancatedCounter += matcher.getStatistics()->truncated; \n                resSize += resultSize; \n                realResSize += std::min(resultSize, maxResListLen); \n                reslens[thread_idx]->emplace_back(resultSize); \n            } \n        }", "pragma": "for reduction(      +: dbmatches diagonaloverflow doublematches kmersperpos queryseqlensum ressize trancatedcounter) ", "hash": "c2e259989118998f1d63b62fc9bb63caa6f9523e1862c91b30523ae932b313c3"}
{"code": "for (integer i=0; i < N; i++) \n    zd[i] = xd[i] + b;", "pragma": "parallel for ", "hash": "6d5cd130e51fbeaedef0fd66e070e08180531659ec93600be4ded50e5c1625fb"}
{"code": "for (unsigned int i = 0; i < count - 1; i++) {\r \n\r \n\t\t\t\t \n \n\t\t\t\tconst cv::Mat &imageNear = greyscales[i];\r \n\t\t\t\tconst cv::Mat &imageFar = greyscales[i + 1];\r \n\r \n\t\t\t\t \n \n\t\t\t\tunsigned int searchStart = 0;\r \n\t\t\t\tunsigned int searchEnd = 3;\r \n\r \n\t\t\t\t \n \n\t\t\t\tunsigned int matchIndex = 0;\r \n\t\t\t\tunsigned int matchStep = 0;\r \n\t\t\t\tunsigned int matchWidth = outputWidth;\r \n\t\t\t\tunsigned int matchHeight = outputHeight;\r \n\t\t\t\tunsigned int matchX = 0;\r \n\t\t\t\tunsigned int matchY = 0;\r \n\t\t\t\tdouble matchScale = 1;\r \n\r \n\t\t\t\t \n \n\t\t\t\tQHash<unsigned int, double> cache;\r \n\r \n\t\t\t\t \n \n\t\t\t\tfor (unsigned int power = 4; power >= 1; power--) {\r \n\r \n\t\t\t\t\t \n \n\t\t\t\t\tconst auto stepPixels = (unsigned int) std::pow(2, power);\r \n\t\t\t\t\tconst auto stepScaled = (double) stepPixels / outputWidth;\r \n\r \n\t\t\t\t\t \n \n\t\t\t\t\tdouble prevError = 1;\r \n\r \n\t\t\t\t\t \n \n\t\t\t\t\tfor (unsigned int n = searchStart; n < searchEnd; n++) {\r \n\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tconst unsigned int step = stepPixels * n;\r \n\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tconst double scale = 1.0 - (stepScaled * n);\r \n\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tconst auto regionWidth = (unsigned int) lround(outputWidth * scale);\r \n\t\t\t\t\t\tconst auto regionHeight = (unsigned int) lround(outputHeight * scale);\r \n\t\t\t\t\t\tconst auto regionX = (unsigned int) lround((outputWidth - regionWidth) / 2.0);\r \n\t\t\t\t\t\tconst auto regionY = (unsigned int) lround((outputHeight - regionHeight) / 2.0);\r \n\t\t\t\t\t\tconst cv::Rect regionRect(regionX, regionY, regionWidth, regionHeight);\r \n\t\t\t\t\t\tconst cv::Size regionSize(regionWidth, regionHeight);\r \n\r \n\t\t\t\t\t\tif (!cache.contains(step)) {\r \n\r \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tcv::Mat region(imageFar, regionRect);\r \n\r \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tcv::Mat temp;\r \n\t\t\t\t\t\t\tcv::resize(imageNear, temp, regionSize, scale, scale, cv::INTER_LINEAR);\r \n\r \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tcv::absdiff(region, temp, temp);\r \n\r \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tcache[step] = cv::mean(temp)[0];\r \n\t\t\t\t\t\t}\r \n\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tconst double error = cache[step];\r \n\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tif (error < prevError) {\r \n\t\t\t\t\t\t\tmatchIndex = n;\r \n\t\t\t\t\t\t\tmatchStep = step;\r \n\t\t\t\t\t\t\tmatchWidth = regionWidth;\r \n\t\t\t\t\t\t\tmatchHeight = regionHeight;\r \n\t\t\t\t\t\t\tmatchX = regionX;\r \n\t\t\t\t\t\t\tmatchY = regionY;\r \n\t\t\t\t\t\t\tmatchScale = scale;\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t\tprevError = error;\r \n\r \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tif (error == 0) {\r \n\t\t\t\t\t\t\tbreak;\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t}\r \n\r \n\t\t\t\t\t \n \n\t\t\t\t\tif (power == 1) {\r \n\r \n      #pragma omp atomic update\r \n\t\t\t\t\t\tscaleTotal += matchScale;\r \n\t\t\t\t\t\tbreak;\r \n\t\t\t\t\t}\r \n\r \n\t\t\t\t\t \n \n\t\t\t\t\tconst int stepMatched = stepPixels * matchIndex;\r \n\t\t\t\t\tconst auto stepNext = (int) std::pow(2, power - 1);\r \n\t\t\t\t\tconst int stepStart = (stepMatched - stepNext) / stepNext;\r \n\t\t\t\t\tsearchStart = (unsigned int) (stepStart < 0 ? 0 : stepStart);\r \n\t\t\t\t\tsearchEnd = (unsigned int) (stepStart + 3);\r \n\t\t\t\t}\r \n\t\t\t}", "pragma": "parallel for ", "hash": "9ab7fe9cea67a2b1c4192bacec6ba95fb519d7f1b62f4bb88e350674f2a5e675"}
{"code": "for (unsigned k = start; k < (unsigned)VALID; k += 2) { \n        if (!flag) continue; \n        flag = cal_sub_Pi(sub[omp_get_thread_num()], k); \n    }", "pragma": "parallel for private(flag)", "hash": "9da0615aca5c332f02f3461f8940c0f657fe5a6297d765dd430919433228eca4"}
{"code": "for (int j = 0; j < n; j++) \n\t  b[i][j] = a[i];", "pragma": "parallel for ", "hash": "c6feb7c7d8c1e062eb68fac6743dc8df1366250bbfe5d284c0887bd08602a297"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t(*this)[i] = (*right)[i] + (*this)[i];", "pragma": "for ", "hash": "c41c63299c048f7ae6b261e3bc592bba4365ce232bab1b5d02ec409a2a8a9d47"}
{"code": "for (int i = 0; i < wanted_mz_intensity.size(); i++) { \n\t\tvector<pair<double, double*> > wanted_item; \n\t\tauto& cur_mz_intensity = wanted_mz_intensity[i]; \n\t\tfor (auto it = cur_mz_intensity.begin(); it != cur_mz_intensity.end(); ++it) { \n\t\t\tfor (vector<double>::iterator jt = it->begin(); jt != it->end(); ++jt) { \n\t\t\t\twanted_item.push_back(pair<double, double*>(*jt, &(*jt))); \n\t\t\t} \n\t\t} \n \n\t\tsort(wanted_item.begin(), wanted_item.end(), small_first<double, double*>); \n\t\tget_record_intensity(i, wanted_item); \n\t}", "pragma": "parallel for ", "hash": "261bdea0d828cff97e8fece0683868429cd3062b74193324686e4b17e7c29b8a"}
{"code": "for(i = 0; i < n; i++) { \n      if(I[i] > ThreadMax) ThreadMax = I[i]; \n      if(I[i] < ThreadMin) ThreadMin = I[i]; \n      I[i] = logf(I[i] + logadd); \n    }", "pragma": "for private(i)", "hash": "de475696c43aa4e0eb35d6c16b55fe1378190c6bd66db82268e74f158999a379"}
{"code": "for(i=0; i<N; ++i) { \n        v[i] *= sc; \n    }", "pragma": "parallel for ", "hash": "56ea365729a7efa8155edf7dde541080240cd6c5c269ba1c64934153ee63dd3d"}
{"code": "for    (iy=0;iy<fdm->nypad;iy++) { \n\tfor(ix=0;ix<fdm->nxpad;ix++) { \n\t    for(iop=0;iop<nop;iop++) { \n\t\t \n\t\t \n \n\t\tif(!abc->free) {  \n \n\t\t    iz = nop-iop; \n\t\t    uo      [iy][ix][iz  ]  \n\t\t\t= um[iy][ix][iz+1]  \n\t\t\t+(um[iy][ix][iz  ] \n\t\t\t- uo[iy][ix][iz+1]) * abc->bzl[iy][ix]; \n\t\t} \n\t\t \n\t\t \n \n\t\tiz = fdm->nzpad-nop+iop-1; \n\t\tuo      [iy][ix][iz  ]  \n\t\t    = um[iy][ix][iz-1] \n\t\t    +(um[iy][ix][iz  ] \n\t\t    - uo[iy][ix][iz-1]) * abc->bzh[iy][ix]; \n\t    } \n\t} \n    }", "pragma": "parallel for private(iop ix iy iz)", "hash": "12833824b1777a3c0a17f8c1ace41ca77b208dcbe7cf1f43169219aa749ff127"}
{"code": "for(i = data_offset; i < SourceSize_in_bytes; i = i + rec_size) \n\t\t\t{ \n\t\t\t\tbyteValue = *(&char_ptr_tempSource[i] + ByteIndex); \n\t\t\t\t \n\t\t\t\t++privateByteCounter[byteValue]; \n\t\t\t}", "pragma": "for private(i)", "hash": "2d462650915b923dfd878b74f0ebc1fc8c47cd5232d4788ab5043c860ccecb82"}
{"code": "for(int j=0; j < L; j++){ \n                double r1 = r[j]; \n                double r2 = r[j+L]; \n                 \n                 \n \n                yr[j]       = c[L]           + r1 * c[L+1]             + r2 * c[L+2]; \n                yr[j + L]   = c[L+cstride]   + r1 * c[cstride + L+1]   + r2 * c[cstride + L+2]; \n                 \n                for(int l=0; l<L; l++){ \n                    double res1 = r[l]     - r1; \n                    double res2 = r[l+L]   - r2; \n                    double norm = sqrt(res1*res1 + res2*res2); \n                    if (norm > 0){ \n                        yr[j]       += c[l]           * norm * norm * log(norm); \n                        yr[L + j]   += c[l+cstride]   * norm * norm * log(norm); \n                    } \n                     \n                } \n            }", "pragma": "parallel for ", "hash": "5d0ed21dfc15977b30d8c96fb9451ee83532b1112008fcd478fbc8bbaed9d4f7"}
{"code": "for (int i = -1; i < nx2; i++) { \n                double as = q * q * EMSolver->GetASquared(GetFinestIndex(i)); \n#pragma ivdep \n                for (int j = -1; j < np1; j++) { \n                    double am =dp_inv * cc * (Gamma(Momentum(j + 1), as) - Gamma(Momentum(j), as)); \n                    ex[IndexNS(i, j)] = am; \n                } \n            }", "pragma": "for ", "hash": "ac6400ff65c30e34663eda1a9162b1a89b755a32f6ff8e44bff6f74c550fd8a3"}
{"code": "for(icx = ioff; icx < (VOLUME/2+ioff); icx++) { \n    ix = g_eo2lexic[icx]; \n     \n    r = l + icx-ioff; \n    s = k + icx-ioff; \n    t = j + icx-ioff; \n     \n    w1=&sw_32[ix][0][0]; \n    w2=w1+2;  \n \n    w3=w1+4;  \n \n    _su3_multiply(psi1,*w1,(*s).s0);  \n    _su3_multiply(chi,*w2,(*s).s1); \n    _vector_add_assign(psi1,chi); \n    _su3_inverse_multiply(psi2,*w2,(*s).s0);  \n    _su3_multiply(chi,*w3,(*s).s1); \n    _vector_add_assign(psi2,chi);  \n     \n \n    _vector_add_i_mul(psi1, (float)mu, (*s).s0); \n    _vector_add_i_mul(psi2, (float)mu, (*s).s1); \n \n    _vector_sub((*r).s0,psi1,(*t).s0); \n    _vector_sub((*r).s1,psi2,(*t).s1); \n     \n    w1++;  \n \n    w2++;  \n \n    w3++;  \n \n    _su3_multiply(psi1,*w1,(*s).s2); _su3_multiply(chi,*w2,(*s).s3); \n    _vector_add_assign(psi1,chi);  \n    _su3_inverse_multiply(psi2,*w2,(*s).s2); _su3_multiply(chi,*w3,(*s).s3); \n    _vector_add_assign(psi2,chi);  \n     \n \n    _vector_add_i_mul(psi1, -mu, (*s).s2); \n    _vector_add_i_mul(psi2, -mu, (*s).s3); \n \n     \n \n    _vector_sub((*r).s2,(*t).s2,psi1); \n    _vector_sub((*r).s3,(*t).s3,psi2); \n     \n \n  }", "pragma": "for ", "hash": "31075c7155cd59b02f68f15da7392bd742f44511216625d243277dcc03555acc"}
{"code": "for ( unsigned int i = 0; i < n_blocks * n_blocks; ++i ) { \n        delete rows[i]; \n    }", "pragma": "parallel for ", "hash": "d4912f06b4f64a947d200fa189ee915748e1b4037f12ad596b3ff9028821d3cb"}
{"code": "for(unsigned int ypx = 0; ypx < image.height; ypx++) { \n\t\t\t\t\tfor(unsigned int xpx = 0; xpx < image.width; xpx++) { \n\t\t\t\t\t\tregister double complex num = (image.xmin + xpx * xdiffratio) + (image.ymax - ypx * ydiffratio) * I; \n\t\t\t\t\t\trgb[ypx * image.width + xpx] = rgb_gen(mandelbrot_test(num)); \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "for ", "hash": "7384c29099d6ba854539d9ef9921b47a4f2c0ad7f42185004fda95df1f200ec3"}
{"code": "for(int i = 0; i < nf; i++)\r \n    {\r \n        for(int j = 0; j < 3; j++)\r \n        {\r \n            if(across_edge[i][j] != -1)\r \n                continue;\r \n            int v1 = faces[i][(j+1) % 3];\r \n            int v2 = faces[i][(j+2) % 3];\r \n            const vector<int>& a1 = adjacentfaces[v1];\r \n            const vector<int>& a2 = adjacentfaces[v2];\r \n            for(int k1 = 0; k1 < a1.size(); k1++)\r \n            {\r \n                int other = a1[k1];\r \n                if(other == i)\r \n                    continue;\r \n                vector<int>::const_iterator it = find(a2.begin(), a2.end(), other);\r \n                if(it == a2.end())\r \n                    continue;\r \n                int ind = (faces[other].indexof(v1)+1)%3;\r \n                if(faces[other][(ind+1)%3] != v2)\r \n                    continue;\r \n                across_edge[i][j] = other;\r \n                across_edge[other][ind] = i;\r \n                break;\r \n            }\r \n        }\r \n    }", "pragma": "parallel ", "hash": "9c37dd98e0919a9264075ba1ebe0c1635b7fbbfa0c459895b06a680ce015d52f"}
{"code": "for (ii = 0; ii < 10; ++ii) \n    c[ii] = a[ii];", "pragma": "parallel for simd ", "hash": "f7203e64a97718af962b0d2b0bbcfde0143885ab4bda7321c3cb3f453fbe648c"}
{"code": "for (int i=0; i<N; i++) { \n            float fProjPixel=(pImg[i]-pDark[i]); \n            if (fProjPixel<=0) \n                pImg[i]=0; \n            else \n                pImg[i]=pFlat[i]*fProjPixel*cDose; \n        }", "pragma": "parallel for private(pdark pflat pimg)", "hash": "58c307919460b6df8787f512c9741f120e8681f4a220e5fce15f4e2c99a3198c"}
{"code": "for(int r = 0; r < src.rows; ++r) \n\tfor(int c = 0; c < src.cols; ++c) \n\t{ \n\t\tPoint2f point = Point2i(c, r); \n\t\tfloat distance = venus::distance(point, center); \n \n\t\t \n \n\t\tif(distance >= outer_radius) \n\t\t\tdst.at<Vec4b>(r, c) = Vec4b(255, 255, 255, 255); \n\t\telse if(distance >= inner_radius) \n\t\t{ \n\t\t\tfloat t = (distance - inner_radius) / (outer_radius - inner_radius); \n\t\t\tuint8_t x = t * 253 + 1;   \n \n\t\t\tdst.at<Vec4b>(r, c) = Vec4b(x, x, x, 255); \n\t\t} \n\t\telse   \n \n\t\t\tdst.at<Vec4b>(r, c) = Vec4b(0, 0, 0, 255); \n\t\tif(distance >= outer_radius) \n\t\t\tdst.at<Vec4b>(r, c) = getBlurredValue(src, point, BLUR_RADIUS); \n\t\telse if(distance >= inner_radius) \n\t\t{ \n\t\t\tfloat t = (outer_radius - distance) / (outer_radius - inner_radius); \n\t\t\tfloat blur_radius = t * (BLUR_RADIUS - 1.0F) + 1.0F; \n\t\t\tdst.at<Vec4b>(r, c) = getBlurredValue(src, point, blur_radius); \n\t\t} \n \n \n \n \n\t}", "pragma": "parallel for ", "hash": "3763369f3909eba6758dbc15d046bb10f2a29118fc9f71b9dd211a2e56f66cc5"}
{"code": "for(int source=0; source < checknodes.size(); source++) \n    { \n        #pragma omp critical \n        { \n            index++; \n            checkednodes.push_back(checknodes.at(source)); \n        } \n \n        if(int(index/float(checknodes.size())*100)%5==0) \n            DM::Logger(DM::Standard) << index/float(checknodes.size())*100 << \"%\"; \n \n         \n \n        DM::Node *currentsource = checknodes.at(source); \n        std::vector<DM::Edge*>  e = currentsource->getEdges(); \n        bool possiblenode=false; \n \n        for(uint i = 0; i < e.size(); i++) \n\t\t\tif(std::find(em.begin(),em.end(),e[i])==em.end()) \n            { \n\t\t\t\tif(std::find(lem.begin(),lem.end(),e[i])!=lem.end()) \n                    possiblenode=true; \n                    break; \n            } \n \n        if(!possiblenode) \n            continue; \n \n        property_map<DynamindBoostGraph::Graph, vertex_distance_t>::type d = get(vertex_distance, g); \n        property_map<DynamindBoostGraph::Graph, vertex_distance_t>::type org_d = get(vertex_distance, org_g); \n        std::vector < int > p(num_vertices(g)); \n        std::vector < int > org_p(num_vertices(org_g)); \n \n         \n \n         \n \n         \n \n \n         \n \n        boost::dijkstra_shortest_paths( g, \n                                        nodesindex[checknodes.at(source)], \n                                        predecessor_map(boost::make_iterator_property_map(p.begin(), get(boost::vertex_index, g))) \n                                        .distance_map(d)); \n \n         \n \n         \n \n         \n \n \n         \n \n        boost::dijkstra_shortest_paths( org_g, \n                                        org_nodesindex[checknodes.at(source)], \n                                        predecessor_map(boost::make_iterator_property_map(org_p.begin(), get(boost::vertex_index, org_g))) \n                                        .distance_map(org_d)); \n \n         \n \n        std::vector<DM::Node*> nearest = TBVectorData::findNearestNeighbours(checknodes.at(source),this->searchdistance,checknodes); \n \n        for(uint n = 0; n < nearest.size(); n++) \n        { \n            DM::Node *targetnode = nearest[n]; \n            DM::Node *rootnode = checknodes.at(source); \n \n            std::vector<DM::Edge*>  e = targetnode->getEdges(); \n            bool possiblenode=false; \n \n            for(uint i = 0; i < e.size(); i++) \n                 \n \n\t\t\t\tif(std::find(em.begin(),em.end(),e[i])==em.end()) \n                { \n                     \n \n\t\t\t\t\tif(std::find(lem.begin(),lem.end(),e[i])!=lem.end()) \n                        possiblenode=true; \n                        break; \n                } \n \n            if(!possiblenode) \n                continue; \n \n            std::vector<DM::Node*> pathnodes, org_pathnodes; \n            std::vector<DM::Edge*> pathedges, org_pathedges; \n            double distance, org_distance; \n \n            if(!DynamindBoostGraph::findShortestPath(pathnodes,pathedges,distance,nodesindex,nodes2edge,d,p,rootnode,targetnode)) \n                continue; \n \n            if(!DynamindBoostGraph::findShortestPath(org_pathnodes,org_pathedges,org_distance,org_nodesindex,org_nodes2edge,org_d,org_p,rootnode,targetnode)) \n                continue; \n \n            bool dirty=false; \n            for(uint check=1; check<pathnodes.size()-1; check++) \n                if(std::find(checknodes.begin(),checknodes.end(),pathnodes[check])!=checknodes.end()) \n                { \n                    dirty=true; \n                    continue; \n                } \n \n            if(pathedges.size()==org_pathedges.size() && pathedges.size()==1) \n                dirty=true; \n \n            if(!dirty) \n            { \n                #pragma omp critical \n                { \n                    result.push_back(distance/org_distance); \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "54e95815df6d0934bd1c17e2ee2e116254f7aa40698cddb0719c078d7991ac23"}
{"code": "for (j = 0; j < overlap; j++) \n      for (i = 0; i < w; i++) \n        pimage[i+overlap + j * tilesize * nrtilesw] = Image->m_Image[i + (overlap-j-1) * w][0];", "pragma": "for private(i j)", "hash": "93df94f8f961a9e5ebd400190e5a47f2a76f5cb219f60658a8ce0562c7303465"}
{"code": "for (int i=0;i<tod->ndet;i++) { \n    for (int j=0;j<nsamp;j++) \n      tod->data[i][j]*=window[j]; \n    for (int j=0;j<nsamp;j++) \n      tod->data[i][nn+j]*=window2[j];     \n  }", "pragma": "parallel for ", "hash": "b8e2deb1cfaa49264048506d86eaeb8b9466bfb3f912969a9b9196304bfcc0fc"}
{"code": "for(int i = 0; i < arr.size(); ++i) \n\t\tresult(i) = lgamma(arr(i));", "pragma": "parallel for ", "hash": "5262173e3665cabdd1f6b405177c8b2547d389f47726bda74460b3ce1de9ed76"}
{"code": "for (i = 0; i < n; i++) x[i] = 0;", "pragma": "parallel for ", "hash": "f33717b6883e2d6949b453aedf92916315779237bb9583c2113673207f7aafe6"}
{"code": "for (i = 0; i < argc; ++i) \n\t\tif (verbose_mode == OFF && !strcmp(argv[i], \"--verbose\")) { \n\t\t\tverbose_mode = ON; \n\t\t} else if (process_sequentially == OFF && !strcmp(argv[i], \"--process-sequentially\")) { \n\t\t\tprocess_sequentially = ON; \n\t\t} else if (process_sequentially == OFF && !strcmp(argv[i], \"--serial\")) { \n\t\t\tprocess_sequentially = ON; \n\t\t} else if (process_sequentially == OFF && !strcmp(argv[i], \"--sequential\")) { \n\t\t\tprocess_sequentially = ON; \n\t\t} else if (process_full == OFF && !strcmp(argv[i], \"--process\")) { \n\t\t\tprocess_full = ON; \n\t\t} else if (!strcmp(argv[i], \"--output-file\")) { \n\t\t\tif (i+1 < argc) \n\t\t\t\toutput_filename = argv[i+1]; \n\t\t} else if (!strcmp(argv[i], \"--corpus-dir\")) { \n\t\t\tif (i+1 < argc) \n\t\t\t\tcorpus_dir = argv[i+1]; \n\t\t}", "pragma": "parallel for ", "hash": "535ed8b7b1f3c3d4314eea76c9187106d550a1fa44b5bc6ae651d09181fdf584"}
{"code": "for ( long long j=0; j<dimY; j++ ) \n  { \n    for ( long long k=0; k<dimZ; k++) \n    { \n      long long ij  = k+dimZ*j; \n      long long ijk = k+dimZ*(j+dimY*x0); \n \n      slice[ij][0] = Phi[ijk][0]; \n      slice[ij][1] = Phi[ijk][1]; \n    } \n  }", "pragma": "parallel for ", "hash": "01f408e7bcd9f1136daf9f115961e08c113dff2e4a3613ae71b579cec6d94a42"}
{"code": "for (i = 0; i < x; i++) \n\t    { \n\t      s += b[i] * c[i] + d[x + i] + sizeof (b) - sizeof (c); \n\t      b[i] = i + 0.5; \n\t      c[i] = 0.5 - i; \n\t      d[x + i] = 0.5 * i; \n\t    }", "pragma": "parallel for reduction(+:s) ", "hash": "0818b5513699fc6de0d822d917f32b6637fd749847dd98656d7f589165fcb491"}
{"code": "for (unsigned pos=0; pos<image.size(); pos++) { \n\t\timage[pos].r > 0.0 ? image[pos].r = pow(((image[pos].r*(A*image[pos].r+B)) / (image[pos].r*(A*image[pos].r+C) + D)),power) / norm : image[pos].r = 0.0; \n\t\timage[pos].g > 0.0 ? image[pos].g = pow(((image[pos].g*(A*image[pos].g+B)) / (image[pos].g*(A*image[pos].g+C) + D)),power) / norm : image[pos].g = 0.0; \n\t\timage[pos].b > 0.0 ? image[pos].b = pow(((image[pos].b*(A*image[pos].b+B)) / (image[pos].b*(A*image[pos].b+C) + D)),power) / norm : image[pos].b = 0.0; \n\t}", "pragma": "parallel for ", "hash": "4a2407bf582bb5f39bf1a1e66d58da283f5476082d89a95417b3821b8112cff6"}
{"code": "for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k  = gradInput_p  + k * itime * iwidth * iheight; \n    real *gradOutput_p_k = gradOutput_p + k * otime * owidth * oheight; \n    THIndex_t *indz_p_k = indz_p + k * otime * owidth * oheight; \n \n     \n \n    long ti, i, j; \n    for (ti = 0; ti < otime; ti++) \n    { \n      for (i = 0; i < oheight; i++) \n      { \n        for (j = 0; j < owidth; j++) \n        { \n           \n \n          THIndex_t * indzp = &indz_p_k[ti * oheight * owidth + i * owidth + j]; \n          long maxti = ((unsigned char*)(indzp))[0] * dilationT + ti * dT - pT; \n          long maxi  = ((unsigned char*)(indzp))[1] * dilationH + i * dH - pH; \n          long maxj  = ((unsigned char*)(indzp))[2] * dilationW + j * dW - pW; \n \n           \n \n          gradInput_p_k[maxti * iheight * iwidth + maxi * iwidth + maxj] += \n            gradOutput_p_k[ti * oheight * owidth + i * owidth + j]; \n        } \n      } \n    } \n  }", "pragma": "parallel for private(k)", "hash": "8e5547bba126207512b4fc94451ebcf0f3d49c5b48d3296025ac6b3ae1815a6a"}
{"code": "for(int i = 0; i < n; i++) { \n      Mat origin = imread(path[i], CV_LOAD_IMAGE_GRAYSCALE); \n      if (!origin.data) { \n        printf(\"Can not open %s\",path[i].c_str()); \n      } \n      int type = 0; \n      int stmp,xtmp,ytmp; \n      int s = bboxes[i].width; \n \n      while(type < 5){ \n        srand(time(0)+type); \n        do{ \n          stmp = s*((float)(rand()%20)/100.0+0.9); \n          xtmp = bboxes[i].x+s*((float)(rand()%10)/100.0-0.05); \n          ytmp = bboxes[i].y+s*((float)(rand()%10)/100.0-0.05); \n        }while(xtmp<0 || ytmp<0 || (xtmp+stmp)>origin.cols || (ytmp+stmp)>origin.rows); \n        Rect rect(xtmp,ytmp,stmp,stmp); \n        fprintf(tmpfile,\"%s %d %d %d %d 0\\n\",path[i].c_str(),xtmp,ytmp,stmp,stmp); \n \n        Mat face = origin(rect); \n        Mat img; \n        cv::resize(face, img, Size(opt.objSize, opt.objSize)); \n        imgs[i*10+type]=img.clone(); \n        type ++; \n      } \n \n      flip(origin,origin,1); \n      bboxes[i].x = origin.cols - bboxes[i].x - bboxes[i].width; \n \n      while(type < 10){ \n        srand(time(0)+type); \n        do{ \n          stmp = s*((float)(rand()%20)/100.0+0.9); \n          xtmp = bboxes[i].x+s*((float)(rand()%10)/100.0-0.05); \n          ytmp = bboxes[i].y+s*((float)(rand()%10)/100.0-0.05); \n        }while(xtmp<0 || ytmp<0 || (xtmp+stmp)>origin.cols || (ytmp+stmp)>origin.rows); \n        Rect rect(xtmp,ytmp,stmp,stmp); \n        fprintf(tmpfile,\"%s %d %d %d %d 1\\n\",path[i].c_str(),xtmp,ytmp,stmp,stmp); \n \n        Mat face = origin(rect); \n        Mat img; \n        cv::resize(face, img, Size(opt.objSize, opt.objSize)); \n        imgs[i*10+type]=img.clone(); \n        type ++; \n      } \n    }", "pragma": "parallel for ", "hash": "b932d24bf1e0687fa47574cd5fc990d186abfc7d12e4c25983744115b0cc5aca"}
{"code": "for (uint j = 0; j < it_ev->second.PERs_on_this_profile.size(); ++j) \n\t\t{               \n\t\t    PERs___loop.at(j)->second.HEURISTIC__determine_which_breakpoints_are_strongly_supported_by_this_PER_for_a_given_Event____using_pseudo_posterior( \n\t\t\t\t\t\t\tit_ev->second.UID, \n\t\t\t\t\t\t\theuristic_posterior_PROBABILITY_threshold, \n\t\t\t\t\t\t\t    map_NAHR_varpos_to_number_of_decent_reads__AB____thread, \n\t\t\t\t\t\t\t    map_NAHR_varpos_to_number_of_decent_reads__BA____thread); \n\t\t}", "pragma": "for ", "hash": "3b308290b4248885a05c8c8c1d132892b1f9e474d3d86841a25b510dc6d975c5"}
{"code": "for (int g = 0; g < NumOfGroups; g++) { \n  \tTIntV* GroupRows = NULL; \n  \tswitch(GroupingCase){ \n  \t\tcase 0: \n  \t\t\tGroupRows = & Mapping.GetDat(Mapping.GetKey(g)); \n  \t\t\tbreak; \n  \t\tcase 1: \n  \t\t\tGroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g)); \n  \t\t\tbreak; \n  \t\tcase 2: \n  \t\t\tGroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g)); \n  \t\t\tbreak; \n  \t    case 3: \n  \t\t\tGroupRows = & GroupByStrMapping.GetDat(GroupByStrMapping.GetKey(g)); \n  \t\t\tbreak; \n  \t\tcase 4: \n  \t\t\tGroupRows = & GroupByIntMapping_MP.GetDat(GroupByIntMPKeys[g]); \n  \t\t\tbreak; \n  \t} \n \n     \n \n     \n \n\tTIntV& ValidRows = *GroupRows; \n    TInt sz = ValidRows.Len(); \n    if (sz <= 0) continue; \n     \n \n    if (AggOp == aaCount) { \n      for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = sz; } \n    } else { \n       \n \n      if (T == atInt) { \n        TIntV V; \n        for (TInt i = 0; i < sz; i++) { V.Add(IntCols[AggrColIdx][ValidRows[i]]); } \n        TInt Res = AggregateVector<TInt>(V, AggOp); \n        if (AggOp == aaMean) { Res = Res / sz; } \n        for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = Res; } \n      } else { \n        TFltV V; \n        for (TInt i = 0; i < sz; i++) { V.Add(FltCols[AggrColIdx][ValidRows[i]]); } \n        TFlt Res = AggregateVector<TFlt>(V, AggOp); \n        if (AggOp == aaMean) { Res /= sz; } \n        for (TInt i = 0; i < sz; i++) { FltCols[ColIdx][ValidRows[i]] = Res; } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "6c378ba62f5713492f743ecc87f2b3f16434cb2f6778afcc8415a3519eb3348d"}
{"code": "for (int i = 0; i < size; i++) { \n    x[i] = gamma[i]; \n  }", "pragma": "parallel for ", "hash": "b243c50998557c614716ca1b853e1280ea0003de8ba9bb250ded4e327a5a6f2e"}
{"code": "for (int c = 0; c <= grid_data.NCM-1; c++) \n\t{ \n\t\tfor (int i = 0; i <= Solution.setup.VAR-1; i++)\tSolution.Rn[c][i]\t= 0.0; \n\t}", "pragma": "parallel for ", "hash": "b092694afc237d9cd5d148f6c9ed616ee9b525f2f620e6c5d447ba2924876d5a"}
{"code": "for(size_t ip=0;ip<pairs[ispin].size();ip++) { \n\t   \n \n\t  for(size_t jp=0;jp<ip;jp++) { \n\t    double tmp=arma::as_scalar(munu_I[ispin].row(pairs[ispin][ip].i*Norbi+pairs[ispin][ip].f)*ab_inv*arma::trans(munu_I[ispin].row(pairs[ispin][jp].i*Norbi+pairs[ispin][jp].f))); \n\t    K(ioff+ip,joff+jp)+=tmp; \n\t    K(joff+jp,ioff+ip)+=tmp; \n\t  } \n\t   \n \n\t  K(ioff+ip,ioff+ip)+=arma::as_scalar(munu_I[ispin].row(pairs[ispin][ip].i*Norbi+pairs[ispin][ip].f)*ab_inv*arma::trans(munu_I[ispin].row(pairs[ispin][ip].i*Norbi+pairs[ispin][ip].f))); \n\t}", "pragma": "parallel for ", "hash": "083d9402abc292212187d294eba4144e12c23001efabb71bc0699c7a41949ee0"}
{"code": "for (idx_t ij = 0; ij < n * nprobe; ij++) { \n                    idx_t i = ij / nprobe; \n                    float* xij = &xrel[ij * d]; \n                    idx_t cij = coarse_ids[ij]; \n \n                    if (cij >= 0) { \n                        quantizer->compute_residual(x + i * d, xij, cij); \n                    } else { \n                         \n \n                        memset(xij, -1, sizeof(float) * d); \n                    } \n                }", "pragma": "parallel for ", "hash": "8385aa011a4855e03f8077dcdb99891d37d8a1be0b2a265641cdfe4d34203ad7"}
{"code": "for (int i = 0; i < 1024; i++) \n    { \n      { r += a[i]; r2 += a[i]; r3 += a[i]; } \n      #pragma omp scan inclusive(r, r2, r3) \n      { \n\tb[i] = r; \n\tb2[i] = r2; \n\tb3[i] = r3; \n      } \n    }", "pragma": "for simd reduction(   +:r inscan r2 r3) ", "hash": "4fa2d8eccc701d18c3111a5001ec596bec094bb7cbb569c86f0fe5efd4001ed1"}
{"code": "for(size_t row = HL_BORDER; row < height - HL_BORDER; row++) \n  { \n    for(size_t col = HL_BORDER; col < w - HL_BORDER; col++) \n    { \n      const size_t v = row * w + col; \n      float g = 0.0f; \n      if((distance[v] > 0.0f) && (distance[v] < 2.0f)) \n      { \n         \n \n        const float gx = 47.0f * (luminance[v-w-1] - luminance[v-w+1]) \n                      + 162.0f * (luminance[v-1]   - luminance[v+1]) \n                       + 47.0f * (luminance[v+w-1] - luminance[v+w+1]); \n        const float gy = 47.0f * (luminance[v-w-1] - luminance[v+w-1]) \n                      + 162.0f * (luminance[v-w]   - luminance[v+w]) \n                       + 47.0f * (luminance[v-w+1] - luminance[v+w+1]); \n        g = 4.0f * sqrtf(sqf(gx / 256.0f) + sqf(gy / 256.0f)); \n      } \n      gradient[v] = g; \n    } \n  }", "pragma": "parallel for ", "hash": "46542b9ff6375eb6994d8d257aa8d30e90110882b905ce38bde49c5e4b144fa5"}
{"code": "for(j = i + 1; j < dim; j++) \n\t\t{ \n\t\t\trow_index_j = pivot[j] * dim; \n\t\t\tmat_a[row_index_j + i] /= pivot_aii; \n \n\t\t\tfor(k = i + 1; k < dim; k++) \n\t\t\t\tmat_a[row_index_j + k] -= mat_a[row_index_j + i] * mat_a[row_index_i + k]; \n\t\t}", "pragma": "parallel for private( k row_index_j)", "hash": "e94dbaa89d779a5ba2c8a8b3cba86c620ed9c94bfd00056900a3d885b8abe954"}
{"code": "for (i = 0; i < x; i++) \n\ttgt (), s += b[i] * c[i];", "pragma": "parallel for reduction(+:s) ", "hash": "2879f6b34f7e8b5637791d4802f674af254159aa2c48a8a46a37134ffc7aba07"}
{"code": "for (int x = 0; x<width; x++) {      \n \n        for (int y = 0; y<height; y++) { \n            Ray r = getRay(x, y); \n \n             \n \n            int objSize = world.size; \n            Color c = traceRay(&r, &world); \n \n            int ipos = 3 * (width * y + x); \n \n             \n \n             \n \n \n             \n \n            rgb[ipos + 2] = (unsigned char)(c.z * 255); \n            rgb[ipos + 1] = (unsigned char)(c.y * 255); \n            rgb[ipos] = (unsigned char)(c.x * 255); \n        } \n    }", "pragma": "parallel for ", "hash": "30f425efc0e59f08e0c0874284a81f562117ace70849b49ddd33a8b9bd8ee67f"}
{"code": "for (int y = 0; y < size.height; y++) { \n      Vec4T const* src = args.get(0).ptr<Vec4T const>(y); \n      cv::Vec4f* dst = local_view.ptr<cv::Vec4f>(y); \n \n      for (int x = 0; x < size.width; x++) { \n         \n \n        cv::Vec3f const bgr(converter[src[x][0]],    \n \n                            converter[src[x][1]],    \n \n                            converter[src[x][2]]);   \n \n        float const alpha = src[x][3] * alpha_scale; \n \n         \n \n        cv::Vec3f const xyz = tnzu::to_xyz(bgr); \n \n        dst[x][0] = xyz[0]; \n        dst[x][1] = xyz[1]; \n        dst[x][2] = xyz[2]; \n        dst[x][3] = alpha; \n      } \n    }", "pragma": "parallel for ", "hash": "67b15167760c566e3f71c08f8614a988d61eab0226bb361715924b37d74e020a"}
{"code": "for (long i=0; i<NV; i++) { \n  \tC[i] = -1; \n  }", "pragma": "parallel for ", "hash": "0f0720a961f664e63d5c287d9c8d6a20caae19d6e2c9c05d075eed971643a981"}
{"code": "for (int j = 0; j < src.rows; j++) \n\t{ \n\t\tfloat* dptr = destf.ptr<float>(j); \n\t\tconst float* sptr = im.ptr<float>(j + r) + r; \n\t\tconst float* aptr = ave.ptr<float>(j); \n \n\t\tfor (int i = 0; i < src.cols; i += 32) \n\t\t{ \n\t\t\tconst float* si = sptr + i; \n\t\t\tconst __m256 ma0 = _mm256_lddqu_ps(aptr + i); \n\t\t\tconst __m256 ma1 = _mm256_lddqu_ps(aptr + i + 8); \n\t\t\tconst __m256 ma2 = _mm256_lddqu_ps(aptr + i + 16); \n\t\t\tconst __m256 ma3 = _mm256_lddqu_ps(aptr + i + 24); \n \n\t\t\t__m256 mv0 = _mm256_setzero_ps(); \n\t\t\t__m256 mv1 = _mm256_setzero_ps(); \n\t\t\t__m256 mv2 = _mm256_setzero_ps(); \n\t\t\t__m256 mv3 = _mm256_setzero_ps(); \n\t\t\t__m256 mw0 = _mm256_setzero_ps(); \n\t\t\t__m256 mw1 = _mm256_setzero_ps(); \n\t\t\t__m256 mw2 = _mm256_setzero_ps(); \n\t\t\t__m256 mw3 = _mm256_setzero_ps(); \n\t\t\tfor (int k = 0; k < d; k++) \n\t\t\t{ \n\t\t\t\tconst __m256 mr0 = _mm256_lddqu_ps(si + offset[k] + 0); \n\t\t\t\tconst __m256 mr1 = _mm256_lddqu_ps(si + offset[k] + 8); \n\t\t\t\tconst __m256 mr2 = _mm256_lddqu_ps(si + offset[k] + 16); \n\t\t\t\tconst __m256 mr3 = _mm256_lddqu_ps(si + offset[k] + 24); \n\t\t\t\t__m256 mlw0 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(_mm256_sub_ps(mr0, ma0))), 4)); \n\t\t\t\t__m256 mlw1 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(_mm256_sub_ps(mr1, ma1))), 4)); \n\t\t\t\t__m256 mlw2 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(_mm256_sub_ps(mr2, ma2))), 4)); \n\t\t\t\t__m256 mlw3 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(_mm256_sub_ps(mr3, ma3))), 4)); \n\t\t\t\tmv0 = _mm256_fmadd_ps(mlw0, mr0, mv0); \n\t\t\t\tmv1 = _mm256_fmadd_ps(mlw1, mr1, mv1); \n\t\t\t\tmv2 = _mm256_fmadd_ps(mlw2, mr2, mv2); \n\t\t\t\tmv3 = _mm256_fmadd_ps(mlw3, mr3, mv3); \n\t\t\t\tmw0 = _mm256_add_ps(mlw0, mw0); \n\t\t\t\tmw1 = _mm256_add_ps(mlw1, mw1); \n\t\t\t\tmw2 = _mm256_add_ps(mlw2, mw2); \n\t\t\t\tmw3 = _mm256_add_ps(mlw3, mw3); \n\t\t\t} \n \n\t\t\tif constexpr (postprocess == 0) \n\t\t\t{ \n\t\t\t\t_mm256_storeu_ps(dptr + i + 0, _mm256_div_ps(mv0, mw0)); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 8, _mm256_div_ps(mv1, mw1)); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 16, _mm256_div_ps(mv2, mw2)); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 24, _mm256_div_ps(mv3, mw3)); \n\t\t\t} \n\t\t\telse if constexpr (postprocess == 1) \n\t\t\t{ \n\t\t\t\tconst float* s = stddev.ptr<float>(j, i); \n \n\t\t\t\t_mm256_storeu_ps(dptr + i + 0, _mm256_mul_ps(_mm256_loadu_ps(s), _mm256_div_ps(mv0, mw0))); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 8, _mm256_mul_ps(_mm256_loadu_ps(s + 8), _mm256_div_ps(mv1, mw1))); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 16, _mm256_mul_ps(_mm256_loadu_ps(s + 16), _mm256_div_ps(mv2, mw2))); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 24, _mm256_mul_ps(_mm256_loadu_ps(s + 24), _mm256_div_ps(mv3, mw3))); \n\t\t\t} \n\t\t\telse if constexpr (postprocess == 2) \n\t\t\t{ \n\t\t\t\tconst float* s = stddev.ptr<float>(j, i); \n \n\t\t\t\t_mm256_storeu_ps(dptr + i + 0, _mm256_mul_ps(_mm256_set1_ps(lastexp), _mm256_div_ps(mv0, _mm256_mul_ps(_mm256_loadu_ps(s), mw0)))); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 8, _mm256_mul_ps(_mm256_set1_ps(lastexp), _mm256_div_ps(mv1, _mm256_mul_ps(_mm256_loadu_ps(s + 8), mw1)))); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 16, _mm256_mul_ps(_mm256_set1_ps(lastexp), _mm256_div_ps(mv2, _mm256_mul_ps(_mm256_loadu_ps(s + 16), mw2)))); \n\t\t\t\t_mm256_storeu_ps(dptr + i + 24, _mm256_mul_ps(_mm256_set1_ps(lastexp), _mm256_div_ps(mv3, _mm256_mul_ps(_mm256_loadu_ps(s + 24), mw3)))); \n\t\t\t} \n \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "4f1394e0fa6b6b1a7ae24ebe4eed387aad84c69649924928fe5498b0e2d822e4"}
{"code": "for (uint i=0; i<eles.size(); i++) { \n    dt = min(dt, eles[i]->calcDt()); \n  }", "pragma": "parallel for reduction(min:dt) ", "hash": "62c0defadc57b0294887719d52a6809e4d41b1a13d837f538f97801b0543d8ff"}
{"code": "for( y=0; y<m_h; y++ ) \n   { \n      for( x=0; x<m_w; x++ ) \n      { \n         index=y*m_w+x; \n         orientation=0; \n         if( m_orientation_map ) orientation = m_orientation_map[index]; \n         if( !( orientation >= 0 && orientation < g_grid_orientation_resolution ) ) orientation = 0; \n         get_unnormalized_descriptor( y, x, orientation, &(m_dense_descriptors[index*m_descriptor_size]) ); \n      } \n   }", "pragma": "parallel for private(index orientation x y)", "hash": "1aad51cf2a15995988acb8d141fec37ff254d5f6d2487fa6c70636e59e2b4cad"}
{"code": "for(unsigned i=0; i<zips.size(); ++i) \n    { \n\tdouble lat = latlng[i*2+0]; \n\tdouble lng = latlng[i*2+1]; \n\t \n \n\tfor(auto& r: json.regions) \n\t{ \n\t    if (r.pointInRegion(lat, lng)) \n\t    { \n\t\tstd::pair<double, double> c = r.calculateCentroid(); \n\t\tstd::cout << \"Point \" << zips[i] << \" calculated inside \" << r.getName() \n\t\t\t  << \". Region Centroid: \" << c.first << \" \" << c.second << std::endl; \n\t\tcontinue; \n\t    } \n\t} \n    }", "pragma": "parallel for ", "hash": "857447de9043b4d905dc932fa33482c3151c74d36a45315cb58ac00e1a7d4cab"}
{"code": "for (T i = ST; i < N; i++) \n    argv[0][i] = argv[0][i] - argv[0][i - ST];", "pragma": "for ", "hash": "06019c904bea5069b11e971b863dda361aec49058610b5f4bfa55eef42bfb2dd"}
{"code": "for(j=1; j < QARR_SZ-1; j++) \n        for(i=1; i < PARR_SZ-1; i++) \n        { \n                o = i + j*PARR_SZ; \n \n                 \n \n                t = 0; \n                t += a[o - 1 - PARR_SZ]; \n                t += a[o     - PARR_SZ]; \n                t += a[o + 1 - PARR_SZ]; \n                t += a[o - 1]; \n                t += a[o + 1]; \n                t += a[o - 1 + PARR_SZ]; \n                t += a[o     + PARR_SZ]; \n                t += a[o + 1 + PARR_SZ]; \n \n                b[o] = a[o] * (t == 2 ? 1 : 0); \n                b[o] |= (t == 3) ? 1 : 0; \n        }", "pragma": "for ", "hash": "36cf4716a5fae117932a4b4d8c2d8675a50e7bd6026e7c52c48543c8391d92d8"}
{"code": "for(int o = 0;o<no;o++) \n  { \n    S[o] = 0; \n  }", "pragma": "parallel for ", "hash": "8b1bafa3017d082817cfa8ea72edf046cebdee18a19e7acd1a3a4edc8a6481c8"}
{"code": "for (int TIdx = 0; TIdx < ChunkNum; TIdx++) { \n      TIntFltH GradV; \n      for (int ui = TIdx * ChunkSize; ui < (TIdx + 1) * ChunkSize; ui++) { \n        const bool IsRow = (ui % 2 == 0); \n        NewNIDV[ui] = -1; \n        if (ui > NIdxV.Len()) { continue; } \n        const int u = NIdxV[ui];  \n \n         \n \n        TNGraph::TNodeI UI = G->GetNI(u); \n        const int Deg = IsRow? UI.GetOutDeg(): UI.GetInDeg(); \n        TIntSet CIDSet(5 * Deg); \n        TIntFltH CurFU = IsRow? F[u]: H[u]; \n        for (int e = 0; e < Deg; e++) { \n          int VID = IsRow? UI.GetOutNId(e): UI.GetInNId(e); \n          if (HOVIDSV[u].IsKey(VID)) { continue; } \n          TIntFltH& NbhCIDH = IsRow? H[VID]: F[VID]; \n          for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) { \n            CIDSet.AddKey(CI.GetKey()); \n          } \n        } \n        if (CIDSet.Empty()) {  \n          CurFU.Clr(); \n        } \n        else { \n          for (TIntFltH::TIter CI = CurFU.BegI(); CI < CurFU.EndI(); CI++) {  \n \n            if (! CIDSet.IsKey(CI.GetKey())) { \n              CurFU.DelIfKey(CI.GetKey()); \n            } \n          } \n          GradientForNode(IsRow, u, GradV, CIDSet); \n          if (Norm2(GradV) < 1e-4) { NIDOPTV[u] = 1; continue; } \n          double LearnRate = GetStepSizeByLineSearch(IsRow, u, GradV, GradV, StepAlpha, StepBeta); \n          if (LearnRate == 0.0) { NewNIDV[ui] = -2; continue; } \n          for (int ci = 0; ci < GradV.Len(); ci++) { \n            int CID = GradV.GetKey(ci); \n            double Change = LearnRate * GradV.GetDat(CID); \n            double NewFuc = CurFU.IsKey(CID)? CurFU.GetDat(CID) + Change : Change; \n            if (NewFuc <= 0.0) { \n              CurFU.DelIfKey(CID); \n            } else { \n              CurFU.AddDat(CID) = NewFuc; \n            } \n          } \n          CurFU.Defrag(); \n        } \n         \n \n        NewF[ui] = CurFU; \n        NewNIDV[ui] = u; \n        IsRowV[ui] = IsRow; \n      } \n    }", "pragma": "parallel for ", "hash": "aaa0e069dc4588ad433e2cd0ab2e4e849a67e3405aa7ad39efd4e11d38285bc5"}
{"code": "for (int y = 0; y < grid->dim_y; ++y) { \n            for (int x = 0; x < grid->dim_x; ++x) { \n                if (which == 0) { \n                    ptmp = hamiltonian->potential->get_value(x, y); \n                    if (grid->coordinate_system == \"cylindrical\") { \n                        ptmp += hamiltonian->azimuthal_potential(x, state->angular_momentum); \n                    } \n                } \n                else { \n                    ptmp = static_cast<Hamiltonian2Component*>(hamiltonian)->potential_b->get_value(x, y); \n                    if (grid->coordinate_system == \"cylindrical\") { \n                        ptmp += static_cast<Hamiltonian2Component*>(hamiltonian)->azimuthal_potential_b(x, state_b->angular_momentum); \n                    } \n                } \n                if (imag_time) { \n                    tmp = exp(complex<double> (-delta_t * ptmp, 0.)); \n                } \n                else { \n                    tmp = exp(complex<double> (0., -delta_t * ptmp)); \n                } \n                external_pot_real[which][y * grid->dim_x + x] = real(tmp); \n                external_pot_imag[which][y * grid->dim_x + x] = imag(tmp); \n            } \n        }", "pragma": "for ", "hash": "0a4531af225136a3599db7510017284b40ca2e72342d527c2b96ea660d731f49"}
{"code": "for (size_t i = 0; i < n; i += 4) { \n        v.load(simg + i); \n        s = square(v); \n        out[i / 4] = sqrt(s[1] + s[2] + s[3]) / v[0]; \n    }", "pragma": "parallel for private(d s v)", "hash": "a4cfcf220d0ccb84a5f3ea9bf143ea3f08899f800d8bab01d540564affaa4c1d"}
{"code": "for(int col = 0; col < num_columns; col += 1) \n        { \n            const float stixel_disparity = \n                    std::max<float>(min_float_disparity, the_stixels[col].disparity); \n            const float stixel_distance = stereo_camera.disparity_to_depth(stixel_disparity); \n \n             \n \n            Eigen::Vector2f uv_point = \n                    stereo_camera.get_left_camera().project_ground_plane_point(the_ground_plane, \n                                                                               0, stixel_distance, minimum_height); \n            const int max_v = static_cast<int>(uv_point[1]); \n \n            uv_point = \n                    stereo_camera.get_left_camera().project_ground_plane_point(the_ground_plane, \n                                                                               0, stixel_distance, maximum_height); \n            const int min_v = static_cast<int>(uv_point[1]); \n \n            uv_point = \n                    stereo_camera.get_left_camera().project_ground_plane_point(the_ground_plane, \n                                                                               0, stixel_distance, expected_object_height); \n            const int expected_v = static_cast<int>(uv_point[1]); \n \n            const int estimated_top_y = the_stixels[col].top_y; \n \n            if(estimated_top_y < min_v or estimated_top_y > max_v) \n            { \n                the_stixels[col].top_y = expected_v; \n                the_stixels[col].default_height_value = true; \n            } \n            else \n            { \n                 \n \n            } \n \n        }", "pragma": "parallel for ", "hash": "0c3908217904164b2be7657df23d416a9d93b9e32f84b5002fc897d7ecff65ff"}
{"code": "for (auto p = 0; p < particles.size(); p++) \n    { \n        auto particle = particles[p]; \n \n        auto velocity = Helpers::ComputeParticleVelocity(grid, particle); \n \n        particle->MoveBy(DT * velocity.U, DT * velocity.V, DT * velocity.W); \n    }", "pragma": "parallel for ", "hash": "7e8431f1154ba3c6d7c9acb241a627e4a1014a375a892e6b8038b3089cb14360"}
{"code": "for(unsigned a=1;a<psize-1;a++){ \n      const Fragment *myfrag = &atom[s][a]; \n      if(myfrag->phi.size()==4){ \n        const Vector d0 = delta(getPosition(myfrag->phi[1]), getPosition(myfrag->phi[0])); \n        const Vector d1 = delta(getPosition(myfrag->phi[2]), getPosition(myfrag->phi[1])); \n        const Vector d2 = delta(getPosition(myfrag->phi[3]), getPosition(myfrag->phi[2])); \n        Torsion t; \n        Vector dd0, dd1, dd2; \n        atom[s][a].t_phi = t.compute(d0,d1,d2,dd0,dd1,dd2); \n        atom[s][a].dd0[0]  = dd0; \n        atom[s][a].dd10[0] = dd1-dd0; \n        atom[s][a].dd21[0] = dd2-dd1; \n        atom[s][a].dd2[0]  = dd2; \n      } \n      if(myfrag->psi.size()==4){ \n        const Vector d0 = delta(getPosition(myfrag->psi[1]), getPosition(myfrag->psi[0])); \n        const Vector d1 = delta(getPosition(myfrag->psi[2]), getPosition(myfrag->psi[1])); \n        const Vector d2 = delta(getPosition(myfrag->psi[3]), getPosition(myfrag->psi[2])); \n        Torsion t; \n        Vector dd0, dd1, dd2; \n        atom[s][a].t_psi = t.compute(d0,d1,d2,dd0,dd1,dd2); \n        atom[s][a].dd0[1]  = dd0; \n        atom[s][a].dd10[1] = dd1-dd0; \n        atom[s][a].dd21[1] = dd2-dd1; \n        atom[s][a].dd2[1]  = dd2; \n      } \n      if(myfrag->chi1.size()==4){ \n        const Vector d0 = delta(getPosition(myfrag->chi1[1]), getPosition(myfrag->chi1[0])); \n        const Vector d1 = delta(getPosition(myfrag->chi1[2]), getPosition(myfrag->chi1[1])); \n        const Vector d2 = delta(getPosition(myfrag->chi1[3]), getPosition(myfrag->chi1[2])); \n        Torsion t; \n        Vector dd0, dd1, dd2; \n        atom[s][a].t_chi1 = t.compute(d0,d1,d2,dd0,dd1,dd2); \n        atom[s][a].dd0[2]  = dd0; \n        atom[s][a].dd10[2] = dd1-dd0; \n        atom[s][a].dd21[2] = dd2-dd1; \n        atom[s][a].dd2[2]  = dd2; \n      } \n    }", "pragma": "parallel for ", "hash": "95526aac835be2bad962db1f6abff4c6b2ec39321d95874ed4dab8b4825831b4"}
{"code": "for ( int elmIdx = 0; elmIdx < elementCount; ++elmIdx ) \n        { \n            RigElementType elmType = femPart->elementType( elmIdx ); \n \n            int elmNodeCount = RigFemTypes::elementNodeCount( femPart->elementType( elmIdx ) ); \n \n            if ( elmType == HEX8P ) \n            { \n                for ( int elmNodIdx = 0; elmNodIdx < elmNodeCount; ++elmNodIdx ) \n                { \n                    size_t elmNodResIdx = femPart->elementNodeResultIdx( elmIdx, elmNodIdx ); \n                    if ( elmNodResIdx < evData.size() ) \n                    { \n                         \n \n                        double initialPermeability = 1.0; \n                        if ( initialPermeabilityData.empty() ) \n                        { \n                             \n \n                            initialPermeability = m_resultCollection->initialPermeabilityFixed(); \n                        } \n                        else \n                        { \n                             \n \n                            initialPermeability = initialPermeabilityData[elmIdx]; \n                        } \n \n                        int nodeIdx = femPart->nodeIdxFromElementNodeResultIdx( elmNodResIdx ); \n \n                         \n \n                        double voidr           = voidRatioData[elmNodResIdx]; \n                        double initialPorosity = voidr / ( 1.0 + voidr ); \n \n                         \n \n                         \n \n                        double deltaPorosity = 0.0; \n                        if ( fIdx != 0 ) \n                        { \n                             \n \n                             \n \n                            double referencePorePressure = referencePorFrameData[nodeIdx]; \n                            double framePorePressure     = porFrameData[nodeIdx]; \n                            double deltaPorePressure = \n                                RiaEclipseUnitTools::barToPascal( framePorePressure - referencePorePressure ); \n \n                             \n \n                            double poreCompressibility = poreCompressibilityFrameData[elmNodResIdx] / 1.0e9; \n \n                             \n \n                            double deltaEv = evData[elmNodResIdx] - referenceEvData[elmNodResIdx]; \n \n                             \n \n                            deltaPorosity = initialPorosity * ( poreCompressibility * deltaPorePressure + deltaEv ); \n                        } \n \n                         \n \n                        double currentPorosity = initialPorosity + deltaPorosity; \n \n                         \n \n                        double permeabilityExponent = m_resultCollection->permeabilityExponent(); \n                        double permeability = \n                            initialPermeability * std::pow( currentPorosity / initialPorosity, permeabilityExponent ); \n \n                        porosityFrameData[elmNodResIdx]      = currentPorosity; \n                        porosityDeltaFrameData[elmNodResIdx] = deltaPorosity; \n                        permeabilityFrameData[elmNodResIdx]  = permeability; \n                    } \n                } \n            } \n            else \n            { \n                for ( int elmNodIdx = 0; elmNodIdx < elmNodeCount; ++elmNodIdx ) \n                { \n                    size_t elmNodResIdx = femPart->elementNodeResultIdx( elmIdx, elmNodIdx ); \n                    if ( elmNodResIdx < poreCompressibilityFrameData.size() ) \n                    { \n                        porosityFrameData[elmNodResIdx]      = inf; \n                        porosityDeltaFrameData[elmNodResIdx] = inf; \n                        permeabilityFrameData[elmNodResIdx]  = inf; \n                    } \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "243217ab1f84d936a53f90b4c8587dc170337aa86654dfcce6dd8449e9e6df8c"}
{"code": "for (long long i = 0; i < 'z'; i += 1u) { \n    c[i] = a[i] + b[i]; \n  }", "pragma": "parallel for simd ", "hash": "cf90bde50905caee01eb6c0e2a393e9056f306e1e8cb1d829605f11c4aa9c474"}
{"code": "for( int i=0; i<ncomm; i++){ \n    int nsend0  = 0; \n    int dest = comm_inode[i]; \n    makeSendListWrapper( tree_tmp, maxx*maxx, this_run->bmin_all[dest], \n\t\t\t this_run->bmax_all[dest], &send_buf[sdispls[dest]], &nsend0, \n\t\t\t particle, treeparam, p_cache); \n    assert( nsend0 == nsend[dest]); \n  }", "pragma": "parallel for ", "hash": "ab56284360f306545b252d98af126ea7592ef8df2807cd409fb46460415b2121"}
{"code": "for (i=0; i< asize; i++) \n            A[i] = A[i] + B[i];", "pragma": "for ", "hash": "6843f3e1735f5c99ab7be4462d52cc6bd012687c23a2a2cdcfa6659ed8d1b103"}
{"code": "for (k = 1; k < nz-1; k++) { \n      for (j = jst; j < jend; j++) { \n        for (i = ist; i < iend; i++) { \n          for (m = 0; m < 5; m++) { \n            u[k][j][i][m] = u[k][j][i][m] + tmp2 * rsd[k][j][i][m]; \n          } \n        } \n      } \n    }", "pragma": "for ", "hash": "11be73ff1c1e55d067cde02cd40332d4a40d9228e4e2763b54898e1a3c3200f1"}
{"code": "for(int i=0;i<n->ptr1.size();++i) { \n\tint c=(i*s)%LUT; \n\tn->ptr1(i)+=mean+noisesd*gn[(c++)%LUT]; \n      }", "pragma": "parallel for ", "hash": "8e326113630b1ba191922f88dfef564ef7d91d7e72b4cde7d0359439965a80d0"}
{"code": "for(long i=0;i<nn;i++)\r \n\t\t{\tv = d->vthr(i);\tm = m>v ? v:m;\t}", "pragma": "for ", "hash": "23628f93790f136af1550b26c9ad78daf38cb13c393da549ec25819c1a49acb1"}
{"code": "for(int k = 0; k < 100000; k++) \n  { \n    void *data = (void *)(long int)k; \n    const int size = 0;  \n \n    const int con1 = dt_cache_contains(&cache, k); \n    const int val1 = (int)(long int)dt_cache_read_get(&cache, k); \n    const int val2 = (int)(long int)dt_cache_read_get(&cache, k); \n     \n \n     \n \n    const int con2 = dt_cache_contains(&cache, k); \n    assert(con1 == 0); \n    assert(con2 == 1); \n    assert(val2 == k); \n    dt_cache_read_release(&cache, k); \n    dt_cache_read_release(&cache, k); \n  }", "pragma": "parallel for ", "hash": "07326fb31f3290f192d9dc3d4c2925feda8d4995109e1078a0946f2e83253864"}
{"code": "for(unsigned int idx = 0; idx < out.size(); ++idx) \n            out[idx] += c*a[idx].cross(b[idx]);", "pragma": "parallel for ", "hash": "68c5b634362d6ceff4e0c99f56a80388a5acadc3ecd33460c5a5d52ba5820c41"}
{"code": "for (i = 0; i < LOOPCOUNT; ++i) \n            { \n                <ompts:check>#pragma omp atomic</ompts:check> \n                bit_and &= logics[i]; \n            }", "pragma": "for ", "hash": "e3b9bc19fe3653291f52a43ec6f28bad657ada3931b0100b107d622abfeca749"}
{"code": "for (int i = 0; i < nNodesinFirstComp; ++i) { \n            perm[inversePerm[i]] = i; \n        }", "pragma": "parallel for ", "hash": "262af3dce67dbe19e453855e11b377ea7cc4113f40809713adc05bc343549ad5"}
{"code": "for (i = 0; i < numberOfVertices; ++i) { \n\t\t\t\tlengthFromItoK = adyacencyMatrix.getEdgeLength(i, k); \n\t\t\t\tfor (j = 0; j < numberOfVertices; ++j) { \n\t\t\t\t\tif (i != j && i != k && j != k) { \n\t\t\t\t\t\tlengthFromItoKAndFromKToJ = lengthFromItoK + kthRow[j]; \n\t\t\t\t\t\tunsigned int minLength = min(lengthFromItoKAndFromKToJ, \n\t\t\t\t\t\t\t\tadyacencyMatrix.getEdgeLength(i, j)); \n\t\t\t\t\t\tadyacencyMatrix.setEdge(i, j, minLength); \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "for ", "hash": "23aac94c89ca2dfb3ad7e76eeec2870d1e81fb354ccc0bc1b85be9aec7fc618b"}
{"code": "for (j = 1; j <= grid_points[1]-2; j++) { \n      for (k = 1; k <= grid_points[2]-2; k++) { \n\trhs[m][i][j][k] = rhs[m][i][j][k]- dssp *  \n\t  ( 5.0*u[m][i][j][k] - 4.0*u[m][i+1][j][k] + \n\t    u[m][i+2][j][k]); \n      } \n    }", "pragma": "for ", "hash": "a75cc048e74b40f42480f246efddaebdfbef1f9b333cf48ae3fe3e9183c0adcb"}
{"code": "for (i = a; i < b; i += c) \n    for (j = d * i + e; j < g + i * f; j += h) \n      { \n\tif (i < 0 || i >= 10 || j < 0 || j >= 10 * i || k[i][j] != 2) \n\t  abort (); \n\tk[i][j]++; \n\tx = i * 1024 + (j & 1023); \n\tniters++; \n      }", "pragma": "parallel for reduction(+:niters) private(  i j x)", "hash": "a48749886048e4a27e2636a5942d266ddebe0048090f4986b1654da3cdcc2c36"}
{"code": "for( unsigned i = 0; i < s_buf.size(  ); ++ i ) \n    { \n\tconst double & s = s_buf[ i ]; \n\txi_s_0_buf[ i ] = outer_integration( 0, s ); \n\txi_s_2_buf[ i ] = outer_integration( 2, s ); \n\txi_s_4_buf[ i ] = outer_integration( 4, s ); \n \n\tstd::vector<double> wedge \n\t    ( wedge_mu_buf.size(  ) - 1 ); \n\tfor( unsigned j = 0; j + 1 < wedge_mu_buf.size(  ); \n\t     ++ j ) \n\t{ \n\t    const double mu_min = wedge_mu_buf[ j ]; \n\t    const double mu_max = wedge_mu_buf[ j + 1 ]; \n\t    wedge[ j ] \n\t\t= wedge_integration( mu_min, mu_max, s ); \n\t} \n\txi_wedge_buf[ i ] = wedge; \n    }", "pragma": "parallel for ", "hash": "03201d73446260c5ceaa89fa5167c8b655a98e7084ad6cf2a5c55d31ba2b1ddf"}
{"code": "for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1) ? length-1 : (start+block_size-1); \n        index_t tsum = (stop-start+1)*k; \n        for(index_t u = start; u <= stop; u++) \n            tsum += a[u]; \n        s[t] = tsum; \n    }", "pragma": "parallel for ", "hash": "7ae28b01cb81171cef1de0faf62a11360c2aea11385cbc3b972ac6f0777fb6c5"}
{"code": "for (i = 1; i < 100; i++) \n\t{ \n\t\tii = i; \n\t<ompts:orphan> \n<ompts:check>#pragma omp ordered</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\t\t{ \n\t\t\tis_larger = check_i_islarger2 (ii) && is_larger; \n\t\t\tsum  = sum + ii; \n\t\t} \n\t</ompts:orphan> \n\t}", "pragma": "parallel for private(i)", "hash": "a3ec319d195a2aecbca81a6bb9808f484ac934cf85e40af76b1bd60104719b54"}
{"code": "for (k=0; k<rsctrellis.numStates; k++) \n        { \n            cases = itpp::dec2bin(mem_len, k); \n             \n \n            feedback = (itpp::bin)n; \n            for (j=1; j<(mem_len+1); j++) \n            { \n                feedback ^= (gen(0,j)*cases[j-1]); \n            } \n             \n \n            out = feedback*gen(1,0); \n            for (j=1; j<(mem_len+1); j++) \n            { \n                out ^= (gen(1,j)*cases[j-1]); \n            } \n            rsctrellis.PARout[k+n*rsctrellis.numStates] = (out?1.0:0.0); \n \n         rsctrellis.fm[k] = itpp::bin(n)^out; \n             \n \n            for (j=mem_len-1; j>0; j--) \n            { \n                cases[j] = cases[j-1]; \n            } \n            cases[0] = feedback; \n             \n \n            buffer = itpp::bin2dec(cases, true); \n            rsctrellis.nextStates[k+n*rsctrellis.numStates] = buffer; \n \n            rsctrellis.prevStates[buffer+n*rsctrellis.numStates] = k; \n \n        }", "pragma": "parallel for private(     buffer cases feedback j k out)", "hash": "24eb1ab538c5fddae527e1d882c4c9e3a0e9009350294bd411869b370092ee33"}
{"code": "for (k = 0; k < nz; k++) { \n    zeta = ( (double)k ) / ( nz - 1 ); \n    for (j = 0; j < ny; j++) { \n      eta = ( (double)j ) / ( ny0 - 1 ); \n      for (i = 0; i < nx; i++) { \n        xi = ( (double)i ) / ( nx0 - 1 ); \n        for (m = 0; m < 5; m++) { \n          rsd[k][j][i][m] =  ce[m][0] \n            + (ce[m][1] \n            + (ce[m][4] \n            + (ce[m][7] \n            +  ce[m][10] * xi) * xi) * xi) * xi \n            + (ce[m][2] \n            + (ce[m][5] \n            + (ce[m][8] \n            +  ce[m][11] * eta) * eta) * eta) * eta \n            + (ce[m][3] \n            + (ce[m][6] \n            + (ce[m][9] \n            +  ce[m][12] * zeta) * zeta) * zeta) * zeta; \n        } \n      } \n    } \n  }", "pragma": "for ", "hash": "b40981b446bf84b4bbdf5545dd248b37d659745770d6dcc0cecb8ab4c04048b6"}
{"code": "for(int y=0;y<theRamCanvas.getNumPixY();y++) { \n    if ((y%100)==0) \n#     pragma omp critical \n      std::cout << \"line \" << y << \" of \" << IMGSIZ << std::endl; \n    for(int x=0;x<theRamCanvas.getNumPixX();x++) { \n      std::complex<double> z = theRamCanvas.int2real(x, y); \n      double minAngleDelta1 = std::numbers::pi; \n      double minAngleDelta2 = std::numbers::pi; \n      double minAngleDelta3 = std::numbers::pi; \n      for(int count=0; count<MAXITR; count++) { \n        double modz = std::abs(z); \n        if (modz<ZROEPS) \n          break; \n        z = z-(z*z*z-1.0)/(z*z*3.0); \n        double curAngle = std::arg(z); \n        double curAngleDelta1 = std::abs(ang12-curAngle); \n        double curAngleDelta2 = std::abs(ang13-curAngle); \n        double curAngleDelta3 = std::min(std::abs(curAngle-ang23), std::abs(curAngle+ang23)); \n        if(curAngleDelta1 < minAngleDelta1) minAngleDelta1 = curAngleDelta1; \n        if(curAngleDelta2 < minAngleDelta2) minAngleDelta2 = curAngleDelta2; \n        if(curAngleDelta3 < minAngleDelta3) minAngleDelta3 = curAngleDelta3; \n        if ((modz<ZROEPS) || (std::abs(z-r1)<ZROEPS) || (std::abs(z-r2)<ZROEPS) || (std::abs(z-r3)<ZROEPS)) \n          break; \n      } \n      rcccT r = static_cast<rcccT>(50.0*std::log(minAngleDelta1)/normer); \n      rcccT g = static_cast<rcccT>(50.0*std::log(minAngleDelta2)/normer); \n      rcccT b = static_cast<rcccT>(50.0*std::log(minAngleDelta3)/normer); \n      theRamCanvas.drawPoint(x, y, rcT::colorType(r, g, b)); \n    } \n  }", "pragma": "parallel for ", "hash": "97a112992c8932f3f7b85e30d54dd41959a1299b4ce693625d6868c8924c5a5c"}
{"code": "for (int y = 0; y < static_cast<int>(outRows); y++) \n    { \n        const float sy = y * dy; \n        const int iy1 =      (  y   * inRows) / outRows; \n        const int iy2 = std::min(((y+1) * inRows) / outRows, inRows-1); \n \n        for (size_t x = 0; x < outCols; x++) \n        { \n            const float sx = x * dx; \n            const int ix1 =      (  x   * inCols) / outCols; \n            const int ix2 = std::min(((x+1) * inCols) / outCols, inCols-1); \n \n            outputData[x + y*outCols] = (((ix1+1) - sx)*((iy1+1 - sy)) * inputData[ix1 + iy1*inCols] + \n                                         ((ix1+1) - sx)*(sy+dy - (iy1+1)) * inputData[ix1 + iy2*inCols] + \n                                         (sx+dx - (ix1+1))*((iy1+1 - sy)) * inputData[ix2 + iy1*inCols] + \n                                         (sx+dx - (ix1+1))*(sy+dx - (iy1+1)) * inputData[ix2 + iy2*inCols])*factor; \n        } \n    }", "pragma": "parallel for ", "hash": "4c496c4c783f34e87aeefafc46f0a77dfc2bf57dc3825b01fc8a58fded7cda39"}
{"code": "for(int x = 0; x < nX; x++) { \n               for(int y = 0; y < nY; y++) { \n                  for(int e = 0; e < nEns; e++) { \n                     float value = (*output)(y, x, e); \n                     float sigmaValue = (*sigmaTransformed)(y, x, e); \n                      \n \n                     if(Util::isValid(value)) { \n                        if(sigmaValue==0 || value<transform(mBoxCoxThreshold)) { \n                          (*output)(y, x, e) = invTransform(value); \n                        } \n                        else { \n                           float f = pow(mLambda * value + 1, 1 / mLambda); \n                           float f2 = pow((1 - mLambda) * (mLambda * value + 1), 1 / mLambda - 2); \n                           if(x == mX && y == mY) { \n                               \n \n                              std::cout <<  (*sigmaTransformed)(y, x, e) << \" \" <<  (*output)(y, x, e) \n                                 << \" \" << f << \" \" << f2 <<  \" \" << f + 0.5 * (*sigmaTransformed)(y, x, e) * \n                                 f2 << std::endl; \n                           } \n                           (*output)(y, x, e) = f + 0.5 * sigmaValue * f2; \n                        } \n                     } \n                  } \n               } \n            }", "pragma": "parallel for ", "hash": "35d86555da530d266de4be19b30d55d330c0cadc2ff88b4502ec896c042afca0"}
{"code": "for (bigint t = 0; t < N; t += chunk_size) { \n        Mda32 chunk; \n#pragma omp critical(compute_templates_in_parallel1) \n        { \n            X.readChunk(chunk, 0, t - clip_size, M, chunk_size + 2 * clip_size); \n        } \n        Mda sums0; \n        Mda counts0; \n        get_sums_and_counts_for_templates(sums0, counts0, chunk, t - clip_size, times, labels, clip_size, K); \n#pragma omp critical(compute_templates_in_parallel2) \n        { \n            for (bigint i = 0; i < M * T * K; i++) { \n                sums.set(sums.get(i) + sums0.get(i), i); \n            } \n            for (int i = 0; i < K; i++) { \n                counts.set(counts.get(i) + counts0.get(i), i); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "d7d8b0abd51c0958099f6044778fecb254d479024c2fefeabeb731a25ec26042"}
{"code": "for(index i = 0; i < mat->nbrows; i++) \n\t\t{ \n\t\t\tfor(index j = mat->browptr[i]; j < mat->browptr[i+1]; j++) \n\t\t\t\tiluvals[j] = scale[i]*mat->vals[j]*scale[mat->bcolind[j]]; \n\t\t\tfor(index j = mat->browptr[i]; j < mat->diagind[i]; j++) \n\t\t\t\tiluvals[j] *= 1.0/(mat->vals[mat->diagind[mat->bcolind[j]]] \n\t\t\t\t                   * scale[mat->diagind[mat->bcolind[j]]] \n\t\t\t\t                   * scale[mat->diagind[mat->bcolind[j]]]); \n\t\t}", "pragma": "parallel for ", "hash": "269132649bec211d9a4af112fc24e2919031d252806274c67b19fd569c6f3b8a"}
{"code": "for (int y = 0; y < m_height; y++) { \n            for (int x = 0; x < m_width; x++) { \n                int yy = m_height - 1 - y; \n \n                dst[yy * m_width + x].r() = (uint8_t)aten::clamp(m_colors[y * m_width + x].x * real(255), real(0), real(255)); \n                dst[yy * m_width + x].g() = (uint8_t)aten::clamp(m_colors[y * m_width + x].y * real(255), real(0), real(255)); \n                dst[yy * m_width + x].b() = (uint8_t)aten::clamp(m_colors[y * m_width + x].z * real(255), real(0), real(255)); \n            } \n        }", "pragma": "parallel for ", "hash": "bf86aa513e6d12e36d64ba0e04f914ea0178422fcc38be8e168baed5f7e1319c"}
{"code": "for( site = 0 ; site < LCU ; site++ ) { \n\t \n\t \n \n        struct spinor SUM_r2[ Nprops ] ; \n\tsum_spatial_sep( SUM_r2 , M , site ) ; \n\t\t \n\tsize_t GSGK ; \n\tfor( GSGK = 0 ; GSGK < flat_dirac ; GSGK++ ) { \n\t  const size_t GSRC = GSGK / stride1 ; \n\t  const size_t GSNK = GSGK % stride2 ; \n\t  #ifdef TWOPOINT_FILTER \n\t  if( !filter[ GSRC ][ GSNK ] ) continue ; \n\t  #endif \n\t   \n\t  const struct gamma gt_GSNKdag_gt = gt_Gdag_gt( M.GAMMAS[ GSNK ] ,  \n\t\t\t\t\t\t\t M.GAMMAS[ GAMMA_T ] ) ; \n\t  M.in[ GSGK ][ site ] =  \n\t    meson_contract( gt_GSNKdag_gt    , SUM_r2[1] ,  \n\t\t\t    M.GAMMAS[ GSRC ] , SUM_r2[0] ,  \n\t\t\t    M.GAMMAS[ GAMMA_5 ] ) ; \n\t} \n      }", "pragma": "for private(site)", "hash": "1b266c133555fd7078ca8d2b3f077700021f5495176b797fdd4895d524c0a2a5"}
{"code": "for (int32_t i = 1; i <= height; i++) { \n      const int32_t* top_left = int_img + (i - 1) * width_; \n      const int32_t* top_right = top_left + rect_width_ - 1; \n      const int32_t* bottom_left = top_left + rect_height_ * width_; \n      const int32_t* bottom_right = bottom_left + rect_width_ - 1; \n      int32_t* dest = rect_sum + i * width_; \n \n      *(dest++) = (*bottom_right) - (*top_right); \n      seeta::fd::MathFunction::VectorSub(bottom_right + 1, top_right + 1, dest, width); \n      seeta::fd::MathFunction::VectorSub(dest, bottom_left, dest, width); \n      seeta::fd::MathFunction::VectorAdd(dest, top_left, dest, width); \n    }", "pragma": "for ", "hash": "077841a415cd09425cab5d022bfaef9b5a9b8bf4d1ef24e00aaf7d0cf57fa5a5"}
{"code": "for (i = 0; i <= n; ++i) \n    { \n        #pragma omp atomic \n        x += i; \n    }", "pragma": "for ", "hash": "c341ddf3fe8f812bd6b54dc0a15b2fa3c428c214034bd22d2a0cfbb16f3bac16"}
{"code": "for (int i = 0; i < n; ++i) { \n        w[i] = x[i] + y[i]; \n      }", "pragma": "parallel for ", "hash": "a6878dfae3e100c10c6f304cb4a28c1b7017e8d2085d231f7442d7a6bf8f6efb"}
{"code": "for (usint i = 0; i < size; i++) { \n                 \n \n                dggBigVectorPvt.push_back(dgg.GenerateInteger(modulus)); \n            }", "pragma": "for ", "hash": "cb457a75e3e4fd0a81481001c786181f221af4fe3de7351a9b04ab70dd2c9edd"}
{"code": "for (std::size_t i = 0; i < x.size(); ++i) { \n            x[i] *= alpha; \n        }", "pragma": "parallel for ", "hash": "c16f39e921736bd13e70f8fd79aa0605222fe5d585254b9e568db8fb026e4c8e"}
{"code": "for (size_t uiI = 0; uiI < m_uiN; uiI++) \n\t\t{ \n\t\t\tvRet.m_lpdValues[uiI] = m_lpdValues[uiI] * i_vRHO.m_lpdValues[uiI]; \n\t\t}", "pragma": "for ", "hash": "6dfbc37287c5583223cd9d03934c9155638831fbd84d0f8183d56a2762d8495d"}
{"code": "for (i = 1; i <= n; i++) \n    for (j = 1; j <= m; j++) { \n      data[i][j] -= mean[j]; \n      data[i][j] /= sqrt(float_n) * stddev[j]; \n    }", "pragma": "for private(j)", "hash": "0a3849e4797c17463a06b4f668a132568f0394a18b59f524c19f706d414e3452"}
{"code": "for (__int64 i=0; i<nb_q_neighbors; i++) \n\t{ \n\t\t \n \n\t\tcurrentI = q_neighbors_array[i]; \n \n\t\t \n \n\t\tfor(std::map<__int64, double>::iterator it1 = adjacencies[currentI].begin(); it1 != adjacencies[currentI].end(); it1++) \n\t\t{ \n\t\t\t \n \n\t\t\tcurrentJ = it1->first; \n \n\t\t\tif(currentJ != nbdata-1)\t \n \n\t\t\t{ \n \n\t\t\t\t \n \n    #pragma omp critical(add_edge) \n\t\t\t\t{ \n\t\t\t\t\tedges.insert(new Edge(currentI, currentJ, it1->second)); \n\t\t\t\t} \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tfor(std::map<__int64, double>::iterator it2 = adjacencies[currentJ].begin(); it2 != adjacencies[currentJ].end(); it2++) \n\t\t\t\t{ \n\t\t\t\t\t \n \n\t\t\t\t\tcurrentK = it2->first; \n \n\t\t\t\t\tif(currentK != currentI)\t \n \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n      #pragma omp critical(add_edge) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tedges.insert(new Edge(currentJ, currentK, it2->second)); \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tfor(std::map<__int64, double>::iterator it3 = adjacencies[currentK].begin(); it3 != adjacencies[currentK].end(); it3++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tcurrentL = it3->first; \n \n\t\t\t\t\t\t\tif(currentL != currentJ)\t \n \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t \n \n        #pragma omp critical(add_edge) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tedges.insert(new Edge(currentK, currentL, it3->second)); \n\t\t\t\t\t\t\t\t} \n \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t}  \n \n\t\t\t} \n\t\t}  \n \n\t}", "pragma": "parallel for private(currenti currentj currentk currentl)", "hash": "78b310e0c935654109ff2b0d9bd05b907cee9da9d8d98217e660328d825dac78"}
{"code": "for (size_t i = start_i; i < stop_i; i += step) \n        { \n            cc_i = i / step; \n            cc_sum[cc_sum_offset + cc_i] = network_corr_precise(templates_t, \n                                                                sum_square_templates_t, \n                                                                moveouts_t, \n                                                                data + i, \n                                                                weights_t, \n                                                                n_samples_template, \n                                                                n_samples_data, \n                                                                n_stations, \n                                                                n_components, \n                                                                normalize); \n        }", "pragma": "parallel for private(cc_i)", "hash": "5895db9280f914a366420376d3b5b673400d8f3a2a23592b64867c75d501b0f4"}
{"code": "for (int l = 0; l < L; l++) { \n        exptab(psi[l], expPsi[l], model_->n_states(l)); \n    }", "pragma": "parallel for ", "hash": "920f547f968bdea2ee9c00f43d17cf1d4cedf10015ffb602eac0f0ee58571939"}
{"code": "for(int i = 0; i < nLat; i++) { \n      for(int j = 0; j < nLon; j++) { \n         int I = nearestI[i][j]; \n         int J = nearestJ[i][j]; \n         for(int e = 0; e < nEns; e++) { \n            if(Util::isValid(I) && Util::isValid(J)) { \n               iOutput(i,j,e) = iInput(I, J, e); \n            } \n            else \n               iOutput(i,j,e) = Util::MV; \n         } \n      } \n   }", "pragma": "parallel for ", "hash": "d982c0b60c793ce52a3f1f0caa0dedebe720d8797473758aaca25836da88fc8e"}
{"code": "for (int64_t i = 0; i < n; ++i) { \n  #pragma omp atomic update \n\t\tsum += i; \n\t}", "pragma": "parallel for ", "hash": "978ec4377d23c2d026f8f2c3bbc3f532441824e0cfbdc1892e6752186cf5202d"}
{"code": "for (OMPInt i = 0; i < c0->N_Elements(); ++i) { \n            (*p0D[0])[i] = (*c0)[i].real(); \n            (*p0D[1])[i] = (*c0)[i].imag(); \n        }", "pragma": "for ", "hash": "1ea272a56f369518f4a104d3235281a2e48d72d94c226e38fd5264d2f1dd5a34"}
{"code": "for(ipp=0;ipp<par->cstm[ipop]->num_pix;ipp++) { \n      par->cstm[ipop]->data[ipp]=0; \n      par->cstm[ipop]->nadd[ipp]=1; \n    }", "pragma": "for ", "hash": "beb50f0849c190c3df8e8701f706a0e471cfc9b50fe0421187bc34bfe44c65ea"}
{"code": "for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n    { \n      out[k] = MIN(clip, in[k]); \n    }", "pragma": "parallel for simd ", "hash": "40c3aae0757437de006028388c0f126bb16e2ade876dd52f4ee4712388a03b8b"}
{"code": "for (q = 0; q < sg->nnodes; q++) \n                if (color[q] != BLACK) { \n                    if (pathval[p] < pathval[q]) { \n                        if (!opf_PrecomputedDistance) \n                            weight = opf_ArcWeight(sg->node[p].feat, sg->node[q].feat, sg->nfeats); \n                        else \n                            weight = opf_DistanceValue[sg->node[p].position][sg->node[q].position]; \n                        if (weight < pathval[q]) { \n                            pathval[q] = weight; \n                            sg->node[q].pred = p; \n                        } \n                    } \n                    if (nextP[threadId] == -1 || pathval[q] < pathval[nextP[threadId]]) \n                        nextP[threadId] = q; \n                }", "pragma": "for ", "hash": "c8c8e44828fd28bb813363be69d00a9138419ddb8506b79ba8e2fca3a38ba5e9"}
{"code": "for (int i = 0; i < interval; ++i) { \n\t\tconst double scale = pow(2.0, -static_cast<double>(i) / interval); \n\t\t \n\t\tJPEGImage scaled = image.rescale(scale); \n\t\t \n\t\t \n \n\t\tHog(scaled, levels_[i], padx, pady, 4); \n\t\t \n\t\t \n \n\t\tif (i + interval <= maxScale) \n\t\t\tHog(scaled, levels_[i + interval], padx, pady, 8); \n\t\t \n\t\t \n \n\t\tfor (int j = 2; i + j * interval <= maxScale; ++j) { \n\t\t\tscaled = scaled.rescale(0.5); \n\t\t\tHog(scaled, levels_[i + j * interval], padx, pady, 8); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "51ee38bf853248cc1c8da3e42ab9839ebb12436e30d7c1940d3b326a6727928e"}
{"code": "for (i2 = 0; i2 < j; i2++) \n        { \n            float tmp = a[j][i2]; \n            a_jj -= tmp * tmp; \n        }", "pragma": "simd for reduction(-:a_jj) private(i2)", "hash": "1bc59141a38e5406b6df86da6cf3a7711f07851148667dcaf5f5ef7cf8b4be33"}
{"code": "for (ompIndexType i = 0; i < ompIndexType(2) * ompIndexType(cN); i++) { \n        dp[i] /= ((single)Narg); \n    }", "pragma": "parallel for ", "hash": "8aa2f9dee8312a310b531027fd4ae7a125b7cca895cc13d09c1a9ad40dc064ae"}
{"code": "for (int j=0; j<SIZE; j++) \n            { \n                b[j] = scalar * c[j]; \n            }", "pragma": "for ", "hash": "8f2fff34d8fc635442ed6d697c4a555f470a12d9ce873dd62dea9c02dd858955"}
{"code": "for (ix = 1; ix < xsize; ix++) { \n\t\tr01 = rhot[s][(ix-1)*ysize]; \n\t\tr11 = rhot[s][ix*ysize]; \n\t\tfor (iy = 1; iy < ysize; iy++) { \n\t\t\tr00 = r01; \n\t\t\tr10 = r11; \n\t\t\tr01 = rhot[s][(ix-1)*ysize+iy]; \n\t\t\tr11 = rhot[s][ix*ysize+iy]; \n\t\t\tmid = r10 + r00 + r11 + r01; \n\t\t\tvxt[s][ix][iy] = -2 * (r10-r00+r11-r01) / mid; \n\t\t\tvyt[s][ix][iy] = -2 * (r01-r00+r11-r10) / mid; \n\t\t} \n\t}", "pragma": "parallel for private(      ix iy mid r00 r01 r10 r11)", "hash": "85fadfcafd6d3c1b3575a42fd0f4f1e4930a3b490ef7aa33fbf0a67e0d3d89f6"}
{"code": "for(long k=0;k<d->nz;k++)\tfor(long j=0;j<d->ny;j++)\tfor(long i=0;i<d->nx;i++) \n\t\t\td->a[i+d->nx*(j+d->ny*k)] = a->v(i,j,k);", "pragma": "parallel for ", "hash": "05e78ab0724ce82d39c988fd69e2bd17abec3c7ad93609bf273b255280fc9bd3"}
{"code": "for (size_t idx = 0; idx < dim; idx++) { \n    dst[idx] /= xs[idx]; \n  }", "pragma": "parallel for ", "hash": "dcc241146d2eb254d974e0643b8b170f41f81377245bcee81a36384ca3626e12"}
{"code": "for (top = 2; top < height - 5; top += LIBRAW_AHD_TILE - 6) \n    { \n      if (0 == omp_get_thread_num()) \n        if (callbacks.progress_cb) \n        { \n          int rr = (*callbacks.progress_cb)(callbacks.progresscb_data, \n                                            LIBRAW_PROGRESS_INTERPOLATE, \n                                            top - 2, height - 7); \n          if (rr) \n            terminate_flag = 1; \n        } \n      for (left = 2; !terminate_flag && (left < width - 5); \n           left += LIBRAW_AHD_TILE - 6) \n      { \n        ahd_interpolate_green_h_and_v(top, left, rgb); \n        ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab); \n        ahd_interpolate_build_homogeneity_map(top, left, lab, homo); \n        ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo); \n      } \n    }", "pragma": "for ", "hash": "f06fedbba0b39c30211934e0a5ccd0121f52ff038f96971fa0146580eb07d630"}
{"code": "for (int i = 0; i < source.channels(); i++) { \n \n        LUTs[i] = build_LUT([new_power](uchar bright) \n                    { \n                        float koef = std::pow(0.9, new_power); \n                        float real_val = 255 * std::pow((float)bright / 255.0, \n                                                        koef); \n                        return cv::saturate_cast<uchar>(real_val); \n                    }); \n    }", "pragma": "parallel for ", "hash": "13cc8a51919246f90e52b6db3b0eef89b2834afe1c3288086d806451b8dd494d"}
{"code": "for ( int k = 0; k < sChunk; k++ ) \n      { \n         if ( ( i + k ) >= TrainPairs.rows ) \n           continue; \n          \n \n         if ( TrainPairs.at<int32_t>( i + k, 1 ) \n          ==  TrainPairs.at<int32_t>( i + k, 3 ) ) \n           Label.at<uchar>( k ) = 1; \n         else \n           Label.at<uchar>( k ) = 0; \n         { \n           #pragma omp atomic \n           chunk++; \n         } \n      }", "pragma": "parallel for ", "hash": "48dcd6d6338fe3da40e4fd586ec52edff0ea38e98f089937a36da6eac4cf73ec"}
{"code": "for (iz=1; iz<=nz; iz++) { \n\t\t\tp[sizem+n1+iz] = 0.0; \n\t\t}", "pragma": "for private(iz)", "hash": "d8cc4f7f39d63420181add3571cc294b5c8c1676542c8ac4fa71ec6e46d3ced9"}
{"code": "for (int i = 0; i < size; i++) { \n   void * m = malloc(GIGABYTE); \n   memset(m,0,GIGABYTE); \n \n}", "pragma": "for ", "hash": "bb6699918d4ef4db72a3839331b54a491b410c2545b64447e4959d2b50a82de4"}
{"code": "for (i = 0; i < samples; ++i) \n\t{ \n\t\ts_time += inter; \n \n\t\tdelta = static_cast<double>(i)* inv_samples; \n \n\t\tt = s_time * delta; \n \n\t\tt2 = s_time + delta; \n \n\t\tvenv.operator[](i) = params.envelope((TWO_PI * efreq * t2) + (0.25 * TWO_PI)); \n\t\ta_phase.operator[](i) = (TWO_PI * cfreq * t) + (0.10 * TWO_PI); \n\t\tvsin.operator[](i).operator=({ t, venv.operator[](i) * ::sin(a_phase.operator[](i)) }); \n \n \n\t\t \n \n \n \n\t}", "pragma": "parallel for reduction(+:s_time) private(   delta i t t2)", "hash": "b92f2675d5e8709b2cf50efb2942e699d4279fdbdf6d0754e9cd2a30104a4aef"}
{"code": "for (i=0; i<N*SPIN*ORB; i++)\t \n\t\t\tfor (k=0; k<N*SPIN*ORB; k++){ \n\t\t\t\tgsl_complex h = gsl_matrix_complex_get (Hso, i, k); \n\t\t\t\tdouble l = gsl_vector_get (eval ,k); \n\t\t\t\tgsl_complex z = gsl_complex_rect(0,5e-3);  \n \n\t\t\t\tgsl_complex num = gsl_complex_mul(h,gsl_complex_conjugate(h));  \n \n\t\t\t\tgsl_complex den = gsl_complex_add_real(z, w-l);  \n \n\t\t\t\tgsl_complex g = gsl_complex_div(num,den); \n\t\t\t\tdos += GSL_IMAG(g); \n\t\t\t}", "pragma": "for reduction(+:dos) private(i k)", "hash": "b1157fdb2a8e5524653fbe7010f25ec46ba0878f370d4c783ab8fad89154678c"}
{"code": "for (i32 = 0; i32 < size2*size3; ++i32) \n\t{ \n\t\tint i2 = i32 % size2; \n\t\tint i3 = i32 / size2; \n\t\tint i1; \n\t\tfor (i1 = 0; i1 < outSize1; ++i1) \n\t\t{ \n\t\t\tout[i3*outSkip3 + i2*outSkip2 + i1*skip1] = 0.0f; \n\t\t\tint k; \n\t\t\tfor (k = 0; k < filterLen; ++k) \n\t\t\t{ \n\t\t\t\tint out_i1 = 2*i1+1 - (filterLen-1) + k; \n\t\t\t\tif (out_i1 < 0) out_i1 = -out_i1-1; \n\t\t\t\tif (out_i1 >= size1) out_i1 = size1-1 - (out_i1-size1); \n \n\t\t\t\tout[i3*outSkip3 + i2*outSkip2 + i1*skip1] += in[i3*skip3 + i2*skip2 + out_i1*skip1] * filter[filterLen-1-k]; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "e3d894150c786d81a7b2e869470ef86b65b2597b947283e1509d58bd3c0a4f4f"}
{"code": "for (unsigned j=0; j < npart; j++) { \n             \n \n            float q_r = 0; \n            for (unsigned k=0; k < dimension; k++) { \n                q_r += *(float*)PyArray_GETPTR2(q, i, k) * *(float*)PyArray_GETPTR2(r, j, k); \n            } \n             \n \n            sin_sum += sinf(q_r);   \n \n            cos_sum += cosf(q_r); \n        }", "pragma": "parallel for reduction(+:sin_sum cos_sum) ", "hash": "8294c5b1288269b9fdebcf9b35d43e2fb517b8b0fa0979848b4089782e52de66"}
{"code": "for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i) \n  { \n    make_rbdiag(i); \n  }", "pragma": "parallel for ", "hash": "4e180761273b36447f1e04144817455a21aea45d200e6ddd2906e92c941e5778"}
{"code": "for(index=0;index<targetVoxelNumber; index++){ \n \n            intensity=0.0; \n \n            if(maskPtr[index]>-1){ \n                world[0]=(FieldTYPE) deformationFieldPtrX[index]; \n                world[1]=(FieldTYPE) deformationFieldPtrY[index]; \n \n                 \n \n                voxel[0] = world[0]*sourceIJKMatrix->m[0][0] + world[1]*sourceIJKMatrix->m[0][1] + \n                        sourceIJKMatrix->m[0][3]; \n                voxel[1] = world[0]*sourceIJKMatrix->m[1][0] + world[1]*sourceIJKMatrix->m[1][1] + \n                        sourceIJKMatrix->m[1][3]; \n \n                if( voxel[0]>=0.0f && voxel[0]<(FieldTYPE)(sourceImage->nx-1) && \n                        voxel[1]>=0.0f && voxel[1]<(FieldTYPE)(sourceImage->ny-1)) { \n \n                    previous[0] = (int)voxel[0]; \n                    previous[1] = (int)voxel[1]; \n                     \n \n                    relative=voxel[0]-(FieldTYPE)previous[0]; \n                    if(relative<0) relative=0.0;  \n \n                    xBasis[0]= (FieldTYPE)(1.0-relative); \n                    xBasis[1]= relative; \n                     \n \n                    relative=voxel[1]-(FieldTYPE)previous[1]; \n                    if(relative<0) relative=0.0;  \n \n                    yBasis[0]= (FieldTYPE)(1.0-relative); \n                    yBasis[1]= relative; \n \n                    for(b=0; b<2; b++){ \n                        Y= previous[1]+b; \n                        xyPointer = &sourceIntensity[Y*sourceImage->nx+previous[0]]; \n                        xTempNewValue=0.0; \n                        for(a=0; a<2; a++){ \n                            xTempNewValue +=  (FieldTYPE)*xyPointer * xBasis[a]; \n                            xyPointer++; \n                        } \n                        intensity += (xTempNewValue * yBasis[b]); \n                    } \n                } \n                else intensity = bgValue; \n            } \n \n            switch(sourceImage->datatype){ \n            case NIFTI_TYPE_FLOAT32: \n                resultIntensity[index]=(SourceTYPE)intensity; \n                break; \n            case NIFTI_TYPE_FLOAT64: \n                resultIntensity[index]=(SourceTYPE)intensity; \n                break; \n            case NIFTI_TYPE_UINT8: \n                resultIntensity[index]=(SourceTYPE)(intensity>0?round(intensity):0); \n                break; \n            case NIFTI_TYPE_UINT16: \n                resultIntensity[index]=(SourceTYPE)(intensity>0?round(intensity):0); \n                break; \n            case NIFTI_TYPE_UINT32: \n                resultIntensity[index]=(SourceTYPE)(intensity>0?round(intensity):0); \n                break; \n            default: \n                resultIntensity[index]=(SourceTYPE)round(intensity); \n                break; \n            } \n        }", "pragma": "parallel for private(                 a b index intensity previous relative voxel world xbasis xtempnewvalue xypointer y ybasis)", "hash": "c92ad4dd77a525946b6ccc8a2c9a854e65e4bd07b3fafb27d983c9cac62403fe"}
{"code": "for( mu = 0 ; mu < ND ; mu++ ) { \n      size_t a , b ; \n      for( a = 0 ; a < NCNC ; a++ ) { \n\tb = 2 * ( a + mu * NCNC ) ; \n\taout[ b ] = (double)creal( A[ list[i].idx ].O[mu][a] ) ; \n\taout[ b + 1 ] = (double)cimag( A[ list[i].idx ].O[mu][a] ) ; \n      } \n    }", "pragma": "parallel for private(mu)", "hash": "9d354103c99167d5b65504b960bfabf477480efe80e2f24bdda1f4e3bef72531"}
{"code": "for(rowcol=0;rowcol<N;rowcol++){ \n\t\tqa = mod11A1a(l3[rowcol]); \n\t\tif( qa == 0 || qa == 1 ) lOut[rowcol] = (l2[rowcol]*0.02)+0.00627*l1[rowcol]; \n\t\telse lOut[rowcol] = -28768; \n\t}", "pragma": "parallel for private( qa rowcol)", "hash": "8532bd4d2e5afab98ef210e3ccd97f0e4b1457e3a569af31b84152453d366165"}
{"code": "for(long j=0;j<ny;j++)\tfor(long k=0;k<nz;k++)\tfor(long i=0;i<nx;i++) \n\t\t\tb[i+nx*(k+nz*j)] = a[i+nx*(j+ny*k)];", "pragma": "parallel for ", "hash": "861b89c3311049bb3d060b1b2e1f1ebc205d007e0c2d878d9c572c4eca4ea800"}
{"code": "for (int i = 0; i < numx; ++i) { \n        for (int j = 0; j < numy; ++j) { \n            for (int k = 0; k < numz; ++k) { \n                double voxelx = xmin + grid_size * i; \n                double voxely = ymin + grid_size * j; \n                double voxelz = zmin + grid_size * k; \n                 \n \n                 \n \n                Point3d voxelpt(voxelx, voxely, voxelz); \n                unsigned int odd_cnt = 0; \n                for (auto &pt : pt_vec) { \n                     \n \n                    Ray ray_query(voxelpt, pt); \n                    unsigned int cnt = aabbtree.number_of_intersected_primitives(ray_query); \n \n                    odd_cnt += (cnt % 2); \n                } \n                voxel_grid[i + j * numx + k * num_pixels] = (odd_cnt > 3); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "9bb7ff9975d23af2fbc8cbaa4a763fc8a6dcc8543cad666d92edf804c66a82c2"}
{"code": "for (uint i = 0; i < (uint) m; i++) { \n \n    DatasetInstance* R_i = NULL; \n\t\tif (randomlySelect) { \n\t\t\t \n \n\t\t\tR_i = dataset->GetRandomInstance(); \n\t\t} else { \n\t\t\t \n \n\t\t\t \n \n\t\t\tuint instanceIndex; \n\t\t\tdataset->GetInstanceIndexForID(instanceIds[i], instanceIndex); \n\t\t\tR_i = dataset->GetInstance(instanceIndex); \n\t\t} \n\t\tif (!R_i) { \n\t\t\terror(\"ERROR: Random or indexed instance count not be found for index: [\" \n\t\t\t\t\t+ int2str(i) + \"]\\n\"); \n\t\t} \n \n\t\t \n \n\t\t \n \n\t\tvector<uint> nNearestNeighbors; \n\t\tbool canGetNeighbors = R_i->GetNNearestInstances(k, nNearestNeighbors); \n\t\tif (!canGetNeighbors) { \n\t\t\terror(\"ERROR: Cannot get \" + int2str(k) + \" nearest neighbors\\n\"); \n\t\t} \n\t\t \n \n\t\tif (nNearestNeighbors.size() < 1) { \n\t\t\terror(\"ERROR: No nearest hits found\\n\"); \n\t\t} \n\t\tif (nNearestNeighbors.size() < k) { \n\t\t\terror(\"ERROR: Could not find enough neighbors\\n\"); \n\t\t} \n \n\t\t \n \n\t\tfor (uint j = 0; j < k; ++j) { \n\t\t\t \n \n\t\t\tDatasetInstance* I_j = dataset->GetInstance(nNearestNeighbors[j]); \n\t\t\tdouble diffPredicted = diffPredictedValueTau(R_i, I_j); \n\t\t\tdouble d_ij = R_i->GetInfluenceFactorD(j); \n#pragma omp critical \n      { \n        ndc += (diffPredicted * d_ij); \n      } \n\t\t\tuint scoresIndex = 0; \n       \n \n\t\t\t \n \n\t\t\tfor (uint attrIdx = 0; attrIdx < numAttributes; \n\t\t\t\t\t++attrIdx) { \n\t\t\t\tuint A = attributeIndices[attrIdx]; \n\t\t\t\tdouble attrScore = snpDiffFuncPtr(A, R_i, I_j) * d_ij; \n#pragma omp critical \n        { \n          nda[scoresIndex] += attrScore; \n          ndcda[scoresIndex] += (diffPredicted * attrScore); \n        } \n        if(par::algorithm_verbose) { \n          cout << \"(i, j) = (\" << i << \",\" << j << \") =>\" \n                  << \" diff predicted: \" << diffPredicted \n                  << \", d_ij: \" << d_ij \n                  << \", ndc: \" << ndc \n                  << \", A: \" << A \n                  << \", snpDiff: \" << snpDiffFuncPtr(A, R_i, I_j) \n                  << \", nda[A}: \" << nda[scoresIndex] \n                  << \" ndcda[A]: \" << ndcda[scoresIndex] \n                  << endl; \n        } \n\t\t\t\t++scoresIndex; \n\t\t\t} \n       \n \n\t\t\t \n \n\t\t\tfor (uint numIdx = 0; numIdx < numericIndices.size(); ++numIdx) { \n\t\t\t\tuint N = numericIndices[numIdx]; \n\t\t\t\tdouble numScore = numDiffFuncPtr(N, R_i, I_j) * d_ij; \n#pragma omp critical \n        { \n          nda[scoresIndex] += numScore; \n          ndcda[scoresIndex] += (diffPredicted * numScore); \n        } \n        if(par::algorithm_verbose) { \n          cout << \"(i, j) = (\" << i << \",\" << j << \") =>\" \n                  << \" diff predicted: \" << diffPredicted \n                  << \", d_ij: \" << d_ij \n                  << \", N: \" << N \n                  << \", snpDiff: \" << numDiffFuncPtr(N, R_i, I_j) \n                  << \", nda[N}: \" << nda[scoresIndex] \n                  << \" ndcda[N]: \" << ndcda[scoresIndex] \n                  << endl; \n        } \n\t\t\t\t++scoresIndex; \n\t\t\t} \n\t\t} \n\t\t \n \n\t\tif (i && ((i % 100) == 0)) { \n\t\t\tPP->printLOG(Timestamp() + int2str(i) + \"/\" + int2str(m)  + \"\\n\"); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "8470c699ea3f66571c555ea9353fd0fb24ef118b8ff79ecff0f6fdf0ee81d33b"}
{"code": "for (p = bodytab; p < bodytab+nbody; p++) {  \n \n        mtot += Mass(p);                         \n \n        DOTVP(velsq, Vel(p), Vel(p));            \n \n        etot[1] += 0.5 * Mass(p) * velsq;        \n \n        etot[2] += 0.5 * Mass(p) * Phi(p);       \n \n        MULVS(tmpv, Vel(p), 0.5 * Mass(p));      \n \n        OUTVP(tmpt, tmpv, Vel(p)); \n        ADDM(keten, keten, tmpt); \n        MULVS(tmpv, Pos(p), Mass(p));            \n \n        OUTVP(tmpt, tmpv, Acc(p)); \n        ADDM(peten, peten, tmpt); \n        CROSSVP(tmpv, Vel(p), Pos(p));           \n \n        MULVS(tmpv, tmpv, Mass(p)); \n        ADDV(amvec, amvec, tmpv); \n        MULVS(tmpv, Pos(p), Mass(p));            \n \n        ADDV(cmpos, cmpos, tmpv); \n        MULVS(tmpv, Vel(p), Mass(p));            \n \n        ADDV(cmvel, cmvel, tmpv); \n    }", "pragma": "parallel for private(p)", "hash": "d1d6c5247642b7dce96b9c5ddf56af1233fe28aa1b93f6817eb012977372e0c6"}
{"code": "for(std::size_t b = this->nParticles; b < this->nSpstates; b++){ \n      for(std::size_t i = 0; i < this->nParticles; i++){ \n        for(std::size_t j = 0; j < this->nParticles; j++){ \n          std::size_t sp_a; \n          if(spIndexExists_from3Body(b,i,j) && (sp_a = spIndex_from3Body(b,i,j)) >= this->nParticles ){ \n            #pragma omp atomic \n            this->threeBodyChanDims[sp_a].phhDim++; \n          } \n        }  \n \n      }  \n \n    }", "pragma": "for ", "hash": "e72cda7f1c99f751df9ccca0828b0c6431d7862320fe1f370bc2f8b6466b5c96"}
{"code": "for (i = 0; i < num_docs; i++) { \n                        uint32_t clusterid; \n                        if (fast_scoring) { \n                            clusterid = assign_cluster_fast(i, \n                                                            docs, \n                                                            num_clusters, \n                                                            tfreqs, \n                                                            cluster_centers, \n                                                            prefixsums, \n                                                            cfreqs, \n                                                            cfreqs_prefixsums, \n                                                            scorebuf); \n                        } else { \n                            clusterid = assign_cluster(i, \n                                                       docs, \n                                                       num_clusters, \n                                                       tfreqs, \n                                                       cluster_centers, \n                                                       prefixsums, \n                                                       cfreqs, \n                                                       cfreqs_prefixsums, \n                                                       scorebuf); \n                        } \n                        cluster_assignments[i] = clusterid; \n                        localclustercount[clusterid]++; \n                        localscore += scorebuf[clusterid]; \n                    }", "pragma": "for ", "hash": "cbcc9a744ec64aca10d0fce7490cc9e418fb1e82250990029d7de6ada2cccfef"}
{"code": "for (OMPInt i = 0; i < nEl; ++i) { \n          MultOmitNaN(prod, (*src)[ i]); \n        }", "pragma": "for reduction(*:prod) ", "hash": "52af160803b6d4574449acb0edd663ce89ccc8d3a96e9aa40983154c2b26af3a"}
{"code": "for(unsigned int j=0; j<NumInputs; j++) \n\t\t{ \n\t\t\tfor(unsigned int i=0; i<sourceNDTHere[j].size(); i++) \n\t\t\t{ \n\t\t\t\tif(sourceNDTHere[j][i]!=NULL) \n\t\t\t\t\tdelete sourceNDTHere[j][i]; \n\t\t\t} \n\t\t\tsourceNDTHere[j].clear(); \n\t\t\tfor(unsigned int i=0; i<sourceNDT[j].size(); i++) \n\t\t\t{ \n\t\t\t\tNDTCell *cell = sourceNDT[j][i]; \n\t\t\t\tif(cell!=NULL) \n\t\t\t\t{ \n\t\t\t\t\tEigen::Vector3d mean = cell->getMean(); \n\t\t\t\t\tEigen::Matrix3d cov = cell->getCov(); \n\t\t\t\t\tmean = ps*mean; \n\t\t\t\t\tcov = ps.rotation()*cov*ps.rotation().transpose(); \n\t\t\t\t\tNDTCell* nd = (NDTCell*)cell->copy(); \n\t\t\t\t\tnd->setMean(mean); \n\t\t\t\t\tnd->setCov(cov); \n\t\t\t\t\tsourceNDTHere[j].push_back(nd); \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "d02088812df8bb4f1b15bd6dac38713dbe539d950b65cf17dd4137d51340bda8"}
{"code": "for (i = 0; i < n; i++) \n\t\t{  \n\t\t\tsuma = suma + a[i]; \n\t\t\tprintf(\" thread %d suma a[%d]=%d suma=%d \\n\", omp_get_thread_num(),i,a[i],suma); \n\t\t}", "pragma": "for private(suma suma)", "hash": "81dda331302dc0cc05b9e14f2c11d86e3c5e7aae4e31f1d16cfc2e9b7b6ae324"}
{"code": "for (int l = 0; l < levIndices.size() - 1; ++l) { \n    int levelBegin = levIndices[l], levelEnd = levIndices[l + 1]; \n    int *b = &bBuffer[0]; \n \n    sort(&reversePerm[levelBegin], &reversePerm[levelEnd]); \n \n     \n \n    int nnz = 0; \n    for (int i = levelBegin; i < levelEnd; ++i) { \n      b[i] = nnz; \n      nnz += costFunction.getCostOf(reversePerm[i]); \n    } \n    int nnzPerThread = (nnz + nthreads - 1)/nthreads; \n \n    int prevEnd = levelBegin; \n    int r = levelBegin; \n    nnz = 0; \n    int t; \n    for (t = 0; t < nthreads; ++t) { \n      int newr = lower_bound(&b[r], &b[levelEnd], (t + 1)*nnzPerThread) - &b[0]; \n      if (aggregateForVectorization) { \n         \n \n        if (0 == t) { \n          r = min(r + (newr - r + 7)/8*8, levelEnd); \n        } \n        else { \n          r = min(r - 1 + (newr - r + 1 + 7)/8*8, levelEnd); \n        } \n      } \n      else { \n        r = newr; \n      } \n       \n \n         \n \n       \n \n       \n \n \n      int begin = prevEnd; \n      int end = min(r, levelEnd); \n      prevEnd = end; \n \n      taskRows[t*(levIndices.size() - 1) + l] = make_pair(begin, end); \n      if (aggregateForVectorization && end >= levelEnd) break; \n \n       \n \n       \n \n         \n \n      ++r;  \n \n    }  \n \n \n    if (aggregateForVectorization) { \n       \n \n       \n \n \n       \n \n       \n \n      for (int i = t; i >= 0; --i) { \n        taskRows[(nthreads - 1 - t + i)*(levIndices.size() - 1) + l] = \n          taskRows[i*(levIndices.size() - 1) + l]; \n      } \n       \n \n      for (int i = 0; i < nthreads - t - 1; ++i) { \n        taskRows[i*(levIndices.size() - 1) + l] = make_pair(levelBegin, levelBegin); \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "c76f2b9f357088f9471fcd2f5ccf14e8bc23869d69f5c58502341522672f20b6"}
{"code": "for (int i=0; i < m_header.channels; i++) {\r \n\t\t\t\t \n \n\t\t\t\tif (error == NoError) {\r \n\t\t\t\t\tOSError err = m_wtChannel[i]->InverseTransform(m_currentLevel, &m_width[i], &m_height[i], &m_channel[i]);\r \n\t\t\t\t\tif (err != NoError) error = err;\r \n\t\t\t\t}\r \n\t\t\t\tASSERT(m_channel[i]);\r \n\t\t\t}", "pragma": "parallel for ", "hash": "f8cebf4ad79443eb8d1236e81ad97820a4fa48e9ce1023e56338797ba35c7a5d"}
{"code": "for (s=0; s<Nsink; s++) { \n \n       \n \n      if (!ParticleInBox(*(sink[s].star), mydomain)) continue; \n \n       \n \n      do { \n        Nlist = neibsearch->GetGatherNeighbourList \n         (sink[s].star->r, sink[s].radius, partdata, hydro->Nhydro, Nneibmax, neiblist); \n \n         \n \n         \n \n        if (Nlist == -1) { \n          delete[] rsqdlist; \n          delete[] neiblist; \n          delete[] ilist; \n          Nneibmax *= 2; \n          ilist = new int[Nneibmax]; \n          neiblist = new int[Nneibmax]; \n          rsqdlist = new FLOAT[Nneibmax]; \n        }; \n \n      } while (Nlist == -1); \n \n       \n \n      for (j=0; j<Nlist; j++) { \n        i = neiblist[j]; \n        Particle<ndim>& part = hydro->GetParticlePointer(i); \n        if (part.flags.is_dead()) continue; \n \n        for (k=0; k<ndim; k++) dr[k] = part.r[k] - sink[s].star->r[k]; \n        drsqd = DotProduct(dr, dr, ndim); \n \n        if (drsqd <= sink[s].radius*sink[s].radius) { \n#pragma omp critical \n          part.sinkid = s; \n          sink[s].Ngas++; \n        } \n \n      } \n \n    }", "pragma": "for ", "hash": "b723c62300f126c6075faac250ed8a47ff3ab7c60ccf7aa6e8395b92d1ed7a0e"}
{"code": "for (int k = 1; k < nz-1; ++k) { \n        for (int j = 1; j < ny-1; ++j) { \n          for (int i = (k+j+1 % 2); i < nx-1; i+=2) { \n            int ix = i*dx + j*dy + k*dz; \n            int _ix = 3*ix; \n            half *_d = d + _ix; \n            half *_b = b + _ix; \n            half const *_sigma = sigma + ix; \n            half *_phi = phi + ix; \n \n            half p = half(1.0/6.0) * ( _sigma[0] \n              + _phi[dx] + _phi[-dx] + _phi[dy] + _phi[-dy] + _phi[dx] + _phi[-dz] \n              + _b[0] - _b[0-_dx] + _b[1] - _b[1-_dy] + _b[2] - _b[2-_dz] \n              - _d[0] + _d[0-_dx] - _d[1] + _d[1-_dy] - _d[2] + _d[2-_dz] ); \n \n            _phi[0] = p > half(1.0) ? half(1.0) : (p < half(0.0) ? half(0.0) : p); \n          } \n        } \n      }", "pragma": "for ", "hash": "de0438544a4e0ec29cc54015d8f0883ae1d505c472407d66a2e5ae6a43fb00bb"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t    (*res)[i] = ((*right)[i] == (*left)[i]);", "pragma": "for ", "hash": "988a960ca38679632209a94a5a40c87c0d6646e4dbd15bf57cfb418c84a77a9f"}
{"code": "for (uint32_t i = req.sim_ids.front(); i <= req.sim_ids.back(); ++i) { \n         \n \n        sim_vect_[i]->doStep(); \n      }", "pragma": "parallel for ", "hash": "1fb1c4e9438b51bde686f5fac593bd41cb8aec48a5c243ac1e5c7cdd1c439272"}
{"code": "for (iz=0; iz < Nz; iz++) { \n            ic = iz * Ncx; \n            ir = iz * Nrx; \n            fftwf_execute_dft_r2c(fwdx,&RX[ir],&CX[ic]); \n            for (ix=0; ix < Ncx; ix++) \n                CX[iz*Ncx + ix] *= DX[ix]; \n            fftwf_execute_dft_c2r(invx,&CX[ic],&RX[ir]); \n        }", "pragma": "parallel for private(ic ir ix iz)", "hash": "14a464f81eb47d6d733e91efad60c55b61d7fcfa32360ceb6f37afe6cc64678a"}
{"code": "for (batch = 0; batch < numBatch; ++batch) { \n      THNN_(SpatialFractionalMaxPooling_updateGradInput_frame)( \n        THTensor_(data)(gradInput) + batch * numPlanes * inputH * inputW, \n        THTensor_(data)(gradOutput) + batch * numPlanes * outputH * outputW, \n        THIndexTensor_(data)(indices) + batch * numPlanes * outputH * outputW, \n        numPlanes, inputW, inputH, outputW, outputH); \n    }", "pragma": "parallel for private(batch)", "hash": "fbfa8047eecf5e54e84cb31843dbd67f06bbcd464936ac6778b5c0c9c6e57622"}
{"code": "for (i = 1; i <= RESN; i++) \n    for (j = 1; j <= RESN; j++) \n      solution[next_gen][i][j] = solution[cur_gen][i][j] + \n\t(solution[cur_gen][i + 1][j] + \n\t solution[cur_gen][i - 1][j] + \n\t solution[cur_gen][i][j + 1] + \n\t solution[cur_gen][i][j - 1] - \n\t 4.0 * solution[cur_gen][i][j]) * diff_constant;", "pragma": "parallel for private(i j)", "hash": "af692bc2bbfce14700b6f3bbb3b5294313e653012b1155ff03562192c96f2573"}
{"code": "for (uint attIdx = 0; attIdx < numAttributes; ++attIdx) { \n    uint A = attributeIndices[attIdx]; \n    string attributeName = attributeNames[A]; \n#pragma omp critical \n    { \n      double tempW = (ndcda[scoresIdx] / ndc) -  \n        ((nda[scoresIdx] - ndcda[scoresIdx]) / (dblM - ndc)); \n      if(std::isnan(tempW)) { \n        error(\"WARNING: detected [NaN] in weight calculation, using zero instead\\n\"); \n        W[scoresIdx] = 0.0; \n      } else { \n        W[scoresIdx] = tempW; \n      } \n      scores.push_back(make_pair(W[scoresIdx], attributeName)); \n      ++scoresIdx; \n       \n \n      if (attIdx && ((attIdx % 100) == 0)) { \n        PP->printLOG(Timestamp() + int2str(attIdx) + \"/\" + int2str(numAttributes)  + \"\\n\"); \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "b734a3c6de2fb11cc4ee0831850636e380984465951f580eb9f38d65cea6126d"}
{"code": "for( int64_t ii = 0; ii < creatures_end ; ++ii ){ \n      int nclose = 0; \n      for ( int64_t jj = ii ; jj < creatures_end ; ++jj){ \n          if (are_close_enough(creatures_[ii] , creatures_[jj])) ++nclose; \n          if ( ii != jj ) { \n#pragma omp critical \n{ \n             boost::optional<being> new_b = reproduce( creatures_[ii] , creatures_[jj] ) ; \n             if (new_b) { \n                being b2(new_b); \n                add(b2);  \n} \n             }; \n          }; \n      }; \n      if (nclose > 4) creatures_[ii].make_inhibited(); \n      else creatures_[ii].remove_inhibition(); \n      creatures_[ii].mutation(); \n      creatures_[ii].older(); \n      creatures_[ii].die(); \n   }", "pragma": "parallel for ", "hash": "d3af0066981f498d7c6caa30591ce1a346893875d8f5b5796f4a5e050ee9f0ed"}
{"code": "for(iz=0;iz<par->nz_here;iz++) { \n      int iy; \n      int inu=0; \n      double z0=dx*(iz+par->iz0_here+0.5)-par->pos_obs[2]; \n      lint indexz=iz*((lint)(2*(par->n_grid/2+1)*par->n_grid)); \n      for(iy=0;iy<par->n_grid;iy++) { \n\tint ix; \n\tdouble y0=dx*(iy+0.5)-par->pos_obs[1]; \n\tlint indexy=(lint)(iy*2*(par->n_grid/2+1)); \n\tfor(ix=0;ix<par->n_grid;ix++) { \n\t  int isub; \n\t  lint index=ix+indexy+indexz; \n\t  double x0=dx*(ix+0.5)-par->pos_obs[0]; \n\t  double mass_sub=par->grid_dens[index]/N_SUBPART; \n\t   \n \n\t  double dz_rsd=(double)(par->grid_rvel[index]); \n \n\t  for(isub=0;isub<N_SUBPART;isub++) { \n\t    double x=x0+x_sub[isub]; \n\t    double y=y0+y_sub[isub]; \n\t    double z=z0+z_sub[isub]; \n\t    double r=sqrt(x*x+y*y+z*z); \n\t    double redshift=z_of_r(par,r)+dz_rsd; \n\t    double nu=NU_21/(1+redshift); \n\t    inu=get_inu(par,nu,inu); \n \n\t    inu=(int)(inv_dnu*(nu-par->nu_min)); \n \n\t    if((inu>=0)&&(inu<par->n_nu)) { \n\t      long ipix; \n\t      double pos[3]={x,y,z}; \n\t     \n\t      vec2pix_ring(par->n_side,pos,&ipix); \n#pragma omp atomic \n \n\t      par->maps_HI[ipix+n_pix_ang*inu]+=mass_sub; \n\t    } \n\t  } \n\t} \n      } \n    }", "pragma": "for ", "hash": "98161dc20fa2761b1881d01c3bdfe94083e1c9333aa0edd40e382fabf029d13c"}
{"code": "for (int i = 0; i < keys.size(); i++){ \n             \n \n            vector<hash_t> r = calc_hashes(seqs[i], lengths[i], kmer); \n            hashes[i] = &(*r.begin()); \n            hash_lengths[i] = r.size(); \n             \n \n            { \n                for (int j = 0; j < hash_lengths[i]; j++){ \n#pragma omp critical  \n \n                    ++read_hash_to_depth[ hashes[i][j] ]; \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "7e272dbfabf0ceb58e0ae37c77b0e5f7712b2041f0f0b5e45b5c2b9e24a7b87f"}
{"code": "for (int i=1; i<Nspl; ++i) { \n      zval[i] = 0.0 + i*(zmax-0.0)/Nspl; \n      cval[i] = chi(zval[i]); \n    }", "pragma": "parallel for ", "hash": "32857b9bc3110583eb7a442ce6cc3e6ff0a932d47d86fd130425e9ce75a0c993"}
{"code": "for(int X = 0; X < iLength; X++) {\t \n \n\t\t\tif(Y == X)\t{\t\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tcontinue; \n\t\t\t} \n\t\t\telse { \n\t\t\t\tfloat fSum = 0.f; \n\t\t\t\tfor(unsigned int i = 0; i < m_pTrainingData->GetNrElements(); i++) { \n\t\t\t\t\tfSum += m_pTrainingData->GetInput(i)[X] * m_pTrainingData->GetInput(i)[Y]; \n\t\t\t\t} \n\t\t\t\tpMat[X*iLength+Y] = fSum; \n\t\t\t\tpMat[Y*iLength+X] = fSum; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "a15d25d34ac453bbd123876586cd3f32058d5a07245359a084285b8d9d01bb0b"}
{"code": "for(int g = 0; g < (int) genes.size(); ++g){ \n    fprintf(stderr, \"average BFs of %s\\n\", genes[g].name_.c_str()); \n     \n     \n \n    if(model == \"configs\") \n      genes[g].avg_raw_bfs(grid_weights, grid_idx_to_keep, config_weights); \n    else if(model == \"types\") \n      genes[g].avg_raw_bfs(grid_weights, grid_idx_to_keep, type_weights, subgroup_weights); \n     \n     \n \n    if(find(quantities_to_save.begin(), quantities_to_save.end(), \"post\") \n       != quantities_to_save.end()){ \n       \n      if(find(post_probas_to_save.begin(), post_probas_to_save.end(), \"a\") \n\t != post_probas_to_save.end()) \n\tgenes[g].calc_posterior(pi0); \n       \n      if(find(post_probas_to_save.begin(), post_probas_to_save.end(), \"b\") \n\t != post_probas_to_save.end()) \n\tgenes[g].calc_cond_snp_posteriors_the_eQTL(); \n       \n      if(find(post_probas_to_save.begin(), post_probas_to_save.end(), \"c\") \n\t != post_probas_to_save.end()) \n\tgenes[g].calc_cond_snp_posteriors_an_eQTL(); \n       \n      if(save_best_dim || save_all_dims){ \n\tif(model == \"configs\") \n\t  genes[g].calc_cond_snp_posteriors_config(config_weights); \n\telse if(model == \"types\") \n\t  genes[g].calc_cond_snp_posteriors_type(type_weights); \n      } \n       \n      if(find(post_probas_to_save.begin(), post_probas_to_save.end(), \"d\") \n\t != post_probas_to_save.end()){ \n\tif(model == \"configs\"){ \n\t  if(! (save_best_dim || save_all_dims)) \n\t    genes[g].calc_cond_snp_posteriors_config(config_weights); \n\t  genes[g].calc_cond_snp_posteriors_subgroup(config_names, \n\t\t\t\t\t\t     config2subgroups); \n\t} \n\telse if(model == \"types\") \n\t  genes[g].calc_cond_snp_posteriors_subgroup(type_weights, \n\t\t\t\t\t\t     subgroup_weights, \n\t\t\t\t\t\t     grid_weights, \n\t\t\t\t\t\t     grid_idx_to_keep); \n      } \n    }  \n \n     \n    genes[g].identify_best_snps(save_best_snps); \n     \n  }", "pragma": "parallel for ", "hash": "5e1799ae4f97e011fd515bea81dd405fc171d304c6a9e9191c8f0af5a7910161"}
{"code": "for (i = 0; i < h; ++i) { \n        (*g)[i][w-1] = (*g)[i][1]; \n        (*g)[i][0] = (*g)[i][w-2]; \n    }", "pragma": "parallel for ", "hash": "d6c7cb76b3d268570772cc7a1eebf1756f2859e27df6dcda8e5467b76b942d0b"}
{"code": "for (int i = 0; i < n; ++i) \n    { \n        result += x[i] + y[i]; \n    }", "pragma": "parallel for reduction(+:result) ", "hash": "9a0f5424ff23c9af077eeae439a3a369573a775835626307a815a1e898c74ba5"}
{"code": "for (unsigned i = 0; i < candidatesSize; ++i) { \n\t\t\t\tauto c = candidates[i]; \n\t\t\t\tdouble sim = jaccardSimilarity(t, c); \n\t\t\t\tif (sim > maxPair.first && sim >= SIM_THRESHOLD) { \n\t\t\t\t\tmaxPair = make_pair(sim, c); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for reduction(pair_max:maxpair) ", "hash": "ea44a64490dc122313f5400793a70d4852d1ddb230614dc31b22255ebf9abe31"}
{"code": "for (int y = 0; y < patch_size_; ++y) { \n        for (int x = 0; x < patch_size_; ++x) { \n          label.at<float>(y, x) = \n              label_mask_probability_[label.at<float>(y, x)] >= randprob() ? \n                  label.at<float>(y, x) : -1.0; \n        } \n      }", "pragma": "for ", "hash": "c58bb4903ab4652869f22e8d85109769d49fd1fa57a7d3cb4c33350e05d4456a"}
{"code": "for (i=0;i<shape[0];i++){ \n\t\tindex1=i*tempstep; \n\t\tfor (j=0;j<shape[1];j++){ \n\t\t\tindex2=index1+j*shape[2]; \n\t\t\tfor (k=0;k<sl;k++){ \n\t\t\t\tindex3=index2+k; \n\t\t\t\tpp=matrix+index3; \n\t\t\t\trpp=result+index3; \n\t\t\t\trpp[0]=weight[0]*pp[0]; \n\t\t\t\tfor (l=-sl;l<-k;l++)\t\trpp[0]+=weight[-l]*pp[indhere1[-l]]; \n\t\t\t\tfor (l=-k;l<0;l++)\t\t\trpp[0]+=weight[-l]*pp[l]; \n\t\t\t\tfor (l=1;l<=sl;l++)\t\t\trpp[0]+=weight[l]*pp[l]; \n\t\t\t} \n\t\t\tfor (k=sl;k<shape[2]-sl;k++){ \n\t\t\t\tindex3=index2+k; \n\t\t\t\tpp=matrix+index3; \n\t\t\t\trpp=result+index3; \n\t\t\t\trpp[0]=weight[0]*pp[0]; \n\t\t\t\tfor (l=1;l<=sl;l++)\t\t\trpp[0]+=weight[l]*(pp[-l]+pp[l]); \n\t\t\t} \n\t\t\tfor (k=shape[2]-sl;k<shape[2];k++){ \n\t\t\t\tindex3=index2+k; \n\t\t\t\tpp=matrix+index3; \n\t\t\t\trpp=result+index3; \n\t\t\t\trpp[0]=weight[0]*pp[0]; \n\t\t\t\tfor (l=-sl;l<0;l++)\t\t\trpp[0]+=weight[-l]*pp[l]; \n\t\t\t\tfor (l=1;l<shape[2]-k;l++)\trpp[0]+=weight[l]*pp[l]; \n\t\t\t\tfor (l=shape[2]-k;l<=sl;l++)\trpp[0]+=weight[l]*pp[-indhere1[l]]; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(index1 index2 index3 j k l pp rpp sl weight)", "hash": "fb26b4ef1b106cb92ffe2c6d464b391d7b1bdaad3f34d1cc685895cf4ba96d55"}
{"code": "for ( int j=0 ; j<n4 ; j+=4 ) { \n                    for ( int i=0 ; i<n4 ; i+=4 ) { \n                        double a00, a01, a02, a03; \n                        double a10, a11, a12, a13; \n                        double a20, a21, a22, a23; \n                        double a30, a31, a32, a33; \n \n                        double b00, b01, b02, b03; \n                        double b10, b11, b12, b13; \n                        double b20, b21, b22, b23; \n                        double b30, b31, b32, b33; \n \n                        a00 = A[(j  )*n+i  ]; \n                        a01 = A[(j  )*n+i+1]; \n                        a02 = A[(j  )*n+i+2]; \n                        a03 = A[(j  )*n+i+3]; \n                        a10 = A[(j+1)*n+i  ]; \n                        a11 = A[(j+1)*n+i+1]; \n                        a12 = A[(j+1)*n+i+2]; \n                        a13 = A[(j+1)*n+i+3]; \n                        a20 = A[(j+2)*n+i  ]; \n                        a21 = A[(j+2)*n+i+1]; \n                        a22 = A[(j+2)*n+i+2]; \n                        a23 = A[(j+2)*n+i+3]; \n                        a30 = A[(j+3)*n+i  ]; \n                        a31 = A[(j+3)*n+i+1]; \n                        a32 = A[(j+3)*n+i+2]; \n                        a33 = A[(j+3)*n+i+3]; \n \n                        b00=a00; b01=a10; b02=a20; b03=a30; \n                        b10=a01; b11=a11; b12=a21; b13=a31; \n                        b20=a02; b21=a12; b22=a22; b23=a32; \n                        b30=a03; b31=a13; b32=a23; b33=a33; \n \n                        B[(i  )*n+j  ] = b00; \n                        B[(i  )*n+j+1] = b01; \n                        B[(i  )*n+j+2] = b02; \n                        B[(i  )*n+j+3] = b03; \n                        B[(i+1)*n+j  ] = b10; \n                        B[(i+1)*n+j+1] = b11; \n                        B[(i+1)*n+j+2] = b12; \n                        B[(i+1)*n+j+3] = b13; \n                        B[(i+2)*n+j  ] = b20; \n                        B[(i+2)*n+j+1] = b21; \n                        B[(i+2)*n+j+2] = b22; \n                        B[(i+2)*n+j+3] = b23; \n                        B[(i+3)*n+j  ] = b30; \n                        B[(i+3)*n+j+1] = b31; \n                        B[(i+3)*n+j+2] = b32; \n                        B[(i+3)*n+j+3] = b33; \n                    } \n                    for ( int i=n4 ; i<n ; i++ ) \n                        B[i*n+j] = A[j*n+i]; \n                }", "pragma": "for private(i j n4)", "hash": "d41616695e5f2ae6bd98c1202782c7fcd3bdd9fe0e8352ec8ccef8ddbfe004f7"}
{"code": "for (int j = 0; j < (int) neglam.size(); j++) \n          neglam[j] *= (negpred[bestind][j] == 0) ? corw : incorw;", "pragma": "parallel for ", "hash": "37f9d33d090b1ca356eb39f1cbdfba470bf79555d922655b0d73ea56f5cfe5e8"}
{"code": "for(int i = 0; i < size; i++) \n    nPos += (int)actual[i];", "pragma": "parallel for reduction(+:npos) ", "hash": "e91733fb656cc1bacdfb2e528b6ff2f1d36329f5c1693f183a9d1508f0cefc8b"}
{"code": "for (unsigned int c = 0; c < nCam_; c++) { \n        std::vector<float> tri_rat_filter(nTri_); \n        const std::vector<float>& tri_ratings = _cam_tri_ratings[c]; \n        for (unsigned int i = 0; i < nTri_; i++) { \n             \n            if (tri_ratings[i] != 0) { \n \n                 \n \n                float sumneighbors = 0;  \n                for (std::list<int>::iterator it = _tri2tri[i].begin(); it != _tri2tri[i].end(); ++it){ \n                    sumneighbors += tri_ratings[*it]; \n                } \n                tri_rat_filter[i] = sumneighbors/_tri2tri[i].size(); \n            } else { \n                tri_rat_filter[i] = 0; \n            } \n        } \n \n        _cam_tri_ratings[c] = tri_rat_filter; \n \n    }", "pragma": "parallel for ", "hash": "8c3b394324d37dd17a7194a1a98b81a83c1dd6eb92732d43f60ef403f45b1638"}
{"code": "for(long k=0;k<m;k++)\tfor(long i=0;i<n;i++)\td->a[i+n*k] /= a->vthr(i);", "pragma": "parallel for ", "hash": "e4c683be6fe95bee667112b3a111bd2a994d4e2a486dba26c111d4284e5369f9"}
{"code": "for (int i = 0; i < numHiddenUnits; i++) \n  { \n    float sum = 0.0; \n    for (int j = 0; j < numInputs; j++) \n    { \n      sum += weights[i * numInputs + j] * input[j]; \n    } \n    output[i] = sigmoidTransform(sum + biases[i]); \n  }", "pragma": "parallel for ", "hash": "fd4dbd39debc64a22181ee3146a4f8c26a2eb73c21fb47df1c32c028674352b4"}
{"code": "for (i = 0; i < n; i++){ \n    for (j = 0; j < n; j++) { \n      angle = 2.0*M_PI*i*j/ (( double ) n); \n      A[i][j] = s * ( sin ( angle ) + cos ( angle ) ); \n      B[j][i] =  A[i][j]; \n    } \n  }", "pragma": "for ", "hash": "7022f7454fa75fa6df5fc8c35807a6e2397a1a58c7a0da722a2ac910de104d8a"}
{"code": "for (int i = 0; i < n_Y_col_; ++i){ \n        Y_.col(i) = solver_.solve(pre_rhs_ * Mt_.col(i)); \n    }", "pragma": "for ", "hash": "192e1817192d336df13f0d9a9a7dec6014eaa2a475c82f57b15854982531e33e"}
{"code": "for (i=0; i< updates_per_unit; i++) { \n                    pran = (pran << 1) ^ ((int64_t) pran < 0 ? POLY : 0); \n                    Table[pran & (TableSize-1)] ^= pran; \n                }", "pragma": "for ", "hash": "1ec6ea239ab942aa96b92dca150721b5d389901dcb5e34227e83374aecea5062"}
{"code": "for(int i = 0; i < samples.size(); ++i) { \n\t\t \n \n\t\tfor(int k = 0; k < n(i); ++k) \n\t\t\tif(rand() / static_cast<double>(RAND_MAX) < p(i)) \n\t\t\t\tsamples(i) += 1; \n\t}", "pragma": "parallel for ", "hash": "3488a6a271a32c7ed6f738f8c3c80822b7b849492fc85ab76733220ae9f3ed56"}
{"code": "for (i = 0; i < faceqty; i++) \n    if (Tess.FaceVerQty[faces[i]] > 0) \n    { \n      face = faces[i]; \n \n      if (Tess.Dim != 2 && !strcmp (Tess.Type, \"periodic\") \n          && Tess.PerFaceMaster[face]) \n        nem_meshing_2d_face_per (Tess, *pNodes, N, M, N + face, M + face, \n                                 master_id + face, &bnodes, &lbnodes, \n                                 &bnodeqty, face); \n    }", "pragma": "parallel for private(face i)", "hash": "90bd699dd4eec6615f2c819c198efed85621fb5b72f49cb7c5bbb34816629953"}
{"code": "for(int j=0;j<K;j++) \n\t\t{ \n\t\t\tgt[i][j] = tmp[j].index; \n\t\t}", "pragma": "parallel for ", "hash": "1d52c86e96aaafc66a21f940ad43b2f5033881f39830d99a213c3ac891390d6f"}
{"code": "for (int z = _zmin; z < _zmax - 1; z++) \n    for (int y = _ymin; y < _ymax - 1; y++) \n      for (int x = _xmin; x < _xmax - 1; x++) { \n        int index = z * _slabSize + y * _xRes + x; \n        int idx = indexMap[index]; \n        if (idx >= 0) { \n          mv.segment<3>(idx * 3) += _mass[index] * _velocity[index]; \n          energy += 0.5 * _mass[index] * _velocity[index].dot(_velocity[index]); \n        } \n      }", "pragma": "parallel for reduction(+ : energy) ", "hash": "1b84ff10cfa2a1c71b9d61eed0afc5ae2d478538d49fccb98c902591d676b1d2"}
{"code": "for (int part_i = 0; part_i < static_cast<int>(part_cnt); ++part_i) { \n                    const float * part_i_pos = reinterpret_cast<const float*>( \n                        static_cast<const unsigned char*>(dat_cur[list_i].parts.GetVertexData())  \n                        + dat_cur[list_i].parts.GetVertexDataStride() * part_i); \n                    part_i_available[part_i] = true; \n                    part_j_available[part_i] = true; \n                    for (unsigned int part_j = 0; part_j < part_cnt; ++part_j) { \n                        const float * part_j_pos = reinterpret_cast<const float*>( \n                            static_cast<const unsigned char*>(dat_prev[list_i].parts.GetVertexData())  \n                            + dat_prev[list_i].parts.GetVertexDataStride() * part_j); \n                         \n \n                        double dist = part_sqdist(part_i_pos, part_j_pos, bboxsize); \n                        if (part_i == part_j) dist *= diag_bonus_fac; else dist += off_diag_malus; \n                        sqdists[part_i + part_j * part_cnt].d = dist; \n                        sqdists[part_i + part_j * part_cnt].i = part_i; \n                        sqdists[part_i + part_j * part_cnt].j = part_j; \n                    } \n                }", "pragma": "parallel for ", "hash": "86b23577d7a4eb70f266b8e46b15dc96827d00958fa3625208ca9d378afb2a15"}
{"code": "for (i = 0; i < local_domain.ncells_active; i++) { \n        if (plugin_options.WATERUSE && plugin_options.NONRENEW_WITH) { \n            wu_nonrenew(i); \n        } \n        if (plugin_options.IRRIGATION) { \n            if (plugin_options.POTENTIAL_IRRIGATION || \n                plugin_options.WATERUSE || \n                plugin_options.WOFOST) { \n                irr_get_withdrawn(i); \n            } \n            irr_run_shortage(i); \n        } \n \n        if (plugin_options.WOFOST) { \n            crop_run(i); \n        } \n    }", "pragma": "parallel for private(i)", "hash": "d3cea5ea46cbb1affe04a468100e31e14256e3c9b5fef425ec1d4f5327acdf86"}
{"code": "for (i = 0; i < M; i++) \n            for (j = 0; j < N; j++) \n                for (k = 0; k < P; k++) \n                    pC[j * M + i] += pA[k * M + i] * pB[j * P + k];", "pragma": "for ", "hash": "d31c5f589c5da399b4468fefdeb4d56a1add670b4dc3f896f99189df3dd0c50a"}
{"code": "for(i2=0; i2<n2; i2++) \n\t\tfirs(-order, order, c1+order, buf[order]+i2*n1, 1, n1, ut[i2], 1);", "pragma": "parallel for ", "hash": "4cfac8df3d43ff104c19bd8a027ec9f55e2d37908108fcfe4a6f486e540edac3"}
{"code": "for(long i=0;i<s;i++)\tmemcpy(GB+4*i,BDef,4);", "pragma": "parallel ", "hash": "57663acdfbb67133dd63e1c8254d75ac0cc9cbf58368e1ae974a9fbb496be7a6"}
{"code": "for (int i = 0; i < size(); i++) { \n\t\tif (trans[i]->get_feature_exp_num() == ref_exp_num) \n\t\t\ttrans[i]->add_ms1(exp, rt, add_exp_num, RT_WINDOWS); \n\t}", "pragma": "parallel for ", "hash": "74f68b08aa8674162002b6eaa8a901a648e04b3dba07838bf8c4a6197a25da34"}
{"code": "for (int j = 1; j < src.rows; j++) \n\t\t{ \n\t\t\tfloat* s = (float*)src.ptr<float>(j); \n\t\t\tfloat* d = dest.ptr<float>(j); \n\t\t\tfor (int i = 1; i < src.cols; i += 8) \n\t\t\t{ \n\t\t\t\t__m256 ms = _mm256_load_ps(s + i); \n\t\t\t\t__m256 px = _mm256_loadu_ps(s - 1 + i); \n\t\t\t\t__m256 py = _mm256_loadu_ps(s - v + i); \n \n\t\t\t\t__m256 a = _mm256_sub_ps(ms, px); \n\t\t\t\tpx = _mm256_mul_ps(a, a); \n\t\t\t\ta = _mm256_sub_ps(ms, py); \n\t\t\t\tpy = _mm256_mul_ps(a, a); \n\t\t\t\ta = _mm256_sqrt_ps(_mm256_add_ps(px, py)); \n\t\t\t\t_mm256_storeu_ps(d + i, a); \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "468975aa84e21c72bf34c1b0c20a8f3bf0b29fb18f2f147b1a347c06e4f58bd6"}
{"code": "for (int j = 0; j < Y; j++) {\r \n        for (int i_i = 0; i_i < Y; i_i++) {\r \n            for (int _batch_idx = 0; _batch_idx < BatchSize; _batch_idx++) {\r \n\r \n                 \n \n                float _wk14 = 0;\r \n                for(int t = 0; t < T; t++){\r \n                    _wk14 += delta_uO[(Y * t + j) * BatchSize + _batch_idx] * (0 <= t - 1 ? y[(Y * (t -1) + i_i) * BatchSize + _batch_idx] : 0);\r \n                }\r \n                delta_wOr[(Y * j + i_i) * BatchSize + _batch_idx] = _wk14;\r \n\r \n            }\r \n        }\r \n    }", "pragma": "parallel ", "hash": "65935c3af1fb770be8de5ad624ada51d572b5df639d2cb8515b400143468d486"}
{"code": "for (int i = 0; i < 16; i = i + 2) \n    for (int j = 0; j < 16; j += 2) \n      ;", "pragma": "for ", "hash": "0656ac3097b267074f07c27d638195df2bf0c2d3963ded0ff459b01551d03be4"}
{"code": "for (int i = 0; i < m_nCells; i++) \n    { \n\t\t \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n        float hWater = 0.f; \n\t\thWater = m_pNet[i] + m_sd[i]; \n        if (hWater > 0.f) \n        { \n\t\t\t \n \n\t\t\t \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n \n\t\t\t \n \n\t\t\tm_soilStorageProfile[i] = 0.f; \n\t\t\tfor (int ly = 0; ly < (int)m_soilLayers[i]; ly++){ \n\t\t\t\tm_soilStorageProfile[i] += m_soilStorage[i][ly]; \n\t\t\t} \n\t\t\tfloat smFraction = min(m_soilStorageProfile[i]/m_sol_sumsat[i], 1.f); \n             \n \n            if (m_soilTemp[i] <= m_tFrozen && smFraction >= m_sFrozen) \n            { \n\t\t\t\tm_pe[i] = m_pNet[i]; \n                m_infil[i] = 0.f; \n            } \n            else \n            { \n                float alpha = m_kRunoff - (m_kRunoff - 1.f) * hWater / m_pMax; \n                if (hWater >= m_pMax) \n                    alpha = 1.f; \n \n                 \n \n                float runoffPercentage; \n                if (m_runoffCo[i] > 0.99f) \n                    runoffPercentage = 1.f; \n                else \n                    runoffPercentage = m_runoffCo[i] * pow(smFraction, alpha); \n \n                float surfq = hWater * runoffPercentage; \n\t\t\t\tif (surfq > hWater) surfq = hWater; \n                m_infil[i] = hWater - surfq; \n                m_pe[i] = surfq; \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n            } \n        } \n        else \n        { \n            m_pe[i] = 0.f; \n            m_infil[i] = 0.f; \n        } \n\t\t \n \n\t\tif (m_infil[i] > 0.f) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tm_soilStorage[i][0] += m_infil[i]; \n\t\t} \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n    }", "pragma": "parallel for ", "hash": "1493437c3123296900646173e3caf728b710ea76ce64458f12891896db068c4d"}
{"code": "for(int i = 1; i < nx+2; i++) { \n\t\tconst int ny_end = ny+1;\t \n \n \n \n  #pragma simd \n \n\t\tfor(int j = 1; j < ny_end; j++) { \n \n\t\t\tfloat maxEdgeSpeed; \n\t\t\tfloat hNetUpLeft, hNetUpRight; \n\t\t\tfloat huNetUpLeft, huNetUpRight; \n \n\t\t\twavePropagationSolver.computeNetUpdates( h[i-1][j], h[i][j], \n                                               hu[i-1][j], hu[i][j], \n                                               b[i-1][j], b[i][j], \n                                               hNetUpLeft, hNetUpRight, \n                                               huNetUpLeft, huNetUpRight, \n                                               maxEdgeSpeed ); \n \n\t\t\t \n \n\t\t\thNetUpdates[i-1][j]  += dx_inv * hNetUpLeft; \n\t\t\thuNetUpdates[i-1][j] += dx_inv * huNetUpLeft; \n\t\t\thNetUpdates[i][j]    += dx_inv * hNetUpRight; \n\t\t\thuNetUpdates[i][j]   += dx_inv * huNetUpRight; \n \n\t\t\t#ifdef LOOP_OPENMP \n\t\t\t\t \n \n\t\t\t\tl_maxWaveSpeed = std::max(l_maxWaveSpeed, maxEdgeSpeed); \n\t\t\t#else  \n \n\t\t\t\t \n \n\t\t\t\tmaxWaveSpeed = std::max(maxWaveSpeed, maxEdgeSpeed); \n\t\t\t#endif  \n \n\t\t} \n\t}", "pragma": "for ", "hash": "cd3c02eb41477a861b2731be12d91b98e5e43cfe5d46a03ee98f4d52b0d6f9dc"}
{"code": "for (int i=0; i<nrow; i++) { \n      if (stop) continue; \n      if (anso[i]!=i+1) stop=true; \n    }", "pragma": "parallel for ", "hash": "0e73b569ec869bd097451db5a7cbb5f2671c06e225f5a5318d0fdc0696fbe28b"}
{"code": "for ( size_t i = 0; i < numPresNodes; ++i){ \n\t\tdouble contrib = dumpingFactor * pr[prLocation[keys[i]]] / adjList[i].size(); \n\t\tfor ( size_t j = 0; j < adjList[i].size(); ++j){ \n\t\t\tauto target = adjList[i][j]; \n \n\t\t\tif ( present[target] ){ \n\t\t\t\tauto l = prLocation[target]; \n    #pragma omp atomic \n\t\t\t\tnewPR[ l ] += contrib; \n\t\t\t}else{ \n    #pragma omp atomic \n\t\t\t\tgivePR[target] += contrib; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "95ee20d93514f6d4985802eb83146952cb5d9a7e7b94bd0adcba85a3fcd36974"}
{"code": "for (nid_t i = 0; i < graph.edge_size(); ++i) { \n        lambda(graph.mutable_edge(i)); \n        if (completed++ % 1000 == 0) { \n            update_progress(completed); \n        } \n    }", "pragma": "parallel for ", "hash": "bb2ea27843de6e7a487b6601964b1fefc1e18c24e011cc401a38ad400f826a7e"}
{"code": "for (ii=kk+1; ii<bots_arg_size; ii++)  \n         if (BENCH[ii*bots_arg_size+kk] != NULL)", "pragma": "for ", "hash": "564ceed74246fc3211092c0e4bccda03684aa518697b6533b88f6f357f65ef88"}
{"code": "for(int i = 1; i <= xsize; i++) \n\t\tfor(int j = 1; j <= ysize; j++) \n\t\t\th_new[i][j] = 0.25 * (h[i - 1][j] + h[i + 1][j] + h[i][j - 1] + h[i][j + 1]);", "pragma": "for ", "hash": "2611789616681a12bf2bef47e44ed159b0c881165a7c3676c328b8c18a88e7d1"}
{"code": "for (j = 1; j < grid_points[1]-1; j++) { \n    for (k = 1; k < grid_points[2]-1; k++) { \n      for (m = 0; m < 5; m++) { \n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp * \n\t  ( u[i-2][j][k][m] - 4.0*u[i-1][j][k][m] +  \n\t    6.0*u[i][j][k][m] - 4.0*u[i+1][j][k][m] ); \n      } \n    } \n  }", "pragma": "for private(k m)", "hash": "48257bf39eace77f60dca0973b266160084db68e45745970c54f4ea2f37e5a8b"}
{"code": "for (int iii = 0; iii < src.rows; iii++) { \n\t\tfor (int jjj = 0; jjj < src.cols; jjj++) { \n\t\t\t \n\t\t\tif ((src.at<cv::Vec3b>(iii,jjj)[0] != 0) && (src.at<cv::Vec3b>(iii,jjj)[1] != 0) && (src.at<cv::Vec3b>(iii,jjj)[2] != 0)) { \n\t\t\t\tfor (unsigned int kkk = 0; kkk < 3; kkk++) { \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tdst.at<cv::Vec3b>(iii,jjj)[0] = (unsigned char) (((1-frac) * double(src.at<cv::Vec3b>(iii,jjj)[0]) + frac * double(dst.at<cv::Vec3b>(iii,jjj)[0])) / 1.0); \n\t\t\t\t\tdst.at<cv::Vec3b>(iii,jjj)[1] = (unsigned char) (((1-frac) * double(src.at<cv::Vec3b>(iii,jjj)[1]) + frac * double(dst.at<cv::Vec3b>(iii,jjj)[1])) / 1.0); \n\t\t\t\t\tdst.at<cv::Vec3b>(iii,jjj)[2] = (unsigned char) (((1-frac) * double(src.at<cv::Vec3b>(iii,jjj)[2]) + frac * double(dst.at<cv::Vec3b>(iii,jjj)[2])) / 1.0); \n\t\t\t\t\t \n\t\t\t\t} \n\t\t\t} else { \n\t\t\t\tdst.at<cv::Vec3b>(iii,jjj)[0] = src.at<cv::Vec3b>(iii,jjj)[0]; \n\t\t\t\tdst.at<cv::Vec3b>(iii,jjj)[1] = src.at<cv::Vec3b>(iii,jjj)[1]; \n\t\t\t\tdst.at<cv::Vec3b>(iii,jjj)[2] = src.at<cv::Vec3b>(iii,jjj)[2]; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "f68f0f11aef32a62df63ea6600fb0c2dd420d19d2f23c512d8bbe461d09aa131"}
{"code": "for(x = 0; x < Nparticles; x++){\r \n\t\t\tweights[x] = weights[x]/sumWeights;\r \n\t\t}", "pragma": "parallel for private(x)", "hash": "510f4be7fe538b50961ccf042b4aa9d9ed1517dba9feac749ee790f08beff7c3"}
{"code": "for (int i = 33; i < 32000000; i += 7) { \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    a[i] = b[i] * c[i] * d[i]; \n \n \n \n \n \n \n \n \n  }", "pragma": "for ", "hash": "3aa795ad38c1308e7c1d7c2570bb9acdba42766e27629795b72dda0840ee602c"}
{"code": "for (int i = 0; i < numVecs; ++i) { \n            for (int j = 0; j < bytesPerVec; ++j) { \n                int dimLo = (j * 8) / 6; \n                int dimHi = dimLo + 1; \n                FAISS_ASSERT(dimLo < dims); \n                FAISS_ASSERT(dimHi <= dims); \n \n                uint8_t lo = data[i * dims + dimLo]; \n                uint8_t hi = dimHi < dims ? data[i * dims + dimHi] : 0; \n \n                out[i * bytesPerVec + j] = pack6(j, lo, hi); \n            } \n        }", "pragma": "parallel for ", "hash": "7b0eccb558819908507bb74a99add8f8b40e5fa83f4ccc8b8b751b01b81ad038"}
{"code": "for (i = 0; i < n; i++) { \n                for (sum = 0.0, j = ptr[i]; j < ptr[i + 1]; j++) { \n                    if (norm == 2) { \n                        sum += val[j] * val[j]; \n                    } else if (norm == 1) { \n                        sum += val[j]; \n                    }  \n \n                } \n                if (sum > 0) { \n                    if (norm == 2) { \n                        sum = 1.0 / sqrt(sum); \n                    } else if (norm == 1) { \n                        sum = 1.0 / sum; \n                    } \n                    for (j = ptr[i]; j < ptr[i + 1]; j++) { \n                        val[j] *= sum; \n                    } \n \n                } \n            }", "pragma": "for private(j sum)", "hash": "ece4f01124d47d37ad5dfeff397723643f7a541c4f6b645d8dbe78dfae2014db"}
{"code": "for (int i = 0; i < nn; i++) { \n    Hdia_inv[i] = 1. / eta[atom->type[i]]; \n    b_s[i] = -chi[atom->type[i]]; \n    if (efield) b_s[i] -= chi_field[i]; \n    b_t[i] = -1.0; \n    b_prc[i] = 0; \n    b_prm[i] = 0; \n    s[i] = t[i] = 0; \n  }", "pragma": "parallel for ", "hash": "da6db4fbfc98052ded8c929c099dc3788f658aadb90a88fa31a8c1c1876af943"}
{"code": "for ( i = 0; i < n; i++ ) \n  { \n    for ( j = 0; j < n; j++ ) \n    { \n      angle = 2.0 * pi * i * j / ( double ) n; \n      a[i*npadded+j] = s * ( sin ( angle ) + cos ( angle ) ); \n    } \n  }", "pragma": "for ", "hash": "84000a3068534239f5af16df30753c30b4c16e43892e5772d46610355103e481"}
{"code": "for (j = 0; j < ctx->no_clusters; j++) { \n        ctx->clusters_not_changed[j] = 1; \n    }", "pragma": "parallel for ", "hash": "ed1feb120ba45ce84f26a451075d98a53796684958c5bbcf99fd8ea27426b486"}
{"code": "for(rocsparse_int i = 0; i < M; ++i) \n    { \n        rocsparse_int csr_idx = csr_row_ptr[i] - csr_base; \n \n        for(rocsparse_int p = 0; p < ell_width; ++p) \n        { \n            rocsparse_int idx = p * M + i; \n            rocsparse_int col = ell_col_ind[idx] - ell_base; \n \n            if(col >= 0 && col < N) \n            { \n                csr_col_ind[csr_idx] = col + csr_base; \n                csr_val[csr_idx]     = ell_val[idx]; \n \n                ++csr_idx; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "a34153dde19d179be3c1d7ff075c84112e03a7a24be62341342fcf2ec82a20ee"}
{"code": "for (int ip = 0; ip < linklist.size(); ++ip)   \n \n    { \n        ChLink* Lpointer = linklist[ip]; \n        Lpointer->ConstraintsBiReset(); \n    }", "pragma": "parallel for ", "hash": "497290943fd8b4b953c6eb4742f141a738470f8f22285f77c623c025251a18f9"}
{"code": "for( int i = iStart; i < iEnd; ++i ){ \n\t\t\t\t\t \n\t\t\t\t\tif( _isnan( dSumGx )){ \n\t\t\t\t\t\tdSumGx = 0; \n\t\t\t\t\t\tdSumGy = 0; \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tfor( int j = i - ( G_SMOOTH_NUM - 1 ) / 2; j < i + G_SMOOTH_NUM / 2; ++j ){ \n\t\t\t\t\t\t\tfBufGx[ j % G_SMOOTH_NUM ] = ( float )Gx( j ); dSumGx += Gx( j ); \n\t\t\t\t\t\t\tfBufGy[ j % G_SMOOTH_NUM ] = ( float )Gy( j ); dSumGy += Gy( j ); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tint k = i + G_SMOOTH_NUM / 2; \n\t\t\t\t\tfBufGx[ k % G_SMOOTH_NUM ] = ( float )Gx( k ); dSumGx += Gx( k ); \n\t\t\t\t\tfBufGy[ k % G_SMOOTH_NUM ] = ( float )Gy( k ); dSumGy += Gy( k ); \n\t\t\t\t\t \n\t\t\t\t\tif( Speed( i ) == 0 ){ \n\t\t\t\t\t\tSetRawGx( i, 0 ); \n\t\t\t\t\t\tSetRawGy( i, 0 ); \n\t\t\t\t\t}else{ \n\t\t\t\t\t\tdouble dx, dy; \n\t\t\t\t\t\tSetRawGx( i, dx = dSumGx / G_SMOOTH_NUM ); \n\t\t\t\t\t\tSetRawGy( i, dy = dSumGy / G_SMOOTH_NUM ); \n\t\t\t\t\t\t \n\t\t\t\t\t\tif(      dMaxGx < dx ) dMaxGx = dx; \n\t\t\t\t\t\telse if( dMinGx > dx ) dMinGx = dx; \n\t\t\t\t\t\tif(      dMaxGy < dy ) dMaxGy = dy; \n\t\t\t\t\t\telse if( dMinGy > dy ) dMinGy = dy; \n\t\t\t\t\t} \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tk = i - ( G_SMOOTH_NUM - 1 ) / 2; \n\t\t\t\t\tdSumGx -= fBufGx[ k % G_SMOOTH_NUM ]; \n\t\t\t\t\tdSumGy -= fBufGy[ k % G_SMOOTH_NUM ]; \n\t\t\t\t}", "pragma": "for ", "hash": "02a3bac40eb02bb3e45d5711ef7af6e0bdd7070efccad1112e4d2022cbda1dd2"}
{"code": "for (i=0; i<nPri; i++) { \n      indp=i*(nPri); \n       \n \n      chib=0.0000000e0; \n      tgx=tgy=tgz=0.0e0; \n      for (j=0; j<nPri; j++) { \n         cc=cab[indp+j]; \n         tgx+=(gx[j]*cc); \n         tgy+=(gy[j]*cc); \n         tgz+=(gz[j]*cc); \n         chib+=(chi[j]*cc); \n      } \n      rho+=(chib*chi[i]); \n      kej+=(tgx*gx[i]); \n      kej+=(tgy*gy[i]); \n      kej+=(tgz*gz[i]); \n      nabx+=(chib*gx[i]); \n      naby+=(chib*gy[i]); \n      nabz+=(chib*gz[i]); \n   }", "pragma": "parallel for reduction(+: kej nabx naby nabz rho) private(cc chib i indr j tgx tgy tgz)", "hash": "2b50e8d4cefda9118295337b2b22806f40d751242896fe645b122790ce2815bb"}
{"code": "for (size_t idx = 0; idx < dim; idx++) { \n    dst[idx] = src[idx]; \n  }", "pragma": "parallel for ", "hash": "7947be00d56981217aa7946590f550891ab15fe960d001c8f18bf7d90cdf97ab"}
{"code": "for (i = 5; i < 16; i = i + i) \n    ;", "pragma": "for ", "hash": "8988f4c32b5229ab7f4c250f2247531606f655358503f90cb4ac375e6780f253"}
{"code": "for (auto strip = strips.cbegin(); strip < strips.cend(); ++strip) { \n    try { \n      decompressStrip(*strip); \n    } catch (const RawspeedException& err) { \n       \n \n      mRaw->setError(err.what()); \n    } \n  }", "pragma": "for ", "hash": "8f34bac94e2f0efa7884d876abc403a8b81243fe89ccec4f9029a6f1592498c9"}
{"code": "for (row = 3; row < height - 3; row++) { \n            for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2) { \n                pix = image + row * width + col; \n                for (i = 0; (d = dir[i]) > 0; i++) { \n                    guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 \n                               - pix[-2 * d][c] - pix[2 * d][c]; \n                    diff[i] = (ABS(pix[-2 * d][c] - pix[ 0][c]) + \n                               ABS(pix[ 2 * d][c] - pix[ 0][c]) + \n                               ABS(pix[  -d][1] - pix[ d][1])) * 3 + \n                              (ABS(pix[ 3 * d][1] - pix[ d][1]) + \n                               ABS(pix[-3 * d][1] - pix[-d][1])) * 2; \n                } \n                d = dir[i = diff[0] > diff[1]]; \n                pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]); \n            } \n        }", "pragma": "for ", "hash": "730835dc2a606132559130411b0d79fed1d99c48c4f1bf58c68c998ce4260bb7"}
{"code": "for(int j=0; j<roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + j*roi_out->width; \n      float *out = ((float*)ovoid) + j*roi_out->width; \n      for(int i=0; i<roi_out->width; i++,out++,in++) \n        *out = *in * d->coeffs[FC(j+roi_out->x, i+roi_out->y, filters)]; \n    }", "pragma": "parallel for ", "hash": "22954fcffc3f1ed124745b46e9adc122e92eeaa19cb48d0db04245a488f4aab6"}
{"code": "for (int y = 0; y < dimY; y += 2 * BLOCKSIZEY) { \n    for (int x = 0; x < dimX / 2; x += BLOCKSIZEX * double_v::size()) { \n      int idx = y * dimX_half + x; \n      std::array<std::array<double_v, BLOCKSIZEX>, 2 * BLOCKSIZEY> red; \n      std::array<std::array<double_v, BLOCKSIZEX>, 2 * BLOCKSIZEY> rhs; \n      std::array<std::array<double_v, BLOCKSIZEX>, 2 * BLOCKSIZEY + 1> blk_l; \n      std::array<std::array<double_v, BLOCKSIZEX>, 2 * BLOCKSIZEY + 1> blk_r; \n      for (int kx = 0; kx < BLOCKSIZEX; ++kx) { \n        blk_l[0][kx] = double_v(&grid_b[idx + kx * double_v::size()], VcEA); \n        blk_r[2 * BLOCKSIZEY][kx] = \n            double_v(&grid_b[idx + (2 * BLOCKSIZEY + 1) * dimX_half + \n                             kx * double_v::size() + 1], \n                     VcEA); \n      } \n      for (int ky = 0; ky < 2 * BLOCKSIZEY; ky += 2) { \n        for (int kx = 0; kx < BLOCKSIZEX; ++kx) { \n          red[ky][kx] = double_v( \n              &grid_r[idx + (ky + 1) * dimX_half + kx * double_v::size()], \n              VcEA); \n          rhs[ky][kx] = double_v( \n              &rhs_r[idx + (ky + 1) * dimX_half + kx * double_v::size()], VcEA); \n          blk_l[ky + 1][kx] = double_v( \n              &grid_b[idx + (ky + 1) * dimX_half + kx * double_v::size()], \n              VcEA); \n          blk_r[ky][kx] = double_v( \n              &grid_b[idx + (ky + 1) * dimX_half + kx * double_v::size() + 1], \n              VcEA); \n          red[ky + 1][kx] = double_v( \n              &grid_r[idx + (ky + 2) * dimX_half + kx * double_v::size() + 1], \n              VcEA); \n          rhs[ky + 1][kx] = double_v( \n              &rhs_r[idx + (ky + 2) * dimX_half + kx * double_v::size() + 1], \n              VcEA); \n          blk_l[ky + 2][kx] = double_v( \n              &grid_b[idx + (ky + 2) * dimX_half + kx * double_v::size()], \n              VcEA); \n          blk_r[ky + 1][kx] = double_v( \n              &grid_b[idx + (ky + 2) * dimX_half + kx * double_v::size() + 1], \n              VcEA); \n        } \n      } \n      for (int ky = 0; ky < 2 * BLOCKSIZEY; ky += 2) { \n        for (int kx = 0; kx < BLOCKSIZEX; ++kx) { \n          rhs[ky][kx] -= \n              DiffusionKernel(red[ky][kx], blk_l[ky + 2][kx], blk_l[ky][kx], \n                              blk_l[ky + 1][kx], blk_r[ky][kx]); \n          red[ky][kx] -= pre * rhs[ky][kx]; \n          rhs[ky + 1][kx] -= \n              DiffusionKernel(red[ky + 1][kx], blk_r[ky + 2][kx], blk_r[ky][kx], \n                              blk_l[ky + 2][kx], blk_r[ky + 1][kx]); \n          red[ky + 1][kx] -= pre * rhs[ky + 1][kx]; \n        } \n      } \n      for (int ky = 0; ky < 2 * BLOCKSIZEY; ky += 2) { \n        for (int kx = 0; kx < BLOCKSIZEX; ++kx) { \n          red[ky][kx].memstore( \n              &grid_r[idx + (ky + 1) * dimX_half + kx * double_v::size()], \n              VcEA); \n          red[ky + 1][kx].memstore( \n              &grid_r[idx + (ky + 2) * dimX_half + kx * double_v::size() + 1], \n              VcEA); \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "d07931e7e7275cb7c79e8c1e061774f117df83e77f3e608885659ef539c8136b"}
{"code": "for( int q=0; q<imsz; q++ ) \n   { \n      m_scale_map[q] = round( m_scale_map[q] ); \n   }", "pragma": "parallel for ", "hash": "bfc5dfdec7c71157bc12679a185d4ab3f9b5239d61ac39de2d0ced349d193792"}
{"code": "for (iel = 0; iel < nelt; iel++) { \n    front[iel] = newc[iel]; \n  }", "pragma": "parallel for private(iel)", "hash": "6399020c2945b83159e3d6c52974ec7aff4162214de7ab4377e6ea776c39c463"}
{"code": "for (int i = 2; i <= limit; i++) { \n        tid = omp_get_thread_num(); \n         \n \n        if (array[i] == 1) { \n            for (int j = i + i; j <= N; j += i) \n                array[j] = 0; \n        } \n    }", "pragma": "parallel for ", "hash": "0501ea78db29a5bde58b033b1252aaf704c72b20d3b4b3096193fe15311da048"}
{"code": "for ( long ikappa=first_kappa; ikappa<last_kappa; ++ikappa ) { \n        double kappa = ikappa*kappastep; \n        double kkl = kappa * invkappal; \n        phi[ikappa-first_kappa] = \n            ( 1. + 1.802 * kkl - 0.254 * pow( kkl, slope1 ) ) \n            * exp( -kkl*kkl ) * pow( kappa*kappa + kappa0sq, slope2 ); \n    }", "pragma": "parallel for ", "hash": "b8aff03e9abc05f473de16fd761f3b5db4c5546ea2e15498cef39e70b03e1f7a"}
{"code": "for (k = 0; k < N2; k++) \n      { \n        g_hat1[k] = f_hat1[k] / (PHI_HUT(k-N2,0)); \n        g_hat2[k] = f_hat2[k] / (PHI_HUT(k,0)); \n      }", "pragma": "parallel for private(k)", "hash": "7ee4569c1107c414f7eae98e9544778859afa10a1b69f0b7aed7af26d1a9254b"}
{"code": "for (int i =0; i<Strecha.size; i++){ \n\t\tcv::PyramidAdaptedFeatureDetector detector2(new  cv::SiftFeatureDetector(),5); \n \n\t\tdetector2.detect(Strecha.I[i],Strecha.keys[i]); \n\t\tstd::cout<< \"sift::image \"<< i<<\" with \" << Strecha.keys[i].size() <<\" keypoints\" <<std::endl; \n\t\tcv::SiftDescriptorExtractor extractor; \n\t\textractor.compute(Strecha.I[i],Strecha.keys[i],Strecha.descriptors[i]);\t \n\t}", "pragma": "parallel for ", "hash": "6c8bd7b07602d7673b56ce42c55fa7e5b05764f891927988cae9067258ca86de"}
{"code": "for(int y = 0; y < volDimY; y++) \n        { \n            for(int x = 0; x < volDimX; x++) \n            { \n                (*volume)[(volDimZ - 1) * volDimY * volDimX + y * volDimX + x] = sp->P3; \n                (*volume)[(volDimZ - 2) * volDimY * volDimX + y * volDimX + x] = sp->P3; \n                (*volume)[(volDimZ - 3) * volDimY * volDimX + y * volDimX + x] = sp->P3; \n                (*volume)[(volDimZ - 4) * volDimY * volDimX + y * volDimX + x] = sp->P3; \n            } \n        }", "pragma": "parallel for ", "hash": "22a73697bfe580706a100c38baffa83b65e14e30b4b671f66fcd5c51419ef77b"}
{"code": "for(unsigned int j = 0; j < mCellInflationRadius + 2; j++) \n\t\t{ \n\t\t\tdouble d = sqrt(i*i + j*j); \n\t\t\tmCachedDistances[i][j] = d; \n\t\t\td /= mCellInflationRadius; \n\t\t\tif(d > 1) d = 1; \n\t\t\tmCachedCosts[i][j] = (1.0 - d) * mCostObstacle; \n\t\t}", "pragma": "parallel for ", "hash": "f3e64127030310c60c23abebad64eeb8e5b1ce4c79e47f5a515aa6f68980848d"}
{"code": "for (int k = 0; k<record_cnt; k++) \n\t{ \n\t\tconst int prediction = cnn.predict_class(test_images[k].data()); \n\t\tif (prediction == test_labels[k]) correct_predictions += 1; \n\t\tif (k % 1000 == 0) progress.draw_progress(k); \n\t}", "pragma": "parallel for reduction(+:correct_predictions) ", "hash": "4b7526ba479c46cef60219f394f714895aa424f7d2f77b69dd456c06834ecfa9"}
{"code": "for(int i=0; i < m; i++) { \n        if(firstloop) { \n          advance(i1,i); \n          firstloop=false; \n        } \n \n        unsigned int x[Mrowsum[i1.index1()]]; \n        double p[Mrowsum[i1.index1()]]; \n        int count=0; \n \n        for(intMatIt2 i2 = i1.begin(); i2 != i1.end(); ++i2) { \n          p[count] = mu[i2.index2()]; \n          count++; \n        } \n         \n        gsl_ran_multinomial(rg[threadid], Mrowsum[i1.index1()], k[i1.index1()], p, x); \n \n        count=0; \n        for(intMatIt2 i2 = i1.begin(); i2 != i1.end(); ++i2) { \n          X(i2.index1(), i2.index2()) = x[count]; \n         \n \n         \n \n          Xcolsums[i2.index2()+n*threadid] += x[count]; \n          count++; \n        } \n        i1++; \n      }", "pragma": "for ", "hash": "ccb456c62050d239a07c1fb2769cd16f52b6a5f5a0a5016c2670eedf194beac0"}
{"code": "for (ibody = 0; ibody < nlocal_body; ibody++) { \n      double * _noalias const fcm = body[ibody].fcm; \n      fcm[0] += langextra[ibody][0]; \n      fcm[1] += langextra[ibody][1]; \n      fcm[2] += langextra[ibody][2]; \n      double * _noalias const tcm = body[ibody].torque; \n      tcm[0] += langextra[ibody][3]; \n      tcm[1] += langextra[ibody][4]; \n      tcm[2] += langextra[ibody][5]; \n    }", "pragma": "parallel for private(ibody)", "hash": "2d6b2a24b81842c312e48c29b3a7886de0c7ca2cc65d62d8a3a0be83b87c1e26"}
{"code": "for (int it2 = range_lower_p; it2<range_upper_p; it2++){   \n \n                a2 = blockArrays_ppp_ppp(1,it2); \n                b2 = blockArrays_ppp_ppp(2,it2); \n                c2 = blockArrays_ppp_ppp(3,it2); \n \n                val_ab2  = b2 + a2*Np + c2*Np2; \n                val_ac2  = c2 + b2*Np + a2*Np2; \n                val_bc2  = a2 + c2*Np + b2*Np2; \n                val_abac2 = c2 + a2*Np + b2*Np2;  \n \n                val_abbc2 = b2 + c2*Np + a2*Np2;  \n \n \n                if (val1 == val_ab2){ \n                    blockArrays_ppp_ppp_Pab.col(it1) << it1, it2; \n                     \n \n                     \n \n                     \n \n                } \n                if (val1 == val_ac2){ \n                    blockArrays_ppp_ppp_Pac.col(it1) << it1, it2; \n                     \n \n                     \n \n                } \n                if (val1 == val_bc2){ \n                    blockArrays_ppp_ppp_Pbc.col(it1) << it1, it2; \n                     \n \n                     \n \n                } \n                if (val1 == val_abac2){ \n                    blockArrays_ppp_ppp_Pabac.col(it1) << it1, it2; \n                     \n \n                     \n \n                } \n                if (val1 == val_abbc2){ \n                    blockArrays_ppp_ppp_Pabbc.col(it1) << it1, it2; \n                     \n \n                     \n \n                } \n            }", "pragma": "parallel for private( a2 b2 c2 val_ab2 val_abac2 val_abbc2 val_ac2 val_bc2)", "hash": "3381397c0484bd77d31dc928fabee72d060568aeef2883fff55310c778af3c8f"}
{"code": "for( i = 0 ; i < SYMM_POINT ; i++ ) { \n    const uint32_t thread = get_GLU_thread( ) ; \n    if( count[i] == CONJUGATE_NOT_IN_LIST ) { \n      count[i] = CONJUGATE_IN_LIST;  \n \n      const size_t b = conjugate_site( i ) ; \n      size_t mu ; \n      if( i == b ) { \n        #if ND%2 == 0 \n\tfor( mu = 0 ; mu < ND ; mu+=2 ) { \n\t  register const GLU_complex cache = par_polar_box( thread ) ; \n\t  fields[mu  ][i] = creal( cache ) ; \n\t  fields[mu+1][i] = cimag( cache ) ; \n\t} \n        #else \n\tfields[0][i] = creal( par_polar_box( thread ) ) ; \n\tfor( mu = 1 ; mu < ND ; mu+=2 ) { \n\t  register const GLU_complex cache = par_polar_box( thread ) ; \n\t  fields[mu  ][i] = creal( cache ) ; \n\t  fields[mu+1][i] = cimag( cache ) ; \n\t} \n        #endif \n      } else { \n\tfor( mu = 0 ; mu < ND ; mu++ ) { \n\t  register const GLU_complex cache = par_polar_box( thread ) ; \n\t  fields[mu][i] = cache ; \n\t  fields[mu][b] = conj( cache ) ; \n\t} \n      } \n       \n \n       \n \n      if( b < SYMM_POINT ) {  \n \n\tcount[b] = CONJUGATE_IN_LIST ; \n      } \n       \n \n    } \n  }", "pragma": "parallel for private(i)", "hash": "6dbe3d5ae37f7d735ad9ab11cb73ed9f14f183098553ea069a92b33cf97eda4b"}
{"code": "for (int i = 0; i < nlocal; i++) \n      if (mask[i] & groupbit) { \n        const double dtfm = dtf / mass[type[i]]; \n        v[i].x += dtfm * f[i].x; \n        v[i].y += dtfm * f[i].y; \n        v[i].z += dtfm * f[i].z; \n        x[i].x += dtv * v[i].x; \n        x[i].y += dtv * v[i].y; \n        x[i].z += dtv * v[i].z; \n      }", "pragma": "parallel for ", "hash": "c94ddea5e77516f6f08a839a4204ac2bc15f0c67bc09a54eafc674892c558cf0"}
{"code": "for(index irow = 0; irow < mat.nbrows; irow++) \n\t{ \n\t\tscalar rowddu[bs], rowddl[bs]; \n\t\tfor(int i = 0; i < bs; i++) { \n\t\t\trowddl[i] = 0; \n\t\t\trowddu[i] = 0; \n\t\t} \n \n\t\tconst index diagp = mat.diagind[irow]; \n \n\t\t \n \n\t\tfor(int i = 0; i < bs; i++) \n\t\t\tfor(int j = 0; j < bs; j++) \n\t\t\t\tif(i != j) \n\t\t\t\t\trowddu[i] += std::abs(data[diagp](i,j)); \n \n\t\t \n \n\t\tfor(index jj = diagp+1; jj < mat.browendptr[irow]; jj++) \n\t\t{ \n\t\t\tfor(int i = 0; i < bs; i++) \n\t\t\t\tfor(int j = 0; j < bs; j++) \n\t\t\t\t\trowddu[i] += std::abs(data[jj](i,j)); \n\t\t} \n \n\t\t \n \n\t\tfor(index jj = mat.browptr[irow]; jj < diagp; jj++) \n\t\t{ \n\t\t\tfor(int i = 0; i < bs; i++) \n\t\t\t\tfor(int j = 0; j < bs; j++) \n\t\t\t\t\trowddl[i] += std::abs(data[jj](i,j)); \n\t\t} \n \n\t\tfor(int i = 0; i < bs; i++) { \n\t\t\trowddl[i] = 1.0 - rowddl[i];                              \n \n\t\t\trowddu[i] = 1.0 - rowddu[i]/std::abs(data[diagp](i,i));   \n \n\t\t} \n \n\t\tscalar uavg_blk = 0, lavg_blk = 0, umin_blk = 1e30, lmin_blk = 1e30; \n\t\tfor(int i = 0; i < bs; i++) \n\t\t{ \n\t\t\tif(umin_blk > rowddu[i]) \n\t\t\t\tumin_blk = rowddu[i]; \n\t\t\tif(lmin_blk > rowddl[i]) \n\t\t\t\tlmin_blk = rowddl[i]; \n \n\t\t\tlavg_blk += rowddl[i]; \n\t\t\tuavg_blk += rowddu[i]; \n\t\t} \n \n\t\tif(uddmin > umin_blk) \n\t\t\tuddmin = umin_blk; \n\t\tif(lddmin > lmin_blk) \n\t\t\tlddmin = lmin_blk; \n\t\tuddavg += uavg_blk; \n\t\tlddavg += lavg_blk; \n\t}", "pragma": "parallel for reduction(+:uddavg lddavg) reduction(lddmin min:uddmin) ", "hash": "cd3c08c9715c425cd137ed4b16537794e855f5961e8b26dcdb2dd963c6e2237f"}
{"code": "for (int i=0; i<numOfGenes; ++i) \n    { \n      for (int j=i+1; j<numOfGenes; ++j) \n\t{ \n\t   \n \n\t   \n \n\t   \n \n\t  v  = sqrt(abs(var1[i][j]+var2[i][j])); \n\t   \n \n\t  c = abs(avgCorr1[i][j]+avgCorr2[i][j]); \n\t   \n \n\t   \n \n\t  csd[i][j][0] = c/v; \n\t   \n \n\t  csd[i][j][1] = abs(abs(avgCorr1[i][j])-abs(avgCorr2[i][j]))/v; \n\t   \n \n\t  csd[i][j][2] = (abs(avgCorr1[i][j])+abs(avgCorr2[i][j])-c)/v; \n\t} \n    }", "pragma": "parallel for private(c v)", "hash": "162975e5d2865f424b6788eb9db851349cd8bd1909018016c35f1453cacdc3d3"}
{"code": "for(long j=0;j<ny;j++)\tfor(long i=0;i<nx;i++)\r \n\t\t{\r \n\t\t\tlong im = i>0 ? i-1:i, ip = i<nx-1 ? i+1:i;\r \n\t\t\tlong jm = j>0 ? j-1:j, jp = j<ny-1 ? j+1:j;\r \n\t\t\tr->a[i+nx*j] = (x->v(ip,j)-x->v(im,j))*(y->v(i,jp)-y->v(i,jm)) -\r \n\t\t\t\t\t\t(y->v(ip,j)-y->v(im,j))*(x->v(i,jp)-x->v(i,jm));\r \n\t\t\tr->a[i+nx*j] *= mreal((nx-1)*(ny-1)) / mreal((ip-im)*(jp-jm));\r \n\t\t}", "pragma": "parallel for ", "hash": "d76187263d43ab2f6dd0995730bf3afc67742289cc9f77000d8da10e89d06795"}
{"code": "for (auto valid_id = 0; valid_id < (int)validImages.size(); ++valid_id) \n        { \n            auto info = validImages[valid_id]; \n            SAIGA_ASSERT(info); \n            auto& img  = scene.images[info.sceneImageId]; \n            auto& extr = x_u[info.validId]; \n             \n \n             \n \n            auto& camera = scene.intrinsics[img.intr]; \n \n            StereoCamera4 scam(camera, scene.bf); \n \n            for (auto& ip : img.stereoPoints) \n            { \n                if (!ip) continue; \n                BlockBAScalar w = ip.weight * scene.scale(); \n                int j           = pointToValidMap[ip.wp]; \n                SAIGA_ASSERT(j >= 0); \n                auto& wp = x_v[j]; \n \n                if (ip.IsStereoOrDepth()) \n                { \n                    auto stereo_point = ip.GetStereoPoint(scene.bf); \n                    auto [res, depth] = \n                        BundleAdjustmentStereo(scam, ip.point, stereo_point, extr, wp, w, w * scene.stereo_weight); \n                    auto res_2 = res.squaredNorm(); \n                    if (baOptions.huberStereo > 0) \n                    { \n                        auto rw = Kernel::HuberLoss<T>(baOptions.huberStereo, res_2); \n                         \n \n                        res_2 = rw(0); \n                    } \n                    newChi2 += res_2; \n                } \n                else \n                { \n                    auto [res, depth] = BundleAdjustment(scam, ip.point, extr, wp, w); \n \n                    auto res_2 = res.squaredNorm(); \n                    if (baOptions.huberMono > 0) \n                    { \n                        auto rw = Kernel::HuberLoss<T>(baOptions.huberMono, res_2); \n                         \n \n                        res_2 = rw(0); \n                    } \n                    newChi2 += res_2; \n                } \n            } \n        }", "pragma": "for ", "hash": "4c5b1e2d39b1561a20b4c5c37e2e1b5da611cb67569eda4ac176a8faae08e525"}
{"code": "for(int k=0; k<l; k++) \n\t\t\t\t\t\tG_bar[k] -= C_j * Q_j[k];", "pragma": "parallel for ", "hash": "fc2b455c79b1a02dd89eac4176e86c75c7af09fd52af6624d6d9592c02bd6e16"}
{"code": "for (int i = 0; i < num_threads_; ++i) { \n      OMP_LOOP_EX_BEGIN(); \n      left_cnts_buf_[i] = 0; \n      right_cnts_buf_[i] = 0; \n      data_size_t cur_start = i * inner_size; \n      if (cur_start > num_data_) { continue; } \n      data_size_t cur_cnt = inner_size; \n      if (cur_start + cur_cnt > num_data_) { cur_cnt = num_data_ - cur_start; } \n      Random cur_rand(gbdt_config_->bagging_seed + iter * num_threads_ + i); \n      data_size_t cur_left_count = BaggingHelper(cur_rand, cur_start, cur_cnt, tmp_indices_.data() + cur_start); \n      offsets_buf_[i] = cur_start; \n      left_cnts_buf_[i] = cur_left_count; \n      right_cnts_buf_[i] = cur_cnt - cur_left_count; \n      OMP_LOOP_EX_END(); \n    }", "pragma": "parallel for ", "hash": "dbb9250d4e03c4387b2bc112a317dacf2031d8e5f04bd77a24b379f86d3d80d3"}
{"code": "for (integer i=0; i < N; i++)  \n    zd[i] = c;", "pragma": "parallel for ", "hash": "34f5ec92097246967cd670e296ebbf3d6d0fadcce728091c122b079c96e1af20"}
{"code": "for (int  _T_i1 = 0; (_T_i1 <= ((R - 8) / 32)); _T_i1 = (_T_i1 + 1)) \n  { \n    float  Dx_inGPyramid_L2[8][259]; \n    for (int  _T_i2 = -1; (_T_i2 <= ((C - 4) / 512)); _T_i2 = (_T_i2 + 1)) \n    { \n      int  _ct32629 = ((((8 * _T_i1) + 7) < ((R / 4) - 2))? ((8 * _T_i1) + 7): ((R / 4) - 2)); \n      int  _ct32630 = ((1 > (8 * _T_i1))? 1: (8 * _T_i1)); \n      for (int  _i1 = _ct32630; (_i1 <= _ct32629); _i1 = (_i1 + 1)) \n      { \n        int  _ct32631 = ((((256 * _T_i2) + 258) < ((C / 2) - 2))? ((256 * _T_i2) + 258): ((C / 2) - 2)); \n        int  _ct32632 = ((1 > (256 * _T_i2))? 1: (256 * _T_i2)); \n        #pragma ivdep \n        for (int  _i2 = _ct32632; (_i2 <= _ct32631); _i2 = (_i2 + 1)) \n        { \n          Dx_inGPyramid_L2[((-8 * _T_i1) + _i1)][((-256 * _T_i2) + _i2)] = ((((D_inGPyramid_L1[(((-2 + (2 * _i1)) * ((((C / 2) - 2) - 1) + 1)) + (-1 + _i2))] + (3.0f * D_inGPyramid_L1[(((-1 + (2 * _i1)) * ((((C / 2) - 2) - 1) + 1)) + (-1 + _i2))])) + (3.0f * D_inGPyramid_L1[(((2 * _i1) * ((((C / 2) - 2) - 1) + 1)) + (-1 + _i2))])) + D_inGPyramid_L1[(((1 + (2 * _i1)) * ((((C / 2) - 2) - 1) + 1)) + (-1 + _i2))]) * 0.125f); \n        } \n      } \n      if ((_T_i2 >= 0)) \n      { \n        int  _ct32633 = ((((8 * _T_i1) + 7) < ((R / 4) - 2))? ((8 * _T_i1) + 7): ((R / 4) - 2)); \n        int  _ct32634 = ((1 > (8 * _T_i1))? 1: (8 * _T_i1)); \n        for (int  _i1 = _ct32634; (_i1 <= _ct32633); _i1 = (_i1 + 1)) \n        { \n          int  _ct32635 = ((((256 * _T_i2) + 256) < ((C / 2) - 4))? ((256 * _T_i2) + 256): ((C / 2) - 4)); \n          #pragma ivdep \n          for (int  _i2 = ((256 * _T_i2) + 2); (_i2 <= _ct32635); _i2 = (_i2 + 2)) \n          { \n            D_inGPyramid_L2[(((_i1 - 1) * ((((C / 4) - 2) - 1) + 1)) + ((_i2 / 2) - 1))] = ((((Dx_inGPyramid_L2[((-8 * _T_i1) + _i1)][(-1 + (2 * ((_i2 / 2) - (128 * _T_i2))))] + (3.0f * Dx_inGPyramid_L2[((-8 * _T_i1) + _i1)][(2 * ((_i2 / 2) - (128 * _T_i2)))])) + (3.0f * Dx_inGPyramid_L2[((-8 * _T_i1) + _i1)][(1 + (2 * ((_i2 / 2) - (128 * _T_i2))))])) + Dx_inGPyramid_L2[((-8 * _T_i1) + _i1)][(2 + (2 * ((_i2 / 2) - (128 * _T_i2))))]) * 0.125f); \n          } \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "4df1b0a9481d8433b01a9353361547103516c19f122198cdd79dc9bc8ba78c4a"}
{"code": "for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    const Quantum \n      *pixels; \n \n    MagickRealType \n      blue, \n      luma, \n      green, \n      hue, \n      red, \n      chroma; \n \n    PixelInfo \n      destination_pixel, \n      source_pixel; \n \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    if (clip_to_self != MagickFalse) \n      { \n        if (y < y_offset) \n          continue; \n        if ((y-y_offset) >= (ssize_t) composite_image->rows) \n          continue; \n      } \n     \n \n    pixels=(Quantum *) NULL; \n    p=(Quantum *) NULL; \n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows)) \n      { \n        p=GetCacheViewVirtualPixels(composite_view,0,y-y_offset, \n          composite_image->columns,1,exception); \n        if (p == (const Quantum *) NULL) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        pixels=p; \n        if (x_offset < 0) \n          p-=x_offset*GetPixelChannels(composite_image); \n      } \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    hue=0.0; \n    chroma=0.0; \n    luma=0.0; \n    GetPixelInfo(image,&destination_pixel); \n    GetPixelInfo(composite_image,&source_pixel); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      MagickRealType \n        alpha, \n        Da, \n        Dc, \n        Dca, \n        gamma, \n        Sa, \n        Sc, \n        Sca; \n \n      register ssize_t \n        i; \n \n      size_t \n        channels; \n \n      if (clip_to_self != MagickFalse) \n        { \n          if (x < x_offset) \n            { \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          if ((x-x_offset) >= (ssize_t) composite_image->columns) \n            break; \n        } \n      if ((pixels == (Quantum *) NULL) || (x < x_offset) || \n          ((x-x_offset) >= (ssize_t) composite_image->columns)) \n        { \n          Quantum \n            source[MaxPixelChannels]; \n \n           \n \n          (void) GetOneVirtualPixel(composite_image,x-x_offset,y-y_offset, \n            source,exception); \n          if (GetPixelMask(image,q) != 0) \n            { \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n          { \n            MagickRealType \n              pixel; \n \n            PixelChannel \n              channel; \n \n            PixelTrait \n              composite_traits, \n              traits; \n \n            channel=GetPixelChannelChannel(image,i); \n            traits=GetPixelChannelTraits(image,channel); \n            composite_traits=GetPixelChannelTraits(composite_image,channel); \n            if ((traits == UndefinedPixelTrait) || \n                (composite_traits == UndefinedPixelTrait)) \n              continue; \n            switch (compose) \n            { \n              case AlphaCompositeOp: \n              case ChangeMaskCompositeOp: \n              case CopyAlphaCompositeOp: \n              case DstAtopCompositeOp: \n              case DstInCompositeOp: \n              case InCompositeOp: \n              case IntensityCompositeOp: \n              case OutCompositeOp: \n              case SrcInCompositeOp: \n              case SrcOutCompositeOp: \n              { \n                pixel=(MagickRealType) q[i]; \n                if (channel == AlphaPixelChannel) \n                  pixel=(MagickRealType) TransparentAlpha; \n                break; \n              } \n              case ClearCompositeOp: \n              case CopyCompositeOp: \n              case ReplaceCompositeOp: \n              case SrcCompositeOp: \n              { \n                if (channel == AlphaPixelChannel) \n                  { \n                    pixel=(MagickRealType) TransparentAlpha; \n                    break; \n                  } \n                pixel=0.0; \n                break; \n              } \n              case BlendCompositeOp: \n              case DissolveCompositeOp: \n              { \n                if (channel == AlphaPixelChannel) \n                  { \n                    pixel=destination_dissolve*GetPixelAlpha(composite_image, \n                      source); \n                    break; \n                  } \n                pixel=(MagickRealType) source[channel]; \n                break; \n              } \n              default: \n              { \n                pixel=(MagickRealType) source[channel]; \n                break; \n              } \n            } \n            q[i]=ClampToQuantum(pixel); \n          } \n          q+=GetPixelChannels(image); \n          continue; \n        } \n       \n \n      Sa=QuantumScale*GetPixelAlpha(composite_image,p); \n      Da=QuantumScale*GetPixelAlpha(image,q); \n      switch (compose) \n      { \n        case BumpmapCompositeOp: \n        { \n          alpha=GetPixelIntensity(composite_image,p)*Sa; \n          break; \n        } \n        case ColorBurnCompositeOp: \n        case ColorDodgeCompositeOp: \n        case DifferenceCompositeOp: \n        case DivideDstCompositeOp: \n        case DivideSrcCompositeOp: \n        case ExclusionCompositeOp: \n        case HardLightCompositeOp: \n        case LinearBurnCompositeOp: \n        case LinearDodgeCompositeOp: \n        case LinearLightCompositeOp: \n        case MathematicsCompositeOp: \n        case MinusDstCompositeOp: \n        case MinusSrcCompositeOp: \n        case ModulusAddCompositeOp: \n        case ModulusSubtractCompositeOp: \n        case MultiplyCompositeOp: \n        case OverlayCompositeOp: \n        case PegtopLightCompositeOp: \n        case PinLightCompositeOp: \n        case ScreenCompositeOp: \n        case SoftLightCompositeOp: \n        case VividLightCompositeOp: \n        { \n          alpha=RoundToUnity(Sa+Da-Sa*Da); \n          break; \n        } \n        case DarkenCompositeOp: \n        case DstAtopCompositeOp: \n        case DstInCompositeOp: \n        case InCompositeOp: \n        case LightenCompositeOp: \n        case SrcInCompositeOp: \n        { \n          alpha=Sa*Da; \n          break; \n        } \n        case DissolveCompositeOp: \n        { \n          alpha=source_dissolve*Sa*(-destination_dissolve*Da)+source_dissolve* \n            Sa+destination_dissolve*Da; \n          break; \n        } \n        case DstOverCompositeOp: \n        { \n          alpha=Da*(-Sa)+Da+Sa; \n          break; \n        } \n        case DstOutCompositeOp: \n        { \n          alpha=Da*(1.0-Sa); \n          break; \n        } \n        case OutCompositeOp: \n        case SrcOutCompositeOp: \n        { \n          alpha=Sa*(1.0-Da); \n          break; \n        } \n        case OverCompositeOp: \n        case SrcOverCompositeOp: \n        { \n          alpha=Sa*(-Da)+Sa+Da; \n          break; \n        } \n        case BlendCompositeOp: \n        case PlusCompositeOp: \n        { \n          alpha=RoundToUnity(Sa+Da); \n          break; \n        } \n        case XorCompositeOp: \n        { \n          alpha=Sa+Da-2.0*Sa*Da; \n          break; \n        } \n        default: \n        { \n          alpha=1.0; \n          break; \n        } \n      } \n      if (GetPixelMask(image,p) != 0) \n        { \n          p+=GetPixelChannels(composite_image); \n          q+=GetPixelChannels(image); \n          continue; \n        } \n      switch (compose) \n      { \n        case ColorizeCompositeOp: \n        case HueCompositeOp: \n        case LuminizeCompositeOp: \n        case ModulateCompositeOp: \n        case SaturateCompositeOp: \n        { \n          GetPixelInfoPixel(composite_image,p,&source_pixel); \n          GetPixelInfoPixel(image,q,&destination_pixel); \n          break; \n        } \n        default: \n          break; \n      } \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        MagickRealType \n          pixel, \n          sans; \n \n        PixelChannel \n          channel; \n \n        PixelTrait \n          composite_traits, \n          traits; \n \n        channel=GetPixelChannelChannel(image,i); \n        traits=GetPixelChannelTraits(image,channel); \n        composite_traits=GetPixelChannelTraits(composite_image,channel); \n        if (traits == UndefinedPixelTrait) \n          continue; \n        if ((compose != IntensityCompositeOp) && \n            (composite_traits == UndefinedPixelTrait)) \n          continue; \n         \n \n        Sc=(MagickRealType) GetPixelChannel(composite_image,channel,p); \n        Dc=(MagickRealType) q[i]; \n        if ((traits & CopyPixelTrait) != 0) \n          { \n            if (channel != AlphaPixelChannel) \n              { \n                 \n \n                q[i]=ClampToQuantum(Sc); \n                continue; \n              } \n             \n \n            switch (compose) \n            { \n              case AlphaCompositeOp: \n              { \n                pixel=QuantumRange*Sa; \n                break; \n              } \n              case AtopCompositeOp: \n              case CopyBlackCompositeOp: \n              case CopyBlueCompositeOp: \n              case CopyCyanCompositeOp: \n              case CopyGreenCompositeOp: \n              case CopyMagentaCompositeOp: \n              case CopyRedCompositeOp: \n              case CopyYellowCompositeOp: \n              case SrcAtopCompositeOp: \n              case DstCompositeOp: \n              case NoCompositeOp: \n              { \n                pixel=QuantumRange*Da; \n                break; \n              } \n              case ChangeMaskCompositeOp: \n              { \n                MagickBooleanType \n                  equivalent; \n \n                if (Da > ((MagickRealType) QuantumRange/2.0)) \n                  { \n                    pixel=(MagickRealType) TransparentAlpha; \n                    break; \n                  } \n                equivalent=IsFuzzyEquivalencePixel(composite_image,p,image,q); \n                if (equivalent != MagickFalse) \n                  { \n                    pixel=(MagickRealType) TransparentAlpha; \n                    break; \n                  } \n                pixel=(MagickRealType) OpaqueAlpha; \n                break; \n              } \n              case ClearCompositeOp: \n              { \n                pixel=(MagickRealType) TransparentAlpha; \n                break; \n              } \n              case ColorizeCompositeOp: \n              case HueCompositeOp: \n              case LuminizeCompositeOp: \n              case SaturateCompositeOp: \n              { \n                if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n                  { \n                    pixel=QuantumRange*Da; \n                    break; \n                  } \n                if (fabs(QuantumRange*Da-TransparentAlpha) < MagickEpsilon) \n                  { \n                    pixel=QuantumRange*Sa; \n                    break; \n                  } \n                if (Sa < Da) \n                  { \n                    pixel=QuantumRange*Da; \n                    break; \n                  } \n                pixel=QuantumRange*Sa; \n                break; \n              } \n              case CopyAlphaCompositeOp: \n              { \n                pixel=QuantumRange*Sa; \n                if (composite_image->alpha_trait != BlendPixelTrait) \n                  pixel=GetPixelIntensity(composite_image,p); \n                break; \n              } \n              case CopyCompositeOp: \n              case DisplaceCompositeOp: \n              case DistortCompositeOp: \n              case DstAtopCompositeOp: \n              case ReplaceCompositeOp: \n              case SrcCompositeOp: \n              { \n                pixel=QuantumRange*Sa; \n                break; \n              } \n              case DarkenIntensityCompositeOp: \n              { \n                pixel=(1.0-Sa)*GetPixelIntensity(composite_image,p) < \n                  (1.0-Da)*GetPixelIntensity(image,q) ? Sa : Da; \n                break; \n              } \n              case IntensityCompositeOp: \n              { \n                pixel=GetPixelIntensity(composite_image,p); \n                break; \n              } \n              case LightenIntensityCompositeOp: \n              { \n                pixel=Sa*GetPixelIntensity(composite_image,p) > \n                  Da*GetPixelIntensity(image,q) ? Sa : Da; \n                break; \n              } \n              case ModulateCompositeOp: \n              { \n                if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n                  { \n                    pixel=QuantumRange*Da; \n                    break; \n                  } \n                pixel=QuantumRange*Da; \n                break; \n              } \n              default: \n              { \n                pixel=QuantumRange*alpha; \n                break; \n              } \n            } \n            q[i]=ClampToQuantum(pixel); \n            continue; \n          } \n         \n \n        Sca=QuantumScale*Sa*Sc; \n        Dca=QuantumScale*Da*Dc; \n        switch (compose) \n        { \n          case DarkenCompositeOp: \n          case LightenCompositeOp: \n          case ModulusSubtractCompositeOp: \n          { \n            gamma=1.0-alpha; \n            break; \n          } \n          default: \n            break; \n        } \n        gamma=PerceptibleReciprocal(alpha); \n        pixel=Dc; \n        switch (compose) \n        { \n          case AlphaCompositeOp: \n          { \n            pixel=QuantumRange*Sa; \n            break; \n          } \n          case AtopCompositeOp: \n          case SrcAtopCompositeOp: \n          { \n            pixel=Sc*Sa+Dc*(1.0-Sa); \n            break; \n          } \n          case BlendCompositeOp: \n          { \n            pixel=gamma*(source_dissolve*Sa*Sc+destination_dissolve*Da*Dc); \n            break; \n          } \n          case BlurCompositeOp: \n          case DisplaceCompositeOp: \n          case DistortCompositeOp: \n          case CopyCompositeOp: \n          case ReplaceCompositeOp: \n          case SrcCompositeOp: \n          { \n            pixel=Sc; \n            break; \n          } \n          case BumpmapCompositeOp: \n          { \n            if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Dc; \n                break; \n              } \n            pixel=QuantumScale*GetPixelIntensity(composite_image,p)*Dc; \n            break; \n          } \n          case ChangeMaskCompositeOp: \n          { \n            pixel=Dc; \n            break; \n          } \n          case ClearCompositeOp: \n          { \n            pixel=0.0; \n            break; \n          } \n          case ColorBurnCompositeOp: \n          { \n             \n \n            if ((fabs(Sca) < MagickEpsilon) && (fabs(Dca-Da) < MagickEpsilon)) \n              { \n                pixel=QuantumRange*gamma*(Sa*Da+Dca*(1.0-Sa)); \n                break; \n              } \n            if (Sca < MagickEpsilon) \n              { \n                pixel=QuantumRange*gamma*(Dca*(1.0-Sa)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Sa*Da-Sa*MagickMin(Da,(Da-Dca)*Sa/Sca)+ \n              Sca*(1.0-Da)+Dca*(1.0-Sa)); \n            break; \n          } \n          case ColorDodgeCompositeOp: \n          { \n            if ((fabs(Sca-Sa) < MagickEpsilon) && (fabs(Dca) < MagickEpsilon)) \n              { \n                pixel=QuantumRange*gamma*(Sca*(1.0-Da)+Dca*(1.0-Sa)); \n                break; \n              } \n            if (fabs(Sca-Sa) < MagickEpsilon) \n              { \n                pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Dca*Sa*Sa/(Sa-Sca)+Sca*(1.0-Da)+Dca* \n              (1.0-Sa)); \n            break; \n          } \n          case ColorizeCompositeOp: \n          { \n            if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Dc; \n                break; \n              } \n            if (fabs(QuantumRange*Da-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Sc; \n                break; \n              } \n            CompositeHCL(destination_pixel.red,destination_pixel.green, \n              destination_pixel.blue,&sans,&sans,&luma); \n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue, \n              &hue,&chroma,&sans); \n            HCLComposite(hue,chroma,luma,&red,&green,&blue); \n            switch (channel) \n            { \n              case RedPixelChannel: pixel=red; break; \n              case GreenPixelChannel: pixel=green; break; \n              case BluePixelChannel: pixel=blue; break; \n              default: pixel=Dc; break; \n            } \n            break; \n          } \n          case CopyAlphaCompositeOp: \n          case IntensityCompositeOp: \n          { \n            pixel=Dc; \n            break; \n          } \n          case CopyBlackCompositeOp: \n          { \n            if (channel == BlackPixelChannel) \n              pixel=(MagickRealType) GetPixelBlack(composite_image,p); \n            break; \n          } \n          case CopyBlueCompositeOp: \n          case CopyYellowCompositeOp: \n          { \n            if (channel == BluePixelChannel) \n              pixel=(MagickRealType) GetPixelBlue(composite_image,p); \n            break; \n          } \n          case CopyGreenCompositeOp: \n          case CopyMagentaCompositeOp: \n          { \n            if (channel == GreenPixelChannel) \n              pixel=(MagickRealType) GetPixelGreen(composite_image,p); \n            break; \n          } \n          case CopyRedCompositeOp: \n          case CopyCyanCompositeOp: \n          { \n            if (channel == RedPixelChannel) \n              pixel=(MagickRealType) GetPixelRed(composite_image,p); \n            break; \n          } \n          case DarkenCompositeOp: \n          { \n             \n \n            if (Sc < Dc) \n              { \n                pixel=gamma*(Sa*Sc-Sa*Da*Dc+Da*Dc); \n                break; \n              } \n            pixel=gamma*(Da*Dc-Da*Sa*Sc+Sa*Sc); \n            break; \n          } \n          case DarkenIntensityCompositeOp: \n          { \n            pixel=(1.0-Sa)*GetPixelIntensity(composite_image,p) < \n              (1.0-Da)*GetPixelIntensity(image,q) ? Sc : Dc; \n            break; \n          } \n          case DifferenceCompositeOp: \n          { \n            pixel=gamma*(Sa*Sc+Da*Dc-Sa*Da*2.0*MagickMin(Sc,Dc)); \n            break; \n          } \n          case DissolveCompositeOp: \n          { \n            pixel=gamma*(source_dissolve*Sa*Sc-source_dissolve*Sa* \n              destination_dissolve*Da*Dc+destination_dissolve*Da*Dc); \n            break; \n          } \n          case DivideDstCompositeOp: \n          { \n            if ((fabs(Sca) < MagickEpsilon) && (fabs(Dca) < MagickEpsilon)) \n              { \n                pixel=QuantumRange*gamma*(Sca*(1.0-Da)+Dca*(1.0-Sa)); \n                break; \n              } \n            if (fabs(Dca) < MagickEpsilon) \n              { \n                pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Sca*Da*Da/Dca+Sca*(1.0-Da)+Dca*(1.0-Sa)); \n            break; \n          } \n          case DivideSrcCompositeOp: \n          { \n            if ((fabs(Dca) < MagickEpsilon) && (fabs(Sca) < MagickEpsilon)) \n              { \n                pixel=QuantumRange*gamma*(Dca*(1.0-Sa)+Sca*(1.0-Da)); \n                break; \n              } \n            if (fabs(Sca) < MagickEpsilon) \n              { \n                pixel=QuantumRange*gamma*(Da*Sa+Dca*(1.0-Sa)+Sca*(1.0-Da)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Dca*Sa*Sa/Sca+Dca*(1.0-Sa)+Sca*(1.0-Da)); \n            break; \n          } \n          case DstAtopCompositeOp: \n          { \n            pixel=Dc*Da+Sc*(1.0-Da); \n            break; \n          } \n          case DstCompositeOp: \n          case NoCompositeOp: \n          { \n            pixel=Dc; \n            break; \n          } \n          case DstInCompositeOp: \n          { \n            pixel=gamma*(Sa*Dc*Sa); \n            break; \n          } \n          case DstOutCompositeOp: \n          { \n            pixel=gamma*(Da*Dc*(1.0-Sa)); \n            break; \n          } \n          case DstOverCompositeOp: \n          { \n            pixel=gamma*(Da*Dc-Da*Sa*Sc+Sa*Sc); \n            break; \n          } \n          case ExclusionCompositeOp: \n          { \n            pixel=QuantumRange*gamma*(Sca*Da+Dca*Sa-2.0*Sca*Dca+Sca*(1.0-Da)+ \n              Dca*(1.0-Sa)); \n            break; \n          } \n          case HardLightCompositeOp: \n          { \n            if ((2.0*Sca) < Sa) \n              { \n                pixel=QuantumRange*gamma*(2.0*Sca*Dca+Sca*(1.0-Da)+Dca* \n                  (1.0-Sa)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Sa*Da-2.0*(Da-Dca)*(Sa-Sca)+Sca*(1.0-Da)+ \n              Dca*(1.0-Sa)); \n            break; \n          } \n          case HueCompositeOp: \n          { \n            if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Dc; \n                break; \n              } \n            if (fabs(QuantumRange*Da-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Sc; \n                break; \n              } \n            CompositeHCL(destination_pixel.red,destination_pixel.green, \n              destination_pixel.blue,&hue,&chroma,&luma); \n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue, \n              &hue,&sans,&sans); \n            HCLComposite(hue,chroma,luma,&red,&green,&blue); \n            switch (channel) \n            { \n              case RedPixelChannel: pixel=red; break; \n              case GreenPixelChannel: pixel=green; break; \n              case BluePixelChannel: pixel=blue; break; \n              default: pixel=Dc; break; \n            } \n            break; \n          } \n          case InCompositeOp: \n          case SrcInCompositeOp: \n          { \n            pixel=gamma*(Da*Sc*Da); \n            break; \n          } \n          case LinearBurnCompositeOp: \n          { \n             \n \n            pixel=QuantumRange*gamma*(Sca+Dca-Sa*Da); \n            break; \n          } \n          case LinearDodgeCompositeOp: \n          { \n            pixel=QuantumRange*gamma*(Sa*Sc+Da*Dc); \n            break; \n          } \n          case LinearLightCompositeOp: \n          { \n             \n \n            pixel=QuantumRange*gamma*((Sca-Sa)*Da+Sca+Dca); \n            break; \n          } \n          case LightenCompositeOp: \n          { \n            if (Sc > Dc) \n              { \n                pixel=gamma*(Sa*Sc-Sa*Da*Dc+Da*Dc); \n                break; \n              } \n            pixel=gamma*(Da*Dc-Da*Sa*Sc+Sa*Sc); \n            break; \n          } \n          case LightenIntensityCompositeOp: \n          { \n             \n \n            pixel=Sa*GetPixelIntensity(composite_image,p) > \n              Da*GetPixelIntensity(image,q) ? Sc : Dc; \n            break; \n          } \n          case LuminizeCompositeOp: \n          { \n            if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Dc; \n                break; \n              } \n            if (fabs(QuantumRange*Da-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Sc; \n                break; \n              } \n            CompositeHCL(destination_pixel.red,destination_pixel.green, \n              destination_pixel.blue,&hue,&chroma,&luma); \n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue, \n              &sans,&sans,&luma); \n            HCLComposite(hue,chroma,luma,&red,&green,&blue); \n            switch (channel) \n            { \n              case RedPixelChannel: pixel=red; break; \n              case GreenPixelChannel: pixel=green; break; \n              case BluePixelChannel: pixel=blue; break; \n              default: pixel=Dc; break; \n            } \n            break; \n          } \n          case MathematicsCompositeOp: \n          { \n             \n \n            pixel=gamma*geometry_info.rho*Sa*Sc*Da*Dc+geometry_info.sigma* \n              Sa*Sc*Da+geometry_info.xi*Da*Dc*Sa+geometry_info.psi*Sa*Da+ \n              Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa); \n            break; \n          } \n          case MinusDstCompositeOp: \n          { \n            pixel=gamma*(Sa*Sc+Da*Dc-2.0*Da*Dc*Sa); \n            break; \n          } \n          case MinusSrcCompositeOp: \n          { \n             \n \n            pixel=QuantumRange*gamma*(Da*Dc+Sa*Sc-2.0*Sa*Sc*Da); \n            break; \n          } \n          case ModulateCompositeOp: \n          { \n            ssize_t \n              offset; \n \n            if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Dc; \n                break; \n              } \n            offset=(ssize_t) (GetPixelIntensity(composite_image,p)-midpoint); \n            if (offset == 0) \n              { \n                pixel=Dc; \n                break; \n              } \n            CompositeHCL(destination_pixel.red,destination_pixel.green, \n              destination_pixel.blue,&hue,&chroma,&luma); \n            luma+=(0.01*percent_luma*offset)/midpoint; \n            chroma*=0.01*percent_chroma; \n            HCLComposite(hue,chroma,luma,&red,&green,&blue); \n            switch (channel) \n            { \n              case RedPixelChannel: pixel=red; break; \n              case GreenPixelChannel: pixel=green; break; \n              case BluePixelChannel: pixel=blue; break; \n              default: pixel=Dc; break; \n            } \n            break; \n          } \n          case ModulusAddCompositeOp: \n          { \n            pixel=Sc+Dc; \n            if (pixel > QuantumRange) \n              pixel-=(QuantumRange+1.0); \n            pixel=gamma*(pixel*Sa*Da+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa)); \n            break; \n          } \n          case ModulusSubtractCompositeOp: \n          { \n            pixel=Sc-Dc; \n            if (pixel < 0.0) \n              pixel+=(QuantumRange+1.0); \n            pixel=gamma*(pixel*Sa*Da+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa)); \n            break; \n          } \n          case MultiplyCompositeOp: \n          { \n            pixel=QuantumRange*gamma*(Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa)); \n            break; \n          } \n          case OutCompositeOp: \n          case SrcOutCompositeOp: \n          { \n            pixel=gamma*(Sa*Sc*(1.0-Da)); \n            break; \n          } \n          case OverCompositeOp: \n          case SrcOverCompositeOp: \n          { \n            pixel=QuantumRange*gamma*(Sa*Sc-Sa*Da*Dc+Da*Dc); \n            break; \n          } \n          case OverlayCompositeOp: \n          { \n            if ((2.0*Dca) < Da) \n              { \n                pixel=QuantumRange*gamma*(2.0*Dca*Sca+Dca*(1.0-Sa)+Sca* \n                  (1.0-Da)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Da*Sa-2.0*(Sa-Sca)*(Da-Dca)+Dca*(1.0-Sa)+ \n              Sca*(1.0-Da)); \n            break; \n          } \n          case PegtopLightCompositeOp: \n          { \n             \n \n            if (fabs(Da) < MagickEpsilon) \n              { \n                pixel=QuantumRange*gamma*(Sca); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Dca*Dca*(Sa-2.0*Sca)/Da+Sca*(2.0*Dca+1.0- \n              Da)+Dca*(1.0-Sa)); \n            break; \n          } \n          case PinLightCompositeOp: \n          { \n             \n \n            if ((Dca*Sa) < (Da*(2.0*Sca-Sa))) \n              { \n                pixel=QuantumRange*gamma*(Sca*(Da+1.0)-Sa*Da+Dca*(1.0-Sa)); \n                break; \n              } \n            if ((Dca*Sa) > (2.0*Sca*Da)) \n              { \n                pixel=QuantumRange*gamma*(Sca*Da+Sca+Dca*(1.0-Sa)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Sca*(1.0-Da)+Dca); \n            break; \n          } \n          case PlusCompositeOp: \n          { \n            pixel=gamma*(Sa*Sc+Da*Dc); \n            break; \n          } \n          case SaturateCompositeOp: \n          { \n            if (fabs(QuantumRange*Sa-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Dc; \n                break; \n              } \n            if (fabs(QuantumRange*Da-TransparentAlpha) < MagickEpsilon) \n              { \n                pixel=Sc; \n                break; \n              } \n            CompositeHCL(destination_pixel.red,destination_pixel.green, \n              destination_pixel.blue,&hue,&chroma,&luma); \n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue, \n              &sans,&chroma,&sans); \n            HCLComposite(hue,chroma,luma,&red,&green,&blue); \n            switch (channel) \n            { \n              case RedPixelChannel: pixel=red; break; \n              case GreenPixelChannel: pixel=green; break; \n              case BluePixelChannel: pixel=blue; break; \n              default: pixel=Dc; break; \n            } \n            break; \n          } \n          case ScreenCompositeOp: \n          { \n             \n \n            pixel=QuantumRange*gamma*(Sca+Dca-Sca*Dca); \n            break; \n          } \n          case SoftLightCompositeOp: \n          { \n             \n \n            if ((2.0*Sca) < Sa) \n              { \n                pixel=QuantumRange*gamma*(Dca*(Sa+(2.0*Sca-Sa)*(1.0-(Dca/Da)))+ \n                  Sca*(1.0-Da)+Dca*(1.0-Sa)); \n                break; \n              } \n            if (((2.0*Sca) > Sa) && ((4.0*Dca) <= Da)) \n              { \n                pixel=QuantumRange*gamma*(Dca*Sa+Da*(2.0*Sca-Sa)*(4.0*(Dca/Da)* \n                  (4.0*(Dca/Da)+1.0)*((Dca/Da)-1.0)+7.0*(Dca/Da))+Sca*(1.0-Da)+ \n                  Dca*(1.0-Sa)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Dca*Sa+Da*(2.0*Sca-Sa)*(pow((Dca/Da),0.5)- \n              (Dca/Da))+Sca*(1.0-Da)+Dca*(1.0-Sa)); \n            break; \n          } \n          case ThresholdCompositeOp: \n          { \n            MagickRealType \n              delta; \n \n            delta=Sc-Dc; \n            if ((MagickRealType) fabs((double) (2.0*delta)) < threshold) \n              { \n                pixel=gamma*Dc; \n                break; \n              } \n            pixel=gamma*(Dc+delta*amount); \n            break; \n          } \n          case VividLightCompositeOp: \n          { \n             \n \n            if ((fabs(Sa) < MagickEpsilon) || (fabs(Sca-Sa) < MagickEpsilon)) \n              { \n                pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa)); \n                break; \n              } \n            if ((2.0*Sca) <= Sa) \n              { \n                pixel=QuantumRange*gamma*(Sa*(Da+Sa*(Dca-Da)/(2.0*Sca))+Sca* \n                  (1.0-Da)+Dca*(1.0-Sa)); \n                break; \n              } \n            pixel=QuantumRange*gamma*(Dca*Sa*Sa/(2.0*(Sa-Sca))+Sca*(1.0-Da)+ \n              Dca*(1.0-Sa)); \n            break; \n          } \n          case XorCompositeOp: \n          { \n            pixel=QuantumRange*gamma*(Sc*Sa*(1.0-Da)+Dc*Da*(1.0-Sa)); \n            break; \n          } \n          default: \n          { \n            pixel=Sc; \n            break; \n          } \n        } \n        q[i]=ClampToQuantum(pixel); \n      } \n      p+=GetPixelChannels(composite_image); \n      channels=GetPixelChannels(composite_image); \n      if (p >= (pixels+channels*composite_image->columns)) \n        p=pixels; \n      q+=GetPixelChannels(image); \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor != (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_CompositeImage) \n        proceed=SetImageProgress(image,CompositeImageTag,progress++, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  }", "pragma": "parallel for ", "hash": "c3c31fab3a4a288443502a3db40c5ca61b3357b955d547291f93c8e06f4343d2"}
{"code": "for(int i = 0; i < _cpuJobs.size(); ++i) \n        computeViewJob(_cpuJobs.at(i));", "pragma": "parallel for ", "hash": "9fb1893853b9932907c37e16917a337fec9041e79df1ac42a64a11ceb7aebf78"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tlong k = i*nx;\t\t\tb[k] = b[k+nx-1] = 0;\r \n\t\tfor(long j=1;j<nx-1;j++)\tb[j+k] = (a[j+k+1]+a[j+k-1]-mgl2*a[j+k])*dd;\r \n\t}", "pragma": "parallel ", "hash": "ddbeca958e14a8ca8ad7db2dd2d802b65c7b6297469dcdce8a10834bd38018e3"}
{"code": "for (int y = 0; y < image_height; y++) { \n        int n = y*image_width*3; \n        for (int x = 0; x < image_width; x++, n+=3) { \n            insert( \n                camera_centre_x, camera_centre_y, camera_centre_z, \n                (int)points[n], (int)points[n+1], (int)points[n+2], \n                img[n], img[n+1], img[n+2]); \n        } \n    }", "pragma": "parallel for ", "hash": "758fa4f9df1e99c6a92bc604ea9e5c54f407f486ac8c420a48da3fe5af3607c9"}
{"code": "for(size_t y = 0; y < stride; y += ch) \n    { \n      const float *const in = image_in + y ; \n      float *const out = image_out + y; \n \n      float xyz[3] DT_ALIGNED_PIXEL = { 0.0f, 0.0f, 0.0f }; \n \n      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, matrix); \n      dt_XYZ_to_Lab(xyz, out); \n    }", "pragma": "parallel for simd ", "hash": "3ffab4301ca631d1420a825357b910230a24d12bf6c15bb3957713df44681f32"}
{"code": "for (i = 0; i < ns; i++) { \n        rowsum = 0.; \n        npx = 0; \n        p = i * nf; \n#pragma omp simd \n        for (j = 0; j < nf; j++) { \n            if (img[p + j] < cut) { \n                rowsum += img[p + j]; \n                npx++; \n            } \n        } \n        if (npx > 0) \n            avg = rowsum / npx; \n#pragma omp simd \n        for (j = 0; j < nf; j++) \n            img[p + j] = img[p + j] - avg; \n    }", "pragma": "parallel for private(    avg i j npx p rowsum)", "hash": "75b222a35fb214d26fcd00c3605f43fa582b63a4d9a063bcec75bb0e2063958d"}
{"code": "for (size_t i = 0; i < sizeQl; i++) { \n        m_vectors[i] = partQl.m_vectors[i]; \n    }", "pragma": "parallel for ", "hash": "2729708f22d74e1933128fbaa386dfe538c0718825bf9139be4bf89620d86181"}
{"code": "for (int it = 0; it < FaceLastLocalID(); it++) if( isValidFace(it) ) \n\t\t\t\t\t{ \n\t\t\t\t\t\tFace f = FaceByLocalID(it); \n\t\t\t\t\t\tCell c1 = f.BackCell(); \n\t\t\t\t\t\tCell c2 = f.FrontCell(); \n\t\t\t\t\t\tcur1 = cur2 = -1; \n\t\t\t\t\t\tif( c1.isValid() ) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\ti1 = c1.IntegerArray(block_index)[0]; \n\t\t\t\t\t\t\tj1 = c1.IntegerArray(block_index)[1]; \n\t\t\t\t\t\t\tk1 = c1.IntegerArray(block_index)[2]; \n\t\t\t\t\t\t\tcur1 = ECL_IJK_DATA(i1, j1, k1); \n\t\t\t\t\t\t} \n\t\t\t\t\t\t \n\t\t\t\t\t\tif( c2.isValid() ) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\ti2 = c2.IntegerArray(block_index)[0]; \n\t\t\t\t\t\t\tj2 = c2.IntegerArray(block_index)[1]; \n\t\t\t\t\t\t\tk2 = c2.IntegerArray(block_index)[2]; \n\t\t\t\t\t\t\tcur2 = ECL_IJK_DATA(i2, j2, k2); \n\t\t\t\t\t\t} \n\t\t\t\t\t\t \n\t\t\t\t\t\tif( c1.isValid() && c2.isValid() ) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tif( (i1 != i2 ? 1 : 0) + (j1 != j2 ? 1 : 0) + (k1 != k2 ? 1 : 0) != 1 ) \n\t\t\t\t\t\t\t\tstd::cout << \"face connects faces (\" << i1 << \",\" << j1 << \",\" << k1 << \") and (\" << i2 << \",\" << j2 << \",\" << k2 << \") which has difference in more then one index\" << std::endl; \n\t\t\t\t\t\t\tif( i1 > i2 || j1 > j2 || k1 > k2 )  \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tstd::swap(c1,c2); \n\t\t\t\t\t\t\t\tstd::swap(i1,i2); \n\t\t\t\t\t\t\t\tstd::swap(j1,j2); \n\t\t\t\t\t\t\t\tstd::swap(k1,k2); \n\t\t\t\t\t\t\t\tstd::swap(cur1,cur2); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tconst int nodes[3][4] = {{0,2,4,6},{0,1,4,5},{0,1,2,3}}; \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tint d = -1, s; \n\t\t\t\t\t\t\tif( i1 != i2 )  \n \n\t\t\t\t\t\t\t\td = 0; \n\t\t\t\t\t\t\telse if( j1 != j2 )  \n \n\t\t\t\t\t\t\t\td = 1; \n\t\t\t\t\t\t\telse if( k1 != k2 )  \n \n\t\t\t\t\t\t\t\td = 2; \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tXF1.Zero(); \n\t\t\t\t\t\t\tXF2.Zero(); \n\t\t\t\t\t\t\ts = (int)pow(2,d); \n\t\t\t\t\t\t\tfor(int q = 0; q < 4; ++q) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tXF1 += raMatrixMake(Node(this, block_nodes[cur1 * 8 + nodes[d][q] + s])->Coords().data(),3,1); \n\t\t\t\t\t\t\t\tXF2 += raMatrixMake(Node(this, block_nodes[cur2 * 8 + nodes[d][q] + 0])->Coords().data(),3,1); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\tXF1 *= INMOST_DATA_REAL_TYPE(0.25); \n\t\t\t\t\t\t\tXF2 *= INMOST_DATA_REAL_TYPE(0.25); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tX1.Zero(); \n\t\t\t\t\t\t\tX2.Zero(); \n\t\t\t\t\t\t\tfor(int q = 0; q < 8; ++q) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tX1 += raMatrixMake(Node(this, block_nodes[cur1 * 8 + q])->Coords().data(),3,1); \n\t\t\t\t\t\t\t\tX2 += raMatrixMake(Node(this, block_nodes[cur2 * 8 + q])->Coords().data(),3,1); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\tX1 *= INMOST_DATA_REAL_TYPE(0.125); \n\t\t\t\t\t\t\tX2 *= INMOST_DATA_REAL_TYPE(0.125); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tD1 = XF1 - X1; \n\t\t\t\t\t\t\tD2 = X2 - XF2; \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tf.OrientedNormal(c1,A.data()); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tntg1 = ntg2 = 1.0; \n\t\t\t\t\t\t\tif( d != 2 && !ntg.empty() ) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tntg1 = ntg[cur1]; \n\t\t\t\t\t\t\t\tntg2 = ntg[cur2]; \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\tR1 = D1.DotProduct(D1); \n\t\t\t\t\t\t\tR2 = D2.DotProduct(D2); \n\t\t\t\t\t\t\tT1 = perm[6*cur1 + d] * ntg1 * A.DotProduct(D1); \n\t\t\t\t\t\t\tT2 = perm[6*cur2 + d] * ntg2 * A.DotProduct(D2); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\ttran[f] = T1*T2 / (T1*R2 + T2*R1);  \n \n\t\t\t\t\t\t} \n\t\t\t\t\t\telse tran[f] = 0.0;  \n \n\t\t\t\t\t}", "pragma": "for ", "hash": "e92267a53294ff5922a5c7cca17791329f5dce6542a16b965453aad089cb4388"}
{"code": "for (ompIndexType k = 0; k < (ompIndexType)res->nIr; ++k) { \n                    res->Ir[k] = (mwIndex)pInner[k]; \n                }", "pragma": "parallel for ", "hash": "c7b598def655d08ae05b076f255d590cc31b947b8c89537a99bddc4d725afcc7"}
{"code": "for (size_t i = 0; i < jobs.size(); i++) { \n            std::string job_name = \"Job \" + std::to_string(i); \n            if (config.show_progress) { \n                #pragma omp critical \n                { \n                    std::cerr << job_name << \": File \" << jobs[i].filename << \", paths {\"; \n                    for (path_handle_t handle : jobs[i].paths) { \n                        std::cerr << \" \" << graphs.path_graph->get_path_name(handle); \n                    } \n                    std::cerr << \" }\" << std::endl; \n                } \n            } \n            vcf_parses[i] = config.haplotype_indexer.parse_vcf(jobs[i].filename, *(graphs.path_graph), jobs[i].paths, job_name); \n        }", "pragma": "parallel for ", "hash": "0c9a5b22587b1c7eb00784e0d67fc0834455eadafda7ddfe11a2e3fa9cade3a3"}
{"code": "for(int j = si; j < this->layersG.front().size[1] - si-1; j += 2) \n\t\t\t\tfor(int i = si; i < this->layersG.front().size[2] - si-1; i += 2) \n\t\t\t\t{ \n\t\t\t\t\t \n \n\t\t\t\t\tint ml, mk, mj, mi; \n\t\t\t\t\tOctaveFinder::PixelType value; \n\t\t\t\t\tcirc.blockmin(l, j, i, ml, mk, mj, mi, value); \n\t\t\t\t\t \n \n\t\t\t\t\tif(value>0 || (1+value*value==1) || \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t(ml > nblayers) || !( \n\t\t\t\t\t\t\t(this->sizes[ml] <= mk+k) && (mk+k < this->layersG.front().size[0] - this->sizes[ml]) && \n\t\t\t\t\t\t\t(this->sizes[ml] <= mj) && (mj < this->layersG.front().size[1] - this->sizes[ml]) && \n\t\t\t\t\t\t\t(this->sizes[ml] <= mi) && (mi < this->layersG.front().size[2] - this->sizes[ml]) \n\t\t\t\t\t\t\t)) \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t \n \n\t\t\t\t\tif(!circ.is_localmin(l, j, i, ml, mk, mj, mi, value)) \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t \n \n\t\t\t\t\tif(circ.is_edge(ml, mk, mj, mi, max_ratio)) \n\t\t\t\t\t\tcontinue; \n \n\t\t\t\t\t \n \n\t\t\t\t\tstd::vector<int> ci(4); \n\t\t\t\t\tci[0] = mi; \n\t\t\t\t\tci[1] = mj; \n\t\t\t\t\tci[2] = mk+k; \n\t\t\t\t\tci[3] = ml; \n     #pragma omp critical(centers_no_subpix) \n\t\t\t\t\tthis->centers_no_subpix.push_back(ci); \n\t\t\t\t\t \n \n\t\t\t\t\tCenter3D c; \n\t\t\t\t\tc.intensity = value; \n\t\t\t\t\tc[0] = ci[0] + circ.shift(ml, mk, mj, mi, 0); \n\t\t\t\t\tc[1] = ci[1] + circ.shift(ml, mk, mj, mi, 1); \n\t\t\t\t\tc[2] = ci[2] + circ.shift(ml, mk, mj, mi, 2); \n\t\t\t\t\tc.r = ml + circ.shift(ml, mk, mj, mi, 3); \n     #pragma omp critical(centers) \n\t\t\t\t\tthis->centers.push_back(c); \n\t\t\t\t}", "pragma": "parallel for ", "hash": "92b3937581ba27c7064e95c204af69ad59a80e5baac61906086587eb2427b79e"}
{"code": "for(i=0; i<=j; i++) { \n                                        nd temp = min_circuit[ic+1+i]; \n                                        min_circuit[ic+1+i] = min_circuit[jc-i]; \n                                        min_circuit[jc-i] = temp; \n                                }", "pragma": "for ", "hash": "6e7cdbba0e7afc10fff484614d61854b1348f5ada6c09cf7791fff916f29fc33"}
{"code": "for(ii=0;ii<glob_nth;ii++) { \n      int jj; \n      double *los_dirty=&(glob_data_maps[ii*glob_n_nu]); \n      double *los_clean=&(glob_clean_maps[ii*glob_n_nu]); \n \n       \n \n      double tmin=los_dirty[0]; \n      for(jj=0;jj<glob_n_nu;jj++) { \n\tdouble t=los_dirty[jj]; \n\tif(t<tmin) tmin=t; \n      } \n \n      double mean_logt=0; \n      for(jj=0;jj<glob_n_nu;jj++) { \n\tdouble t=los_dirty[jj]; \n\tif(tmin<=0) t+=-2*tmin; \n\t \n\tmean_logt+=log10(t); \n \n\tinv_sigma2_arr[jj]=1.0/(glob_rms_arr[jj]*glob_rms_arr[jj]); \n\tlos_minim[jj]=t; \n      } \n      mean_logt/=glob_n_nu; \n \n      gsl_vector_set(v_c,0,mean_logt); \n      gsl_vector_set(v_c,1,-2); \n      for(jj=2;jj<n_remove;jj++) gsl_vector_set(v_c,jj,0); \n \n      gsl_multimin_fminimizer_set(minimizer,&min_chi2,v_c,step); \n \n      int iter=0; \n      int status; \n      double size; \n      do { \n\titer++; \n\tstatus=gsl_multimin_fminimizer_iterate(minimizer); \n\tif(status) break; \n\tsize=gsl_multimin_fminimizer_size(minimizer); \n\tstatus=gsl_multimin_test_size(size,1E-6); \n      } while((status==GSL_CONTINUE)||(iter<1000)); \n       \n      gsl_vector_memcpy(v_c,minimizer->x); \n \n      for(jj=0;jj<glob_n_nu;jj++) { \n\tdouble tfg=model_fit(v_c,lnu_arr[jj]); \n\tif(tmin<=0) tfg+=2*tmin; \n\tlos_clean[jj]=los_dirty[jj]-tfg; \n      } \n    }", "pragma": "for ", "hash": "c3ad6d1f45d6eb8b25c57d28ef4035ae98172c21dbf61695b000aa3cdd666568"}
{"code": "for (int i = 0; i < level * numLandmarks; i++){\r \n\t\tcout<<\"Building index for tree \"<<i<<endl;\r \n\t\tcvflann::Matrix<float> dataset(f_map + i*ids.size()*descriptorSize[i], ids.size(), descriptorSize[i]);\r \n\t\t \n \n\t\t \n \n\t\tindex[i] = new cvflann::Index<cvflann::L2<float> >(dataset, cvflann::KDTreeIndexParams(10));\r \n\t\tindex[i]->buildIndex();\r \n\t}", "pragma": "parallel ", "hash": "bea73fbf2c8bcdb9a3223b1c4d81adfe40766ae505302c2bcf8486f9696822a6"}
{"code": "for( int i=0; i<subbox_total; i++){ \n      mesh_density_subbox[i][0] *= gk[i]; \n      mesh_density_subbox[i][1] *= gk[i]; \n    }", "pragma": "parallel for ", "hash": "39c040371ede03ef87da57cf162d93c1228456b85a0bf1064eba63f341b0f740"}
{"code": "for(int xn = 0; xn<NMAX; xn++){ \n        double x = (double)xn+1.; \n        xx[xn] = x; \n        VecDoub X2=X; \n        X2[p]=x; \n        if(qq==\"general\"){ \n            X[0]=x/2.;X[1]=x/3.;X[2]=x/2.; \n        } \n        triaxial[xn] = (T.Phi(X2)-centre2); \n        multipole[xn] = (ME2.Phi(X2)-centre3); \n    }", "pragma": "parallel for ", "hash": "d40fc6548707f17f99409acc690ef5792d738a7c173b66b38040862d0d50afa8"}
{"code": "for (int igrp = 0; igrp < ngrp; ++igrp) { \n                    for (auto ixyz = 0; ixyz < nxyz; ++ixyz) { \n \n                        auto fcs_cart = 0.0; \n                        const auto nentry = coord_list_grp[igrp].size(); \n                        for (j = 0; j < nentry; ++j) { \n                            prod_matrix = 1.0; \n                            for (auto k = 0; k < nelems; ++k) { \n                                prod_matrix *= basis_conversion_matrix(coord_list_grp[igrp][j][k], \n                                                                       xyzcomponent[ixyz][k]); \n                            } \n                            fcs_cart += prod_matrix * fc_list_grp[igrp][j]; \n                        } \n \n                        if (std::abs(fcs_cart) >= fc_zero_threshold) { \n                            fc_cart_omp.emplace_back(nelems, \n                                                     fcs_cart, \n                                                     &atoms_grp[igrp][0], \n                                                     xyzcomponent[ixyz]); \n                        } \n                    } \n                }", "pragma": "for private( j prod_matrix)", "hash": "7c71fbd957e5e3a6dcc220a54c8168b40499782caf367ec9a3c8353364976997"}
{"code": "for (int a = 0; a < agtCount; ++a) { \n    Agents::BaseAgent* agt = sim->getAgent(a); \n    fsm->computePrefVelocity(agt); \n  }", "pragma": "parallel for ", "hash": "b06a1749a8a9c9f4a8e84d3f7ad24102099f46ed67e10aefd83bd7ffa857e6ef"}
{"code": "for( int i=0; i<points->getNumIndexes(); i++ ){ \n                                const double *val = points->getValueList(i); \n                                sum += weights[i] * val[j]; \n                        }", "pragma": "parallel for reduction(  + : sum) ", "hash": "3f2a752251fd89bd63cc6679b9f80570f2eefd4f2390a881e3e1f76cd137219b"}
{"code": "for (long i=0; i<n; i++) { \n    bool isolated = true; \n    for (long j=i+1; j<n; j++) { \n       \n \n       \n \n      double dx   = src[i]  - src[j]; \n      double dy   = dest[i] - dest[j]; \n      double dist = sqrt ( dx*dx + dy*dy ); \n       \n \n      if ( dist <= r ) { \n\t__sync_fetch_and_add(&m, 1); \n\tisolated = false; \n\t__sync_fetch_and_add(&degrees[i+1], 1);  \n \n\t__sync_fetch_and_add(&degrees[j+1], 1); \n      } \n    }  \n \n     \n \n     \n \n     \n \n  }", "pragma": "parallel for ", "hash": "47a0fb5306e16e795f03ef4c6fc8e444f69772340b3f39cdc28c7573ec6580cd"}
{"code": "for    (ix=0; ix<fdm->nxpad; ix++) { \n\t\t\tfor(iz=0; iz<fdm->nzpad; iz++) { \n\t\t\t    up[ix][iz] = 2*uo[ix][iz]  \n\t\t\t\t-  um[ix][iz]  \n\t\t\t\t-  ro[ix][iz]*vt[ix][iz]*ua[ix][iz]; \n\t\t\t} \n\t\t    }", "pragma": "for ", "hash": "bd02bbf3717377722f9b8007ba542e29807df6273630ba13c625dc94302e5152"}
{"code": "for (int loopIndex = 0; loopIndex < numLoop; loopIndex++) { \n         int kPreExt; \n         if(activity->isSparse){ \n            kPreExt = activeIndicesBatch[loopIndex]; \n         } \n         else{ \n            kPreExt = loopIndex; \n         } \n \n         float a = activityBatch[kPreExt] * dt_factor; \n          \n \n \n          \n \n         pvdata_t * gSynPatchHead; \n          \n \n         int * gatePatchHead = NULL; \n         if(thread_gSyn){ \n            int ti = omp_get_thread_num(); \n            gSynPatchHead = thread_gSyn[ti]; \n         } \n         else{ \n            gSynPatchHead = gSynPatchHeadBatch; \n         } \n \n         if(needPostIndexLayer){ \n            if(thread_gateIdxBuffer){ \n               int ti = omp_get_thread_num(); \n               gatePatchHead = thread_gateIdxBuffer[ti]; \n            } \n            else{ \n               gatePatchHead = gatePatchHeadBatch; \n            } \n         } \n \n         gSynPatchHead = gSynPatchHeadBatch; \n         if(needPostIndexLayer){ \n            gatePatchHead = gatePatchHeadBatch; \n         } \n \n          \n \n          \n         PVPatch * weights = getWeights(kPreExt, arborID); \n         const int nk = weights->nx * fPatchSize(); \n         const int ny = weights->ny; \n         const int sy  = getPostNonextStrides()->sy;        \n \n         pvwdata_t * weightDataStart = NULL;  \n         pvgsyndata_t * postPatchStart = gSynPatchHead + getGSynPatchStart(kPreExt, arborID); \n         int* postGatePatchStart = gatePatchHead + getGSynPatchStart(kPreExt, arborID); \n          \n \n \n         const int kxPreExt = kxPos(kPreExt, preLoc->nx + preLoc->halo.lt + preLoc->halo.rt, preLoc->ny + preLoc->halo.dn + preLoc->halo.up, preLoc->nf); \n         const int kyPreExt = kyPos(kPreExt, preLoc->nx + preLoc->halo.lt + preLoc->halo.rt, preLoc->ny + preLoc->halo.dn + preLoc->halo.up, preLoc->nf); \n         const int kfPre = featureIndex(kPreExt, preLoc->nx + preLoc->halo.lt + preLoc->halo.rt, preLoc->ny + preLoc->halo.dn + preLoc->halo.up, preLoc->nf); \n \n         const int kxPreGlobalExt = kxPreExt + preLoc->kx0; \n         const int kyPreGlobalExt = kyPreExt + preLoc->ky0; \n \n         const int kPreGlobalExt = kIndex(kxPreGlobalExt, kyPreGlobalExt, kfPre, preLoc->nxGlobal + preLoc->halo.lt + preLoc->halo.rt, preLoc->nyGlobal + preLoc->halo.up + preLoc->halo.dn, preLoc->nf); \n \n         int offset = kfPre; \n         int sf = fPatchSize(); \n         pvwdata_t w = 1.0; \n         if(getPvpatchAccumulateType() == ACCUMULATE_SUMPOOLING){ \n           float relative_XScale = pow(2, (post->getXScale() - pre->getXScale())); \n           float relative_YScale = pow(2, (post->getYScale() - pre->getYScale())); \n           w = 1.0/(nxp*nyp*relative_XScale*relative_YScale); \n         } \n         void* auxPtr = NULL; \n         for (int y = 0; y < ny; y++) { \n            if(needPostIndexLayer){ \n               auxPtr = (postGatePatchStart+ y*sy + offset); \n            } \n            (accumulateFunctionPointer)(kPreGlobalExt, nk, postPatchStart + y*sy + offset, a, &w, auxPtr, sf); \n         } \n      }", "pragma": "parallel for ", "hash": "6340de9cedcc62e109270d062d228f05570aec0666f542931854d6d561e684e4"}
{"code": "for (ix=0; ix < nx; ix++) { \n\t\tfor (ih=0; ih < nh; ih++) { \n\t\t    dat[ix][ih] = 0.; \n\t\t} \n\t    }", "pragma": "parallel for private(ih ix)", "hash": "683a984740a92bcd7c84098cb7ca646f65c9a5701785a06be1fee2f54c007650"}
{"code": "for (int i = 1; i < n; i++) \n            (*invertedMatrix)(i, i - 1) = -(*inputMatrix)(i, i - 1);", "pragma": "parallel for ", "hash": "95b66ef750c58002bec4f8736b3f2a7dc0921428fda38f64fc608b3bc4b5864a"}
{"code": "for (u32 outputindex=0; outputindex<missingblockcount; outputindex++) \n      { \n         \n \n        void *outbuf = &((u8*)outputbuffer)[chunksize * outputindex]; \n \n         \n \n        rs.Process(blocklength, inputindex, inputbuffer, outputindex, outbuf); \n \n        if (noiselevel > CommandLine::nlQuiet) \n        { \n           \n \n          u32 oldfraction = (u32)(1000 * progress / totaldata); \n          #pragma omp atomic \n          progress += blocklength; \n          u32 newfraction = (u32)(1000 * progress / totaldata); \n \n          if (oldfraction != newfraction) \n          { \n            #pragma omp critical \n            cout << \"Repairing: \" << newfraction/10 << '.' << newfraction%10 << \"%\\r\" << flush; \n          } \n        } \n      }", "pragma": "parallel for ", "hash": "e1cad37859e3454ae2192a85455793cd5a6cd06e1d53abf66ce16b72f0f86daa"}
{"code": "for (i = 1; i < numgroups; i++) { \n\t\tstruct stark_hierarchical_assembler_group_s *group = hierarchical_assembler->groups.list + i; \n\t\t \n\t\t \n \n\t\tif (group->group_id) { \n\t\t\t \n\t\t\tneighbours_list.size = 0; \n\t\t\t \n\t\t\t \n\t\t\tthread_dfs_stack.size = 0; \n\t\t\tlist_insert(&thread_dfs_stack, group->endpoint[0]); \n\t\t\t \n\t\t\tmap_zero(&thread_seen_map); \n\t\t\tstark_navigate_dfs( &thread_dfs_stack, \n\t\t\t\t  hierarchical_assembler->minK \n\t\t\t\t \n \n\t\t\t\t, stark_hierarchical_assembler_init_group_neighbours_dfs_test_cb_thread_safe \n\t\t\t\t, &neighbours_list \n\t\t\t); \n\t\t\t \n\t\t\tlist_qsort(neighbours_list, stark_hierarchical_assembler_merge_groups_neighbour_id_comparator); \n\t\t\t \n\t\t\thirarchial_assembler_group_t last_group_id = 0; \n\t\t\tsize_t j; \n   #pragma omp critical (merge_neighbours) \n\t\t\tfor (j = 0; j < neighbours_list.size; j++) { \n\t\t\t\tif (last_group_id != neighbours_list.list[j].id) { \n\t\t\t\t\tlast_group_id = neighbours_list.list[j].id; \n\t\t\t\t\tstruct stark_hierarchical_assembler_neighbours_global_s neighbours_entry = { \n\t\t\t\t\t\t  .link_strength = neighbours_list.list[j].link_strength \n\t\t\t\t\t\t, .ids = { \n\t\t\t\t\t\t\ti, neighbours_list.list[j].id \n\t\t\t\t\t\t} \n\t\t\t\t\t}; \n \n\t\t\t\t\tlist_insert(&hierarchical_assembler->neighbours, neighbours_entry); \n\t\t\t\t\t \n\t\t\t\t} \n\t\t\t} \n \n\t\t\t \n\t\t} \n\t}", "pragma": "for ", "hash": "a597e25daf74646b96d33a41402150a1442ff8778653db6aa7d580b38aba64ea"}
{"code": "for(unsigned long i = 0; i < psy_partition.size(); i++) \n            { \n                 \n \n                box b = psy_partition.at(i); \n                 \n \n                #pragma omp critical \n                { \n                    CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"psy_box: \" << b; \n                } \n                int res = decision_procedure::evaluate(pdrh::init.front(), goal, path, {b}); \n                #pragma omp critical \n                { \n                    switch (res) \n                    { \n                        case decision_procedure::SAT: \n                        { \n                            CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"SAT\"; \n                            sat_boxes.push_back(b); \n                             \n \n                            break; \n                        } \n                        case decision_procedure::UNSAT: \n                        { \n                            CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"UNSAT\"; \n                            unsat_boxes.push_back(b); \n                             \n \n                            break; \n                        } \n                        case decision_procedure::UNDET: \n                        { \n                            CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"UNDET\"; \n                             \n \n                            std::vector<box> tmp_vector = box_factory::bisect(b, pdrh::syn_map); \n                            if (tmp_vector.size() == 0) \n                            { \n                                 \n \n                                undet_boxes.push_back(b); \n                                 \n \n                            } \n                            else \n                            { \n                                CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"Bisected\"; \n                                swap_psy_partition.insert(swap_psy_partition.cend(), tmp_vector.cbegin(), tmp_vector.cend()); \n                            } \n                            break; \n                        } \n                        case decision_procedure::SOLVER_TIMEOUT: \n                        { \n                            CLOG_IF(global_config.verbose, INFO, \"algorithm\") << \"SOLVER_TIMEOUT\"; \n                            break; \n                        } \n                        case decision_procedure::ERROR: \n                        { \n                            LOG(ERROR) << \"ERROR\"; \n                            break; \n                        } \n                    } \n                } \n            }", "pragma": "parallel for ", "hash": "faa4a532b28fb9a8307c07b0f2728e8fde346b8f7001447318426c7c4f0382ac"}
{"code": "for (uint32_t i=0; i<(uint32_t) m_Height*m_Width; i++) {\r \n    for (short Ch=0; Ch<NrChannels; Ch++) {\r \n      MaskLayer->m_Image[i][Ch] = CLIP((int32_t) ((WPH-(int32_t)DenoiseLayer->m_Image[i][Ch])+m_Image[i][Ch]));\r \n      MaskLayer->m_Image[i][Ch] = Table[MaskLayer->m_Image[i][Ch]];\r \n    }\r \n    Temp[i] = m_Image[i][0];\r \n  }", "pragma": "parallel for ", "hash": "48614ae03d6723fa12a5d6b09f12f725d8616aeb49b8cbaab356437bd343fd91"}
{"code": "for (int index = 0; index < num_shapes; index++) { \n    shape_type T = obj_data_T[index]; \n \n     \n \n    uint ID = obj_data_ID[index]; \n \n    real3 pos = body_pos[ID];   \n \n    real4 rot = body_rot[ID];   \n \n \n    obj_data_A_global[index] = TransformLocalToParent(pos, rot, obj_data_A[index]); \n    if (T == TRIANGLEMESH) { \n      obj_data_B_global[index] = TransformLocalToParent(pos, rot, obj_data_B[index]); \n      obj_data_C_global[index] = TransformLocalToParent(pos, rot, obj_data_C[index]); \n    } else { \n      obj_data_B_global[index] = obj_data_B[index]; \n      obj_data_C_global[index] = obj_data_C[index]; \n    } \n    obj_data_R_global[index] = mult(rot, obj_data_R[index]); \n  }", "pragma": "parallel for ", "hash": "9d600463e9012027cb57d42a95dfdc8ed3f3824806107758e8e83e15f5edcaec"}
{"code": "for( int i=0; i<sA->dimI; i++){ \n\t\tx[i] = 0.; \n\t\tfor( int jj=0; jj<sA->sizeA[i]; jj++){ \n\t\t\tint j = sA->JA[i][jj]; \n\t\t\tx[i] += sA->A[i][jj] * b[j]; \n\t\t\tif( isnan(x[i])){ \n\t\t\t\tfprintf( stderr, \"nan occures in sparseMatrixVectorProduct\\n\"); \n\t\t\t\t \n \n\t\t\t\tx[i] = 0.; \n\t\t\t\tfor( int jj=0; jj<sA->sizeA[i]; jj++){ \n\t\t\t\t\tj = sA->JA[i][jj]; \n\t\t\t\t\tx[i] += sA->A[i][jj] * b[j]; \n\t\t\t\t\tfprintf( stderr, \"matrix A[%i][%i] = %lf, vector b[%i] = %lf, x[%i] = %lf\\n\", i, j, sA->A[i][jj], j, b[j], i, x[i]); \n\t\t\t\t} \n\t\t\t\texit( 0); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "9a1c75c79406b240733700d4ec09ec71ea847d04fb7c88546eee4b29561cbab5"}
{"code": "for(int out_grid_idx = 0; out_grid_idx < n_blocks; ++out_grid_idx) { \n    ot_tree_t* otree = octree_get_tree(out, out_grid_idx); \n \n    int gn, ogd, ogh, ogw; \n    octree_split_grid_idx(out, out_grid_idx, &gn, &ogd, &ogh, &ogw);  \n \n     \n \n    tree_set_bit(otree, 0);  \n \n    int obit_idx_l1 = 1; \n    for(int dgd = 0; dgd < 2; ++dgd) { \n      for(int hgh = 0; hgh < 2; ++hgh) { \n        for(int wgw = 0; wgw < 2; ++wgw) { \n          int igd = 2*ogd + dgd; \n          int igh = 2*ogh + hgh; \n          int igw = 2*ogw + wgw; \n          int in_grid_idx = octree_grid_idx(in, gn, igd, igh, igw); \n          ot_tree_t* itree = octree_get_tree(in, in_grid_idx); \n \n           \n \n          if(tree_isset_bit(itree, 0)) { \n            tree_set_bit(otree, obit_idx_l1); \n \n            int obit_idx_l2 = tree_child_bit_idx(obit_idx_l1); \n            for(int ibit_idx_l1 = 1; ibit_idx_l1 < 9; ++ibit_idx_l1) { \n               \n \n              if(tree_isset_bit(itree, ibit_idx_l1)) { \n                tree_set_bit(otree, obit_idx_l2); \n              } \n              obit_idx_l2++; \n            } \n          } \n          obit_idx_l1++; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "58ecf5f9a7ab3a7f75acb7b3ff7021c737e56448ca6ede440d8decb594d7cdb7"}
{"code": "for (uint32_t i=0; i<(uint32_t) m_Height*m_Width; i++) {\r \n        m_Image[i][0]=CLIP((int32_t)(2.0f*ContrastLayer->m_ImageC[i]));\r \n        m_Image[i][1]=0x8080;\r \n        m_Image[i][2]=0x8080;\r \n      }", "pragma": "parallel for ", "hash": "344951c67cde3ff611bd856d3ca4f307285f0fd0ab78b68d190de738d811dfb0"}
{"code": "for(int i=0; i<bsize1; i++) \n          ptr[i] = 0;", "pragma": "parallel for ", "hash": "fe97ccf20339f4b61dd2b02b36d94a7420367978af0b71ea47c28f51788cd243"}
{"code": "for (int i=0; i<N; i++) { \n \n                float fProjPixel=pFlat[i]-pDark[i]-pFlatBB[i]; \n                if (fProjPixel<=0) \n                    pFlat[i]=0; \n                else { \n                    if (m_bComputeLogarithm) \n                        pFlat[i]=log(fProjPixel*(dose)); \n                    else \n                        pFlat[i]=(fProjPixel*(dose)); \n                } \n \n            }", "pragma": "parallel for ", "hash": "f01df1476c5a70382e63a27a9e6ff55802a3416a9337df2dfdbc646d8942489f"}
{"code": "for(int i = 0; i < m; i++){ \n \n\t\t\tint num_elem = row_ptr[i+1] - row_ptr[i]; \n\t\t\tint row_start = row_ptr[i]; \n\t\t\tfor(int j = 0; j < num_elem; j++){ \n\t\t\t\ty[i] += val[row_start+j] * x[col_ind[row_start + j]]; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "cd2aa142a573587a88c3568c9292f45be706c9cd4fddac0a27ac7a50fe1ca4b3"}
{"code": "for (int y = 0; y < output.height; ++y) { \n        int row = shape.inverseYAxis ? output.height-y-1 : y; \n        for (int x = 0; x < output.width; ++x) { \n            Point2 p = Vector2(x+.5, y+.5)/scale-translate; \n            SignedDistance minDistance; \n            const EdgeHolder *nearEdge = NULL; \n            double nearParam = 0; \n            for (std::vector<Contour>::const_iterator contour = shape.contours.begin(); contour != shape.contours.end(); ++contour) \n                for (std::vector<EdgeHolder>::const_iterator edge = contour->edges.begin(); edge != contour->edges.end(); ++edge) { \n                    double param; \n                    SignedDistance distance = (*edge)->signedDistance(p, param); \n                    if (distance < minDistance) { \n                        minDistance = distance; \n                        nearEdge = &*edge; \n                        nearParam = param; \n                    } \n                } \n            if (nearEdge) \n                (*nearEdge)->distanceToPseudoDistance(minDistance, p, nearParam); \n            *output(x, row) = float(minDistance.distance/range+.5); \n        } \n    }", "pragma": "parallel for ", "hash": "9ed87358920790ad0814859f0948a1b39311deb52e30dfc043e32fda30a3c182"}
{"code": "for (i1 = 0; i1 < 64; i1++) \n      { \n\tl2[0] = i1; \n\tl2[1] = i1 + 1; \n\tl2[2] = i1 + 2; \n\tl2[3] = i1 + 3; \n\tif (i1 < 37) \n\t  l3 = i1; \n\tif ((fl & 1) && (((uintptr_t) &l2[0] | (uintptr_t) &l3 | (uintptr_t) &i1) & 63) != 0) \n\t  abort (); \n      }", "pragma": "for private(conditional: i1 l2 l3)", "hash": "4805b850c8c2c10d40303afab2572cf61bc304c167174f56266b9c3b8a8c1cb8"}
{"code": "for(int j=GPU_SIZE;j<array_elements;j++) \n\ta[j] = b[j] + scalar*c[j];", "pragma": "parallel for ", "hash": "eb5c0baa8a3632aefa50efbf73c94d7b3b1415f606a19e7585232415fb24f8b9"}
{"code": "for(int i = 0; i < primes.size(); i++) { \n\t\t\t\tuint64_t p = primes.at(i); \n\t\t\t\tmark_multiples_of_prime(p); \n\t\t\t}", "pragma": "parallel for ", "hash": "ec9b75fb01d498ab62ee57e6e3e0d8c8c08b36b15c6ffbd573fc8d584ed2cf33"}
{"code": "for(unsigned i=0; i<positions.size(); ++i) { \n    positions[i][0]=px[stride*i]*scalep; \n    positions[i][1]=py[stride*i]*scalep; \n    positions[i][2]=pz[stride*i]*scalep; \n  }", "pragma": "parallel for ", "hash": "5e54526cb8aef8852de6328d3e7a94df0d3e92fa0a887027129c0ace838ceeb9"}
{"code": "for (i = 0; i < count; i++) { \n                pout = out + m2 * i; \n                pin  = in  + mm * i; \n                for (n = 0, j = 0; j < m; j++) { \n                        for (k = 0; k < j; k++, n++) { \n                                pout[n] = pin[j*m+k] + pin[k*m+j]; \n                        } \n                        pout[n] = pin[j*m+j] * diagfac; \n                        n++; \n                } \n        }", "pragma": "for ", "hash": "9be7401e345e1e3793f617c6ef6cb1ea3db3963e6c5fc85d70fc5e37b9eb660e"}
{"code": "for( OMPInt i=0; i < rEl; ++i) \n        (*res)[i] = ((*right)[i] == (*left)[i]);", "pragma": "for ", "hash": "08f449cd2bed9e71838e481c725e8e2436397b06a4b94ab6d8ce1ee9a826d56f"}
{"code": "for(int i = 0; i < (int)m_orderedOutputs.size(); i++) \n    { \n      IOutput *output = m_orderedOutputs[i]; \n      AbstractOutput *abstractOutput = dynamic_cast<AbstractOutput*>(output); \n \n      if(abstractOutput && (abstractOutput->consumers().length() || abstractOutput->adaptedOutputs().length() )) \n      { \n        abstractOutput->updateValues(); \n      } \n    }", "pragma": "parallel for ", "hash": "1446ff103d3e2f0396ac49fce9ddfdb91de2ab4035b991960850fd0f3a7da283"}
{"code": "for (int y = 0; y < rotateH; ++y) { \n\t\t\tprocessLine(y); \n\t\t}", "pragma": "parallel for ", "hash": "7896d368667acb31863bfea8270220e5ea057e3cca1b1bfd7f4e9511d3ee9e12"}
{"code": "for (i = 0; i < 16; i++) \n      c[i] = i;", "pragma": "parallel for ", "hash": "ec680c64fca93d17d76238e8e2ee035b3a84ff2c3d278a0e96905461e7ee35a6"}
{"code": "for (ix=0; ix<nx; ix++) \n    for (iz=0; iz<nz; iz++) \n      img[ix][iz] = x[iz+ix*nz];", "pragma": "parallel for private(ix iz)", "hash": "d041a2afa2e695b4d632df7749cb65d56dc2829f5c6e6ec2eb9451edd9e28f77"}
{"code": "for (int c = 1; c <= grid.NCM; c++) \n\t\t\t\t{ \n\t\t\t\t\tCFD::VariableChange::V_to_Q(CFD_variabletype, CFD_NT, grid.cells[c].data1D(indexV), species_set, grid.ND, grid.cells[c].data1D(indexQ)); \n\t\t\t\t}", "pragma": "parallel for ", "hash": "e77b4ab0e0c1d176782b7061803e9fa9a965f948d26dc5df7bf9c9436d9c6e9d"}
{"code": "for(uint i=0; i<nTestingSketches; i++){ \n\t\tMat desc(1, n*99, CV_32F); \n\t\t \n\t\ttemp = *(testingSketchesDescriptors[i]); \n\t\ttemp = temp - meanXs; \n\t\t \n\t\tfor(uint col=0; col<n; col++){ \n\t\t\tRange slice = Range(col*m*descSize,(col+1)*m*descSize); \n\t\t\tMat aux = ((*(projectionMatrix[col])).t()*temp(slice, Range::all())).t(); \n\t\t\taux.copyTo(desc(Range::all(), Range(col*99,(col+1)*99))); \n\t\t} \n\t\ttestingSketchesProjection[i] = new Mat(); \n\t\t*(testingSketchesProjection[i]) = desc.clone(); \n\t}", "pragma": "parallel for private(temp)", "hash": "e2925bd8a8f16ff2c047cd87ba3d944d3aa2ca95dde556bf22f3acf98a2871e1"}
{"code": "for (int i = 0; i < 10; ++i) { \n    #pragma omp ordered depend(source)  \n \n    #pragma omp ordered depend(sink : i)  \n \n  }", "pragma": "parallel for ", "hash": "562cefc733aa57aaf4d5f7425c64d444915e71ba12ccb64c7c9dc7225dc8110b"}
{"code": "for (int k = 0; k < numNeurons; k++) { \n            int kextOriginal = kIndexExtended( \n                  k, \n                  locOriginal->nx, \n                  locOriginal->ny, \n                  locOriginal->nf, \n                  locOriginal->halo.lt, \n                  locOriginal->halo.rt, \n                  locOriginal->halo.dn, \n                  locOriginal->halo.up); \n            sum += originalABatch[kextOriginal]; \n         }", "pragma": "parallel for reduction(+ : sum) ", "hash": "de7fbbe3ca0f3ed5d48948edc00cb43d6d36c6b69710517f0bc507913ad32d30"}
{"code": "for (j = 0; j < NJ->maxnode; j++) { \n    besthit_t *sv = allhits != NULL ? &allhits[j] : &tmp; \n    sv->i = node; \n    sv->j = j; \n    if (NJ->parent[j] >= 0) { \n      sv->i = -1;\t\t \n \n      sv->weight = 0.0; \n      sv->criterion = sv->dist = 1e20; \n      continue; \n    } \n     \n \n    SetDistCriterion(NJ, nActive,  \nsv); \n    if (sv->criterion < bestjoin->criterion && node != j) \n      *bestjoin = *sv; \n  }", "pragma": "parallel for ", "hash": "c78df2268fe4a6aec78591f8c5270d1c16ba7f444eec6f76dfb0b21b5c7b1afb"}
{"code": "for (unsigned int i = 0; i < n_p; ++i) \n\t{ \n\t\t \n \n\t\t \n \n\t\tif (gdim == 1) \n\t\t\tdet_dF = dF_xx[i]; \n \n\t\t \n \n\t\tif (gdim == 2) \n\t\t\tdet_dF = dF_xx[i] * dF_yy[i] - dF_yx[i] * dF_xy[i]; \n \n\t\t \n \n\t\tif (gdim == 3) \n\t\t\tdet_dF = + dF_xx[i] * dF_yy[i] * dF_zz[i] \n\t\t\t         + dF_xy[i] * dF_yz[i] * dF_zx[i] \n\t\t\t         + dF_xz[i] * dF_yx[i] * dF_zy[i] \n\t\t\t         - dF_xz[i] * dF_yy[i] * dF_zx[i] \n\t\t\t         - dF_xy[i] * dF_yx[i] * dF_zz[i] \n\t\t\t         - dF_xx[i] * dF_yz[i] * dF_zy[i]; \n \n\t\trho[i] /= det_dF; \n\t}", "pragma": "parallel for simd ", "hash": "0e4cb541373f2082aaf7cd0100582f9215f7f44185c815c68d008607e51d77d1"}
{"code": "for (i2=0; i2<local_n0; i2++) { \n    for (i1=0; i1<nk; i1++) { \n      out[i2*nk+i1]=dd[i2*nk+i1]; \n    } \n  }", "pragma": "parallel for private(i1 i2)", "hash": "3f0c0421a72400cdcca7218927cf1be9474fda593feca580c0f386b86ec4e258"}
{"code": "for (int i = h-1; i >= 0; i--) { \n\t\t\t\tfor (int j = 0; j < w; j++) { \n\t\t\t\t\tint p = i*w+j;  \n \n\t\t\t\t\trgba->r[p] = color::srgbuncurve((data[(i*rowstride+j)*2+0]-min)*tof); \n\t\t\t\t\trgba->g[p] = color::srgbuncurve((data[(i*rowstride+j)*2+1]-min)*tof); \n\t\t\t\t\trgba->b[p] = 1.0f; \n\t\t\t\t\trgba->a[p] = 1.0f; \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "f61946566f876103278798c81c8628348a9d286f7fb6b3ec155628029a35229a"}
{"code": "for (i = 0; i < hdr -> nprof*hdr -> nsubs; ++i) \n\thdr -> modelc -> points[i] = 0;", "pragma": "parallel for ", "hash": "e7da8f841a3f3bf1362397d1379c7db7739daf230e9f70b02e73a8d255b4a76d"}
{"code": "for(__int64 j = 0; j < n; j++)\t \n \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tdist = EuclidianDist( dim, clusters->GetElements()[current_rep_index]->ptr, clusters->GetElements()[j]->ptr ); \n \n      #pragma omp critical(update_farthest) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tif ( dist >= 0 && dist > max_dist ) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\tif ((find (rep_index.begin(), rep_index.end(), j) == rep_index.end())) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tfarthest_object_index = j; \n\t\t\t\t\t\t\t\t\tmax_dist = dist; \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t}", "pragma": "parallel for private(dist)", "hash": "2f1ed15a839c81bb2f9c599079910a877be83c37778ddc352e55d3073d32355d"}
{"code": "for (data_size_t i = 0; i < num_line; ++i) { \n      double tmp = 0.0f; \n      oneline_init_score = Common::Split(reader.Lines()[i].c_str(), '\\t'); \n      if (static_cast<int>(oneline_init_score.size()) != num_class) { \n        Log::Fatal(\"Invalid initial score file. Redundant or insufficient columns\"); \n      } \n      for (int k = 0; k < num_class; ++k) { \n        Common::Atof(oneline_init_score[k].c_str(), &tmp); \n        init_score_[static_cast<size_t>(k) * num_line + i] = Common::AvoidInf(static_cast<double>(tmp)); \n      } \n    }", "pragma": "parallel for ", "hash": "b2af8dfc1eb87fe6aef4dd0945cd026b4d2b34709ba418abc35a3b6fcb621348"}
{"code": "for ( int tIdx = 0; tIdx < static_cast<int>( m_triangleIndexToNNCIndex->size() ); tIdx++ ) \n    { \n        double cellScalarValue = HUGE_VAL; \n        size_t resultIndex     = ( *m_triangleIndexToNNCIndex )[tIdx]; \n \n         \n \n         \n \n \n        if ( resultIndex < nncResultVals->size() ) \n        { \n            cellScalarValue = ( *nncResultVals )[resultIndex]; \n        } \n \n        cvf::Vec2f texCoord = mapper->mapToTextureCoord( cellScalarValue ); \n        if ( cellScalarValue == HUGE_VAL || cellScalarValue != cellScalarValue )  \n \n        { \n            texCoord[1] = 1.0f; \n        } \n \n        size_t j; \n        for ( j = 0; j < 3; j++ ) \n        { \n            rawPtr[tIdx * 3 + j] = texCoord; \n        } \n    }", "pragma": "parallel for ", "hash": "eed76677d751e1bfc60d17a10a6a0f031dee1704ef3c3628575ed84ff05b43ce"}
{"code": "for (i = 0; i < N; i++) \n\t{ \n\t\tif (i % 2 == 0) \n\t\t{ \n\t\t\ta_n = (1.0 / (2 * i + 1)); \n\t\t} \n\t\telse \n\t\t{ \n\t\t\ta_n = (-1.0 / (2 * i + 1)); \n\t\t} \n\t\ttemp = temp + a_n; \n\t}", "pragma": "parallel for reduction(+:temp) private( a_n i)", "hash": "b49174b27374fbe4aaca96950b1563e1974dc151d9bdb5a817a544599d9d07eb"}
{"code": "for (int i = 0; i < rows; i++){ \n      for (int j = 0; j < cols; j++){ \n        out->data[cols*i + j] = data[cols*i + j];  \n \n      } \n    }", "pragma": "parallel for ", "hash": "eadd773009f2cf08b2cb5ea128cf41543bb485bf845c25fee1d08e65e89bed8f"}
{"code": "for(unsigned long int i=0; i<N; i++){ \n    tmp += x[i] * y[i]; \n  }", "pragma": "parallel for reduction(+:tmp) ", "hash": "97923096e24b22d0ec45eab9ebea59930df4d0cbc181191e3db0b4495c240245"}
{"code": "for (ic = 0; ic < shape[0]; ic++) { \n                NPztranspose(shape[1], shape[2], a+ic*nm, at+ic*nm); \n        }", "pragma": "for ", "hash": "c6e4f8923577ca5e1742eb7cf97eaa8fae7ea43e0d548330f7328a1c66d79de6"}
{"code": "for (int i=0; i<sph->Nhydro; i++) { \n    SphParticle<ndim>& part = sphdata[i]; \n    int dn = n - part.nlast; \n \n     \n \n    if (dn == (part.nstep/2)) \n      part.flags.set(active); \n    else \n      part.flags.unset(active); \n  }", "pragma": "parallel for ", "hash": "77ad24d0586d1dec4edd5804ecb3bf5e4b74187bdc141f17078b2dd2a217acd0"}
{"code": "for (i=0; i < N; i++)  \n    { \n        p[i].v[0] += (vel_t)(Fx[i] * dt); \n        p[i].v[1] += (vel_t)(Fy[i] * dt); \n        p[i].v[2] += (vel_t)(Fz[i] * dt); \n        DBG(1) eprintf(\"a[%ld] \"ACCT\" \"ACCT\" \"ACCT\"\\n\", i, (acc_t)Fx[i], (acc_t)Fy[i], (acc_t)Fz[i]); \n        DBG(1) eprintf(\"v[%ld] \"VELT\" \"VELT\" \"VELT\"\\n\", i, p[i].v[0], p[i].v[1], p[i].v[2]); \n    }", "pragma": "parallel for private(n)", "hash": "eef685b1623f65b9ece3b2c1a7efc146f0707a032ac1749981175162b53381a3"}
{"code": "for (int latitude=-89; latitude < 90; latitude++) { \n        for (int longitude=-179; longitude < 180; longitude++) { \n            int grid_cell_index = \n                globalgrid::get_closest_grid_cell((float)-longitude, \n                                                  (float)latitude,grid); \n \n            grid[grid_cell_index].temp_value = \n                grid[grid_cell_index].get_anomaly(year,reference_start_year, \n                                                  reference_end_year,pressure, \n                                                  graph_type); \n        } \n    }", "pragma": "parallel for ", "hash": "7c60bdddc1750810104010b6387895394e96687e886f2476a459159bf1471916"}
{"code": "for (int i = 0; i < nReaches; ++i) \n\t\t{ \n\t\t\tint reachIndex = it->second[i];  \n \n \n\t\t\tSedChannelRouting(reachIndex); \n\t\t}", "pragma": "parallel for ", "hash": "2ac6241018830f18788a53459a0cfa48f9b99892287c97b8447f8caea1bb90e7"}
{"code": "for (int j = 0; j < num_data_; ++j) { \n            host4[j].s[i >> 1] |= (uint8_t)((iter.RawGet(j) * device_bin_mults_[copied_feature4 * dword_features_ + i] \n                                + ((j+i) & (device_bin_mults_[copied_feature4 * dword_features_ + i] - 1))) \n                               << ((i & 1) << 2)); \n          }", "pragma": "parallel for ", "hash": "8c4a1351e50674bad8d10ec0ce047057b62536a2377e4d9f96aa51c9c6c32df6"}
{"code": "for(size_t y = 0; y < stride; y += ch) \n    { \n      const float *const restrict in = __builtin_assume_aligned(image_in + y, 16); \n      float *const restrict out = __builtin_assume_aligned(image_out + y, 16); \n \n      dt_aligned_pixel_t xyz;  \n \n      dt_apply_transposed_color_matrix(in, *matrix_ptr, xyz); \n      dt_XYZ_to_Lab(xyz, out); \n    }", "pragma": "parallel for simd ", "hash": "5500412120d30acc9516dfdc6ab8be1a012e16981027e45174bdf659bff05827"}
{"code": "for (int k = 0; k < v; ++k) \n      ++this->a;", "pragma": "parallel private(a this->a)", "hash": "c01384bc72c58c5978fb0450ef9c415a2f61fb31ddc08f43bf3556be8af9bfe7"}
{"code": "for (int b = 0; b < B; ++b) { \n      for (int j = 0; j <= S - R; ++j) { \n        for (int i = 0; i <= S - R; ++i) { \n          for (int k = 0; k < K; ++k) { \n            float const a = dy[((b * S + (j + R / 2)) * S + (i + R / 2)) * K + k]; \n            for (int jj = 0; jj < R; ++jj) { \n              ispc::axpyf(a, \n                          x .data() + ((b * S + (jj + j)) * S + i) * C, \n                          dw.data() + ( k * R +  jj     ) * R      * C, R * C); \n            } \n          } \n        } \n      } \n    }", "pragma": "parallel for ", "hash": "83f25903b16839a20a375a6faf6e5f7bcf1d372fa3462453812a317f552abf25"}
{"code": "for (int i = 0; i < chromaWidth - 1; i++) { \n        dstUV[c][dstLastLine + i * 2 + 1] = ((3 * (int)(srcUV[c][srcLastLine + i]) + (int)(srcUV[c][srcLastLine + i + 1]) + 2) >> 2); \n        dstUV[c][dstLastLine + i * 2 + 2] = (((int)(srcUV[c][srcLastLine + i]) + 3 * (int)(srcUV[c][srcLastLine + i + 1]) + 2) >> 2); \n      }", "pragma": "parallel for private(c)", "hash": "baf29cfb4a4a1797f1ca09d2ab4eef9c71c1683990bcf5b603272bea4c64214a"}
{"code": "for(int row = 1; row < roi_out->height - 1; row++) \n  { \n    float *buf = out + 4 * roi_out->width * row + 4; \n    const float *buf_in = in + roi_in->width * row + 1; \n    for(int col = 1; col < roi_out->width - 1; col++) \n    { \n      float sum[4] = { 0.0f }; \n      int *ip = lookup[row % size][col % size]; \n       \n \n      for(int i = *ip++; i--; ip += 3) sum[ip[2]] += buf_in[ip[0]] * ip[1]; \n       \n \n      for(int i = colors; --i; ip += 2) buf[*ip] = sum[ip[0]] / ip[1]; \n      buf[*ip] = *buf_in; \n      buf += 4; \n      buf_in++; \n    } \n  }", "pragma": "parallel for ", "hash": "daeeb3e55e874862daafc6a2b8a50abff4836f76eeac4b8989131c3f1fb8d824"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp target  \n \n    ++a; \n  }", "pragma": "for simd ", "hash": "36e6db8a8a9ef9e5a2a50f34d31cbd0609b94e9f1471513d6cf19d87cea4a2cf"}
{"code": "for(idx_t s=0; s < rinfo->nlocal2nbr[m]; ++s) { \n    idx_t const row = local2nbr_inds[s]; \n    for(idx_t f=0; f < nfactors; ++f) { \n      local2nbr_buf[f + (s*nfactors)] = matv[f + (row*nfactors)]; \n    } \n  }", "pragma": "parallel for ", "hash": "622f84a0c91d20b208cd93ddd765fc722bd39c1c32ba56f975d2531375115021"}
{"code": "for (i=0; i<ncols; i++) { \n\t\t\t\tfor (tsum=0.0, ncand=0, j=colptr[i]; j<colptr[i+1]; j++, ncand++) { \n\t\t\t\t\tcand[ncand].key = colind[j]; \n\t\t\t\t\tcand[ncand].val = colval[j]; \n\t\t\t\t\ttsum += (norm == 1 ? colval[j] : colval[j]*colval[j]); \n\t\t\t\t} \n\t\t\t\tda_ivkvsortd(ncand, cand); \n \n\t\t\t\tfor (rsum=0.0, j=0; j<ncand && rsum<=fraction*tsum; j++) { \n\t\t\t\t\trsum += (norm == 1 ? cand[j].val : cand[j].val*cand[j].val); \n\t\t\t\t\tnrowind[nrowptr[cand[j].key]] = i; \n\t\t\t\t\tnrowval[nrowptr[cand[j].key]] = cand[j].val; \n\t\t\t\t\tnrowptr[cand[j].key]++; \n\t\t\t\t} \n\t\t\t}", "pragma": "for ", "hash": "da77aaa7a830518b053199e2bca282e80becbc68891f619b38f39a413d12c0b0"}
{"code": "for(i=0;i<he_nalms(pars->lmax);i++) { \n      int j; \n      for(j=0;j<pars->n_nu;j++) { \n\tgsl_vector_set(aux1_re,j,creal(alms_uncorr[j][i])); \n\tgsl_vector_set(aux1_im,j,cimag(alms_uncorr[j][i])); \n      } \n      gsl_blas_dgemv(CblasNoTrans,1,eigenvec,aux1_re,0,aux2_re); \n      gsl_blas_dgemv(CblasNoTrans,1,eigenvec,aux1_im,0,aux2_im); \n      for(j=0;j<pars->n_nu;j++) { \n\tdouble re=gsl_vector_get(aux2_re,j); \n\tdouble im=gsl_vector_get(aux2_im,j); \n\talms_corr[j][i]=re+I*im; \n      } \n    }", "pragma": "for ", "hash": "a74c248811581642834b47bc1a801fe51a45a00be272a19bd36ba5f34d9ad52e"}
{"code": "for (int j = 0; j < omp_p; j++) { \n      unsigned int seed  = j * p + myrank; \n      size_t       start = ( j    * N) / omp_p; \n      size_t       end   = ((j+1) * N) / omp_p; \n      for (unsigned int i = start; i < end; i++) {  \n        in[i]= mn + sqrt(-2*log(rand_r(&seed)*1.0/RAND_MAX)/log_e) \n               * cos(rand_r(&seed)*2*M_PI/RAND_MAX)*RAND_MAX*0.1; \n      } \n    }", "pragma": "parallel for ", "hash": "3652364f40dbbcba02bd798949cc36785242ffaafec97e17bba192ca68e084f1"}
{"code": "for (ii=0; ii< N; ii++) { \n    *(v + (xi+ii)->idx)+= dt_kick * *(a + (xi+ii)->idx); \n    (xi+ii)->val+= dt_drift * *(v + (xi+ii)->idx); \n  }", "pragma": "parallel for private(ii)", "hash": "9018a3ee0f8c6164c58012e8dd12eaf2d0b813867cc90415e7581edebab2c3bd"}
{"code": "for (int i = 0; i < (int)num_normals; i++) { \n    if (verbose && omp_get_thread_num() == 0 && i % 1000 == 0) { \n      bar.update(i); \n      cout << \"\\r\" << bar.get_string(); \n    } \n \n    int i_ = i; \n    if (subsample_indices != NULL) \n      i_ = (*subsample_indices)[i]; \n \n     \n \n     \n \n    pointkd::Indices indices; \n    vector<T> q(P.data() + i_ * 3, P.data() + (i_ + 1) * 3); \n    if (k == -1) \n      tree.RNearNeighbors(indices, &q[0], d_max); \n    else \n      tree.KNearestNeighbors(indices, &q[0], k, d_max); \n \n    Matrix<T, Dynamic, 3, RowMajor> X(indices.size(), 3); \n    for (size_t j = 0; j < indices.size(); j++) X.row(j) = P.row(indices[j]); \n    X.rowwise() -= X.colwise().mean(); \n    Matrix<T, 3, 3> C = X.transpose() * X; \n    C /= (T)indices.size(); \n    SelfAdjointEigenSolver<Matrix<T, 3, 3> > es(C); \n \n     \n \n    if (eigenvectors) { \n      if (num_eigen == 1) { \n        Map<Matrix<T, 3, 1> > temp(&(*eigenvectors)[i * 3]); \n        temp = es.eigenvectors().col(0); \n      } else {   \n \n        Map<Matrix<T, 3, 3> > temp(&(*eigenvectors)[i * 9]); \n        temp = es.eigenvectors(); \n      } \n    } \n    if (eigenvalues) { \n      if (num_eigen == 1) { \n        (*eigenvalues)[i] = es.eigenvalues()(0); \n      } else {   \n \n        Map<Matrix<T, 3, 1> > temp(&(*eigenvalues)[i * 3]); \n        temp = es.eigenvalues(); \n      } \n    } \n    if (neighborhood_sizes) \n      (*neighborhood_sizes)[i] = indices.size(); \n  }", "pragma": "parallel for ", "hash": "2d1ce0924eb8110d6094d34183f2ff92a812633f3523ff5c718b31bf83375bde"}
{"code": "for(ImpInt i = 0; i < m; i++ ) { \n            w_p[i] =1; \n        }", "pragma": "parallel for ", "hash": "fb4ba3dc786412e29015b7bcb133f75d96a1b66269400d6afce7ade14082ca11"}
{"code": "for (int i=_N_real; i<N; i++){ \n\tfor (int j=i+1; j<N; j++){ \n\t\tif (_gravity_ignore_10 && ((i==_N_real+1 && j==_N_real) || (j==_N_real+1 && i==_N_real)) ) continue; \n\t\tconst double dx = particles[i-N/2].x - particles[j-N/2].x; \n\t\tconst double dy = particles[i-N/2].y - particles[j-N/2].y; \n\t\tconst double dz = particles[i-N/2].z - particles[j-N/2].z; \n\t\tconst double r2 = dx*dx + dy*dy + dz*dz + softening*softening; \n\t\tconst double r  = sqrt(r2); \n\t\tconst double r3inv = 1./(r2*r); \n\t\tconst double r5inv = 3.*r3inv/r2; \n\t\tconst double ddx = particles[i].x - particles[j].x; \n\t\tconst double ddy = particles[i].y - particles[j].y; \n\t\tconst double ddz = particles[i].z - particles[j].z; \n\t\tconst double Gmi = G * particles[i].m; \n\t\tconst double Gmj = G * particles[j].m; \n\t\t \n\t\t \n \n\t\tconst double dax =   ddx * ( dx*dx*r5inv - r3inv ) \n\t\t\t\t   + ddy * ( dx*dy*r5inv ) \n\t\t\t\t   + ddz * ( dx*dz*r5inv ); \n\t\tconst double day =   ddx * ( dy*dx*r5inv ) \n\t\t\t\t   + ddy * ( dy*dy*r5inv - r3inv ) \n\t\t\t\t   + ddz * ( dy*dz*r5inv ); \n\t\tconst double daz =   ddx * ( dz*dx*r5inv ) \n\t\t\t\t   + ddy * ( dz*dy*r5inv ) \n\t\t\t\t   + ddz * ( dz*dz*r5inv - r3inv ); \n\t\t \n\t\tparticles[i].ax += Gmj * dax; \n\t\tparticles[i].ay += Gmj * day; \n\t\tparticles[i].az += Gmj * daz; \n\t\t \n\t\tparticles[j].ax -= Gmi * dax; \n\t\tparticles[j].ay -= Gmi * day; \n\t\tparticles[j].az -= Gmi * daz; \n\t} \n\t}", "pragma": "parallel for ", "hash": "f30f5329e5864b85ded3a3faf4957214cd11e03f2806ed026578a1eca3160e9f"}
{"code": "for(size_t j = box[1]; j < box[3]; j++) \n    { \n      for(size_t i = box[0]; i < box[2]; i++) \n      { \n        const int c = FCxtrans(j, i, roi, xtrans); \n        const size_t k = width * j + i; \n \n        const float v = pixel[k]; \n \n        tsum[c] += v; \n        tmmin[c] = fminf(tmmin[c], v); \n        tmmax[c] = fmaxf(tmmax[c], v); \n        tcnt[c]++; \n      } \n    }", "pragma": "for ", "hash": "b0ec5339419044369df9c2ff844fea97accbc17d314f8e652ba83a7468ebefca"}
{"code": "for (k = 0; k < ng; k++) { \n        h0 = ubi[0][0] * gv[k][0] + ubi[0][1] * gv[k][1] + ubi[0][2] * gv[k][2]; \n        h1 = ubi[1][0] * gv[k][0] + ubi[1][1] * gv[k][1] + ubi[1][2] * gv[k][2]; \n        h2 = ubi[2][0] * gv[k][0] + ubi[2][1] * gv[k][1] + ubi[2][2] * gv[k][2]; \n        t0 = h0 - conv_double_to_int_fast(h0); \n        t1 = h1 - conv_double_to_int_fast(h1); \n        t2 = h2 - conv_double_to_int_fast(h2); \n        sumsq = t0 * t0 + t1 * t1 + t2 * t2; \n         \n \n        if ((sumsq < tolsq) && (sumsq < drlv2[k])) { \n            labels[k] = label; \n            drlv2[k] = sumsq; \n            n++; \n        } else if (labels[k] == label) { \n             \n \n            labels[k] = -1; \n        } \n    }", "pragma": "parallel for reduction(+ : n) private(      h0 h1 h2 sumsq t0 t1 t2)", "hash": "55ad74fba488b6c0916d3b53d06efe2e7f5b0dbbbaffd4378f1a9e23ede7cf61"}
{"code": "for (i = 0; i < Npoints; ++i) { \n         \n \n        ident(mtemp); \n        for (j = 0; j < Ns; ++j) { \n             \n \n            mtemp2[0] = kappadir[0]; \n            mtemp2[1] = kappadir[1]; \n            mtemp2[2] = kappadir[2]; \n            sampleRotation[j](sampleAngles[Ns * i + j], mtemp2); \n            matmul(mtemp, mtemp2); \n        } \n         \n \n        matmul(mtemp, UB); \n         \n \n        inversemat(mtemp, ms); \n \n         \n \n        ident(md); \n        for (j = 0; j < Nd; ++j) { \n            detectorRotation[j](detectorAngles[Nd * i + j], mtemp); \n            matmul(md, mtemp); \n        } \n        ident(mtemp); \n        diffmat(md, mtemp); \n \n        matmul(ms, md); \n         \n \n        veccopy(ki, local_ri);   \n \n        vecmul(ki, M_2PI / lambda[i]);  \n \n        matvec(ms, ki, &qpos[3 * i]); \n    }", "pragma": "parallel for private(      i j ki md ms mtemp mtemp2)", "hash": "14c0a63d98088832366a7946ad84ea463031006b7c9b4c1fb25271f057da67eb"}
{"code": "for (i = 0; i < nprint; i++) \n    { \n        int             j; \n        double          outval; \n        double          outtime; \n \n        if(PrintNow(varctrl[i].intvl, lapse, pihm_time)) \n        { \n            if (ascii) \n            { \n                fprintf(varctrl[i].txtfile, \"\\\"%s\\\"\", pihm_time.str); \n                for (j = 0; j < varctrl[i].nvar; j++) \n                { \n                    outval = (varctrl[i].counter > 0) ? \n                        varctrl[i].buffer[j] / (double)varctrl[i].counter : varctrl[i].buffer[j]; \n \n                    fprintf(varctrl[i].txtfile, (roundi(outval) == BADVAL) ? \n                        \"\\t%-8.0lf\" : ((outval == 0.0 || fabs(outval) > 1.0E-3) ? \"\\t%lf\" : \"\\t%.2le\"), outval); \n                } \n                fprintf(varctrl[i].txtfile, \"\\n\"); \n                fflush(varctrl[i].txtfile); \n            } \n \n            outtime = (double)t; \n            fwrite(&outtime, sizeof(double), 1, varctrl[i].datfile); \n            for (j = 0; j < varctrl[i].nvar; j++) \n            { \n                outval = (varctrl[i].counter > 0) ? \n                    varctrl[i].buffer[j] / (double)varctrl[i].counter : varctrl[i].buffer[j]; \n \n                fwrite(&outval, sizeof(double), 1, varctrl[i].datfile); \n \n                varctrl[i].buffer[j] = 0.0; \n            } \n            varctrl[i].counter = 0; \n            fflush(varctrl[i].datfile); \n        } \n    }", "pragma": "parallel for ", "hash": "9e283de81d64479087bcfe02195e358f4c1ad76fd7d154318e9f331700c4b911"}
{"code": "for(unsigned long n=0; n<ncells; n++)\t\t\t\t\t\t \n \n\t\t{ \n\t\t \n\t\tbool cellisOK = true; \n\t\t \n\t\t \n \n\t\tif( fabs(mGinOld[n] - mGinNew[n]) > eps*0.5*(fabs(mGinOld[n])+fabs(mGinNew[n]))+TOL )  \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[4]++; \n\t\t\tdouble newprec = 2.*fabs(mGinOld[n] - mGinNew[n])/(fabs(mGinOld[n])+fabs(mGinNew[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(mGinOld[n] - mGinNew[n]) > 0.5*(fabs(mGinOld[n])+fabs(mGinNew[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"mGin: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(mGinNew[n]-mGinOld[n])/mGinOld[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\tif( fabs(mGextOld[n] - mGextNew[n]) > eps*0.5*(fabs(mGextOld[n])+fabs(mGextNew[n]))+TOL ) \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[5]++; \n\t\t\tdouble newprec = 2.*fabs(mGextOld[n] - mGextNew[n])/(fabs(mGextOld[n])+fabs(mGextNew[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(mGextOld[n] - mGextNew[n]) > 0.5*(fabs(mGextOld[n])+fabs(mGextNew[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"mGext: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(mGextNew[n]-mGextOld[n])/mGextOld[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\tif( fabs(mO2Old[n] - mO2New[n]) > eps*0.5*(fabs(mO2Old[n])+fabs(mO2New[n]))+TOL ) \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[6]++; \n\t\t\tdouble newprec = 2.*fabs(mO2Old[n] - mO2New[n])/(fabs(mO2Old[n])+fabs(mO2New[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(mO2Old[n] - mO2New[n]) > 0.5*(fabs(mO2Old[n])+fabs(mO2New[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"mO2: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(mO2New[n]-mO2Old[n])/mO2Old[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\tif( fabs(mAinOld[n] - mAinNew[n]) > eps*0.5*(fabs(mAinOld[n])+fabs(mAinNew[n]))+TOL ) \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[7]++; \n\t\t\tdouble newprec = 2.*fabs(mAinOld[n] - mAinNew[n])/(fabs(mAinOld[n])+fabs(mAinNew[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(mAinOld[n] - mAinNew[n]) > 0.5*(fabs(mAinOld[n])+fabs(mAinNew[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"mAin: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(mAinNew[n]-mAinOld[n])/mAinOld[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\tif( fabs(mAextOld[n] - mAextNew[n]) > eps*0.5*(fabs(mAextOld[n])+fabs(mAextNew[n]))+TOL ) \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[8]++; \n\t\t\tdouble newprec = 2.*fabs(mAextOld[n] - mAextNew[n])/(fabs(mAextOld[n])+fabs(mAextNew[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(mAextOld[n] - mAextNew[n]) > 0.5*(fabs(mAextOld[n])+fabs(mAextNew[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"mAext: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(mAextNew[n]-mAextOld[n])/mAextOld[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\tif( fabs(mAcLinOld[n] - mAcLinNew[n]) > eps*0.5*(fabs(mAcLinOld[n])+fabs(mAcLinNew[n]))+TOL ) \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[9]++; \n\t\t\tdouble newprec = 2.*fabs(mAcLinOld[n] - mAcLinNew[n])/(fabs(mAcLinOld[n])+fabs(mAcLinNew[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(mAcLinOld[n] - mAcLinNew[n]) > 0.5*fabs(fabs(mAcLinOld[n])+fabs(mAcLinNew[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"mAcLin: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(mAcLinNew[n]-mAcLinOld[n])/mAcLinOld[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\tif( fabs(mAcLextOld[n] - mAcLextNew[n]) > eps*0.5*(fabs(mAcLextOld[n])+fabs(mAcLextNew[n]))+TOL ) \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[10]++; \n\t\t\tdouble newprec = 2.*fabs(mAcLextOld[n] - mAcLextNew[n])/(fabs(mAcLextOld[n])+fabs(mAcLextNew[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(mAcLextOld[n] - mAcLextNew[n]) > 0.5*fabs(fabs(mAcLextOld[n])+fabs(mAcLextNew[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"mAcLext: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(mAcLextNew[n]-mAcLextOld[n])/mAcLextOld[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\tif( fabs(ATPpOld[n] - ATPpNew[n]) > eps*0.5*(fabs(ATPpOld[n])+fabs(ATPpNew[n]))+TOL ) \n\t\t\t{ \n\t\t\tisOK = false; \n\t\t\tcellisOK = false; \n\t\t\tconvergence_fail[11]++; \n\t\t\tdouble newprec = 2.*fabs(ATPpOld[n] - ATPpNew[n])/(fabs(ATPpOld[n])+fabs(ATPpNew[n])); \n\t\t\tprec = newprec > prec ? newprec : prec; \n\t\t\tif ( fabs(ATPpOld[n] - ATPpNew[n]) > 0.5*(fabs(ATPpOld[n])+fabs(ATPpNew[n])) && EXTENDED_ERRORLOG )  \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"CellsSystem::Diff() - passo \" << Get_nstep() << \", iterazione \" << nrepeats << endl; \n\t\t\t\terrorlog_file << \"ATPp: Differenza maggiore del 50% nel calcolo iterativo per la cellula \" << n <<\"-esima\\n\"; \n\t\t\t\terrorlog_file << \"\\tdifferenza : \" << 100.*(ATPpNew[n]-ATPpOld[n])/ATPpOld[n] << \"%\\n\"; \n\t\t\t\terrorlog_file << \"\\tfase : \" << phase[n] << endl; \n\t\t\t\terrorlog_file << \"\\teta' di fase: \" << phase_age[n] << \" s\\n\" << endl; \n\t\t\t\t} \n\t\t\t} \n\t\t \n\t\tif( !cellisOK ) ncell_fails++; \n\t\t \n\t\t \n \n\t\tvolumeOld[n] = volumeNew[n]; \n\t\tvolume_extraOld[n] = volume_extraNew[n]; \n\t\tMitOld[n] = MitNew[n]; \n\t\tpHiOld[n] = pHiNew[n]; \n\t\tpHOld[n] = pHNew[n]; \n\t\tmGinOld[n] = mGinNew[n]; \n\t\tmGextOld[n] = mGextNew[n]; \n\t\tmG6POld[n] = mG6PNew[n]; \n\t\tmO2Old[n] = mO2New[n]; \n\t\tStoreOld[n] = StoreNew[n]; \n\t\tmAinOld[n] = mAinNew[n]; \n\t\tmAextOld[n] = mAextNew[n]; \n\t\tmAcLinOld[n] = mAcLinNew[n]; \n\t\tmAcLextOld[n] = mAcLextNew[n]; \n\t\tATPpOld[n] = ATPpNew[n]; \n\t\t}", "pragma": "parallel for ", "hash": "f5375caeb51e31e266dc25a98df16231e1f68cdf92d34bcd6d736e2aa5c7d13e"}
{"code": "for(int i = 0; i < n; ++i)\r \n            result[i] = dist(coor, x_.row(i), w_);", "pragma": "parallel for ", "hash": "1b00848965c8cb8300b8bc4a73ae8fb756a5f4335ed4d5bb535f44f5efd3700b"}
{"code": "for (long i=0; i<size; i++){ \n\t\tCellHandle& cell = Tes.cellHandles[i]; \n\t\tCVector l; \n\t\tdouble charLength = 0.000001; \n\t\t \n \n\t\tdouble Nusselt=2.; \n\t\tfor(int i=0;i<4;i++) { \n\t\t\tif(!cell->neighbor(i)->info().isFictious) { \n\t\t\t\tl = cell->info() - cell->neighbor(i)->info(); \n\t\t\t\tcharLength = sqrt(l.squared_length()); \n\t\t\t} \n\t\t} \n\t\tconst double avgCellFluidVel = sqrt(cell->info().averageVelocity().squared_length()); \n\t\tdouble Reynolds = flow->solver->fluidRho*avgCellFluidVel*charLength/flow->viscosity; \n\t\tif (Reynolds<0 || std::isnan(Reynolds)){cerr<<\"Reynolds is negative or nan\"<<endl; Reynolds = 0;} \n\t\tif (Reynolds > 1000 || poro<0.35){ \n\t\t\tNusselt = 2. + 0.6*pow(Reynolds,0.5)*pow(Pr,0.33333); \n\t\t\tcell->info().Reynolds = Reynolds; \n\t\t} else if ((0 <= Reynolds) && (Reynolds <= 1000)) {  \n \n\t\t\tNusselt = (7.-10.*poro+5.*poro*poro)*(1.+0.1*pow(Reynolds,0.2)*pow(Pr,0.333))+(1.33-2.19*poro+1.15*poro*poro)*pow(Reynolds,0.7)*pow(Pr,0.333); \n\t\t\tNutimesFluidK = Nu*fluidK; \n\t\t\tcell->info().Reynolds = Reynolds; \n\t\t} \n\t\tcell->info().NutimesFluidK = Nusselt*fluidK; \n\t}", "pragma": "parallel for ", "hash": "6871645180498d1aae81fd84bf424cc025c3498f7410ebfca6adcda2d043a33f"}
{"code": "for(i=0; i<N; i++) \n    { \n      zp[i] = zp[i] + dt*vz[i]; \n      yp[i] = yp[i] + dt*vy[i]; \n      xp[i] = xp[i] + dt*vx[i]; \n    }", "pragma": "parallel for ", "hash": "610ae1476ec15b018ebbca0b2d88bc91283ab78295c2f2b9e3e65817ccd50fa4"}
{"code": "for (i=0; i<ydest; i++) \n\t{ \n\t\tint y2_xsource = ((i*y_ratio)>>16)*xsource;  \n \n\t\tint i_xdest = i*xdest; \n\t\tint j; \n\t\tfor (j=0; j<xdest; j++) \n\t\t{ \n\t\t\tint x2 = ((j*x_ratio)>>16) ; \n\t\t\tint y2_x2_colors = (y2_xsource+x2)*colors; \n\t\t\tint i_x_colors = (i_xdest+j)*colors; \n\t\t\tint c; \n\t\t\tfor (c=0; c<colors; c++) \n\t\t\t\tdest[i_x_colors + c] = source[y2_x2_colors + c] ; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "1db4532493934ea1b87b01bfb1f8f90c7912b8d03af2f092a66e211b975b6a98"}
{"code": "for (i=0; i<numel; i++) \n        tensor_data[i] = src_data[index_data[i] - TH_INDEX_BASE];", "pragma": "parallel for private(i)", "hash": "05c8e0cdb5219fd7c966ebf765e49b646084bc740863445aeabf4546821dc669"}
{"code": "for( int ix = 0; ix < width; ++ix ) \n        { \n            for( int iy = 0; iy < height; ++iy ) \n            { \n                pic[ix][iy].r = -xexp.expm1(pic[ix][iy].r); \n                pic[ix][iy].g = -xexp.expm1(pic[ix][iy].g); \n                pic[ix][iy].b = -xexp.expm1(pic[ix][iy].b); \n            } \n        }", "pragma": "parallel for ", "hash": "ba3c278ce4c0028064a348387021d9139e52d65dd02c7a4bbf3988e4eb8244cc"}
{"code": "for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) { \n          register double complex temp = zero; \n          for (size_t l = 0; l < k; l++) \n            temp += conj(A[i * lda + l]) * B[j * ldb + l]; \n          if (beta == zero) \n            C[j * ldc + i] = alpha * temp; \n          else \n            C[j * ldc + i] = alpha * temp + beta * C[j * ldc + i]; \n        } \n      }", "pragma": "parallel for ", "hash": "03a1d094c4eac1d4734e7ddcfd85ffd7a3bb37e9b801d5276f3d020371498f0f"}
{"code": "for (i = 0; i < _sp.size(); i++) { \n        _values[i] *= conj(_values[i]); \n    }", "pragma": "parallel for private(i)", "hash": "59f5bcd84dced861910b6806f0febeb6275a19e30aeaca76442e63dd18301505"}
{"code": "for(int i = 0; i < riverReachMethods.size(); ++i)\r \n\t\t\t\t{\r \n\t\t\t\t\tcurrentRiverReachMethods = &(riverReachMethods[i]);\r \n\t\t\t\t\tcurrentRiverReachProperties = currentRiverReachMethods->getPointerToCorrespondingRiverReachProperties();\r \n\t\t\t\t\tcurrentUpstreamProperties = (currentRiverReachProperties->getUpstreamCellPointers()).at(0);\r \n\t\t\t\t\tif(currentUpstreamProperties->isUpstreamMargin())\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tflowMethods.handDownOtherParameters(*currentUpstreamProperties);\r \n\t\t\t\t\t\tupdateWaterEnergySlope(*currentUpstreamProperties, overallMethods);\r \n\t\t\t\t\t\tupdateSedimentEnergySlope(*currentUpstreamProperties, overallMethods);\r \n\t\t\t\t\t\tRegularRiverReachMethods regularRiverReachMethods = currentRiverReachMethods->getRegularRiverReachMethods();\r \n\t\t\t\t\t\tregularRiverReachMethods.calculateTau(*currentUpstreamProperties, overallMethods);\r \n\t\t\t\t\t\tregularRiverReachMethods.calculateActiveWidth(*currentUpstreamProperties, sedimentFlowMethods, overallMethods);\r \n\t\t\t\t\t\t(*(*currentFlowMethod)).updateChangeRateDependingParameters(*currentUpstreamProperties);\r \n\t\t\t\t\t}\r \n\t\t\t\t\tflowMethods.handDownOtherParameters(*currentRiverReachProperties);\r \n\t\t\t\t\tcurrentRiverReachMethods->updateAdditionalRiverReachProperties();\r \n\t\t\t\t\tupdateWaterEnergySlope(*currentRiverReachProperties, overallMethods);\r \n\t\t\t\t\tupdateSedimentEnergySlope(*currentRiverReachProperties, overallMethods);\r \n\t\t\t\t\tcurrentRiverReachMethods->calculateTau();\r \n\t\t\t\t\tcurrentRiverReachMethods->calculateActiveWidth(sedimentFlowMethods);\r \n\t\t\t\t\t(*(*currentFlowMethod)).updateChangeRateDependingParameters(*currentRiverReachProperties);\r \n\t\t\t\t}", "pragma": "parallel for private(  currentriverreachmethods currentriverreachproperties currentupstreamproperties)", "hash": "cc635db97b209c9be1e0326fa14855690f2da3be9d054d8d119a5a264e97ae9c"}
{"code": "for (long p = 0; p < pc; p++) \n        { \n            int randSubset; \n            mdts[g].getValue(EMDL_PARTICLE_RANDOM_SUBSET, randSubset, p); \n            randSubset -= 1; \n \n            if (quadratic) \n            { \n                Matrix2D<RFLOAT> A(27,10); \n                Matrix1D<RFLOAT> b(27); \n \n                for (int rot = -1; rot <= 1; rot++) \n                for (int tilt = -1; tilt <= 1; tilt++) \n                for (int psi = -1; psi <= 1; psi++) \n                { \n                    Image<Complex> pred; \n \n                    if (randSubset == 0) \n                    { \n                        pred = obsModel.predictObservation( \n                            projector0, mdts[g], p, true, true, \n                            rot*deltaAngle, tilt*deltaAngle, psi*deltaAngle); \n                    } \n                    else \n                    { \n                        pred = obsModel.predictObservation( \n                            projector1, mdts[g], p, true, true, \n                            rot*deltaAngle, tilt*deltaAngle, psi*deltaAngle); \n                    } \n \n                    const double index = 9*(rot+1) + 3*(tilt+1) + (psi+1); \n \n                    b(index) = 0.0; \n \n                    for (int y = 0; y < s; y++) \n                    for (int x = 0; x < sh; x++) \n                    { \n                        double yy = y < sh? y : y - s; \n                        double r = sqrt(x*x + yy*yy); \n                        if (r > kmax) continue; \n \n                        b(index) += imgSnr(y,x) * (pred(y,x) - obsF[p](y,x)).norm(); \n                    } \n \n                    A(index, 0) = rot*rot; \n                    A(index, 1) = 2.0*rot*tilt; \n                    A(index, 2) = 2.0*rot*psi; \n                    A(index, 3) = 2.0*rot; \n \n                    A(index, 4) = tilt*tilt; \n                    A(index, 5) = 2.0*tilt*psi; \n                    A(index, 6) = 2.0*tilt; \n \n                    A(index, 7) = psi*psi; \n                    A(index, 8) = 2.0*psi; \n \n                    A(index, 9) = 1.0; \n                } \n \n                const double tol = 1e-20; \n                Matrix1D<RFLOAT> x(10); \n                solve(A, b, x, tol); \n \n                d3Matrix C3(x(0), x(1), x(2), \n                            x(1), x(4), x(5), \n                            x(2), x(5), x(7)); \n \n                d3Vector d(x(3), x(6), x(8)); \n \n                d3Matrix C3i = C3; \n                C3i.invert(); \n \n                d3Vector min = -C3i * d; \n \n                if (debug) std::cout << p << \": \" << min*deltaAngle << \"\\n\"; \n \n                if (min.length() > 1.0) min /= min.length(); \n \n                double rot, tilt, psi; \n \n                mdts[g].getValue(EMDL_ORIENT_ROT, rot, p); \n                mdts[g].getValue(EMDL_ORIENT_TILT, tilt, p); \n                mdts[g].getValue(EMDL_ORIENT_PSI, psi, p); \n \n                rot += min[0]*deltaAngle; \n                tilt += min[1]*deltaAngle; \n                psi += min[2]*deltaAngle; \n \n                mdts[g].setValue(EMDL_ORIENT_ROT, rot, p); \n                mdts[g].setValue(EMDL_ORIENT_TILT, tilt, p); \n                mdts[g].setValue(EMDL_ORIENT_PSI, psi, p); \n \n            } \n            else \n            { \n \n            } \n        }", "pragma": "parallel for ", "hash": "7759349406a64d4adfbce4eb4a7e6562b90881f57c11a3eb1a6c6b460d6f1208"}
{"code": "for (i = 0; i < ndata; i++) { \n    \t    data[i] = (save->n[i] != save->n_fields) ? UNDEFINED : save->sum[i]; \n        }", "pragma": "parallel for private(i)", "hash": "56475fccdb81a1e0fd2372da944bc44c060af6ff19937cf7e5968226a5417608"}
{"code": "for (int i = 0; i < GridSqr; ++i) \n\t{ \n\t\tconst int x = i % GridSize; \n\t\tconst int y = i / GridSize; \n \n\t\tbool AliveStatus = Array[y * GridSize + x];  \n \n\t\tint N = GetNeighbors(x, y, Array);  \n \n \n\t\tbool Result = GetRule(N, AliveStatus, DefaultSet);  \n \n\t\t\t\t\t\t\t\t\t\t\t\t    \n\t\tNext[y * GridSize + x] = Result;  \n \n\t}", "pragma": "parallel for ", "hash": "cc4ee478973dee50f68c60d322c50a6ea1e2ae4b07c65a6cc755c96c13bb0ace"}
{"code": "for(long i0=t->id;i0<t->n;i0+=mglNumThr) \n\t{ \n\t\tregister long i=i0%nx, j=(i0/nx)%ny, k=i0/(nx*ny); \n\t\tregister long ip = i<nx-1 ? 1:0, jp = j<ny-1 ? nx:0, kp = k<nz-1 ? nx*ny:0; \n\t\tregister long im = i>0 ? -1:0, jm = j>0 ? -nx:0, km = k>0 ? -nx*ny:0; \n\t\tr[i0] = (x[i0+ip]-x[i0+im])*(y[i0+jp]-y[i0+jm])*(z[i0+kp]-z[i0+km]) - \n\t\t\t\t(x[i0+ip]-x[i0+im])*(y[i0+kp]-y[i0+km])*(z[i0+jp]-z[i0+jm]) - \n\t\t\t\t(x[i0+jp]-x[i0+jm])*(y[i0+ip]-y[i0+im])*(z[i0+kp]-z[i0+km]) + \n\t\t\t\t(x[i0+jp]-x[i0+jm])*(y[i0+kp]-y[i0+km])*(z[i0+ip]-z[i0+im]) + \n\t\t\t\t(x[i0+kp]-x[i0+km])*(y[i0+ip]-y[i0+im])*(z[i0+jp]-z[i0+jm]) - \n\t\t\t\t(x[i0+kp]-x[i0+km])*(y[i0+jp]-y[i0+jm])*(z[i0+ip]-z[i0+im]); \n\t\tr[i0] *= mreal((nx-1)*(ny-1)*(nz-1)) / ((ip-im)*(jp-jm)*(kp-km)); \n\t}", "pragma": "parallel for ", "hash": "5c3436f7f13a8f09d42cde431a5db17139f1b6ecc74a006dad49668a43d0941d"}
{"code": "for (row=3; row<m_Height-3; row++) \n    for (col=3+(FC(row,2)&1),indx=row*m_Width+col; col<u-3; col+=2,indx+=2) \n      for(c=d=0;d<=1;c+=2,d++){ \n        f[0]=1.0f/(1.0f+abs(chroma[indx-u][d]-chroma[indx+u][d])+abs(chroma[indx-u][d]-chroma[indx-w][d])+abs(chroma[indx+u][d]-chroma[indx-w][d])); \n        f[1]=1.0f/(1.0f+abs(chroma[indx+1][d]-chroma[indx-1][d])+abs(chroma[indx+1][d]-chroma[indx+3][d])+abs(chroma[indx-1][d]-chroma[indx+3][d])); \n        f[2]=1.0f/(1.0f+abs(chroma[indx-1][d]-chroma[indx+1][d])+abs(chroma[indx-1][d]-chroma[indx-3][d])+abs(chroma[indx+1][d]-chroma[indx-3][d])); \n        f[3]=1.0f/(1.0f+abs(chroma[indx+u][d]-chroma[indx-u][d])+abs(chroma[indx+u][d]-chroma[indx+w][d])+abs(chroma[indx-u][d]-chroma[indx+w][d])); \n        m_Image[indx][c]=CLIP((int32_t)((f[0]*chroma[indx-u][d]+f[1]*chroma[indx+1][d]+f[2]*chroma[indx-1][d]+f[3]*chroma[indx+u][d])/(f[0]+f[1]+f[2]+f[3])+m_Image[indx][1])); \n      }", "pragma": "for private(     c col d f indx row)", "hash": "cae2aa1b124217267daa537fcf9824306516ab98ada4114eedcb5c8892882ffe"}
{"code": "for (y = 0; y < world_size; y++) \n\t{ \n\t\tfor (x = 0; x < world_size; x++) \n\t\t{ \n\t\t\tswitch (world[index(TABLE_RED, x, y)].type) \n\t\t\t{ \n\t\t\tcase CELL_WOLF: \n\t\t\t\tif (world[index(TABLE_RED, x, y)].starvation_period++ == wolf_starvation_period) \n\t\t\t\t\tworld[index(TABLE_RED, x, y)].type = CELL_EMPTY; \n\t\t\tcase CELL_SQUIRREL: \n\t\t\tcase CELL_TREE_SQUIRREL: \n\t\t\t\tworld[index(TABLE_RED, x, y)].breeding_period++; \n\t\t\t} \n\t\t} \n\t}", "pragma": "for ", "hash": "b3ab6907632047a8f3ee1d2c9a110aa03ba83c5d643bc9ba38782a4643952ca3"}
{"code": "for (k = 0; k < static_cast<int>(scmLinks.size()); k++) \n        { \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n            mklgemm.execute(CblasRowMajor,  \n \n                            CblasNoTrans,  \n \n                            CblasTrans,   \n \n                            channel->getSpectrum()->getNumberOfPRBs(direction),  \n \n                            maxMsAntennas * maxBsAntennas,  \n \n                            MaxClusters,  \n \n                            &one,  \n \n                            &((*frequencyCoeff[direction])[k][0][0]),  \n \n                            MaxClusters,  \n \n                            &((*H[direction])[k][0][0][0]),  \n \n                            MaxClusters,  \n \n                            &zero,  \n \n                            &((*T[direction])[k][0][0][0]),  \n \n                            maxMsAntennas * maxBsAntennas  \n \n                );  \n        }", "pragma": "parallel for ", "hash": "266f9fe430da23835fd2ee6e13835328884f0a9048dc285f452d4b6415a449f2"}
{"code": "for (TDoc d = 0; d < num_docs; ++d) { \n        auto row = cdk.row(d); \n        TLen L = 0; \n        for (auto &entry : row) { \n            L += entry.v; \n        } \n        word_per_doc[d] = L; \n    }", "pragma": "parallel for ", "hash": "20fa71c8035711a4b9e883333204850e6699c750ae4b1211bc982b5edfdbf061"}
{"code": "for \t(ix=NOP; ix<fdm->nxpad-NOP; ix++) { \n\t\t\tfor\t(iz=NOP; iz<fdm->nzpad-NOP; iz++) { \n\t\t\t     \n\t\t\t     \n \n\t\t\t    ua[ix  ][iz]  +=     \n\t\t\t\tf1x*(uat[ix  ][iz] - \n\t\t\t\t     uat[ix+1][iz]) + \n\t\t\t\tf2x*(uat[ix-1][iz] - \n\t\t\t\t     uat[ix+2][iz]); \n\t\t\t} \n\t\t    }", "pragma": "for ", "hash": "e21ebbcb79055ae4bfaf83f245af8e9108a4bfdb868823c1120eb73f4ec22595"}
{"code": "for (i = 0; i < count; i++) \n          new_map[i] = normal_op(map[i], min, range);", "pragma": "parallel for ", "hash": "b5a5c37421a6278ee7f9e56fb0e74efcc7adf819052e8cf5c71a5897ba1d795d"}
{"code": "for (int i = 0; i<values_.size(); ++i) { \n        result = result + values_[i]; \n    }", "pragma": "parallel for reduction(+:result) ", "hash": "3c0c88c759a238074c343e1b00e398e320bfbfc3fa6b31c2fa7188e362fab6a6"}
{"code": "for(int i = edges.Size(); i < vertices.Size(); i++) \n\t\t{ \n\t\t\tmarker.points[i].x = vertices[i]->GetVertexObject()->GetCorrectedPose().GetX(); \n\t\t\tmarker.points[i].y = vertices[i]->GetVertexObject()->GetCorrectedPose().GetY(); \n\t\t\tmarker.points[i].z = 0; \n\t\t}", "pragma": "parallel for ", "hash": "e11011f316e71cdbb82e1137c4cd23e70089aea710a8dd6e7158c94c1a1427e0"}
{"code": "for (i=0; i<mfv->Nhydro; i++) { \n    MeshlessFVParticle<ndim> &part = partdata[i]; \n    if (part.flags.is_dead()) continue; \n \n    if (part.flags.check(end_timestep)) { \n \n       \n \n      FLOAT Qcons[MeshlessFV<ndim>::nvar] ; \n      for (int k=0; k<MeshlessFV<ndim>::nvar; k++) Qcons[k] = part.Qcons0[k] + part.dQ[k]; \n      for (int k=0; k<ndim; k++) { \n        Qcons[ietot] += 0.5*part.dt* \n            (part.a0[k]*(part.Qcons0[k] + 0.5*part.Qcons0[irho]*part.a0[k]*part.dt) + \n             part.a [k]*(Qcons[k]       + 0.5*     Qcons [irho]*part.a [k]*part.dt)); \n \n        Qcons[k] += 0.5*part.dt * (part.Qcons0[irho]*part.a0[k] + Qcons[irho]*part.a[k]); \n      } \n \n      mfv->UpdateArrayVariables(part, Qcons); \n      mfv->ComputeThermalProperties(part); \n      mfv->UpdatePrimitiveVector(part); \n \n      temp = eos->Temperature(part); \n      if (radfb) temp_amb = radfb->AmbientTemp(part); \n      col2 = GetCol2(part); \n \n       \n \n      FLOAT heating = ImplicitEnergyUpdate(part.rho, part.u, temp, temp_amb, col2, 0, part.dt); \n \n       \n \n      heating = max(heating, -0.95*part.u/part.dt); \n      part.cooling = - part.m*heating; \n    } \n  }", "pragma": "parallel for private(  col2 i temp)", "hash": "bf36c280978c264799b9bf426152a03ba2431b4b7d7e87f65e5f1ab9575e7cf1"}
{"code": "for (int i = base; i < A.getNnz() + base; i++) { \n    lu[i] = values[i]; \n  }", "pragma": "for ", "hash": "590ea5c254bb9b1af22756fbaad79476ad85f148bb612e867c0b4fa3289fe48c"}
{"code": "for( int j = 0 ; j < train_num ; j++ ) \n                { \n                    pcl::PointCloud<PointT>::Ptr mycloud = train_objects[0][j].cloud; \n                    cv::Mat map2d = train_objects[0][j].map2d; \n                    cv::Mat img = train_objects[0][j].img; \n \n                    pcl::PointCloud<PointT>::Ptr full_cloud(new pcl::PointCloud<PointT>()); \n                    full_cloud->resize(map2d.rows*map2d.cols); \n                    for(int r = 0, this_idx = 0 ; r < map2d.rows ; r++ ){ \n                        for(int c = 0 ; c < map2d.cols ; c++, this_idx++ ) \n                        { \n                            int idx2 = map2d.at<int>(r, c); \n                            if( idx2 >= 0 ) \n                            { \n                                full_cloud->at(this_idx).x = mycloud->at(idx2).x; \n                                full_cloud->at(this_idx).y = mycloud->at(idx2).y; \n                                full_cloud->at(this_idx).z = mycloud->at(idx2).z; \n                                full_cloud->at(this_idx).rgba = mycloud->at(idx2).rgba; \n                            } \n                            else \n                            { \n                                uint32_t rgba = img.at<uchar>(r, c*3+0) | img.at<uchar>(r, c*3+1) << 8 | img.at<uchar>(r, c*3+2) << 16; \n                                full_cloud->at(this_idx).x = std::numeric_limits<float>::quiet_NaN(); \n                                full_cloud->at(this_idx).y = std::numeric_limits<float>::quiet_NaN(); \n                                full_cloud->at(this_idx).z = std::numeric_limits<float>::quiet_NaN(); \n                                full_cloud->at(this_idx).rgba = rgba; \n                            } \n                        } \n                    } \n                    full_cloud->height = map2d.rows; \n                    full_cloud->width = map2d.cols; \n                    full_cloud->is_dense = false; \n \n                    spPooler triple_pooler; \n                    triple_pooler.init(full_cloud, hie_producer, radius, down_ss); \n                    triple_pooler.build_SP_LAB(lab_pooler_set, false); \n                    triple_pooler.build_SP_FPFH(fpfh_pooler_set, radius, false); \n                    triple_pooler.build_SP_SIFT(sift_pooler_set, hie_producer, sift_det_vec, false); \n \n                    for( int ll = 0 ; ll <= 4 ; ll++ ) \n                    { \n                        std::vector<cv::Mat> sp_fea = triple_pooler.sampleSPFea(ll, box_num, false, true); \n                        std::vector<cv::Mat> sp_raw; \n                        if( ll == 0 ) \n                            sp_raw = triple_pooler.sampleSPFea(ll, box_num, false, false); \n                        for( std::vector<cv::Mat>::iterator it = sp_fea.begin(); it < sp_fea.end() ; it++ ) \n                        { \n                            if( train_dim > 0 && it->cols != train_dim ) \n                            { \n                                std::cerr << \"Error: fea_dim > 0 && cur_final.cols != fea_dim   \" << train_dim << \" \" << it->cols << std::endl; \n                                exit(0); \n                            } \n                            else if( train_dim < 0 ) \n                            { \n                                #pragma omp critical \n                                { \n                                    train_dim = it->cols; \n                                    std::cerr << \"Fea Dim: \" << train_dim << std::endl; \n                                } \n                            }\t \n                            std::vector< sparseVec> this_sparse; \n                            sparseCvMat(*it, this_sparse); \n                            #pragma omp critical \n                            { \n                                final_train[ll].push_back(this_sparse[0]); \n                                if( ll == 0 ) \n                                    raw_fea[i].insert(raw_fea[i].end(), sp_raw.begin(), sp_raw.end()); \n                            } \n                        } \n                    } \n                }", "pragma": "parallel for ", "hash": "30b30a954783543a67c65835a399861f986d0f2bcba661cd4d615562176a6037"}
{"code": "for (int i=0;i<tod->ndet;i++) \n      for (int j=0;j<n;j++) \n\ttod->data[i][j]/=nn;", "pragma": "for ", "hash": "56513e7dbff6cde32e1dbd86f4e5af64b77dfa1205ea93c69909f96e8448fb02"}
{"code": "for ( unsigned int i = 0; i < arrsize; ++i ) { \n        delete arr[i]; \n \n    }", "pragma": "parallel for ", "hash": "8d1a04c2c75fe78f8bfd54ab98c4294b8d7501cfc93c369a9dba891043cee507"}
{"code": "for (int index = 0; index < data_manager->num_rigid_contacts; index++) { \n    real fric = data_manager->host_data.fric_rigid_rigid[index].x; \n    int2 body_id = ids[index]; \n \n    real s_v = D_t_T(index * 2 + 0, body_id.x * 6 + 0) * +v_new[body_id.x * 6 + 0] + \n               D_t_T(index * 2 + 0, body_id.x * 6 + 1) * +v_new[body_id.x * 6 + 1] + \n               D_t_T(index * 2 + 0, body_id.x * 6 + 2) * +v_new[body_id.x * 6 + 2] + \n               D_t_T(index * 2 + 0, body_id.x * 6 + 3) * +v_new[body_id.x * 6 + 3] + \n               D_t_T(index * 2 + 0, body_id.x * 6 + 4) * +v_new[body_id.x * 6 + 4] + \n               D_t_T(index * 2 + 0, body_id.x * 6 + 5) * +v_new[body_id.x * 6 + 5] + \n \n               D_t_T(index * 2 + 0, body_id.y * 6 + 0) * +v_new[body_id.y * 6 + 0] + \n               D_t_T(index * 2 + 0, body_id.y * 6 + 1) * +v_new[body_id.y * 6 + 1] + \n               D_t_T(index * 2 + 0, body_id.y * 6 + 2) * +v_new[body_id.y * 6 + 2] + \n               D_t_T(index * 2 + 0, body_id.y * 6 + 3) * +v_new[body_id.y * 6 + 3] + \n               D_t_T(index * 2 + 0, body_id.y * 6 + 4) * +v_new[body_id.y * 6 + 4] + \n               D_t_T(index * 2 + 0, body_id.y * 6 + 5) * +v_new[body_id.y * 6 + 5]; \n \n    real s_w = D_t_T(index * 2 + 1, body_id.x * 6 + 0) * +v_new[body_id.x * 6 + 0] + \n               D_t_T(index * 2 + 1, body_id.x * 6 + 1) * +v_new[body_id.x * 6 + 1] + \n               D_t_T(index * 2 + 1, body_id.x * 6 + 2) * +v_new[body_id.x * 6 + 2] + \n               D_t_T(index * 2 + 1, body_id.x * 6 + 3) * +v_new[body_id.x * 6 + 3] + \n               D_t_T(index * 2 + 1, body_id.x * 6 + 4) * +v_new[body_id.x * 6 + 4] + \n               D_t_T(index * 2 + 1, body_id.x * 6 + 5) * +v_new[body_id.x * 6 + 5] + \n \n               D_t_T(index * 2 + 1, body_id.y * 6 + 0) * +v_new[body_id.y * 6 + 0] + \n               D_t_T(index * 2 + 1, body_id.y * 6 + 1) * +v_new[body_id.y * 6 + 1] + \n               D_t_T(index * 2 + 1, body_id.y * 6 + 2) * +v_new[body_id.y * 6 + 2] + \n               D_t_T(index * 2 + 1, body_id.y * 6 + 3) * +v_new[body_id.y * 6 + 3] + \n               D_t_T(index * 2 + 1, body_id.y * 6 + 4) * +v_new[body_id.y * 6 + 4] + \n               D_t_T(index * 2 + 1, body_id.y * 6 + 5) * +v_new[body_id.y * 6 + 5]; \n \n    data_manager->host_data.s[index * 1 + 0] = sqrt(s_v * s_v + s_w * s_w) * fric; \n  }", "pragma": "parallel for ", "hash": "2211a404f92b1e5fd63aea254684b202de3cc5f124ba9af954554fda7a42e21a"}
{"code": "for (int i=0; i < _sz; i++) op(i,val,maxVal);", "pragma": "for ", "hash": "c8c817bc9da61b45e9a2a0fa991005bb38b3b0d9d9980c05ba17f0789a89733c"}
{"code": "for (int k = 0; k < negx.size(); k++) \n          Hneg[k] += negpred[_selectors[s]][k];", "pragma": "parallel for ", "hash": "bdefcd7bea84632d28f3514adec51a711bcb3995e7cf1e7aa8a276314eff8935"}
{"code": "for (int j = 0; j < tri.colorDisplacement.size(); ++j) \n\t\t\t\tcolors[triData[nextTri].cPtr + j] = convertToRGB(tri.colorDisplacement[j]);", "pragma": "parallel for ", "hash": "ea1f3fcb26fc3083a2e563ba9924624099726273e0440208d01cb836dc8bd2de"}
{"code": "for (int i = 0; i < 1024; i++) \n      for (int j = 2; j < 7; j++) \n\tx[j] += j * i;", "pragma": "parallel for reduction(+:x[2:5]) ", "hash": "fb277f7364126e22fdd2a0698800d477c50e56c7c7dfa2f458121be6e241735f"}
{"code": "for( i=0 ; i < j ; i++ )\t \n \n\t{ \n\t\ttemp1 = ( complex_buff[i][0] * response[i][0] - complex_buff[i][1] * response[i][1] ) / double( k ); \n\t\ttemp2 = ( complex_buff[i][1] * response[i][0] + complex_buff[i][0] * response[i][1] ) / double( k );\t \n \n \n\t\tcomplex_buff[i][0] = temp1; \n\t\tcomplex_buff[i][1] = temp2; \n\t}", "pragma": "parallel for private(temp1 temp2)", "hash": "33d1e9feab64db265057861735f0c77fa171ec47e2e6f04f396d1be832b3afc8"}
{"code": "for (int i = 0; i < N; i += size) {\r \n            for (int j = i, k = 0; j < i + period; ++j, k += rate) {\r \n                double treal =  realIO[j + period] * cosLUT[k] + imagIO[j + period] * sinLUT[k];\r \n                double timag = -realIO[j + period] * sinLUT[k] + imagIO[j + period] * cosLUT[k];\r \n                realIO[j + period] = realIO[j] - treal;\r \n                imagIO[j + period] = imagIO[j] - timag;\r \n                realIO[j] += treal;\r \n                imagIO[j] += timag;\r \n            }\r \n        }", "pragma": "parallel for ", "hash": "236ffa84f2f11b90956c66f3d051f7a0422906bd7c37d0f2b7e5336a4306863b"}
{"code": "for (i = 0; i < N; i++) \n      yd[i] -= xd[i];", "pragma": "parallel for private(i)", "hash": "d8ced446de097f82f1678d9185c45b97e84bccba0543c4d05ffeac76bb45207e"}
{"code": "for (PartitionQueue::size_t moduleIndex = 0; moduleIndex < numModules; ++moduleIndex) { \n    InfoNode& module = *queue[moduleIndex]; \n \n    module.codelength = calcCodelength(module); \n     \n \n    if (module.disposeInfomap()) \n      module.codelength = calcCodelength(module); \n \n     \n \n    if (module.childDegree() <= 2) { \n      module.codelength = calcCodelength(module); \n      leafCodelengths[moduleIndex] = module.codelength; \n      continue; \n    } \n \n    double oldModuleCodelength = module.codelength; \n    PartitionQueue& subQueue = subQueues[moduleIndex]; \n    subQueue.level = queue.level + 1; \n \n    auto& subInfomap = getSubInfomap(module) \n                           .initNetwork(module); \n     \n \n    subInfomap.setOnlySuperModules(true).run(); \n \n    double subCodelength = subInfomap.getHierarchicalCodelength(); \n    double subIndexCodelength = subInfomap.root().codelength; \n    double subModuleCodelength = subCodelength - subIndexCodelength; \n    InfoNode& subRoot = *module.getInfomapRoot(); \n    unsigned int numSubModules = subRoot.childDegree(); \n    bool trivialSubPartition = numSubModules == 1 || numSubModules == module.childDegree(); \n    bool improvedCodelength = subCodelength < oldModuleCodelength - minimumCodelengthImprovement; \n \n    if (trivialSubPartition || !improvedCodelength) { \n      Log(1) << \"Disposing unaccepted sub Infomap instance.\\n\"; \n      module.disposeInfomap(); \n      module.codelength = oldModuleCodelength; \n      subQueue.skip = true; \n      leafCodelengths[moduleIndex] = module.codelength; \n    } else { \n       \n \n      subInfomap.queueTopModules(subQueue); \n      indexCodelengths[moduleIndex] = subIndexCodelength; \n      moduleCodelengths[moduleIndex] = subModuleCodelength; \n    } \n  }", "pragma": "parallel for ", "hash": "c57c800cba6f526cccc2be47b18d05fcbef159fdaf86f43d49a6d0c0057a25f0"}
{"code": "for (int i = y; i<m_pyramid->levels[el].h - 2; i += 5) \n\t{ \n\t\tloop_inside_by<2, Nei<CTT, CT, CBB, CB, CLL, CL, CRR, CR>, FUN>(el, nx, i); \n#pragma omp atomic \n\t\tnum++; \n\t}", "pragma": "parallel for ", "hash": "08066fe43d58f267d3926e2fb7e6ef6295e515de0270c73b504f35f83cebf737"}
{"code": "for (i_cl = 0 ; i_cl < (signed)numClusters ; ++ i_cl) { \n    TYPE logSigma = 0 ; \n    if (priors[i_cl] < VL_GMM_MIN_PRIOR) { \n      logWeights[i_cl] = - (TYPE) VL_INFINITY_D ; \n    } else { \n      logWeights[i_cl] = log(priors[i_cl]); \n    } \n    for(dim = 0 ; dim < dimension ; ++ dim) { \n      logSigma += log(covariances[i_cl*dimension + dim]); \n      invCovariances [i_cl*dimension + dim] = (TYPE) 1.0 / covariances[i_cl*dimension + dim]; \n    } \n    logCovariances[i_cl] = logSigma; \n  }", "pragma": "parallel for private(dim i_cl)", "hash": "ccc312ef5cb9ed4f31be062e2712c18736eb4b17b00e3237bf967801fb770868"}
{"code": "for (unsigned y=2; y<imax; y++) \n    { \n      int inc = 1; \n      while (down_scan[y][inc] > 0) \n      { \n        unsigned x = down_scan[y][inc]; \n \n        edge_temp[x][y] = 0; \n        if (x == 1) x++; \n        if (x == jmax) x--; \n        if (y == 1) break; \n        if (y == imax) break; \n        inc++; \n \n        if (edge[x][y] > -9999) \n        { \n          double mean = 0; \n          double num = 0; \n          double water_flag = 0; \n \n           \n \n          mean += edge[x][y]; \n          num++; \n \n \n          for (int dir = 1; dir <= 8; dir++) \n          { \n            int x2, y2; \n            x2 = x + deltaX[dir]; \n            y2 = y + deltaY[dir]; \n            if (water_depth2[x2][y2] > mft) water_flag++; \n \n            if ( n > edge_smoothing_passes && edge[x2][y2] > -9999 && water_depth2[x2][y2] < mft && mean_ws_elev(x2,y2)>mean_ws_elev(x,y)) \n            { \n               \n \n              if ((std::abs(deltaX[dir]) + std::abs(deltaY[dir])) != 2) \n              { \n                if (deltaX[dir] == 1 && deltaY[dir] == 0 && \n                    (water_depth2[x + 1][y - 1] > mft || \n                     water_depth2[x + 1][y + 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 0 && deltaY[dir] == 1 && \n                    (water_depth2[x + 1][y + 1] > mft || \n                     water_depth2[x - 1][y + 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == -1 && deltaY[dir] == 0 && \n                    (water_depth2[x - 1][y - 1] > mft || \n                     water_depth2[x - 1][y + 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 0 && deltaY[dir] == -1 && \n                    (water_depth2[x - 1][y - 1] > mft || \n                     water_depth2[x + 1][y - 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n              } \n \n               \n \n              else \n              { \n                if (deltaX[dir] == -1 && deltaY[dir] == -1 && \n                    (water_depth2[x][y - 1] < mft || \n                     water_depth2[x - 1][y] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 1 && deltaY[dir] == -1 && \n                    (water_depth2[x][y - 1] < mft || \n                     water_depth2[x + 1][y] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 1 && deltaY[dir] == 1 && \n                    (water_depth2[x + 1][y] < mft || \n                     water_depth2[x][y + 1] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == -1 && deltaY[dir] == 1 && \n                    (water_depth2[x][y + 1] < mft || \n                     water_depth2[x - 1][y] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n              } \n            } \n \n            else if ( n <= edge_smoothing_passes && edge[x2][y2] > -9999 && water_depth2[x2][y2] < mft) \n            { \n               \n \n              if ((std::abs(deltaX[dir]) + std::abs(deltaY[dir])) != 2) \n              { \n                if (deltaX[dir] == 1 && deltaY[dir] == 0 && \n                    (water_depth2[x + 1][y - 1] > mft || \n                     water_depth2[x + 1][y + 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 0 && deltaY[dir] == 1 && \n                    (water_depth2[x + 1][y + 1] > mft || \n                     water_depth2[x - 1][y + 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == -1 && deltaY[dir] == 0 && \n                    (water_depth2[x - 1][y - 1] > mft || \n                     water_depth2[x - 1][y + 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 0 && deltaY[dir] == -1 && \n                    (water_depth2[x - 1][y - 1] > mft || \n                     water_depth2[x + 1][y - 1] > mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n              } \n               \n \n              else \n              { \n                if (deltaX[dir] == -1 && deltaY[dir] == -1 && \n                    (water_depth2[x][y - 1] < mft || \n                     water_depth2[x - 1][y] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 1 && deltaY[dir] == -1 && \n                    (water_depth2[x][y - 1] < mft || \n                     water_depth2[x + 1][y] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == 1 && deltaY[dir] == 1 && \n                    (water_depth2[x + 1][y] < mft || \n                     water_depth2[x][y + 1] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n                if (deltaX[dir] == -1 && deltaY[dir] == 1 && \n                    (water_depth2[x][y + 1] < mft || \n                     water_depth2[x - 1][y] < mft)) \n                { \n                  mean += (edge[x + deltaX[dir]][y + deltaY[dir]]); \n                  num++; \n                } \n              } \n            } \n          } \n          if (mean != 0) edge_temp[x][y] = mean / num; \n \n           \n \n          if (x < 3 || x > (jmax - 3)) edge_temp[x][y] = 0; \n          if (y < 3 || y > (imax - 3)) edge_temp[x][y] = 0; \n \n        } \n      } \n    }", "pragma": "parallel for ", "hash": "500409a57f9e09936c2fcc98847f90a24231b8f82dc5f916d3ca8ef3c32dbad4"}
{"code": "for(long long i=0; i< nbins; i++) \n        { \n            if(tau[i] > thresh) \n                continue; \n            const double temp=exp(-scale*tau[i]); \n            mean_flux+=temp; \n            tau_mean_flux+=temp*tau[i]; \n            nbins_used++; \n        }", "pragma": "parallel for reduction(  +:mean_flux nbins_used tau_mean_flux) ", "hash": "f353ee9c62bb1b714fc08844036cd08f396f2afea485030d425b460ad6d8771e"}
{"code": "for (int y = 1; y <= dimY; y += 1) { \n    for (int x = 0; x < dimX / 2; x += double_v::size()) { \n      int i = (y) * (dimX / 2 + 1) + x; \n      if ((y) % 2 == RED) { \n        res += SORResidualKernel<dimX / 2 + 1, RED>( \n            &grid_r[i], &grid_b[i - dimX / 2 - 1], &rhs_r[i]); \n        ++i; \n        res += SORResidualKernel<dimX / 2 + 1, BLACK>( \n            &grid_b[i], &grid_r[i - dimX / 2 - 1], &rhs_b[i]); \n      } else { \n        res += SORResidualKernel<dimX / 2 + 1, RED>( \n            &grid_b[i], &grid_r[i - dimX / 2 - 1], &rhs_b[i]); \n        ++i; \n        res += SORResidualKernel<dimX / 2 + 1, BLACK>( \n            &grid_r[i], &grid_b[i - dimX / 2 - 1], &rhs_r[i]); \n      } \n    } \n  }", "pragma": "parallel for reduction(+ : res) ", "hash": "bd15b6d578115b350b6e90f7246496a0597ef46c98b7d61db5fc9160712d84a8"}
{"code": "for (int i = 0; i < m_nCells; i++) { \n            for (int k = 0; k < CVT_INT(m_nSoilLyrs[i]); k++) { \n                m_soilMass[i][k] = 10000. * m_soilThk[i][k] * \n                        m_soilBD[i][k] * (1. - m_soilRock[i][k] * 0.01); \n            } \n        }", "pragma": "parallel for ", "hash": "609ae022854d370a30053c0612c303cd427d4fe4620ce593d829194f9bb54f99"}
{"code": "for (uint64_t i = 0; i < weights->size(); ++i) { \n\t\tstd::string gzRmCommand = weights->at(i).second; \n\t\tif (verbose) { \n\t\t\tstd::cout << \"remove(\" + gzRmCommand + \")\\n\"; \n\t\t} \n\t\tif (remove(gzRmCommand.c_str())) { \n\t\t\tstd::cout << \"ERROR: \" + gzRmCommand + \" could not be removed.\\n\"; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "9eb5045da28f964741e03cd543f5a766102eb34fc769c3e1900d30f0dd3a46ec"}
{"code": "for (unsigned int curid = 0; curid < idLoc.size()-1; ++curid) { \n    calcNpdeInfoId idInfo = calcNpdeId(idLoc, sim, dvt, evid, cens, limit, censMethod, doLimit, curid, K, tolChol, ties, ru, ru2, ru3, \n\t\t\t\t       lambda, yj, hi, low); \n    npde(span(idLoc[curid],idLoc[curid+1]-1)) = idInfo.npde; \n    npd(span(idLoc[curid], idLoc[curid+1]-1)) = idInfo.npd; \n    epred(span(idLoc[curid], idLoc[curid+1]-1)) = idInfo.epred; \n    dvf(span(idLoc[curid], idLoc[curid+1]-1)) = idInfo.yobs; \n    eres(span(idLoc[curid], idLoc[curid+1]-1)) = idInfo.eres; \n    warn[curid] = idInfo.warn; \n  }", "pragma": "parallel for ", "hash": "c0edcc29255553424717a1de31774b12d4d94055b16d5d23db68ae3139d1e478"}
{"code": "for (size_t index=0; index<vpairs.size(); ++index) \n            { \n                int i = vpairs[index].first; \n                int j = vpairs[index].second; \n                long i_beg = BEG[i]; \n                long i_end = END[i]; \n                long i_len = i_end-i_beg; \n                long j_beg = BEG[j]; \n                long j_end = END[j]; \n                long j_len = j_end-j_beg; \n                unsigned long local_work = i_len * j_len; \n                parasail_result_t *result = function( \n                        (const char*)&T[i_beg], i_len, \n                        (const char*)&T[j_beg], j_len, \n                        gap_open, gap_extend, matrix); \n                work += local_work; \n#pragma omp atomic \n                work += local_work; \n                results[index] = result; \n            }", "pragma": "for ", "hash": "22541fc874e225b6edf1ac28c3cd126f15782ab8368b53c89c8cc8ded580c237"}
{"code": "for( size_t i = 0; i < tree.edge_count(); ++i ) { \n \n         \n \n        auto& edge_data = tree.edge_at(i).data<MassTreeEdgeData>(); \n        auto new_masses = std::map<double, double>(); \n \n         \n \n        for( auto const& mass : edge_data.masses ) { \n            auto const bin = get_bin_pos( mass.first, edge_data.branch_length ); \n \n            work += mass.second * std::abs( bin - mass.first ); \n            new_masses[ bin ] += mass.second; \n        } \n \n         \n \n        edge_data.masses = new_masses; \n    }", "pragma": "parallel for ", "hash": "e8bab5711c203c2a982548c3ae7031d54508554643a792727be5474ab93b8e0e"}
{"code": "for (int depth_y = 0; depth_y < depth_intrin.height; ++depth_y) \n        { \n            int depth_pixel_index = depth_y * depth_intrin.width; \n            for (int depth_x = 0; depth_x < depth_intrin.width; ++depth_x, ++depth_pixel_index) \n            { \n                 \n \n                if (float depth = get_depth(depth_pixel_index)) \n                { \n                     \n \n                    float depth_pixel[2] = { depth_x - 0.5f, depth_y - 0.5f }, depth_point[3], other_point[3], other_pixel[2]; \n                    rs2_deproject_pixel_to_point(depth_point, &depth_intrin, depth_pixel, depth); \n                    rs2_transform_point_to_point(other_point, &depth_to_other, depth_point); \n                    rs2_project_point_to_pixel(other_pixel, &other_intrin, other_point); \n                    const int other_x0 = static_cast<int>(other_pixel[0] + 0.5f); \n                    const int other_y0 = static_cast<int>(other_pixel[1] + 0.5f); \n \n                     \n \n                    depth_pixel[0] = depth_x + 0.5f; depth_pixel[1] = depth_y + 0.5f; \n                    rs2_deproject_pixel_to_point(depth_point, &depth_intrin, depth_pixel, depth); \n                    rs2_transform_point_to_point(other_point, &depth_to_other, depth_point); \n                    rs2_project_point_to_pixel(other_pixel, &other_intrin, other_point); \n                    const int other_x1 = static_cast<int>(other_pixel[0] + 0.5f); \n                    const int other_y1 = static_cast<int>(other_pixel[1] + 0.5f); \n \n                    if (other_x0 < 0 || other_y0 < 0 || other_x1 >= other_intrin.width || other_y1 >= other_intrin.height) \n                        continue; \n \n                     \n \n                    for (int y = other_y0; y <= other_y1; ++y) \n                    { \n                        for (int x = other_x0; x <= other_x1; ++x) \n                        { \n                            transfer_pixel(depth_pixel_index, y * other_intrin.width + x); \n                        } \n                    } \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "1f7b4ada7d6347bbc5ba959bdce4165935c9830ffdb8b2cc51cff4758022d292"}
{"code": "for (Index j = 0 ; j < n ; j++) \n                { \n                    int64_t jnz = 0 ; \n                    for (int64_t p = Ap [j] ; p < Ap [j+1] ; p++) \n                    { \n                        Index i = Ai [p] ; \n                        if (perm [i] > perm [j]) \n                        { \n                            jnz++ ; \n                        } \n                    } \n                    Sp [j] = jnz ; \n                }", "pragma": "parallel for ", "hash": "3dbce443366d1540d4284fc3722dce6e670331ab98336df5b2f1a61ea0390037"}
{"code": "for (i = 3; i < grid_points[0]-3; i++) { \n    for (j = 1; j < grid_points[1]-1; j++) { \n      for (k = 1; k < grid_points[2]-1; k++) { \n\tfor (m = 0; m < 5; m++) { \n\t  rhs[i][j][k][m] = rhs[i][j][k][m] - dssp *  \n\t    (  u[i-2][j][k][m] - 4.0*u[i-1][j][k][m] +  \n\t       6.0*u[i][j][k][m] - 4.0*u[i+1][j][k][m] +  \n\t       u[i+2][j][k][m] ); \n\t} \n      } \n    } \n  }", "pragma": "for private(j k m)", "hash": "4a71b57448d31db3d0c902cbc9ff5b7b64ecfb9adb25f19dc67eef9ffce36ab0"}
{"code": "for (i = 0; i < size; i++) { \n        \t    ((char *) rbuf)[i] = ((char *) sbuf)[i]; \n\t}", "pragma": "parallel for ", "hash": "12d85eecc07c2bc5ae5cceeb90988b7c0458c76b01068addc164ac48e3ca1240"}
{"code": "for(int i = 0; i < length; i++){ \n\t\t\tnorm += pow(x[i], type); \n\t\t}", "pragma": "parallel for reduction(+:norm) ", "hash": "1e39b555e0968810a3b19533cc0a19ab57b0cb637c1353fb02423e3502414cd0"}
{"code": "for ( i = 0; i < N ; i++ )  \n    { \n        x = x + vector[i]; \n        y = y * vector[i]; \n    }", "pragma": "parallel for reduction(+:x) reduction(*:y) ", "hash": "ed41ae5db329dde0b375e144f71f5e9187ec6290dde7c49bfe4bc84fb4d6d1f1"}
{"code": "for (i = 1; i < N + f; i++) \n      { \n #pragma omp atomic write \n\ta[i] = 1; \n #pragma omp ordered depend(sink: i - 1) \n\tif (i > 1) \n\t  { \n     #pragma omp atomic read \n\t    l = a[i - 1]; \n\t    if (l < 2) \n\t      abort (); \n\t  } \n #pragma omp atomic write \n\ta[i] = 2; \n\tif (i < N - 1) \n\t  { \n     #pragma omp atomic read \n\t    l = a[i + 1]; \n\t    if (l == 3) \n\t      abort (); \n\t  } \n #pragma omp ordered depend(source) \n #pragma omp atomic write \n\ta[i] = 3; \n      }", "pragma": "for ", "hash": "b1efcfc0f1af5d10a2ef25b57aaef07d67b1f2e64eac5b705cd931659440fa78"}
{"code": "for (i = 0; i < num_loaded_hashes; i++) { \n\t\tunsigned int idx = loaded_hashes_128[i].LO64 & (hash_table_size - 1); \n#pragma omp atomic \n\t\tcollisions[idx]++; \n\t}", "pragma": "for ", "hash": "cb48ba33f43b5f2c4ead855365f8ba7ebfe29a2436c37e1678279f57a576d64f"}
{"code": "for (i = 0; i < local_domain.ncells_active; i++) { \n         \n \n        sprintf(vic_run_ref_str, \"Gridcell io_idx: %zu, timestep info: %s\", \n                local_domain.locations[i].io_idx, dmy_str); \n \n        update_step_vars(&(all_vars[i]), veg_con[i], veg_hist[i]); \n \n        timer_start(&timer); \n        vic_run(&(force[i]), &(all_vars[i]), dmy_current, &global_param, \n                &lake_con, &(soil_con[i]), veg_con[i], veg_lib[i]); \n        timer_stop(&timer); \n \n        put_data(&(all_vars[i]), &(force[i]), &(soil_con[i]), veg_con[i], \n                 veg_lib[i], &lake_con, out_data[i], &(save_data[i]), \n                 &timer); \n    }", "pragma": "parallel for private(  i timer vic_run_ref_str)", "hash": "0af3b99c3722b669916f119381014ff2653d153e2a626aa7552a9b0dc21595be"}
{"code": "for(k=0;k<npol;k++)\t \n \n\t{ \n\t\tfor(i=ignore_edge_pixels;i<right_pixel_limit;i++) \n\t\t{ \n\t\t\tfor(j=ignore_edge_pixels;j<right_pixel_limit;j++)\t \n \n\t\t\t{ \n\t\t\t\tctr = i * imsize + j; \n\t\t\t\tt1 = (model_step[k][ctr]*model_step[k][ctr])/dx_dot_df; \n\t\t\t\tt2 = - pow(hessian[k][ctr] * grad_step[k][ctr], 2.0) / df_dot_hessian_dot_df; \n\t\t\t\tif(do_bfgs)\t \n \n\t\t\t\t{ \n\t\t\t\t\tu = (model_step[k][ctr]/dx_dot_df) - (hessian[k][ctr] * grad_step[k][ctr])/df_dot_hessian_dot_df; \n\t\t\t\t\tt3 = df_dot_hessian_dot_df * u * u; \n\t\t\t\t} \n\t\t\t\thessian[k][ctr] = hessian[k][ctr] + t1 + t2 +t3; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(       ctr i j k t1 t2 t3 u)", "hash": "ab754b33565c5db9415f979902ff6f321843cc69fde3c6586b62ed58acb72cad"}
{"code": "for (OMPInt i = 0; i < chunksize; ++i) \n      { \n        double x = xval[i]; \n        double y = yval[i]; \n        (*res)[i * ninterp + iterate] = gdl_interp2d_eval(interpolant, xa, ya, temp, x, y, accx, accy); \n      }", "pragma": "for ", "hash": "2c67f15004e51ac5cf5cd3a214e848f6a757e89f95ecaa3d44c335b7db31e52e"}
{"code": "for( i = 0 ; i < LCU ; i++ ) { \n    trace_ab_dag( &FFTW -> out[ i ] , slice_poly[ i ] , slice_poly[ i ] ) ; \n  }", "pragma": "parallel for private(i)", "hash": "530dafc242dba7e86c5f9aa5461ba3643af46f59273399be446621ef387df175"}
{"code": "for ( unsigned i = 0; i < N; i++ ) { \n\t\tmin = std::min(min, a[i]); \n\t\tmax = std::max(max, a[i]); \n\t}", "pragma": "parallel for reduction(: min std::min) reduction(: max std::max) ", "hash": "4e3f09316c4448f6f0c6e7f6ef98db1811f56202ad55e02037910dd9cf849e05"}
{"code": "for (auto e = slices.cbegin(); e < slices.cend(); ++e) { \n    UncompressedDecompressor decompressor(e->bs, mRaw); \n \n    iPoint2D tileSize(e->width, e->height); \n    iPoint2D pos(e->offX, e->offY); \n \n    bool big_endian = e->bs.getByteOrder() == Endianness::big; \n \n     \n \n    if (mBps != 8 && mBps != 16) \n      big_endian = true; \n \n    try { \n      const uint32_t inputPixelBits = mRaw->getCpp() * mBps; \n \n      if (e->dsc.tileW > std::numeric_limits<int>::max() / inputPixelBits) \n        ThrowIOE(\"Integer overflow when calculating input pitch\"); \n \n      const int inputPitchBits = inputPixelBits * e->dsc.tileW; \n      assert(inputPitchBits > 0); \n \n      if (inputPitchBits % 8 != 0) { \n        ThrowRDE(\"Bad combination of cpp (%u), bps (%u) and width (%u), the \" \n                 \"pitch is %u bits, which is not a multiple of 8 (1 byte)\", \n                 mRaw->getCpp(), mBps, e->width, inputPitchBits); \n      } \n \n      const int inputPitch = inputPitchBits / 8; \n      if (inputPitch == 0) \n        ThrowRDE(\"Data input pitch is too short. Can not decode!\"); \n \n      decompressor.readUncompressedRaw(tileSize, pos, inputPitch, mBps, \n                                       big_endian ? BitOrder_MSB \n                                                  : BitOrder_LSB); \n    } catch (RawDecoderException& err) { \n      mRaw->setError(err.what()); \n    } catch (IOException& err) { \n      mRaw->setError(err.what()); \n    } \n  }", "pragma": "for ", "hash": "6308eaef4dc9999f097ce85c1fef8b70ce3d61bfbc2fbd499e1f32fcd8ea48c2"}
{"code": "for (int c = 1; c <= grid.NCM; c++) \n\t\t{ \n\t\t\tfor (int index_i = 0; index_i <= grid.cells[c].geo.NF-1; index_i++) \n\t\t\t{ \n\t\t\t\tdouble S = 0.0; \n\t\t\t\tS = grid.cells[c].geo.face_list[index_i]->geo.S * Math::fabs<double>(grid.cells[c].geo.face_list[index_i]->geo.x[1]); \n \n\t\t\t\tfor (int k = 0; k <= grid.cells[c].geo.face_list[index_i]->data1D(0).numData-1; k++) \n\t\t\t\t{ \n\t\t\t\t\tdouble flux\t= grid.cells[c].geo.face_list[index_i]->data1D(0)(k) * S; \n \n\t\t\t\t\tif (grid.cells[c].geo.face_list[index_i]->geo.cr[0]->geo.ID == grid.cells[c].geo.ID) \n\t\t\t\t\t{ \n\t\t\t\t\t\tgrid.cells[c].data1D(indexResidue)(k)\t-= flux; \n\t\t\t\t\t} \n\t\t\t\t\telse if (grid.cells[c].geo.face_list[index_i]->geo.cl[0]->geo.ID == grid.cells[c].geo.ID) \n\t\t\t\t\t{ \n\t\t\t\t\t\tgrid.cells[c].data1D(indexResidue)(k)\t+= flux; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "339a70f4f5dfa17a873672323f92cb0dafde6610a2e9ad845fc5299fe446fd86"}
{"code": "for (i = 0; i < 4; i++) \n\t{ \n\t  if (a != 8 || b != 12 || e[0] != 'a' || f[0] != 'b') \n\t    j++; \n#pragma omp barrier  \n \n#pragma omp atomic \n\t  a += i; \n\t  b += i; \n\t  c = i; \n\t  d = i; \n#pragma omp atomic \n\t  e[0] += i; \n\t  f[0] += i; \n\t  g[0] = 'g' + i; \n\t  h[0] = 'h' + i; \n#pragma omp barrier  \n \n\t  if (a != 8 + 6 || b != 12 + i || c != i || d != i) \n\t    j += 8; \n\t  if (e[0] != 'a' + 6 || f[0] != 'b' + i || g[0] != 'g' + i) \n\t    j += 64; \n\t  if (h[0] != 'h' + i) \n\t    j += 512; \n\t}", "pragma": "parallel for reduction(+:j) private(   b c d f g h)", "hash": "4935af27645795ccaf24fc206f23ef802dfdabef29605dd53416337573c594a5"}
{"code": "for(int i=0; i < m_nLayers; i++) \n    { \n\t\tfor(int j=0; j < m_size; j++) \n\t\t{ \n\t\t\tm_pai[i][j] = 0.7f; \n\t\t    m_actMinP[i][j] = m_SoluP[i][j] * (1 - m_pai[i][j]) / m_pai[i][j]; \n\t\t\tm_staMinP[i][j] = 4 * m_actMinP[i][j]; \n            float r = m_actMinP[i][j] * m_pai[i][j] / (1 - m_pai[i][j]); \n\t\t    if(m_SoluP[i][j] > r) \n\t\t\t\tm_tSolActP[i][j] = 0.1f * (m_SoluP[i][j] - r); \n\t\t    else \n\t\t\t    m_tSolActP[i][j] = 0.6f * (m_SoluP[i][j] - r); \n\t\t \n\t\t    float r1 = 4 * m_actMinP[i][j] - m_staMinP[i][j]; \n\t\t    if(r1 > 0) \n\t\t\t    m_tStaActP[i][j] = m_sloER * r1; \n\t\t    else \n\t\t\t    m_tStaActP[i][j] = 0.1f * m_sloER * r1; \n \n\t\t\tm_SoluP[i][j] -= m_tSolActP[i][j]; \n\t\t\tm_actMinP[i][j] += m_tSolActP[i][j] - m_tStaActP[i][j]; \n\t\t\tm_staMinP[i][j] += m_tStaActP[i][j]; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "fbfc12b9a7fd18983546a32e347dc1dc4e8dabbf2075857461777c05a3f8f735"}
{"code": "for (i = 0; i < n; i++){ \n     Norm2  += c[i]*c[i]; \n  }", "pragma": "for ", "hash": "7710f4b1f63bfc31ad405e228a8d5839a21c70b0fad39654e1556314f6f4f6c4"}
{"code": "for (int i = 0; i < 10; ++i) \n  {}", "pragma": "parallel for private(fl)", "hash": "2b52bd4a1add5b0faca5f3f3d0ce22aad52de1a85e0450936d62ba7840c62af1"}
{"code": "for (int i = 0; i < height; i++) \n\t{ \n\t\tMat temp = buff(Rect(0, 12 * omp_get_thread_num(), width + 2 * R, 12)); \n \n\t\tfloat* tp_a_b0 = temp.ptr<float>(0, R); \n\t\tfloat* tp_a_g0 = temp.ptr<float>(1, R); \n\t\tfloat* tp_a_r0 = temp.ptr<float>(2, R); \n\t\tfloat* tp_b__0 = temp.ptr<float>(3, R); \n\t\tfloat* tp_a_b1 = temp.ptr<float>(4, R); \n\t\tfloat* tp_a_g1 = temp.ptr<float>(5, R); \n\t\tfloat* tp_a_r1 = temp.ptr<float>(6, R); \n\t\tfloat* tp_b__1 = temp.ptr<float>(7, R); \n\t\tfloat* tp_a_b2 = temp.ptr<float>(8, R); \n\t\tfloat* tp_a_g2 = temp.ptr<float>(9, R); \n\t\tfloat* tp_a_r2 = temp.ptr<float>(10, R); \n\t\tfloat* tp_b__2 = temp.ptr<float>(11, R); \n \n\t\tif (r <= i && i <= height - 1 - r) \n\t\t{ \n\t\t\tfor (int j = 0; j < width; j += 8) \n\t\t\t{ \n\t\t\t\tfloat* a_b0ptr = a_b[0].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_g0ptr = a_g[0].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_r0ptr = a_r[0].ptr<float>(i - r, j); \n\t\t\t\tfloat* b0ptr = b[0].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_b1ptr = a_b[1].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_g1ptr = a_g[1].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_r1ptr = a_r[1].ptr<float>(i - r, j); \n\t\t\t\tfloat* b1ptr = b[1].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_b2ptr = a_b[2].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_g2ptr = a_g[2].ptr<float>(i - r, j); \n\t\t\t\tfloat* a_r2ptr = a_r[2].ptr<float>(i - r, j); \n\t\t\t\tfloat* b2ptr = b[2].ptr<float>(i - r, j); \n \n\t\t\t\t__m256 mSum_ab0 = _mm256_load_ps(a_b0ptr); \n\t\t\t\t__m256 mSum_ag0 = _mm256_load_ps(a_g0ptr); \n\t\t\t\t__m256 mSum_ar0 = _mm256_load_ps(a_r0ptr); \n\t\t\t\t__m256 mSum_b0 = _mm256_load_ps(b0ptr); \n \n\t\t\t\t__m256 mSum_ab1 = _mm256_load_ps(a_b1ptr); \n\t\t\t\t__m256 mSum_ag1 = _mm256_load_ps(a_g1ptr); \n\t\t\t\t__m256 mSum_ar1 = _mm256_load_ps(a_r1ptr); \n\t\t\t\t__m256 mSum_b1 = _mm256_load_ps(b1ptr); \n \n\t\t\t\t__m256 mSum_ab2 = _mm256_load_ps(a_b2ptr); \n\t\t\t\t__m256 mSum_ag2 = _mm256_load_ps(a_g2ptr); \n\t\t\t\t__m256 mSum_ar2 = _mm256_load_ps(a_r2ptr); \n\t\t\t\t__m256 mSum_b2 = _mm256_load_ps(b2ptr); \n \n\t\t\t\ta_b0ptr += width; \n\t\t\t\ta_g0ptr += width; \n\t\t\t\ta_r0ptr += width; \n\t\t\t\tb0ptr += width; \n\t\t\t\ta_b1ptr += width; \n\t\t\t\ta_g1ptr += width; \n\t\t\t\ta_r1ptr += width; \n\t\t\t\tb1ptr += width; \n\t\t\t\ta_b2ptr += width; \n\t\t\t\ta_g2ptr += width; \n\t\t\t\ta_r2ptr += width; \n\t\t\t\tb2ptr += width; \n \n\t\t\t\tfor (int k = 0; k < d - 1; k++) \n\t\t\t\t{ \n\t\t\t\t\tmSum_ab0 = _mm256_add_ps(mSum_ab0, _mm256_load_ps(a_b0ptr)); \n\t\t\t\t\tmSum_ag0 = _mm256_add_ps(mSum_ag0, _mm256_load_ps(a_g0ptr)); \n\t\t\t\t\tmSum_ar0 = _mm256_add_ps(mSum_ar0, _mm256_load_ps(a_r0ptr)); \n\t\t\t\t\tmSum_b0 = _mm256_add_ps(mSum_b0, _mm256_load_ps(b0ptr)); \n \n\t\t\t\t\tmSum_ab1 = _mm256_add_ps(mSum_ab1, _mm256_load_ps(a_b1ptr)); \n\t\t\t\t\tmSum_ag1 = _mm256_add_ps(mSum_ag1, _mm256_load_ps(a_g1ptr)); \n\t\t\t\t\tmSum_ar1 = _mm256_add_ps(mSum_ar1, _mm256_load_ps(a_r1ptr)); \n\t\t\t\t\tmSum_b1 = _mm256_add_ps(mSum_b1, _mm256_load_ps(b1ptr)); \n \n\t\t\t\t\tmSum_ab2 = _mm256_add_ps(mSum_ab2, _mm256_load_ps(a_b2ptr)); \n\t\t\t\t\tmSum_ag2 = _mm256_add_ps(mSum_ag2, _mm256_load_ps(a_g2ptr)); \n\t\t\t\t\tmSum_ar2 = _mm256_add_ps(mSum_ar2, _mm256_load_ps(a_r2ptr)); \n\t\t\t\t\tmSum_b2 = _mm256_add_ps(mSum_b2, _mm256_load_ps(b2ptr)); \n \n\t\t\t\t\ta_b0ptr += width; \n\t\t\t\t\ta_g0ptr += width; \n\t\t\t\t\ta_r0ptr += width; \n\t\t\t\t\tb0ptr += width; \n\t\t\t\t\ta_b1ptr += width; \n\t\t\t\t\ta_g1ptr += width; \n\t\t\t\t\ta_r1ptr += width; \n\t\t\t\t\tb1ptr += width; \n\t\t\t\t\ta_b2ptr += width; \n\t\t\t\t\ta_g2ptr += width; \n\t\t\t\t\ta_r2ptr += width; \n\t\t\t\t\tb2ptr += width; \n\t\t\t\t} \n \n\t\t\t\t_mm256_store_ps(tp_a_b0, mSum_ab0); \n\t\t\t\t_mm256_store_ps(tp_a_g0, mSum_ag0); \n\t\t\t\t_mm256_store_ps(tp_a_r0, mSum_ar0); \n\t\t\t\t_mm256_store_ps(tp_b__0, mSum_b0); \n \n\t\t\t\t_mm256_store_ps(tp_a_b1, mSum_ab1); \n\t\t\t\t_mm256_store_ps(tp_a_g1, mSum_ag1); \n\t\t\t\t_mm256_store_ps(tp_a_r1, mSum_ar1); \n\t\t\t\t_mm256_store_ps(tp_b__1, mSum_b1); \n \n\t\t\t\t_mm256_store_ps(tp_a_b2, mSum_ab2); \n\t\t\t\t_mm256_store_ps(tp_a_g2, mSum_ag2); \n\t\t\t\t_mm256_store_ps(tp_a_r2, mSum_ar2); \n\t\t\t\t_mm256_store_ps(tp_b__2, mSum_b2); \n \n\t\t\t\ttp_a_b0 += 8; \n\t\t\t\ttp_a_g0 += 8; \n\t\t\t\ttp_a_r0 += 8; \n\t\t\t\ttp_b__0 += 8; \n \n\t\t\t\ttp_a_b1 += 8; \n\t\t\t\ttp_a_g1 += 8; \n\t\t\t\ttp_a_r1 += 8; \n\t\t\t\ttp_b__1 += 8; \n \n\t\t\t\ttp_a_b2 += 8; \n\t\t\t\ttp_a_g2 += 8; \n\t\t\t\ttp_a_r2 += 8; \n\t\t\t\ttp_b__2 += 8; \n\t\t\t} \n \n\t\t\tcopyMakeBorderReplicateForLineBuffers(temp, R); \n \n\t\t\tfloat* guideptr_0 = guide[0].ptr<float>(i); \n\t\t\tfloat* guideptr_1 = guide[1].ptr<float>(i); \n\t\t\tfloat* guideptr_2 = guide[2].ptr<float>(i); \n\t\t\tfloat* dptr0 = dest[0].ptr<float>(i); \n\t\t\tfloat* dptr1 = dest[1].ptr<float>(i); \n\t\t\tfloat* dptr2 = dest[2].ptr<float>(i); \n \n\t\t\ttp_a_b0 = temp.ptr<float>(0, roffset); \n\t\t\ttp_a_g0 = temp.ptr<float>(1, roffset); \n\t\t\ttp_a_r0 = temp.ptr<float>(2, roffset); \n\t\t\ttp_b__0 = temp.ptr<float>(3, roffset); \n\t\t\ttp_a_b1 = temp.ptr<float>(4, roffset); \n\t\t\ttp_a_g1 = temp.ptr<float>(5, roffset); \n\t\t\ttp_a_r1 = temp.ptr<float>(6, roffset); \n\t\t\ttp_b__1 = temp.ptr<float>(7, roffset); \n\t\t\ttp_a_b2 = temp.ptr<float>(8, roffset); \n\t\t\ttp_a_g2 = temp.ptr<float>(9, roffset); \n\t\t\ttp_a_r2 = temp.ptr<float>(10, roffset); \n\t\t\ttp_b__2 = temp.ptr<float>(11, roffset); \n \n\t\t\tfor (int j = 0; j < width; j += 8) \n\t\t\t{ \n\t\t\t\t__m256 mSum_a_b0 = _mm256_loadu_ps(tp_a_b0); \n\t\t\t\t__m256 mSum_a_g0 = _mm256_loadu_ps(tp_a_g0); \n\t\t\t\t__m256 mSum_a_r0 = _mm256_loadu_ps(tp_a_r0); \n\t\t\t\t__m256 mSum_b__0 = _mm256_loadu_ps(tp_b__0); \n \n\t\t\t\t__m256 mSum_a_b1 = _mm256_loadu_ps(tp_a_b1); \n\t\t\t\t__m256 mSum_a_g1 = _mm256_loadu_ps(tp_a_g1); \n\t\t\t\t__m256 mSum_a_r1 = _mm256_loadu_ps(tp_a_r1); \n\t\t\t\t__m256 mSum_b__1 = _mm256_loadu_ps(tp_b__1); \n \n\t\t\t\t__m256 mSum_a_b2 = _mm256_loadu_ps(tp_a_b2); \n\t\t\t\t__m256 mSum_a_g2 = _mm256_loadu_ps(tp_a_g2); \n\t\t\t\t__m256 mSum_a_r2 = _mm256_loadu_ps(tp_a_r2); \n\t\t\t\t__m256 mSum_b__2 = _mm256_loadu_ps(tp_b__2); \n \n\t\t\t\tfor (int k = 1; k < d; k++) \n\t\t\t\t{ \n\t\t\t\t\tmSum_a_b0 = _mm256_add_ps(mSum_a_b0, _mm256_loadu_ps(tp_a_b0 + k)); \n\t\t\t\t\tmSum_a_g0 = _mm256_add_ps(mSum_a_g0, _mm256_loadu_ps(tp_a_g0 + k)); \n\t\t\t\t\tmSum_a_r0 = _mm256_add_ps(mSum_a_r0, _mm256_loadu_ps(tp_a_r0 + k)); \n\t\t\t\t\tmSum_b__0 = _mm256_add_ps(mSum_b__0, _mm256_loadu_ps(tp_b__0 + k)); \n \n\t\t\t\t\tmSum_a_b1 = _mm256_add_ps(mSum_a_b1, _mm256_loadu_ps(tp_a_b1 + k)); \n\t\t\t\t\tmSum_a_g1 = _mm256_add_ps(mSum_a_g1, _mm256_loadu_ps(tp_a_g1 + k)); \n\t\t\t\t\tmSum_a_r1 = _mm256_add_ps(mSum_a_r1, _mm256_loadu_ps(tp_a_r1 + k)); \n\t\t\t\t\tmSum_b__1 = _mm256_add_ps(mSum_b__1, _mm256_loadu_ps(tp_b__1 + k)); \n \n\t\t\t\t\tmSum_a_b2 = _mm256_add_ps(mSum_a_b2, _mm256_loadu_ps(tp_a_b2 + k)); \n\t\t\t\t\tmSum_a_g2 = _mm256_add_ps(mSum_a_g2, _mm256_loadu_ps(tp_a_g2 + k)); \n\t\t\t\t\tmSum_a_r2 = _mm256_add_ps(mSum_a_r2, _mm256_loadu_ps(tp_a_r2 + k)); \n\t\t\t\t\tmSum_b__2 = _mm256_add_ps(mSum_b__2, _mm256_loadu_ps(tp_b__2 + k)); \n\t\t\t\t} \n \n\t\t\t\t__m256 v = _mm256_mul_ps(mSum_b__0, mDiv); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_0), _mm256_mul_ps(mSum_a_b0, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_1), _mm256_mul_ps(mSum_a_g0, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_2), _mm256_mul_ps(mSum_a_r0, mDiv), v); \n\t\t\t\t_mm256_store_ps(dptr0, v); \n \n\t\t\t\tv = _mm256_mul_ps(mSum_b__1, mDiv); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_0), _mm256_mul_ps(mSum_a_b1, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_1), _mm256_mul_ps(mSum_a_g1, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_2), _mm256_mul_ps(mSum_a_r1, mDiv), v); \n\t\t\t\t_mm256_store_ps(dptr1, v); \n \n\t\t\t\tv = _mm256_mul_ps(mSum_b__2, mDiv); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_0), _mm256_mul_ps(mSum_a_b2, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_1), _mm256_mul_ps(mSum_a_g2, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_2), _mm256_mul_ps(mSum_a_r2, mDiv), v); \n\t\t\t\t_mm256_store_ps(dptr2, v); \n \n\t\t\t\ttp_a_b0 += 8; \n\t\t\t\ttp_a_g0 += 8; \n\t\t\t\ttp_a_r0 += 8; \n\t\t\t\ttp_b__0 += 8; \n\t\t\t\ttp_a_b1 += 8; \n\t\t\t\ttp_a_g1 += 8; \n\t\t\t\ttp_a_r1 += 8; \n\t\t\t\ttp_b__1 += 8; \n\t\t\t\ttp_a_b2 += 8; \n\t\t\t\ttp_a_g2 += 8; \n\t\t\t\ttp_a_r2 += 8; \n\t\t\t\ttp_b__2 += 8; \n\t\t\t\tguideptr_0 += 8; \n\t\t\t\tguideptr_1 += 8; \n\t\t\t\tguideptr_2 += 8; \n\t\t\t\tdptr0 += 8; \n\t\t\t\tdptr1 += 8; \n\t\t\t\tdptr2 += 8; \n\t\t\t} \n\t\t} \n\t\telse \n\t\t{ \n\t\t\tfor (int j = 0; j < width; j += 8) \n\t\t\t{ \n\t\t\t\t__m256 mSum_ab0 = _mm256_load_ps(a_b[0].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_ag0 = _mm256_load_ps(a_g[0].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_ar0 = _mm256_load_ps(a_r[0].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_b0 = _mm256_load_ps(b[0].ptr<float>(i, j)); \n \n\t\t\t\t__m256 mSum_ab1 = _mm256_load_ps(a_b[1].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_ag1 = _mm256_load_ps(a_g[1].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_ar1 = _mm256_load_ps(a_r[1].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_b1 = _mm256_load_ps(b[1].ptr<float>(i, j)); \n \n\t\t\t\t__m256 mSum_ab2 = _mm256_load_ps(a_b[2].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_ag2 = _mm256_load_ps(a_g[2].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_ar2 = _mm256_load_ps(a_r[2].ptr<float>(i, j)); \n\t\t\t\t__m256 mSum_b2 = _mm256_load_ps(b[2].ptr<float>(i, j)); \n\t\t\t\tfor (int k = 1; k <= r; k++) \n\t\t\t\t{ \n\t\t\t\t\tint vl = max(i - k, 0); \n\t\t\t\t\tint vh = min(i + k, height - 1); \n \n\t\t\t\t\tfloat* sp1 = a_b[0].ptr<float>(vl, j); \n\t\t\t\t\tfloat* sp2 = a_b[0].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ab0 = _mm256_add_ps(mSum_ab0, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ab0 = _mm256_add_ps(mSum_ab0, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_g[0].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_g[0].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ag0 = _mm256_add_ps(mSum_ag0, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ag0 = _mm256_add_ps(mSum_ag0, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_r[0].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_r[0].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ar0 = _mm256_add_ps(mSum_ar0, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ar0 = _mm256_add_ps(mSum_ar0, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = b[0].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = b[0].ptr<float>(vh, j); \n\t\t\t\t\tmSum_b0 = _mm256_add_ps(mSum_b0, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_b0 = _mm256_add_ps(mSum_b0, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_b[1].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_b[1].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ab1 = _mm256_add_ps(mSum_ab1, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ab1 = _mm256_add_ps(mSum_ab1, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_g[1].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_g[1].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ag1 = _mm256_add_ps(mSum_ag1, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ag1 = _mm256_add_ps(mSum_ag1, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_r[1].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_r[1].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ar1 = _mm256_add_ps(mSum_ar1, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ar1 = _mm256_add_ps(mSum_ar1, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = b[1].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = b[1].ptr<float>(vh, j); \n\t\t\t\t\tmSum_b1 = _mm256_add_ps(mSum_b1, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_b1 = _mm256_add_ps(mSum_b1, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_b[2].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_b[2].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ab2 = _mm256_add_ps(mSum_ab2, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ab2 = _mm256_add_ps(mSum_ab2, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_g[2].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_g[2].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ag2 = _mm256_add_ps(mSum_ag2, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ag2 = _mm256_add_ps(mSum_ag2, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = a_r[2].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = a_r[2].ptr<float>(vh, j); \n\t\t\t\t\tmSum_ar2 = _mm256_add_ps(mSum_ar2, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_ar2 = _mm256_add_ps(mSum_ar2, _mm256_load_ps(sp2)); \n \n\t\t\t\t\tsp1 = b[2].ptr<float>(vl, j); \n\t\t\t\t\tsp2 = b[2].ptr<float>(vh, j); \n\t\t\t\t\tmSum_b2 = _mm256_add_ps(mSum_b2, _mm256_load_ps(sp1)); \n\t\t\t\t\tmSum_b2 = _mm256_add_ps(mSum_b2, _mm256_load_ps(sp2)); \n\t\t\t\t} \n \n\t\t\t\t_mm256_store_ps(tp_a_b0, mSum_ab0); \n\t\t\t\t_mm256_store_ps(tp_a_g0, mSum_ag0); \n\t\t\t\t_mm256_store_ps(tp_a_r0, mSum_ar0); \n\t\t\t\t_mm256_store_ps(tp_b__0, mSum_b0); \n \n\t\t\t\t_mm256_store_ps(tp_a_b1, mSum_ab1); \n\t\t\t\t_mm256_store_ps(tp_a_g1, mSum_ag1); \n\t\t\t\t_mm256_store_ps(tp_a_r1, mSum_ar1); \n\t\t\t\t_mm256_store_ps(tp_b__1, mSum_b1); \n \n\t\t\t\t_mm256_store_ps(tp_a_b2, mSum_ab2); \n\t\t\t\t_mm256_store_ps(tp_a_g2, mSum_ag2); \n\t\t\t\t_mm256_store_ps(tp_a_r2, mSum_ar2); \n\t\t\t\t_mm256_store_ps(tp_b__2, mSum_b2); \n \n\t\t\t\ttp_a_b0 += 8; \n\t\t\t\ttp_a_g0 += 8; \n\t\t\t\ttp_a_r0 += 8; \n\t\t\t\ttp_b__0 += 8; \n \n\t\t\t\ttp_a_b1 += 8; \n\t\t\t\ttp_a_g1 += 8; \n\t\t\t\ttp_a_r1 += 8; \n\t\t\t\ttp_b__1 += 8; \n \n\t\t\t\ttp_a_b2 += 8; \n\t\t\t\ttp_a_g2 += 8; \n\t\t\t\ttp_a_r2 += 8; \n\t\t\t\ttp_b__2 += 8; \n\t\t\t} \n \n\t\t\tcopyMakeBorderReplicateForLineBuffers(temp, R); \n \n\t\t\tfloat* guideptr_0 = guide[0].ptr<float>(i); \n\t\t\tfloat* guideptr_1 = guide[1].ptr<float>(i); \n\t\t\tfloat* guideptr_2 = guide[2].ptr<float>(i); \n\t\t\tfloat* dptr0 = dest[0].ptr<float>(i); \n\t\t\tfloat* dptr1 = dest[1].ptr<float>(i); \n\t\t\tfloat* dptr2 = dest[2].ptr<float>(i); \n \n\t\t\ttp_a_b0 = temp.ptr<float>(0, roffset); \n\t\t\ttp_a_g0 = temp.ptr<float>(1, roffset); \n\t\t\ttp_a_r0 = temp.ptr<float>(2, roffset); \n\t\t\ttp_b__0 = temp.ptr<float>(3, roffset); \n\t\t\ttp_a_b1 = temp.ptr<float>(4, roffset); \n\t\t\ttp_a_g1 = temp.ptr<float>(5, roffset); \n\t\t\ttp_a_r1 = temp.ptr<float>(6, roffset); \n\t\t\ttp_b__1 = temp.ptr<float>(7, roffset); \n\t\t\ttp_a_b2 = temp.ptr<float>(8, roffset); \n\t\t\ttp_a_g2 = temp.ptr<float>(9, roffset); \n\t\t\ttp_a_r2 = temp.ptr<float>(10, roffset); \n\t\t\ttp_b__2 = temp.ptr<float>(11, roffset); \n \n\t\t\tfor (int j = 0; j < width; j += 8) \n\t\t\t{ \n\t\t\t\t__m256 mSum_a_b0 = _mm256_loadu_ps(tp_a_b0 + r); \n\t\t\t\t__m256 mSum_a_g0 = _mm256_loadu_ps(tp_a_g0 + r); \n\t\t\t\t__m256 mSum_a_r0 = _mm256_loadu_ps(tp_a_r0 + r); \n\t\t\t\t__m256 mSum_b__0 = _mm256_loadu_ps(tp_b__0 + r); \n \n\t\t\t\t__m256 mSum_a_b1 = _mm256_loadu_ps(tp_a_b1 + r); \n\t\t\t\t__m256 mSum_a_g1 = _mm256_loadu_ps(tp_a_g1 + r); \n\t\t\t\t__m256 mSum_a_r1 = _mm256_loadu_ps(tp_a_r1 + r); \n\t\t\t\t__m256 mSum_b__1 = _mm256_loadu_ps(tp_b__1 + r); \n \n\t\t\t\t__m256 mSum_a_b2 = _mm256_loadu_ps(tp_a_b2 + r); \n\t\t\t\t__m256 mSum_a_g2 = _mm256_loadu_ps(tp_a_g2 + r); \n\t\t\t\t__m256 mSum_a_r2 = _mm256_loadu_ps(tp_a_r2 + r); \n\t\t\t\t__m256 mSum_b__2 = _mm256_loadu_ps(tp_b__2 + r); \n\t\t\t\tfor (int k = 1; k <= r; k++) \n\t\t\t\t{ \n\t\t\t\t\tmSum_a_b0 = _mm256_add_ps(mSum_a_b0, _mm256_loadu_ps(tp_a_b0 - k + r)); \n\t\t\t\t\tmSum_a_b0 = _mm256_add_ps(mSum_a_b0, _mm256_loadu_ps(tp_a_b0 + k + r)); \n\t\t\t\t\tmSum_a_g0 = _mm256_add_ps(mSum_a_g0, _mm256_loadu_ps(tp_a_g0 - k + r)); \n\t\t\t\t\tmSum_a_g0 = _mm256_add_ps(mSum_a_g0, _mm256_loadu_ps(tp_a_g0 + k + r)); \n\t\t\t\t\tmSum_a_r0 = _mm256_add_ps(mSum_a_r0, _mm256_loadu_ps(tp_a_r0 - k + r)); \n\t\t\t\t\tmSum_a_r0 = _mm256_add_ps(mSum_a_r0, _mm256_loadu_ps(tp_a_r0 + k + r)); \n\t\t\t\t\tmSum_b__0 = _mm256_add_ps(mSum_b__0, _mm256_loadu_ps(tp_b__0 - k + r)); \n\t\t\t\t\tmSum_b__0 = _mm256_add_ps(mSum_b__0, _mm256_loadu_ps(tp_b__0 + k + r)); \n \n\t\t\t\t\tmSum_a_b1 = _mm256_add_ps(mSum_a_b1, _mm256_loadu_ps(tp_a_b1 - k + r)); \n\t\t\t\t\tmSum_a_b1 = _mm256_add_ps(mSum_a_b1, _mm256_loadu_ps(tp_a_b1 + k + r)); \n\t\t\t\t\tmSum_a_g1 = _mm256_add_ps(mSum_a_g1, _mm256_loadu_ps(tp_a_g1 - k + r)); \n\t\t\t\t\tmSum_a_g1 = _mm256_add_ps(mSum_a_g1, _mm256_loadu_ps(tp_a_g1 + k + r)); \n\t\t\t\t\tmSum_a_r1 = _mm256_add_ps(mSum_a_r1, _mm256_loadu_ps(tp_a_r1 - k + r)); \n\t\t\t\t\tmSum_a_r1 = _mm256_add_ps(mSum_a_r1, _mm256_loadu_ps(tp_a_r1 + k + r)); \n\t\t\t\t\tmSum_b__1 = _mm256_add_ps(mSum_b__1, _mm256_loadu_ps(tp_b__1 - k + r)); \n\t\t\t\t\tmSum_b__1 = _mm256_add_ps(mSum_b__1, _mm256_loadu_ps(tp_b__1 + k + r)); \n \n\t\t\t\t\tmSum_a_b2 = _mm256_add_ps(mSum_a_b2, _mm256_loadu_ps(tp_a_b2 - k + r)); \n\t\t\t\t\tmSum_a_b2 = _mm256_add_ps(mSum_a_b2, _mm256_loadu_ps(tp_a_b2 + k + r)); \n\t\t\t\t\tmSum_a_g2 = _mm256_add_ps(mSum_a_g2, _mm256_loadu_ps(tp_a_g2 - k + r)); \n\t\t\t\t\tmSum_a_g2 = _mm256_add_ps(mSum_a_g2, _mm256_loadu_ps(tp_a_g2 + k + r)); \n\t\t\t\t\tmSum_a_r2 = _mm256_add_ps(mSum_a_r2, _mm256_loadu_ps(tp_a_r2 - k + r)); \n\t\t\t\t\tmSum_a_r2 = _mm256_add_ps(mSum_a_r2, _mm256_loadu_ps(tp_a_r2 + k + r)); \n\t\t\t\t\tmSum_b__2 = _mm256_add_ps(mSum_b__2, _mm256_loadu_ps(tp_b__2 - k + r)); \n\t\t\t\t\tmSum_b__2 = _mm256_add_ps(mSum_b__2, _mm256_loadu_ps(tp_b__2 + k + r)); \n\t\t\t\t} \n \n\t\t\t\t__m256 v = _mm256_mul_ps(mSum_b__0, mDiv); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_0), _mm256_mul_ps(mSum_a_b0, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_1), _mm256_mul_ps(mSum_a_g0, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_2), _mm256_mul_ps(mSum_a_r0, mDiv), v); \n\t\t\t\t_mm256_store_ps(dptr0, v); \n \n\t\t\t\tv = _mm256_mul_ps(mSum_b__1, mDiv); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_0), _mm256_mul_ps(mSum_a_b1, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_1), _mm256_mul_ps(mSum_a_g1, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_2), _mm256_mul_ps(mSum_a_r1, mDiv), v); \n\t\t\t\t_mm256_store_ps(dptr1, v); \n \n\t\t\t\tv = _mm256_mul_ps(mSum_b__2, mDiv); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_0), _mm256_mul_ps(mSum_a_b2, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_1), _mm256_mul_ps(mSum_a_g2, mDiv), v); \n\t\t\t\tv = _mm256_fmadd_ps(_mm256_load_ps(guideptr_2), _mm256_mul_ps(mSum_a_r2, mDiv), v); \n\t\t\t\t_mm256_store_ps(dptr2, v); \n \n\t\t\t\ttp_a_b0 += 8; \n\t\t\t\ttp_a_g0 += 8; \n\t\t\t\ttp_a_r0 += 8; \n\t\t\t\ttp_b__0 += 8; \n\t\t\t\ttp_a_b1 += 8; \n\t\t\t\ttp_a_g1 += 8; \n\t\t\t\ttp_a_r1 += 8; \n\t\t\t\ttp_b__1 += 8; \n\t\t\t\ttp_a_b2 += 8; \n\t\t\t\ttp_a_g2 += 8; \n\t\t\t\ttp_a_r2 += 8; \n\t\t\t\ttp_b__2 += 8; \n\t\t\t\tguideptr_0 += 8; \n\t\t\t\tguideptr_1 += 8; \n\t\t\t\tguideptr_2 += 8; \n\t\t\t\tdptr0 += 8; \n\t\t\t\tdptr1 += 8; \n\t\t\t\tdptr2 += 8; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "0c3b7ac0787f5663556e5cd8ea0d749eb0f5514b49a8f38aec923ef5e88b8b12"}
{"code": "for (it = m_SimulationSetup->CompTable()->constBegin();it != m_SimulationSetup->CompTable()->constEnd(); ++it) { \n\t\t\t\tit.value()->pre(); \n\t\t\t\tit.value()->step(i, i / frequency); \n\t\t\t}", "pragma": "for private(it)", "hash": "3be09042691372b5e942d5095228be711367a8be6b3a06850905b1722a5b1b54"}
{"code": "for (int t = 0; t < tc; t++) \n\t{  \n\t\tconst SpectralCtfCost& scc = tileCosts[t]; \n\t\t \n\t\tconst int ti = omp_get_thread_num(); \n\t\t \n\t\tx_tile[ti][0] = scc.offsetDefocusParam(x[0], hand * tileOffZ[t]); \n\t\t\t\t \n\t\tfor (int i = 1; i < 5; i++) \n\t\t{ \n\t\t\tx_tile[ti][i] = x[i]; \n\t\t} \n\t\t  \n\t\tx_tile[ti][5] = x[5 + t]; \n\t\t \n\t\tscc.grad(x_tile[ti], grad_par_tile[ti], tempStorage); \n\t\t \n\t\tfor (int i = 0; i < 5; i++) \n\t\t{ \n\t\t\tgrad_par_out[ti][i] += grad_par_tile[ti][i]; \n\t\t} \n\t\t  \n\t\tgrad_par_out[ti][5 + t] += grad_par_tile[ti][5]; \n\t}", "pragma": "parallel for ", "hash": "22184f5d3088ffe774ccdd0aa2e9c5c5a99c7484226295819b31785a97557b5c"}
{"code": "for (int j = 0; j < num_data_; ++j) { \n        for (i = k; i < dword_features_; ++i) { \n           \n \n          host4[j].s[i] = j; \n        } \n      }", "pragma": "parallel for ", "hash": "cc39583047f3e2aaba1bba53a13a23ab5314fa3584332fcb028dbebcba09e204"}
{"code": "for (i=0; i<sizeofBuffer; i++){ \n            finalRightBuf[i] = rightRecvBuf[i]; \n            finalLeftBuf[i] = leftRecvBuf[i]; \n        }", "pragma": "parallel for private(i)", "hash": "8fd69248d7e9e01669cf768e737abeae000cb06e9e68f9b9861cba9659de2109"}
{"code": "for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MAX(dest[index], mask); \n    }", "pragma": "parallel for ", "hash": "d769a91f21a907ffcd880bf18a958ddcb9a21975bc2be6105c5a56cad45eef4a"}
{"code": "for (int i = 0; i < n; i++) \n        { \n#pragma omp parallel for \n            for (int j = 0; j < n; j++) \n            { \n                s = 0.0; \n                for (int k = 0; k < n; k++) \n                { \n                    s = s + a[i + k*lda] * b[k + j*ldb]; \n                } \n                c[i + j*ldc] = s; \n            } \n        }", "pragma": "parallel for ", "hash": "1e880a70a71e310a4bd5d41c05131179aede0a83122a4d710aee8d493cbb6323"}
{"code": "for (ii=0; ii < ndata; ii++){ \n    tid= omp_get_thread_num(); \n    tid = 0; \n    if ( *(umin+ii) == -9999.99 || *(umax+ii) == -9999.99 ){ \n      *(jr+ii)= 9999.99; \n      continue; \n    } \n    if ( (*(umax+ii) - *(umin+ii)) / *(umax+ii) < 0.000001 ){ \n \n      *(jr+ii) = 0.; \n      continue; \n    } \n     \n \n    (params+tid)->E= *(E+ii); \n    (params+tid)->Lz22delta= 0.5 * *(Lz+ii) * *(Lz+ii) / delta / delta; \n    (params+tid)->I3U= *(I3U+ii); \n    (params+tid)->u0= *(u0+ii); \n    (params+tid)->sinh2u0= *(sinh2u0+ii); \n    (params+tid)->v0= *(v0+ii); \n    (params+tid)->sin2v0= *(sin2v0+ii); \n    (params+tid)->potu0v0= *(potu0v0+ii); \n    (JRInt+tid)->function = &JRStaeckelIntegrand; \n    (JRInt+tid)->params = params+tid; \n     \n \n    *(jr+ii)= gsl_integration_glfixed (JRInt+tid,*(umin+ii),*(umax+ii),T) \n      * sqrt(2.) * delta / M_PI; \n  }", "pragma": "parallel for private(ii tid)", "hash": "74b951233d6fa6b28a170e435e663bf2868c565f845cccd14530042df9cc634b"}
{"code": "for (unsigned long int i=0; i<m_ampClass->T3_elements_A_new.size(); i++){ \n                m_ampClass->T3_elements_A_new[i] *= m_ampClass->denom3_elements[i]; \n            }", "pragma": "parallel for ", "hash": "b55fa6ff25e6210c78a88fa7877d32fa62addfe191d2733de60cfe74b6ef7219"}
{"code": "for(i = 0; i < n; i++) { \n    j = list[i]; \n    f[j][0] += buf[3 * i]; \n    f[j][1] += buf[3 * i + 1]; \n    f[j][2] += buf[3 * i + 2]; \n  }", "pragma": "for ", "hash": "84c1a89fde1c133f02bc628d701cf3b093b5fc65e6da007e8090a3006140a3ab"}
{"code": "for ( size_t i = 0; i < uKeys->size(); ++i){ \n\t\t\tstd::pair<L,U> r = ( (ImapByKeyG2FunctionP<K,L,U>) func)  \n\t\t\t\t( (*uKeys)[i],  \n\t\t\t\t  (*keyLocations[0])[i],  \n\t\t\t\t  (*keyLocations[1])[i] ); \n\t\t\tok[i] = r.first; \n\t\t\tod[i] = r.second; \n \n\t\t}", "pragma": "parallel for ", "hash": "05428daff24d2bce43cc3d2344129c3f922627a41853352af50269c0dad75b35"}
{"code": "for (i=0; i < (ssize_t) image->colors; i++) \n    { \n       \n \n      if ((channel & RedChannel) != 0) \n        image->colormap[i].red=LevelQuantum(image->colormap[i].red); \n      if ((channel & GreenChannel) != 0) \n        image->colormap[i].green=LevelQuantum(image->colormap[i].green); \n      if ((channel & BlueChannel) != 0) \n        image->colormap[i].blue=LevelQuantum(image->colormap[i].blue); \n      if ((channel & OpacityChannel) != 0) \n        image->colormap[i].opacity=LevelQuantum(image->colormap[i].opacity); \n      }", "pragma": "parallel for ", "hash": "122295558d78b402b825f9a032e9ff2fe781721ff43fc60dae3f9ad3101be335"}
{"code": "for (i=0; i<N; i++){ \n\t\t\t\tfor (j=0; j<N; j++){\t \n\t\t\t\t\ttmp = 0; \n\t\t\t\t\tfor (k=0; k<N; k++){ \n \n\t\t\t\t\t\ttmp += a[i][k] * b[j][k]; \n\t\t\t\t\t} \n\t\t\t\t\tc[i][j] = tmp; \n\t\t  \t\t} \n\t\t\t}", "pragma": "for ", "hash": "0358cd15ae3e4e25ffd8e17b89583f99f0e9dbfef580555d46501c2d264d41e6"}
{"code": "for (i = 0; i < nelem; i++) \n    { \n        int             kz; \n \n         \n \n        elem[i].daily.avg_sfctmp += elem[i].es.sfctmp; \n        elem[i].daily.tmax = MAX(elem[i].daily.tmax, elem[i].es.sfctmp); \n        elem[i].daily.tmin = MIN(elem[i].daily.tmin, elem[i].es.sfctmp); \n \n         \n \n        for (kz = 0; kz < elem[i].ps.nlayers; kz++) \n        { \n            elem[i].daily.avg_stc[kz] += elem[i].es.stc[kz]; \n            elem[i].daily.avg_sh2o[kz] += elem[i].ws.swc[kz]; \n        } \n \n        if (elem[i].ef.soldn > 0.0) \n        { \n            elem[i].daily.tday += elem[i].es.sfctmp; \n            elem[i].daily.avg_q2d += elem[i].ps.q2sat - elem[i].ps.q2; \n            elem[i].daily.avg_ch += elem[i].ps.ch; \n            elem[i].daily.avg_rc += elem[i].ps.rc; \n            elem[i].daily.avg_sfcprs += elem[i].ps.sfcprs; \n            elem[i].daily.avg_albedo += elem[i].ps.albedo; \n            elem[i].daily.avg_soldn += elem[i].ef.soldn; \n            (elem[i].daily.daylight_counter)++; \n        } \n        else \n        { \n            elem[i].daily.tnight += elem[i].es.sfctmp; \n        } \n \n        (elem[i].daily.counter)++; \n    }", "pragma": "parallel for ", "hash": "4bc937c236bc69e49376013fa6e174e9262c66e16077e81d3b71c19684419d7b"}
{"code": "for ( cid = 0 ; cid < s->nr_real ; cid++ ) { \n            c = &(s->cells[s->cid_real[cid]]); \n            if ( c->oldx == NULL || c->oldx_size < c->count ) { \n                free(c->oldx); \n                c->oldx_size = c->size + 20; \n                c->oldx = (FPTYPE *)malloc( sizeof(FPTYPE) * 4 * c->oldx_size ); \n                } \n            for ( pid = 0 ; pid < c->count ; pid++ ) { \n                p = &(c->parts[pid]); \n                for ( k = 0 ; k < 3 ; k++ ) \n                    c->oldx[ 4*pid + k ] = p->x[k]; \n                } \n            }", "pragma": "parallel for private(c cid k p pid)", "hash": "8b13b9997fb7cf03fedf105a72059bbbd0816177a70ec45d5129696d1ffe321e"}
{"code": "for (j = 0; j < row; j++) { \n            sum = 0.0f; \n            for (i = 0; i < col; i++) { \n                size_t index = j * col + i; \n                sum += in_tensor[index]; \n            } \n            out_tensor[j] = sum; \n        }", "pragma": "parallel for private(j)", "hash": "931547a11025521254432d5618e1864adecea65d0f5f1ad4ae504e214e7d7fb9"}
{"code": "for(C=0;C<N;C++){ \n\ttermo_coluna[C] = B[0*N+C] * B[1*N+C]; \n\tfor(K=1;K<P;K++) \n\t\ttermo_coluna[C] += B[2*K*N+C] * B[(2*K+1)*N+C]; \n}", "pragma": "parallel for private(c k p)", "hash": "dff1b60ecf4385aa36af80af6d781c331c79c98a4aa60b87a99d75acb52ff53c"}
{"code": "for (int i = 0; i < numAggregates; i++) { \n        int **intArrays = new int *[maxIntArrays]; \n \n        double **arguments = helper.getArguments(i); \n        int **shapes = helper.getShapeArguments(i); \n        int *idxArg = helper.getIndexArguments(i); \n        double *realArg = helper.getRealArguments(i); \n \n        for (int e = 0; e < maxIntArrays; e++) { \n            intArrays[e] = helper.getIntArrayArguments(i, e); \n        } \n \n        execAggregateDouble(extraPointers, \n                            opNum, \n                            arguments, \n                            helper.getNumArguments(i), \n                            shapes, \n                            helper.getNumShapeArguments(i), \n                            idxArg, \n                            helper.getNumIndexArguments(i), \n                            intArrays, \n                            helper.getNumIntArrayArguments(i), \n                            realArg, \n                            helper.getNumRealArguments(i)); \n \n        delete [] intArrays; \n    }", "pragma": "parallel for ", "hash": "26cdf5092ec7bf43fc284d372c480abdcf7e9050031574059007491c8164ef9f"}
{"code": "for(size_t j = box[1]; j < box[3]; j++) \n    { \n      for(size_t i = box[0]; i < box[2]; i++) \n      { \n        const size_t k = 4 * (width * j + i); \n        const float L = pixel[k]; \n        const float a = pixel[k + 1]; \n        const float b = pixel[k + 2]; \n        tmean[0] += w * L; \n        tmean[1] += w * a; \n        tmean[2] += w * b; \n        tmmin[0] = fminf(tmmin[0], L); \n        tmmin[1] = fminf(tmmin[1], a); \n        tmmin[2] = fminf(tmmin[2], b); \n        tmmax[0] = fmaxf(tmmax[0], L); \n        tmmax[1] = fmaxf(tmmax[1], a); \n        tmmax[2] = fmaxf(tmmax[2], b); \n      } \n    }", "pragma": "for ", "hash": "4d2877ccd00a626c5027fa485429899f550d43d2ef449ed173d4408152f97657"}
{"code": "for (int y=0; y<_pyramids[el].height; y++) \n\t\t\t\t\tfor (int x=0; x<_pyramids[el].width; x++) \n\t\t\t\t\t{\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tVec2f val=temp.at<Vec2f>(y,x); \n\t\t\t\t\t\ttemp.at<Vec2f>(y,x)=Vec2f(val[0]*ratio_x,val[1]*ratio_y); \n\t\t\t\t\t}", "pragma": "parallel for ", "hash": "fb24abb0a74a432bd6eab607c850e7061714753990061f4c734368159cd2175b"}
{"code": "for (int i = 0; i < 4; i++) { \n    for (int j = i; j < 4; j++) { \n    } \n  }", "pragma": "for ", "hash": "f56dadb426cdd08b892969e404241d8520e29375f463cdc9fef9d27a2243c7bb"}
{"code": "for(long j=0;j<ny;j++)\tfor(long i=0;i<nx;i++) \n\t\t\t{ \n\t\t\t\tregister long i0 = i+nx*j; \n\t\t\t\ts.x.a[i0] = x->v(i,p,j)*(1-d) + x->v(i,p+1,j)*d; \n\t\t\t\ts.y.a[i0] = y->v(i,p,j)*(1-d) + y->v(i,p+1,j)*d; \n\t\t\t\ts.z.a[i0] = z->v(i,p,j)*(1-d) + z->v(i,p+1,j)*d; \n\t\t\t\ts.a.a[i0] = a->v(i,p,j)*(1-d) + a->v(i,p+1,j)*d; \n\t\t\t}", "pragma": "parallel for ", "hash": "fd067585063032a3181e4e37cf61eb5c0ab8cbb26707275d5093af3d45dcb613"}
{"code": "for (unsigned int i = 0 ; i < vd.num_vertices() ; ++i) \n  { \n     \n \n    if (abort) continue; \n    if (pb.check_interrupt()) abort = true; \n    pb.increment(); \n \n    std::vector<point_int> triangle; \n    const voronoi_diagram<double>::const_vertex_iterator it = vd.vertices().begin() + i; \n    const voronoi_diagram<double>::vertex_type& vertex = *it; \n    const voronoi_diagram<double>::edge_type* edge = vertex.incident_edge(); \n \n    do \n    { \n      const voronoi_diagram<double>::cell_type* cell = edge->cell(); \n      assert(cell->contains_point()); \n \n      triangle.push_back(points[cell->source_index()]); \n \n      if (triangle.size() == 3) \n      { \n         \n \n        point_int &A_ = triangle[0]; \n        Point A(A_.x*scale_x+offset_x, A_.y*scale_y+offset_y, A_.id); \n        point_int &B_ = triangle[1]; \n        Point B(B_.x*scale_y+offset_x, B_.y*scale_y+offset_y, B_.id); \n        point_int &C_ = triangle[2]; \n        Point C(C_.x*scale_x+offset_x, C_.y*scale_y+offset_y, C_.id); \n \n         \n \n        PointXYZ u(A.x - B.x, A.y - B.y, Z[A.id] - Z[B.id], 0); \n        PointXYZ v(A.x - C.x, A.y - C.y, Z[A.id] - Z[C.id], 0); \n        PointXYZ w(B.x - C.x, B.y - C.y, Z[B.id] - Z[C.id], 0); \n \n         \n \n        double edge_AB = u.x * u.x + u.y * u.y; \n        double edge_AC = v.x * v.x + v.y * v.y; \n        double edge_BC = w.x * w.x + w.y * w.y; \n        double edge_max = MAX(edge_AB, edge_AC, edge_BC); \n \n         \n \n        if (trim == 0 || edge_max < trim) \n        { \n          Triangle tri(A,B,C); \n \n           \n \n          std::vector<PointXYZ> pts; \n          tree.lookup(tri,pts); \n \n          if (pts.size() > 0) \n          { \n             \n \n            for (unsigned int j = 0 ; j < pts.size() ; j++) \n            { \n              PointXYZ& p = pts[j]; \n \n              PointXYZ n; \n              n.x = u.y*v.z-u.z*v.y; \n              n.y = u.z*v.x-u.x*v.z; \n              n.z = u.x*v.y-u.y*v.x; \n \n              PointXYZ nn;   \n \n              double norm = std::sqrt(n.x*n.x + n.y*n.y + n.z*n.z); \n              nn.x = n.x/norm; \n              nn.y = n.y/norm; \n              nn.z = n.z/norm; \n \n               \n \n               \n \n              if (nn.z > min_normal_z) \n              { \n                double intercept = -(n.x*C.x + n.y*C.y + n.z*Z[C.id]); \n \n                #pragma omp critical \n                { \n                  z_out[p.id] = -(p.x * n.x + p.y * n.y + intercept)/n.z; \n                } \n              } \n            } \n          } \n        } \n \n        triangle.erase(triangle.begin() + 1); \n      } \n \n      edge = edge->rot_next(); \n \n \n    } while (edge != vertex.incident_edge()); \n  }", "pragma": "parallel for ", "hash": "8cd5eab3c6c499bdb2893bd81035a54758945179161863df92dc9f20ab347486"}
{"code": "for    (ix=0; ix<fdm->nxpad; ix++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tup[ix][iz] = uo[ix][iz]  \n\t\t    +        ua[ix][iz] * kk[ix][iz] * dt; \n\t    } \n\t}", "pragma": "parallel for private(ix iz)", "hash": "566519747630ff80edc450fd04a042b413403df36f7e6834aa2d212ffaccdb8e"}
{"code": "for (i = 0; i < MONOTONIC_END (73); i++) \n      { \n\tif (l == MONOTONIC_UNDEF) \n\t  { \n\t    n = 1; \n\t    c++; \n\t  } \n\telse if (l == i - 1) \n\t  n++; \n\telse \n\t  { \n\t    if (l >= i) \n\t      abort (); \n\t    if (n < 7) \n\t      abort (); \n\t    n = 1; \n\t    c++; \n\t  } \n\tl = i; \n      }", "pragma": "for ", "hash": "44d442e00e487ff6533399481fa724111333ca859f2c5fc4e87d911d7c0d653c"}
{"code": "for(i=0; i<system->N; i++) \n    for(int t=0; t<nthreads; t++) { \n      const int indx = t*system->N + i; \n      workspace->dDeltap_self[i][0]  += tmp_ddelta[indx][0]; \n      workspace->dDeltap_self[i][1]  += tmp_ddelta[indx][1]; \n      workspace->dDeltap_self[i][2]  += tmp_ddelta[indx][2]; \n      workspace->total_bond_order[i] += tmp_bond_order[indx]; \n    }", "pragma": "for ", "hash": "bc220c83c4b7f705cca7d9d8836b4e7dca3920c474c6937625cc4b9f10df51ac"}
{"code": "for (int blockId = 0; blockId < nBlocks; ++blockId) \n        { \n            int inputPtr  = 0; for (int p = 0; p < blockId; ++p) inputPtr  += *(int *)(input + 1 + 8 * p + 4); \n            int outputPtr = 0; for (int p = 0; p < blockId; ++p) outputPtr += *(int *)(input + 1 + 8 * p + 0); \n \n            inputPtr += 1 + 8 * nBlocks; \n \n            int inputSize  = *(int *)(input + 1 + 8 * blockId + 4); \n            int outputSize = *(int *)(input + 1 + 8 * blockId + 0); \n \n            if (inputSize != outputSize) \n            { \n                decompressionResult[blockId] = bsc_coder_decode_block(input + inputPtr, output + outputPtr, coder); \n            } \n            else \n            { \n                decompressionResult[blockId] = inputSize; memcpy(output + outputPtr, input + inputPtr, inputSize); \n            } \n        }", "pragma": "parallel for ", "hash": "703591c05d0e55a43e70505110539395206d13aa3baa748987ef1baca9a43813"}
{"code": "for (i = ist; i <= iend; i++) { \n    for (j = jst; j <= jend; j++) { \n      for (k = 1; k <= nz0-2; k++) { \n\t  sum0 = sum0 + v[i][j][k][0] * v[i][j][k][0]; \n\t  sum1 = sum1 + v[i][j][k][1] * v[i][j][k][1]; \n\t  sum2 = sum2 + v[i][j][k][2] * v[i][j][k][2]; \n\t  sum3 = sum3 + v[i][j][k][3] * v[i][j][k][3]; \n\t  sum4 = sum4 + v[i][j][k][4] * v[i][j][k][4]; \n      } \n    } \n  }", "pragma": "for ", "hash": "b94fcd44e62b4e1ed67bc34cfb68e3c74bd94942893a3720d4808cc82cc296b8"}
{"code": "for (int j = 0; j < n__; j++) { \n            for (int i = 0; i < m__; i++) { \n                result__(irow0__ + i, jcol0__ + j) = tmp(i, j); \n            } \n        }", "pragma": "parallel for ", "hash": "ced8022659f9faf5affdccb8980052768800e8c4761dcc82a457b0023c7084aa"}
{"code": "for (uint i = 0; i < positions.size()/3; ++i) { \n            double tmp_x = positions[i * 3]; \n            double tmp_y = positions[i * 3 + 1]; \n            double tmp_z = positions[i * 3 + 2]; \n \n            positions[i * 3]     = positions[i * 3]     * 2.0 - previous[i * 3]     + forces[i * 3]     * dt * dt; \n            positions[i * 3 + 1] = positions[i * 3 + 1] * 2.0 - previous[i * 3 + 1] + forces[i * 3 + 1] * dt * dt; \n            positions[i * 3 + 2] = positions[i * 3 + 2] * 2.0 - previous[i * 3 + 2] + forces[i * 3 + 2] * dt * dt; \n \n            previous[i * 3]     = tmp_x; \n            previous[i * 3 + 1] = tmp_y; \n            previous[i * 3 + 2] = tmp_z; \n        }", "pragma": "parallel for ", "hash": "684ce47e66d8a9e6d4e8d400eaa38fac981384fab0f7eafedbe1aaead37dc856"}
{"code": "for (k = 1; k <= nz2; k++) { \n    for (j = 1; j <= ny2; j++) { \n      for (i = 1; i <= nx2; i++) { \n        uijk = us[k][j][i]; \n        up1  = us[k][j][i+1]; \n        um1  = us[k][j][i-1]; \n \n        rhs[k][j][i][0] = rhs[k][j][i][0] + dx1tx1 *  \n          (u[k][j][i+1][0] - 2.0*u[k][j][i][0] + u[k][j][i-1][0]) - \n          tx2 * (u[k][j][i+1][1] - u[k][j][i-1][1]); \n \n        rhs[k][j][i][1] = rhs[k][j][i][1] + dx2tx1 *  \n          (u[k][j][i+1][1] - 2.0*u[k][j][i][1] + u[k][j][i-1][1]) + \n          xxcon2*con43 * (up1 - 2.0*uijk + um1) - \n          tx2 * (u[k][j][i+1][1]*up1 - u[k][j][i-1][1]*um1 + \n                (u[k][j][i+1][4] - square[k][j][i+1] - \n                 u[k][j][i-1][4] + square[k][j][i-1]) * c2); \n \n        rhs[k][j][i][2] = rhs[k][j][i][2] + dx3tx1 *  \n          (u[k][j][i+1][2] - 2.0*u[k][j][i][2] + u[k][j][i-1][2]) + \n          xxcon2 * (vs[k][j][i+1] - 2.0*vs[k][j][i] + vs[k][j][i-1]) - \n          tx2 * (u[k][j][i+1][2]*up1 - u[k][j][i-1][2]*um1); \n \n        rhs[k][j][i][3] = rhs[k][j][i][3] + dx4tx1 *  \n          (u[k][j][i+1][3] - 2.0*u[k][j][i][3] + u[k][j][i-1][3]) + \n          xxcon2 * (ws[k][j][i+1] - 2.0*ws[k][j][i] + ws[k][j][i-1]) - \n          tx2 * (u[k][j][i+1][3]*up1 - u[k][j][i-1][3]*um1); \n \n        rhs[k][j][i][4] = rhs[k][j][i][4] + dx5tx1 *  \n          (u[k][j][i+1][4] - 2.0*u[k][j][i][4] + u[k][j][i-1][4]) + \n          xxcon3 * (qs[k][j][i+1] - 2.0*qs[k][j][i] + qs[k][j][i-1]) + \n          xxcon4 * (up1*up1 -       2.0*uijk*uijk + um1*um1) + \n          xxcon5 * (u[k][j][i+1][4]*rho_i[k][j][i+1] -  \n                2.0*u[k][j][i][4]*rho_i[k][j][i] + \n                    u[k][j][i-1][4]*rho_i[k][j][i-1]) - \n          tx2 * ( (c1*u[k][j][i+1][4] - c2*square[k][j][i+1])*up1 - \n                  (c1*u[k][j][i-1][4] - c2*square[k][j][i-1])*um1 ); \n      } \n    } \n \n     \n \n     \n \n     \n \n    for (j = 1; j <= ny2; j++) { \n      i = 1; \n      for (m = 0; m < 5; m++) { \n        rhs[k][j][i][m] = rhs[k][j][i][m]- dssp *  \n          (5.0*u[k][j][i][m] - 4.0*u[k][j][i+1][m] + u[k][j][i+2][m]); \n      } \n \n      i = 2; \n      for (m = 0; m < 5; m++) { \n        rhs[k][j][i][m] = rhs[k][j][i][m] - dssp *  \n          (-4.0*u[k][j][i-1][m] + 6.0*u[k][j][i][m] - \n            4.0*u[k][j][i+1][m] + u[k][j][i+2][m]); \n      } \n    } \n \n    for (j = 1; j <= ny2; j++) { \n      for (i = 3; i <= nx2-2; i++) { \n        for (m = 0; m < 5; m++) { \n          rhs[k][j][i][m] = rhs[k][j][i][m] - dssp *  \n            ( u[k][j][i-2][m] - 4.0*u[k][j][i-1][m] +  \n            6.0*u[k][j][i][m] - 4.0*u[k][j][i+1][m] +  \n              u[k][j][i+2][m] ); \n        } \n      } \n    } \n \n    for (j = 1; j <= ny2; j++) { \n      i = nx2-1; \n      for (m = 0; m < 5; m++) { \n        rhs[k][j][i][m] = rhs[k][j][i][m] - dssp * \n          ( u[k][j][i-2][m] - 4.0*u[k][j][i-1][m] +  \n          6.0*u[k][j][i][m] - 4.0*u[k][j][i+1][m] ); \n      } \n \n      i = nx2; \n      for (m = 0; m < 5; m++) { \n        rhs[k][j][i][m] = rhs[k][j][i][m] - dssp * \n          ( u[k][j][i-2][m] - 4.0*u[k][j][i-1][m] + 5.0*u[k][j][i][m] ); \n      } \n    } \n  }", "pragma": "for ", "hash": "e3ecadb636e4485dbe95105668d6e49c9ef232495152dc190523c26d93c6ef1d"}
{"code": "for (i = ist; i <= iend; i++) { \n    for (j = jst; j <= jend; j++) { \n      for (m = 0; m < 5; m++) { \n\tv[i][j][k][m] = v[i][j][k][m] \n\t  - omega * (  ldz[i][j][m][0] * v[i][j][k-1][0] \n\t\t       + ldz[i][j][m][1] * v[i][j][k-1][1] \n\t\t       + ldz[i][j][m][2] * v[i][j][k-1][2] \n\t\t       + ldz[i][j][m][3] * v[i][j][k-1][3] \n\t\t       + ldz[i][j][m][4] * v[i][j][k-1][4]  ); \n      } \n    } \n  }", "pragma": "for ", "hash": "0c73c82930b167e319c3310e740948d057beb45c46a3fa5df3ea1c84fc372fd2"}
{"code": "for (int j=0; j<mR[1]; j++) {\r \n    const int yIndex = j*mR[0];\r \n    for (int i=0; i<mR[0]; i++) {\r \n\r \n       \n \n       \n \n      const t_real x_voxel = c*i - s*j + precomputedParamA;\r \n      const t_real y_voxel = s*i + c*j + precomputedParamB;\r \n      \r \n       \n \n\t  const t_real val =  dataR[yIndex+i] - linearInterPoint2D(dataT, x_voxel, y_voxel, width);\r \n\r \n      fval += val*val;\r \n    }\r \n  }", "pragma": "parallel for reduction(+: fval) ", "hash": "9779cea94863af35dacc23faf285a2a0045ff69bdc7a3e79144f0a6428bf27c4"}
{"code": "for(int y=0; y<height; y++) \n\t\t\t{ \n\t\t\t\tHistogram h(truncate,mode); \n\t\t\t\tfor(int x=0; x<width; x++) \n\t\t\t\t{ \n\t\t\t\t\th.clear(); \n\t\t\t\t\tfor(int j=0,idx=0; j<2*r+1; j++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tuchar* sp = src2.ptr<uchar>(y+j); sp+=x; \n\t\t\t\t\t\tfor(int i=0; i<2*r+1; i++,idx++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tfloat addval = luts[idx]; \n\t\t\t\t\t\t\th.add(addval, *sp, metric); \n\t\t\t\t\t\t\tsp++; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t\tdst.at<uchar>(y,x) = h.returnVal(); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "528ac5e7c85312517dfb7a0285a60cae8968c533168f7e7b0ed9427ff1236038"}
{"code": "for (unsigned int i = 0; i < X[j].size(); ++i) \n        qZaug[j][i] = auglabels(k, mapidx[j][i], \n                                (qZref[j][i].col(1).array() > 0.5), qZ[j][i]);", "pragma": "parallel for ", "hash": "38059c2d99c42bb09c20cf9949e127ecbb97e1686b69b8226e04f349cea74f23"}
{"code": "for (i = 0; i < 1000; ++i) \n      { \n #pragma omp cancel for if (x[3]) \n #pragma omp atomic \n\tv += 2; \n      }", "pragma": "for ", "hash": "c9433e7cc5b466dff07751112a327d1f340a0a95ca1c5700ff1cb2c149d5abd7"}
{"code": "for (int64_t i = 0; i < (int64_t)contigs.size(); ++i) \n    { \n        if ((int)contigs[i].size() > option.min_contig) \n        { \n            sum_coverage += num_aligned_reads[i]; \n            sum_length += contigs[i].size() - read_length + 1; \n            coverage[i] = 1.0 * num_aligned_reads[i] / (contigs[i].size() - reads[0].size() + 1); \n            contig_infos[i].set_kmer_count(num_aligned_reads[i]); \n        } \n    }", "pragma": "parallel for reduction( +: sum_coverage sum_length) ", "hash": "45821fe390cf704a55418953990b0ed460f5752e0c022ea6694f7f601cb9de44"}
{"code": "for (int i = 0; i < (int)edatas.size(); ++i) { \n        auto mySolver = std::unique_ptr<Solver>(solver.clone()); \n        auto myModel = std::unique_ptr<Model>(model.clone()); \n \n         \n \n        if (skipThrough) { \n            ConditionContext conditionContext(myModel.get(), edatas[i]); \n            results[i] = \n              std::unique_ptr<ReturnData>(new ReturnData(solver, model)); \n        } else { \n            results[i] = runAmiciSimulation(*mySolver, edatas[i], *myModel); \n        } \n \n        skipThrough |= failfast && results[i]->status < 0; \n    }", "pragma": "parallel for ", "hash": "0528fb0c3f6cf385686c5899880e2eeac64c0f7806af51b86eb7ff94f631ab79"}
{"code": "for (int k = 2; k <= LIM; k++) { \n    bool go = true; \n    int i = k - 1; \n    for (; go && i < WM.size(); i++) { \n      for (int n = 0; go && n < WM[i].size(); n++) { \n        vector<int> w = WM[i][n]; \n        if (w.size() <= k) { \n          int sum = 0; \n          for (const auto c : w) sum += c; \n \n          int d = k - w.size(); \n          if (d + sum == i + 1) { \n            go = false; \n \n \n#pragma omp critical \n            S.insert(i + 1); \n          } \n        } \n      } \n    } \n    if (go) { \n      cout << \"WRONGGGGGGGG\" << k << endl; \n      exit(-1); \n    } \n  }", "pragma": "parallel for ", "hash": "093a8d9f10b08166b6ae93e4760fedffc6800956ca01cf30086a8746bda94d6e"}
{"code": "for (int t = 0; t < nt; t++) { \n        s1s[t].i0 = s1.i0 + s1.len() * t / nt; \n        s1s[t].i1 = s1.i0 + s1.len() * (t + 1) / nt; \n \n        if (t + 1 < nt) { \n            T pivot = src[s1s[t].i1]; \n            size_t i0 = s2.i0, i1 = s2.i1; \n            while (i0 + 1 < i1) { \n                size_t imed = (i1 + i0) / 2; \n                if (comp(pivot, src[imed])) { \n                    i1 = imed; \n                } else { \n                    i0 = imed; \n                } \n            } \n            s2s[t].i1 = s2s[t + 1].i0 = i1; \n        } \n    }", "pragma": "parallel for ", "hash": "f129857e64f5b974a9c2e22151589bc57c057d60072036225bf0c92e2c5caa38"}
{"code": "for (i = 0; i < M; i++) \n\t\tfor (j = 0; j < M; j++) { \n\t\t\td = P1[i*M+j]-P2[i*M+j]; \n\t\t\ts += d*d; \n\t\t}", "pragma": "parallel for reduction(+:s) private(d j)", "hash": "13da3bb20d71192fc4826b90319f99cdf16b6f2c133e142f3c26e59d824daea3"}
{"code": "for (long i=0; i<NV; i++) { \n                assert(C_orig[i] < G->numVertices); \n                if (C_orig[i] >=0) \n\t  \t\tC_orig[i] = C[C_orig[i]];  \n \n\t  }", "pragma": "parallel for ", "hash": "c3e0405d494beea5fcc3f2ad0cf28d584e76701a26de0fb5efb802f694333c70"}
{"code": "for (int g = 0; g < group_; ++g) { \n    caffe_cpu_gemm<Dtype>(CblasTrans, CblasNoTrans, kernel_dim_ / group_, \n        conv_out_spatial_dim_, conv_out_channels_ / group_, \n        (Dtype)1., weights + weight_offset_ * 0, output + output_offset_ * g, \n        (Dtype)0., col_buff + col_offset_ * g); \n  }", "pragma": "parallel for ", "hash": "ef54bc47600493fcc2042dd989561e93731d478791de626335ca5b6ce111ff13"}
{"code": "for (k = 1; k < mMaxIndex.z; ++k) { \n        for (i = 1; i < mMaxIndex.x; ++i) { \n            for (j = 0; j < mMaxIndex.y; ++j) { \n                Ey.p[i][j][k] = Ceye.p[i][j][k] * Ey.p[i][j][k] + \n                        (Hz.p[i][j][k] - Hz.p[i - 1][j][k]) * Ceyhz.p[i][j][k] + \n                        (Hx.p[i][j][k] - Hx.p[i][j][k - 1]) * Ceyhx.p[i][j][k]; \n            } \n        } \n    }", "pragma": "parallel for private(i j k)", "hash": "382ededb3382c7b5cc26a2ce5224f87e635fce65a698fcf383af741b5032a166"}
{"code": "for ( int64_t i = 0; i < (int64_t)faceList->size(); i += 3 ) \n        { \n            std::vector<cvf::Vec3d> triangle( 3 ); \n            std::vector<cvf::Vec4d> triangleWithValues( 3 ); \n            bool                    anyValidVertex = false; \n            for ( size_t n = 0; n < 3; ++n ) \n            { \n                uint   vn    = ( *faceList )[i + n]; \n                double value = vn < m_aggregatedVertexResults.size() ? m_aggregatedVertexResults[vn] \n                                                                     : std::numeric_limits<double>::infinity(); \n                triangle[n]           = vertices[vn]; \n                triangleWithValues[n] = cvf::Vec4d( vertices[vn], value ); \n                if ( value != std::numeric_limits<double>::infinity() ) \n                { \n                    anyValidVertex = true; \n                } \n            } \n \n            if ( !anyValidVertex ) \n            { \n                continue; \n            } \n \n            if ( m_contourPolygons.empty() ) \n            { \n                threadTriangles[myThread][0].insert( threadTriangles[myThread][0].end(), \n                                                     triangleWithValues.begin(), \n                                                     triangleWithValues.end() ); \n                continue; \n            } \n \n            bool outsideOuterLimit = false; \n            for ( size_t c = 0; c < m_contourPolygons.size() && !outsideOuterLimit; ++c ) \n            { \n                std::vector<std::vector<cvf::Vec3d>> intersectPolygons; \n                for ( size_t j = 0; j < m_contourPolygons[c].size(); ++j ) \n                { \n                    bool containsAtLeastOne = false; \n                    for ( size_t t = 0; t < 3; ++t ) \n                    { \n                        if ( m_contourPolygons[c][j].bbox.contains( triangle[t] ) ) \n                        { \n                            containsAtLeastOne = true; \n                        } \n                    } \n                    if ( containsAtLeastOne ) \n                    { \n                        std::vector<std::vector<cvf::Vec3d>> clippedPolygons = \n                            RigCellGeometryTools::intersectionWithPolygon( triangle, m_contourPolygons[c][j].vertices ); \n                        intersectPolygons.insert( intersectPolygons.end(), clippedPolygons.begin(), clippedPolygons.end() ); \n                    } \n                } \n \n                if ( intersectPolygons.empty() ) \n                { \n                    outsideOuterLimit = true; \n                    continue; \n                } \n \n                std::vector<std::vector<cvf::Vec3d>> clippedPolygons; \n \n                if ( !subtractPolygons[c].empty() ) \n                { \n                    for ( const std::vector<cvf::Vec3d>& polygon : intersectPolygons ) \n                    { \n                        std::vector<std::vector<cvf::Vec3d>> fullyClippedPolygons = \n                            RigCellGeometryTools::subtractPolygons( polygon, subtractPolygons[c] ); \n                        clippedPolygons.insert( clippedPolygons.end(), \n                                                fullyClippedPolygons.begin(), \n                                                fullyClippedPolygons.end() ); \n                    } \n                } \n                else \n                { \n                    clippedPolygons.swap( intersectPolygons ); \n                } \n \n                { \n                    std::vector<cvf::Vec4d> clippedTriangles; \n                    for ( std::vector<cvf::Vec3d>& clippedPolygon : clippedPolygons ) \n                    { \n                        std::vector<std::vector<cvf::Vec3d>> polygonTriangles; \n                        if ( clippedPolygon.size() == 3u ) \n                        { \n                            polygonTriangles.push_back( clippedPolygon ); \n                        } \n                        else \n                        { \n                            cvf::Vec3d baryCenter = cvf::Vec3d::ZERO; \n                            for ( size_t v = 0; v < clippedPolygon.size(); ++v ) \n                            { \n                                cvf::Vec3d& clippedVertex = clippedPolygon[v]; \n                                baryCenter += clippedVertex; \n                            } \n                            baryCenter /= clippedPolygon.size(); \n                            for ( size_t v = 0; v < clippedPolygon.size(); ++v ) \n                            { \n                                std::vector<cvf::Vec3d> clippedTriangle; \n                                if ( v == clippedPolygon.size() - 1 ) \n                                { \n                                    clippedTriangle = { clippedPolygon[v], clippedPolygon[0], baryCenter }; \n                                } \n                                else \n                                { \n                                    clippedTriangle = { clippedPolygon[v], clippedPolygon[v + 1], baryCenter }; \n                                } \n                                polygonTriangles.push_back( clippedTriangle ); \n                            } \n                        } \n                        for ( const std::vector<cvf::Vec3d>& polygonTriangle : polygonTriangles ) \n                        { \n                             \n \n                            double area = 0.5 * ( ( polygonTriangle[1] - polygonTriangle[0] ) ^ \n                                                  ( polygonTriangle[2] - polygonTriangle[0] ) ) \n                                                    .length(); \n                            if ( area < areaThreshold ) continue; \n                            for ( const cvf::Vec3d& localVertex : polygonTriangle ) \n                            { \n                                double value = std::numeric_limits<double>::infinity(); \n                                if ( discrete ) \n                                { \n                                    value = contourLevels[c] + 0.01 * ( contourLevels.back() - contourLevels.front() ) / \n                                                                   contourLevels.size(); \n                                } \n                                else \n                                { \n                                    for ( size_t n = 0; n < 3; ++n ) \n                                    { \n                                        if ( ( triangle[n] - localVertex ).length() < sampleSpacing() * 0.01 && \n                                             triangleWithValues[n].w() != std::numeric_limits<double>::infinity() ) \n                                        { \n                                            value = triangleWithValues[n].w(); \n                                            break; \n                                        } \n                                    } \n                                    if ( value == std::numeric_limits<double>::infinity() ) \n                                    { \n                                        value = interpolateValue( cvf::Vec2d( localVertex.x(), localVertex.y() ) ); \n                                        if ( value == std::numeric_limits<double>::infinity() ) \n                                        { \n                                            value = contourLevels[c]; \n                                        } \n                                    } \n                                } \n \n                                cvf::Vec4d globalVertex( localVertex, value ); \n                                clippedTriangles.push_back( globalVertex ); \n                            } \n                        } \n                    } \n \n                    { \n                         \n \n                         \n \n                         \n \n#pragma omp critical \n                        threadTriangles[myThread][c].insert( threadTriangles[myThread][c].end(), \n                                                             clippedTriangles.begin(), \n                                                             clippedTriangles.end() ); \n                    } \n                } \n            } \n        }", "pragma": "for ", "hash": "80dd4953579fa5b056b9ac3709bfe6c77f40b620a6c304ad41d959bc169e0884"}
{"code": "for (int i=0; i<height; i++) { \n                for (int j=0; j<width; j++) { \n                         \n                         \n \n                         \n                        if ((red[i][j]>thresh[0] || green[i][j]>thresh[1] || blue[i][j]>thresh[2]) && \n                                (red[i][j]<max_f[0] && green[i][j]<max_f[1] && blue[i][j]<max_f[2])) { \n                                 \n                                hipass_sum += fabs(channelblur[0][i][j]-red[i][j]) + fabs(channelblur[1][i][j]-green[i][j]) + fabs(channelblur[2][i][j]-blue[i][j]); \n                                hipass_norm++; \n                                 \n                                hilite_full[0][i][j] = red[i][j]; \n                                hilite_full[1][i][j] = green[i][j]; \n                                hilite_full[2][i][j] = blue[i][j]; \n                                hilite_full[3][i][j] = 1; \n                                hilite_full[4][i][j] = 1; \n                                 \n                        } \n                         \n \n                         \n \n                } \n        }", "pragma": "parallel for reduction(+:hipass_sum hipass_norm) ", "hash": "653b5517aef77d506e2459b45624c7df422612aa4794e12fe61156fedfa45530"}
{"code": "for (k = 0; k < nkernel; k++) \n  { \n    int o = (int)THTensor_(get2d)(connTable,k,1)-1; \n    int i = (int)THTensor_(get2d)(connTable,k,0)-1; \n \n     \n \n    THTensor_(validXCorr2DRevptr)( \n      gradWeight_data + k*weight_w*weight_h, \n      scale, \n      gradOutput_data + o*output_w*output_h, output_h, output_w, \n      input_data + i*input_w*input_h, input_h, input_w, \n      dH, dW \n    ); \n  }", "pragma": "parallel for private(k)", "hash": "a7d3720116cd379ede1c9ee3ecff591ea6af9c86da47ff1b75afc1d8791c909b"}
{"code": "for(j = 0; j < this -> rank2; j++) \n            { \n                #pragma omp parallel for private(m) ordered schedule(dynamic) \n                for(m = 0; m < this -> rank3; m++) \n                { \n                    #pragma omp parallel for private(n) ordered schedule(dynamic) \n                    for(n = 0; n < this -> rank4; n++) \n                    { \n                        c.data4[i][j][m][n] = this -> data4[i][j][m][n]*b; \n                    } \n                } \n            }", "pragma": "parallel for private(j)", "hash": "90bd64d872be5b874abe5f3917d9919dcb65d93d1239f28785e9798e21f880c4"}
{"code": "for (long ii = 0; ii < nfcs; ++ii) { \n \n            for (i = 0; i < order + 2; ++i) { \n                atm_index[i] = fc_table_in[ii].elems[i] / 3; \n                xyz_index[i] = fc_table_in[ii].elems[i] % 3; \n            } \n \n            for (isym = 0; isym < nsym_in_use; ++isym) { \n \n                for (i = 0; i < order + 2; ++i) \n                    atm_index_symm[i] = map_sym[atm_index[i]][isym]; \n                if (!is_inprim(order + 2, atm_index_symm, natmin, symmetry->get_map_p2s())) continue; \n \n                for (i = 0; i < nparams; ++i) const_now_omp[i] = 0; \n \n                const_now_omp[fc_table_in[ii].mother] = -nint(fc_table_in[ii].sign); \n \n                for (ixyz = 0; ixyz < nxyz; ++ixyz) { \n                    for (i = 0; i < order + 2; ++i) \n                        ind[i] = 3 * atm_index_symm[i] + xyzcomponent[ixyz][i]; \n \n                    i_prim = get_minimum_index_in_primitive(order + 2, ind, nat, natmin, symmetry->get_map_p2s()); \n                    std::swap(ind[0], ind[i_prim]); \n                    sort_tail(order + 2, ind); \n \n                    iter_found = list_found.find(FcProperty(order + 2, 1.0, ind, 1)); \n                    if (iter_found != list_found.end()) { \n                        c_tmp = nint(coef_sym(order + 2, rotation[isym], xyz_index, xyzcomponent[ixyz])); \n                        const_now_omp[(*iter_found).mother] += nint((*iter_found).sign) * c_tmp; \n                    } \n                } \n \n                if (!is_allzero(const_now_omp, loc_nonzero)) { \n                    if (const_now_omp[loc_nonzero] < 0) { \n                        for (j = 0; j < nparams; ++j) const_now_omp[j] *= -1; \n                    } \n \n                    const_tmp_omp.clear(); \n                    for (j = 0; j < nparams; ++j) { \n                        if (std::abs(const_now_omp[j]) > 0) { \n                            const_tmp_omp.emplace_back(j, const_now_omp[j]); \n                        } \n                    } \n                    constraint_list_omp.emplace_back(const_tmp_omp); \n                } \n \n            }  \n \n        }", "pragma": "for private(  i isym ixyz)", "hash": "76419ce09a12e800ef25067f675cb9bcfae72685a163621888ff2205d313731a"}
{"code": "for(int i = 0; i < awidth; i++) \n        lf_modifier_apply_subpixel_geometry_distortion(modifier, xoff + i * xstep, yoff + (height - 1), 1, 1, buf + 6 * (awidth + i));", "pragma": "for ", "hash": "8c566f286ff677007ab3e9369cb594955c7077909f66b1a8a45a46494e44a534"}
{"code": "for (k = 0; k < n; k++) { \n        bias = k * offset; \n        for (i = 0; i < size; i++) { \n             \n \n             \n \n            arg = (double)i * isize; \n            v = flat_top(arg); \n            (*in)[bias + i] = (float)((double)(*in)[bias + i] * v); \n        } \n \n    }", "pragma": "parallel for private(   arg bias i v)", "hash": "6bb4bfaeae8bd0e03a429ca474b779e78e7de5b9eb23d996912b5c84d7245201"}
{"code": "for(int i=0; i<num_planets; i++) \n    { \n        x_old[i] = x[i]; \n        y_old[i] = y[i]; \n        z_old[i] = z[i]; \n    }", "pragma": "parallel for ", "hash": "2970808a5690573f7f1dd67bdf6c5099cc59950c33d11cb03ddb33ed7d5d161c"}
{"code": "for (size_t y = 0; y < m_cvts.ymax; y++) \n        for (size_t x = 0; x < m_cvts.xmax; x++) { \n            if (m_use_scales) { \n                int prefscale = m_range - 1; \n                for (int scale = 0; scale < m_range - 1; scale++) \n                    if (fabs(ACTIVITY(x, y, scale)) > m_threshold) { \n                        prefscale = scale; \n                        break; \n                    } \n                m_image[y][x] /= 1.f + V1(x, y, prefscale); \n            } else \n                m_image[y][x] = m_image[y][x] * \n                                   (1.f + (m_image[y][x] / Lmax2)) / \n                                   (1.f + m_image[y][x]); \n        }", "pragma": "parallel for ", "hash": "724bed4fa28aacb758f99b62630d1e96625ecd3ecd518e83d43812af34072261"}
{"code": "for( int line = 0; line < m_AOIh; line++ ) \n    { \n        _Ty* pData = reinterpret_cast<_Ty*>( static_cast<unsigned char*>( pIB->vpData ) + ( ( m_AOIy + line ) * pIB->pChannels[pY].iLinePitch ) + ( m_AOIx * pIB->iBytesPerPixel ) ); \n        _Ty difference = 0; \n        for( int pixel = 0; pixel < m_AOIw / 2; pixel++ ) \n        { \n            bool boIsVY = ( m_AOIx + pixel ) & 1; \n            if( pixel < ( m_AOIw - 3 ) / 2 ) \n            { \n                difference = abs( pData[1] - pData[3] ); \n                m_pHistogramAverage[pChannel0Hor] += difference; \n                ++m_ppHistogramBuffer[pChannel0Hor][difference]; \n                difference = abs( pData[3] - pData[5] ); \n                m_pHistogramAverage[pChannel0Hor] += difference; \n                ++m_ppHistogramBuffer[pChannel0Hor][difference]; \n                difference = abs( pData[0] - pData[4] ); \n                m_pHistogramAverage[boIsVY ? pChannel2Hor : pChannel1Hor] += 2 * difference; \n                m_ppHistogramBuffer[boIsVY ? pChannel2Hor : pChannel1Hor][difference] += 2; \n                difference = abs( pData[2] - pData[6] ); \n                m_pHistogramAverage[boIsVY ? pChannel1Hor : pChannel2Hor] += 2 * difference; \n                m_ppHistogramBuffer[boIsVY ? pChannel1Hor : pChannel2Hor][difference] += 2; \n            } \n            if( line < m_AOIh - 1 ) \n            { \n                difference = abs( pData[1] - pData[1 + pIB->pChannels[0].iLinePitch] ); \n                m_pHistogramAverage[pChannel0Ver] += difference; \n                ++m_ppHistogramBuffer[pChannel0Ver][difference]; \n                difference = abs( pData[0] - pData[pIB->pChannels[0].iLinePitch] ); \n                m_pHistogramAverage[boIsVY ? pChannel2Ver : pChannel1Ver] += difference; \n                ++m_ppHistogramBuffer[boIsVY ? pChannel2Ver : pChannel1Ver][difference]; \n                difference = abs( pData[3] - pData[3 + pIB->pChannels[0].iLinePitch] ); \n                m_pHistogramAverage[pChannel0Ver] += difference; \n                ++m_ppHistogramBuffer[pChannel0Ver][difference]; \n                difference = abs( pData[2] - pData[2 + pIB->pChannels[0].iLinePitch] ); \n                m_pHistogramAverage[boIsVY ? pChannel1Ver : pChannel2Ver] += difference; \n                ++m_ppHistogramBuffer[boIsVY ? pChannel1Ver : pChannel2Ver][difference]; \n            } \n            pData += 4; \n        } \n    }", "pragma": "parallel for ", "hash": "b38327bdf01decb857b49adc6f3a118b296ac052b90b114b0b6c0bf9a73dce70"}
{"code": "for(size_t ip=0;ip<np;ip++) { \n      orbs.row(ip)=arma::trans(compute_orbitals(Cwrk,bas,r[ip].r)); \n    }", "pragma": "parallel for ", "hash": "e11e4e042b7ca9ecf1d8095fe6b224527d088e0666caa7083af2783aea50f91d"}
{"code": "for ( int x = 0 ; x < width - 7 ; x += 8 ) { \n        for ( int y = 1 ; y < height - 1 ; y++ ) { \n            for (int xx = 0; xx < 8; ++xx) { \n                float t = 2.f * T (x + xx, y); \n                t += T (x + xx, y - 1); \n                t += T (x + xx, y + 1); \n                L (x + xx, y) = t * 0.25f;  \n \n            } \n        } \n \n        for (int xx = 0; xx < 8; ++xx) { \n            L (x + xx, 0) = ( 3.f * T (x + xx, 0) + T (x + xx, 1) ) * 0.25f;  \n \n            L (x + xx, height - 1) = ( 3.f * T (x + xx, height - 1) + T (x + xx, height - 2) ) * 0.25f;  \n \n        } \n    }", "pragma": "parallel for ", "hash": "17a45898ba2ff6fcaa641429fd512e9736a5a4636395d425acd209ea55a155e3"}
{"code": "for (i=0; i<numel; i++) \n        memcpy(tensor_data + i*stride, src_data + (index_data[i]-1)*stride, stride*sizeof(real));", "pragma": "parallel for private(i)", "hash": "cb946fb727ce57b98a60da17b4a2ba9b437db5bf761607e0a201d4d5447a6155"}
{"code": "for (int32 seek_row = 0; seek_row < RowSize; seek_row = seek_row + 1) \n\t{ \n\t\tint32 Index = seek_row * StreamSize.x; \n\t\tSVECTOR3 Coord(Index, 0, seek_row); \n \n\t\tfor (int32 seek_col = 0; seek_col<ColSize; seek_col = seek_col + 1) \n\t\t{ \n\t\t\tDataStream[Index] = ProjectionPixelTo3DSpace(Coord, DataStream[Index]); \n \n\t\t\tMinVector.x = MinVector.x > DataStream[Index].x ? DataStream[Index].x : MinVector.x; \n\t\t\tMinVector.y = MinVector.y > DataStream[Index].y ? DataStream[Index].y : MinVector.y; \n\t\t\tMinVector.z = MinVector.z > DataStream[Index].z ? DataStream[Index].z : MinVector.z; \n \n\t\t\tMaxVector.x = MaxVector.x < DataStream[Index].x ? DataStream[Index].x : MaxVector.x; \n\t\t\tMaxVector.y = MaxVector.y < DataStream[Index].y ? DataStream[Index].y : MaxVector.y; \n\t\t\tMaxVector.z = MaxVector.z < DataStream[Index].z ? DataStream[Index].z : MaxVector.z; \n \n\t\t\tIndex = Index + 1; \n\t\t\tCoord.x = Coord.x + 1; \n\t\t\tCoord.y = Coord.y + 1; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "097d032969eede3e2ba8207c9e7cb086c817ce48677d222e125585bc540510d3"}
{"code": "for (int i = 0; i < totalCount; ++i) { \n        eigenVector[i] /= norm; \n    }", "pragma": "parallel for ", "hash": "0de5933619cf831ca763fab57758957c637ca323470b693e7a7fbb559f5e027c"}
{"code": "for(i2=0;i2<fdm->n2pad;i2++) { \n\tfor(iop=0;iop<nop;iop++) { \n \n\t     \n \n\t    if(!abc->free) {  \n \n\t\ti1 = nop-iop; \n\t\tuo      [i2][i1  ]  \n\t\t    = um[i2][i1+1]  \n\t\t    +(um[i2][i1  ] \n\t\t      - uo[i2][i1+1]) * abc->b1l[i2]; \n\t    } \n \n\t     \n \n\t    i1 = fdm->n1pad-nop+iop-1; \n\t    uo      [i2][i1  ]  \n\t\t= um[i2][i1-1] \n\t\t+(um[i2][i1  ] \n\t\t- uo[i2][i1-1]) * abc->b1h[i2]; \n\t} \n    }", "pragma": "parallel for private(i1 i2 iop)", "hash": "ed99c65844ef323325b34c66f4010901a26398b9f5978f30af13b4dcd708fbfd"}
{"code": "for (int ksq = SQ11; ksq < SquareNum; ++ksq) { \n                for (EvalIndex i = (EvalIndex)0; i < fe_end; ++i) { \n                    for (EvalIndex j = (EvalIndex)0; j < fe_end; ++j) { \n                        const int64_t index = evalBase.minKPPIndex((Square)ksq, i, j); \n                        if (index == std::numeric_limits<int64_t>::max()) \n                            continue; \n                        else if (index < 0) { \n                             \n \n                            Evaluator::KPP[ksq][i][j][0] = -round((*evalBase.oneArrayKPP(-index))[0]); \n                            Evaluator::KPP[ksq][i][j][1] =  round((*evalBase.oneArrayKPP(-index))[1]); \n                        } \n                        else { \n                            Evaluator::KPP[ksq][i][j][0] =  round((*evalBase.oneArrayKPP( index))[0]); \n                            Evaluator::KPP[ksq][i][j][1] =  round((*evalBase.oneArrayKPP( index))[1]); \n                        } \n                    } \n                } \n            }", "pragma": "for ", "hash": "5635ae2f3d684cb31e11ea3520f96d725810a792c963a334c0c7e4bb2f833744"}
{"code": "for(i=0; i<(N-16); i++) \n        { \n            tmp += b[i] *  \n \n                (((b[i+1] +  \n                  b[i+2] *  \n                   b[i+3]) +  \n \n                    (b[i+4] +  \n                     b[i+5] * \n                      b[i+6]) * \n \n                       ((b[i+7] +  \n                        b[i+8] *  \n                         b[i+9]) +  \n \n                          (b[i+10] + \n                           b[i+11] * \n                            b[i+12]) * \n \n                             (b[i+13] + \n                              b[i+14] * \n                               b[i+15])))); \n        }", "pragma": "simd for reduction(+:tmp) ", "hash": "d2c4bb0fe427a50628f5c372a3f5ea24ec7667343805c0785fa6fac9222b5547"}
{"code": "for (i = ist; i <= iend; i++) { \n      for (j = jst; j <= jend; j++) { \n\tfor (k = 1; k <= nz-2; k++) { \n\t  for (m = 0; m < 5; m++) { \n\t    u[i][j][k][m] = u[i][j][k][m] \n\t      + tmp * rsd[i][j][k][m]; \n\t  } \n\t} \n      } \n    }", "pragma": "for ", "hash": "f03bd9fab015dd46f02e5f2b2e23614c98bdf53785d60127b4ecd6da554fe525"}
{"code": "for (i = 0; i < 16; i++) \n    { \n      lab7: \n #pragma omp ordered depend(source)  \n \n      ; \n      lab8: \n #pragma omp ordered depend(sink: i-1)  \n \n      ; \n    }", "pragma": "for ", "hash": "583dc9ccbb8e0006fca61abf9af7246f7dcb1a9bce7c209325916bdef4bfcacf"}
{"code": "for( int i=0;i<max;++i ) \n    applyLocalGlobal(res[i],u[i],Q,'N',trans,skip);", "pragma": "parallel for ", "hash": "a86ec810c1a4812d668bced6b66f4cdcb8e22f38683b8299adc2dc56ea8a7581"}
{"code": "for(int i=0; i<n; i++) { \n        if(keep[i] == 0) { \n            continue; \n        } \n        for(int j=i+1; j<n; j++) { \n            if (keep[j] == 0) { \n                continue; \n            } \n            float iou_result = lowerleft_iou(xmins, ymins, widths, heights, i, j); \n            if(iou_result > threshold) { \n                if (probs[i] > probs[j]) { \n                    keep[j] = 0; \n                } else { \n                    keep[i] = 0; \n                    break; \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "7a4b09ef5f4f3bd28b770be110731237b0dd90aa9f320c2ddbaf49103766c027"}
{"code": "for (i = 0; i < nx; i++) { \n    q[i] = 0; \n    for (j = 0; j < ny; j++) { \n      s[j] = s[j] + r[i] * A[i][j]; \n      q[i] = q[i] + A[i][j] * p[j]; \n    } \n  }", "pragma": "parallel for private(j)", "hash": "e299a58dae68e7fe65641d90225370d37001e1c067de4d35c6cbd94793f00b3b"}
{"code": "for (int i = 0; i < numF; ++i) { \n\t\t \n \n\t\t \n \n\t\tVector6d dSi = Dsd[0].col(i); \n\t\tVector6d dsi = Dsd[1].col(i); \n\t\t \n \n\t\tVector6d a1i = a1d.col(i); \n\t\tVector6d a2i = a2d.col(i); \n\t\tVector6d b1i = b1d.col(i); \n\t\tVector6d b2i = b2d.col(i); \n\t\tHi[i] = Area(i)*ComputeConvexConcaveFaceHessian( \n\t\t\ta1i, a2i, b1i, b2i, \n\t\t\taY(i), bY(i), cY(i), dY(i), \n\t\t\tdSi, dsi, \n\t\t\tgradfS(i), gradfs(i), \n\t\t\tHS(i), Hs(i)); \n \n \n\t\tint index2 = i * 21; \n\t\tfor (int a = 0; a < 6; ++a) \n\t\t{ \n\t\t\tfor (int b = 0; b <= a; ++b) \n\t\t\t{ \n\t\t\t\tSS[index2++] = Hi[i](a, b); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "8ba53d2f938c25be120d25b5f5d1ff9e46924c99c6e1bddcde323bc7a27be536"}
{"code": "for (i = 0; i < 16; i = i + 2) \n    ;", "pragma": "for ", "hash": "b1a8c6e0c62b875218464b672f9c8e4ee968254859669430ea66e9fec5dabdea"}
{"code": "for (unsigned j = i + 1; j < mat.width(); j++) { \n \n                if (mat.entry_sorted(pivot_i, j)) { \n                     \n \n                     \n \n \n                    mat.add_column_sorted(i, j); \n                } \n            }", "pragma": "parallel for ", "hash": "c1a0e3c902d4e82fa75c45a49c4022e595879de3a7e394fb8d91e78aa8fa5e76"}
{"code": "for (index_mu=0; index_mu<num_mu; index_mu++) { \n        d11[index_mu][0]=0; \n        dlm1=(1.0+mu[index_mu])/2. * sqrt(3./2.);  \n \n        d11[index_mu][1]=dlm1 * sqrt(2./3.); \n        dl=(1.0+mu[index_mu])/2.*(2.0*mu[index_mu]-1.0) * sqrt(5./2.);  \n \n        d11[index_mu][2] = dl * sqrt(2./5.); \n        for(l=2; l<lmax; l++) { \n            ll=(double) l; \n             \n \n            dlp1 = fac1[l]*(mu[index_mu]-fac2[l])*dl - fac3[l]*dlm1; \n            d11[index_mu][l+1] = dlp1 * fac4[l]; \n            dlm1 = dl; \n            dl = dlp1; \n        } \n    }", "pragma": "parallel for private(dl dlm1 dlp1 index_mu l ll)", "hash": "6e2b9b709fe0d92625d2c3ec6ff5e5aaafd92875409fd91e2e24ae718eecca60"}
{"code": "for ( int ii = 0; ii < static_cast< int >( rows * columns ); ++ii ) \n\t\t\tsolution[ ii ] -= average;", "pragma": "parallel for ", "hash": "08f9a988b13be616f1e94a9003945a726582de2588f0b2d4f797872e6e3bcaab"}
{"code": "for(int r = 0; r < src.rows; ++r) \n\tfor(int c = 0; c < src.cols; ++c) \n\t{ \n\t\tPoint2f point = Point2i(c, r); \n\t\tfloat distance = venus::distance(point, line); \n\t\t \n \n\t\tdistance = venus::clamp(distance, inner_radius, outer_radius); \n\t\tfloat t = (distance - inner_radius) / (outer_radius - inner_radius); \n\t\tuint8_t x = t * 255; \n\t\tdst.at<Vec4b>(r, c) = Vec4b(x, x, x, 255); \n\t\tif(distance >= outer_radius) \n\t\t\tdst.at<Vec4b>(r, c) = getBlurredValue(src, point, BLUR_RADIUS); \n\t\telse if(distance >= inner_radius) \n\t\t\tdst.at<Vec4b>(r, c) = getBlurredValue(src, point, distance / outer_radius * BLUR_RADIUS); \n\t\telse   \n \n\t\t\tdst.at<Vec4b>(r, c) = src.at<Vec4b>(r, c); \n\t}", "pragma": "parallel for ", "hash": "6cdda8a1400c35b12752c15a87cc66489cba1399ab5caa5208c330ba20771f55"}
{"code": "for(unsigned int ui=0;ui<mesh.size();ui++) \n\t\t{ \n\t\t\tPoint3D centroid; \n\t\t\tmesh[ui].getCentroid(centroid); \n \n\t\t\teyeDists[ui].first=centroid.sqrDist(camOrigin); \n\t\t\teyeDists[ui].second=ui; \n\t\t}", "pragma": "parallel for ", "hash": "ed1a0e99b58c587cf7f7dce8fcea534ac833f7eb56238f36f0ae11fa51822c9d"}
{"code": "for (y=0; y < scans; ++y) \n\t{ \n\t\tint x; \n\t\tint out1 = y * rgbstride * 2; \n\t\tint pos = y * stride * 2; \n\t\tconst unsigned char* chroma_p = chroma + (y * stride); \n \n\t\tfor (x=stride; x != 0; x-=2) \n\t\t{ \n\t\t\tint U = *chroma_p++; \n\t\t\tint V = *chroma_p++; \n \n\t\t\tint RU=yuv2rgbtable_ru[U];  \n \n\t\t\tint GU=yuv2rgbtable_gu[U]; \n\t\t\tint GV=yuv2rgbtable_gv[V]; \n\t\t\tint BV=yuv2rgbtable_bv[V]; \n \n\t\t\t \n \n\t\t\tint Y=yuv2rgbtable_y[luma[pos]]; \n \n\t\t\tvideo[out1]=CLAMP((Y + RU)>>16); \n\t\t\tvideo[out1+1]=CLAMP((Y - GV - GU)>>16); \n\t\t\tvideo[out1+2]=CLAMP((Y + BV)>>16); \n \n\t\t\tY=yuv2rgbtable_y[luma[stride+pos]]; \n \n\t\t\tvideo[out1+rgbstride]=CLAMP((Y + RU)>>16); \n\t\t\tvideo[out1+1+rgbstride]=CLAMP((Y - GV - GU)>>16); \n\t\t\tvideo[out1+2+rgbstride]=CLAMP((Y + BV)>>16); \n \n\t\t\tpos++; \n\t\t\tout1+=3; \n \n\t\t\tY=yuv2rgbtable_y[luma[pos]]; \n \n\t\t\tvideo[out1]=CLAMP((Y + RU)>>16); \n\t\t\tvideo[out1+1]=CLAMP((Y - GV - GU)>>16); \n\t\t\tvideo[out1+2]=CLAMP((Y + BV)>>16); \n \n\t\t\tY=yuv2rgbtable_y[luma[stride+pos]]; \n \n\t\t\tvideo[out1+rgbstride]=CLAMP((Y + RU)>>16); \n\t\t\tvideo[out1+1+rgbstride]=CLAMP((Y - GV - GU)>>16); \n\t\t\tvideo[out1+2+rgbstride]=CLAMP((Y + BV)>>16); \n \n\t\t\tout1+=3; \n\t\t\tpos++; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "a86fe9a0ac7577c44eca1ca4c6cdb39d4d9d18db28e214dbf1565e539c54a0bf"}
{"code": "for(int y = 0; y < Y; y++) { \n        for(int x = 0; x < X; x++) { \n            ivec I = points.get_neighbours(lats[y][x], lons[y][x], radius); \n            if(min_num <= 0 || I.size() >= min_num) { \n                vec curr(I.size()); \n                for(int i = 0; i < I.size(); i++) { \n                    curr[i] = values[I[i]]; \n                } \n                output[y][x] = gridpp::calc_statistic(curr, statistic); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "9c16952ffde299260ea869159f839257fbda524e6def94df14767c3f948a2a33"}
{"code": "for(index i = 0; i < mat.nbrows; i++) { \n\t\t\tzz[i] = scale[i]*rr[i]; \n\t\t}", "pragma": "parallel for simd ", "hash": "7690832d06dfac5ecf785032988bf8afd2a298e948ecffe74dd2a5cdcc6a77cb"}
{"code": "for ( lp = 0; lp < nplev; lp++ ) \n    { \n      pres = plev[lp]; \n      nxl  = nx + lp*ngp; \n      ptl  = pt + lp*ngp; \n      for ( i = 0; i < ngp; i++ ) \n\t{ \n\t  if ( nxl[i] == -1 ) \n\t    ptl[i] = missval; \n\t  else \n\t    { \n\t      nl = nxl[i] * ngp + i; \n\t      nh = nl + ngp; \n\t      if ( nh >= ngp*nhlev ) \n\t\tptl[i] = gt[nl]; \n\t      else \n\t\tptl[i] =  gt[nl] + (pres-hyb_press[nl]) \n\t\t       * (gt[nh] - gt[nl]) / (hyb_press[nh] - hyb_press[nl]); \n\t    } \n\t} \n    }", "pragma": "parallel for private(     i nh nl nxl pres ptl)", "hash": "80f04d2745d90e20b3bfa6db8121f16868fca8e771f7c04dd22a2b89d6c1a51a"}
{"code": "for(i2=1; i2<nxpad-2; i2++) \n\tfor(i1=1; i1<nzpad-2; i1++) \n\t{ \n\t\tDiffVz_z = c1*(Vz[i2][i1+1]-Vz[i2][i1])+c2*(Vz[i2][i1+2]-Vz[i2][i1-1]); \n\t\tDiffVx_z = c1*(Vx[i2][i1+1]-Vx[i2][i1])+c2*(Vx[i2][i1+2]-Vx[i2][i1-1]); \n\t\tDiffVz_x = c1*(Vz[i2+1][i1]-Vz[i2][i1])+c2*(Vz[i2+2][i1]-Vz[i2-1][i1]); \n\t\tDiffVx_x = c1*(Vx[i2+1][i1]-Vx[i2][i1])+c2*(Vx[i2+2][i1]-Vx[i2-1][i1]); \n \n\t\t \n \n\t\ttmpxz=(_dz*DiffVx_z+_dx*DiffVz_x); \n\t\ttmpxx=(_dx*DiffVx_x+_dz*DiffVz_z); \n\t\ttmpzz=(_dx*DiffVx_x+_dz*DiffVz_z); \n\t\tTxz[i2][i1]+=dt*( vs[i2][i1]*taus[i2][i1]*tmpxz+ Rxz[i2][i1] ); \n\t\tTxx[i2][i1]+=dt*( vp[i2][i1]*taup[i2][i1]*tmpxx-2.*vs[i2][i1]*taus[i2][i1]*_dz*DiffVz_z+ Rxx[i2][i1] ); \n\t\tTzz[i2][i1]+=dt*( vp[i2][i1]*taup[i2][i1]*tmpzz-2.*vs[i2][i1]*taus[i2][i1]*_dx*DiffVx_x+ Rzz[i2][i1] ); \n \n\t\ttmp=dt*tauo[i2][i1]; \n\t\tRxz[i2][i1]=( (1.-0.5*tmp)*Rxz[i2][i1]-tmp*vs[i2][i1]*(taus[i2][i1]-1.)*tmpxz )/(1.+0.5*tmp); \n\t\tRxx[i2][i1]=( (1.-0.5*tmp)*Rxx[i2][i1]-tmp*( vp[i2][i1]*(taup[i2][i1]-1.)*tmpxx-2.*vs[i2][i1]*(taus[i2][i1]-1.)*_dz*DiffVz_z ) )/(1.+0.5*tmp); \n\t\tRzz[i2][i1]=( (1.-0.5*tmp)*Rzz[i2][i1]-tmp*( vp[i2][i1]*(taup[i2][i1]-1.)*tmpzz-2.*vs[i2][i1]*(taus[i2][i1]-1.)*_dx*DiffVx_x ) )/(1.+0.5*tmp); \n\t}", "pragma": "parallel for private(    diffvx_x diffvx_z diffvz_x diffvz_z i1 i2 tmp tmpxx tmpxz tmpzz)", "hash": "b3e92e21a3e4e171c6dc705bef7ba485dde5496d07e598cedfa6aee007d14903"}
{"code": "for(i = 0; i < h->total_count; i+=1) { \n\t\tdouble current = rmsummary_get_int_field_by_offset(h->summaries_sorted[i], h->offset); \n\t\tdouble wall_time; \n\t\tif(cumulative) { \n\t\t\twall_time = 1; \n\t\t} else { \n\t\t\twall_time = h->summaries_sorted[i]->wall_time; \n\t\t} \n \n\t\tusage += current * wall_time; \n\t}", "pragma": "parallel for reduction(+: usage) private(i)", "hash": "1978e25c7d53c84826b967d8f2163baa29b1b9f28efca43eb5d7c2bbf72475b0"}
{"code": "for (j = i; j <i + 1; j++) { \n\tfor (k = 0; k < i; k++) { \n\t    B[i][j] += alpha * A[i][k] * B[j][k]; \n\t} \n    }", "pragma": "parallel for private(k)", "hash": "3d3240dd9c329499afdfbaf3b7f6200c95682e6c67daba12fffeae0bc9e533a2"}
{"code": "for (unsigned y=0; y<h; y++) { \n\t\tfor (unsigned x=0; x<w; x++) { \n\t\t\tunsigned spos = x + y*w; \n\t\t\tunsigned dpos = (w-x-1) + y*w; \n\t\t\timage[dpos] = src[spos]; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "2bd1de43f7c99f7af10bd78b2505726556faa55e099903ab594106c755cd8ff6"}
{"code": "for(i2=nb; i2<nx+nb; i2++) \n\tfor(i1=nb; i1<nz+nb; i1++) \n\t{ \n\t\tdiff1=1.125*(p[i2][i1+1]-p[i2][i1])-0.041666666666667*(p[i2][i1+2]-p[i2][i1-1]); \n\t\tdiff2=1.125*(p[i2+1][i1]-p[i2][i1])-0.041666666666667*(p[i2+2][i1]-p[i2-1][i1]); \n\t\tdiff1*=_dz; \n\t\tdiff2*=_dx; \n\t\tvz[i2][i1]-=dt*diff1; \n\t\tvx[i2][i1]-=dt*diff2; \n\t}", "pragma": "parallel for private(diff1 diff2 i1 i2)", "hash": "c8b20ccc2ef93fd489c6d663e8f93e0c8306cc4e7b861c03e6ffbc1479184843"}
{"code": "for (size_t i = i_start; i < i_end; i++) { \n        int64_t id = iterations * n_samples_ + i; \n        uint64_t seed = init_seed(id, STREAM_VOLUME); \n \n        p.n_coord() = 1; \n        Position xi {prn(&seed), prn(&seed), prn(&seed)}; \n        p.r() = lower_left_ + xi * (upper_right_ - lower_left_); \n        p.u() = {0.5, 0.5, 0.5}; \n \n         \n \n        if (!exhaustive_find_cell(p)) \n          continue; \n \n        if (domain_type_ == TallyDomain::MATERIAL) { \n          if (p.material() != MATERIAL_VOID) { \n            for (int i_domain = 0; i_domain < n; i_domain++) { \n              if (model::materials[p.material()]->id_ == \n                  domain_ids_[i_domain]) { \n                this->check_hit( \n                  p.material(), indices[i_domain], hits[i_domain]); \n                break; \n              } \n            } \n          } \n        } else if (domain_type_ == TallyDomain::CELL) { \n          for (int level = 0; level < p.n_coord(); ++level) { \n            for (int i_domain = 0; i_domain < n; i_domain++) { \n              if (model::cells[p.coord(level).cell]->id_ == \n                  domain_ids_[i_domain]) { \n                this->check_hit( \n                  p.material(), indices[i_domain], hits[i_domain]); \n                break; \n              } \n            } \n          } \n        } else if (domain_type_ == TallyDomain::UNIVERSE) { \n          for (int level = 0; level < p.n_coord(); ++level) { \n            for (int i_domain = 0; i_domain < n; ++i_domain) { \n              if (model::universes[p.coord(level).universe]->id_ == \n                  domain_ids_[i_domain]) { \n                check_hit(p.material(), indices[i_domain], hits[i_domain]); \n                break; \n              } \n            } \n          } \n        } \n      }", "pragma": "for ", "hash": "09c1d9541527974521685b08201134efb635171c7d13678164f05679b63ebc67"}
{"code": "for (int h = 0; h < nframes_block - 1; ++h) { \n      msd_[h][0] = 0.0; \n      msd_[h][1] = 0.0; \n      msd_[h][2] = 0.0; \n \n      if (vtag_) { \n        sdvar_[h][0] = 0.0; \n        sdvar_[h][1] = 0.0; \n        sdvar_[h][2] = 0.0; \n      } \n \n       \n \n      for (auto i = 0; i < nframes_block - h - 1; ++i) { \n        auto j = i + h + 1; \n \n         \n \n        for (auto mi = 0; mi < nmol; ++mi) { \n          auto dx = tc.cxx(0, mi, j) - tc.cxx(0, mi, i); \n          auto dy = tc.cxx(1, mi, j) - tc.cxx(1, mi, i); \n          auto dz = tc.cxx(2, mi, j) - tc.cxx(2, mi, i); \n \n          msd_[h][0] += dx * dx; \n          msd_[h][1] += dy * dy; \n          msd_[h][2] += dz * dz; \n \n          if (vtag_) { \n            sdvar_[h][0] += std::pow(dx, 4.0); \n            sdvar_[h][1] += std::pow(dy, 4.0); \n            sdvar_[h][2] += std::pow(dz, 4.0); \n          } \n        } \n      } \n \n      num_of_measure_[h] = (nframes_block - h - 1) * nmol; \n \n      time_gap_[h] = dt_ * (h + 1); \n \n      msd_[h][0] /= num_of_measure_[h]; \n      msd_[h][1] /= num_of_measure_[h]; \n      msd_[h][2] /= num_of_measure_[h]; \n      msd_[h][3] = (msd_[h][0] + msd_[h][1] + msd_[h][2]) / 3.0; \n \n      dcoeff_[h] = msd_[h][3] / 2.0 / time_gap_[h] * \n                   ang2_per_ps_to_10_n5_cm2_per_s; \n \n      if (vtag_) { \n        sdvar_[h][0] = \n          sdvar_[h][0] / num_of_measure_[h] - msd_[h][0] * msd_[h][0]; \n        sdvar_[h][1] = \n          sdvar_[h][1] / num_of_measure_[h] - msd_[h][1] * msd_[h][1]; \n        sdvar_[h][2] = \n          sdvar_[h][2] / num_of_measure_[h] - msd_[h][2] * msd_[h][2]; \n        sdvar_[h][3] = \n          (sdvar_[h][0] + sdvar_[h][1] + sdvar_[h][2]) / 3.0 + ZERO; \n \n        derr_[h] = std::sqrt(sdvar_[h][3] / num_of_measure_[h]) / 2.0 / \n                   time_gap_[h] * ang2_per_ps_to_10_n5_cm2_per_s; \n      } \n    }", "pragma": "parallel for ", "hash": "9c753d9184d341964671bd8c2696cd6c81cb92cdfe41c1ece2de7a689360d837"}
{"code": "for (long int i=0;i<NumberofCommands;i++) {\r \n        string command = commandsArray[i];         \r \n        \r \n        if (VERBOSE_LEVEL == 2) {\r \n\r \n            int thread_no = omp_get_thread_num();\r \n\r \n            #pragma omp critical (standard_error)\r \n            {\r \n                cerr << \"CMD[\" << i << \"], thread[\" << thread_no << \"]: \" << command << endl;\r \n            }\r \n        }\r \n        \r \n        int ret = -1;\r \n        int try_count = 0;\r \n        while (ret != 0 && try_count < max_retries) {\r \n            ret = system(command.c_str());\r \n            if (ret != 0 && try_count < max_retries) {\r \n                try_count++;\r \n                cerr << \"warning, cmd: \" << command << \" failed with ret: \" << ret << \", going to retry.\" << endl;\r \n                system(\"sleep 10\");  \n \n            }\r \n        }\r \n        \r \n         \n \n        if (WIFSIGNALED(ret) &&\r \n            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)) {\r \n            #pragma omp critical (exit_critical)\r \n            exit(ret);  \n \n        }\r \n        else if (ret != 0) {\r \n                        \r \n            #pragma omp critical (capture_failed_command)\r \n            {\r \n                num_failed_commands++;\r \n                failedCommands.push_back(command);\r \n            }\r \n            \r \n\r \n            if (VERBOSE_LEVEL == 2) {\r \n                #pragma omp critical (standard_error)\r \n                {\r \n                    cerr << \"FAILURE:[\" << i << \"]  \" << command << endl;\r \n                }\r \n            }\r \n\r \n        }\r \n        else {\r \n            #pragma omp critical (report_success)\r \n            {\r \n                num_succeeded_commands++;\r \n            \r \n                successfully_completed_fh << command << endl;\r \n            }\r \n                \r \n            if (VERBOSE_LEVEL == 2) {\r \n            #pragma omp critical (standard_error)\r \n                cerr << \"SUCCESS:[\" << i << \"]  \" << command << endl;\r \n            }\r \n        }\r \n        \r \n        if (VERBOSE_LEVEL == 1) {\r \n            \r \n            stringstream ss;\r \n            ss << \"\\rsucceeded(\" << num_succeeded_commands << \")\";\r \n            if (num_failed_commands > 0) {\r \n                ss << \", failed(\" << num_failed_commands << \")\";\r \n            }\r \n            int total_executed = num_succeeded_commands + num_failed_commands + count_skip;\r \n            float percent_done = (float)total_executed/ (NumberofCommands+count_skip) * 100;\r \n            \r \n            ss << \"   \" << percent_done << \"% completed.    \";\r \n\r \n            #pragma omp critical (standard_error)\r \n            cerr << ss.str();\r \n        }\r \n    }", "pragma": "parallel for ", "hash": "ca97a52bc5805be9626e75c40cc183c7179d70d7754ee0faa0530d312754f19a"}
{"code": "for( \n\t\t\t\t\t\tunsigned int m = 0; \n\t\t\t\t\t\tm < momentums.size(); \n\t\t\t\t\t\tm++ \n\t\t\t\t\t){ \n\t\t\t\t\t\tconst vector<double> &momentum \n\t\t\t\t\t\t\t= momentums[m]; \n \n\t\t\t\t\t\tdouble exponent = 0.; \n\t\t\t\t\t\tfor( \n\t\t\t\t\t\t\tunsigned int c = 0; \n\t\t\t\t\t\t\tc < momentums[m].size(); \n\t\t\t\t\t\t\tc++ \n\t\t\t\t\t\t){ \n\t\t\t\t\t\t\texponent += momentum[c]*coordinatesDifference[c]; \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tamplitudes[m] \n\t\t\t\t\t\t\t+= matrixElement*exp( \n\t\t\t\t\t\t\t\ti*exponent \n\t\t\t\t\t\t\t); \n\t\t\t\t\t}", "pragma": "parallel for ", "hash": "6b7610d112352ecf47a9e2df7a161120f143835d7c498be8af84f254bb6392ff"}
{"code": "for (int i; i < 10; i++) \n    c[i] = a[i];", "pragma": "parallel for simd ", "hash": "d354bd868832b9c2e836093f762ac7cbae16fab798aac93881c38793a4133d1a"}
{"code": "for(int i = 0; i < arr.size(); ++i) \n\t\tresult(i) = std::tanh(arr(i));", "pragma": "parallel for ", "hash": "d5aece9ef9e5c2a78035fdc6ceab9d8d007e77ce9bf1cd3c84c9425187df4f17"}
{"code": "for (size_t y = 0; y < Y.getRows(); ++y) { \n        size_t x = 0; \n        for (; x < Y.getCols() - 3; x+=4) { \n            avLumThrv += xlogf(LVFU(Y(x,y)) + c1v); \n        } \n        for (; x < Y.getCols(); ++x) { \n            avLumThr += xlogf(Y(x,y) + 1e-4f); \n        } \n    }", "pragma": "for ", "hash": "440edadfe3f7c423acdd3237d3dab9d785ba96e07cd29e1fbb8fa8d0416af5cb"}
{"code": "for (index i = 0; i < v1.getDimension(); ++i) { \n\t\tresult += v1[i] * v2[i]; \n\t}", "pragma": "parallel for reduction(+:result) ", "hash": "722bd3dfbe4d92a54ad4ffca1612fe3d442e47b0d226724c3a60a1f55885c9a6"}
{"code": "for (int iframe = 0; iframe < n_frames; iframe++) { \n\t\tif (!early_binning) { \n\t\t\tNewFFT::FourierTransform(Iframes[iframe](), Fframes[iframe]); \n\t\t} else { \n\t\t\tMultidimArray<fComplex> Fframe; \n\t\t\tNewFFT::FourierTransform(Iframes[iframe](), Fframe); \n\t\t\tFframes[iframe].reshape(ny, nx / 2 + 1); \n\t\t\tcropInFourierSpace(Fframe, Fframes[iframe]); \n\t\t} \n\t\tIframes[iframe].clear();  \n \n\t}", "pragma": "parallel for ", "hash": "6ec3a63da6d8d3954b320bd94fd776d392d84624985bff2d1c068b08af097374"}
{"code": "for (int i = 0; i < tree->num_leaves(); ++i) { \n    OMP_LOOP_EX_BEGIN(); \n    data_size_t cnt_leaf_data = 0; \n    auto tmp_idx = data_partition_->GetIndexOnLeaf(i, &cnt_leaf_data); \n    double sum_grad = 0.0f; \n    double sum_hess = kEpsilon; \n    for (data_size_t j = 0; j < cnt_leaf_data; ++j) { \n      auto idx = tmp_idx[j]; \n      sum_grad += gradients[idx]; \n      sum_hess += hessians[idx]; \n    } \n    double output; \n    if ((config_->path_smooth > kEpsilon) & (i > 0)) { \n      output = FeatureHistogram::CalculateSplittedLeafOutput<true, true, true>( \n          sum_grad, sum_hess, config_->lambda_l1, config_->lambda_l2, \n          config_->max_delta_step, config_->path_smooth, cnt_leaf_data, tree->leaf_parent(i)); \n    } else { \n      output = FeatureHistogram::CalculateSplittedLeafOutput<true, true, false>( \n          sum_grad, sum_hess, config_->lambda_l1, config_->lambda_l2, \n          config_->max_delta_step, config_->path_smooth, cnt_leaf_data, 0); \n    } \n    auto old_leaf_output = tree->LeafOutput(i); \n    auto new_leaf_output = output * tree->shrinkage(); \n    tree->SetLeafOutput(i, config_->refit_decay_rate * old_leaf_output + (1.0 - config_->refit_decay_rate) * new_leaf_output); \n    OMP_LOOP_EX_END(); \n  }", "pragma": "parallel for ", "hash": "bda8f469526ace5bb9335ad36414d9e9d58fc7e1d6f508b04b453157b1814fed"}
{"code": "for(long i=0;i<n;i+=d) \n\t{ \n\t\tif(gr->Stop)\tcontinue; \n\t\tmglPoint p = mglPoint(x->vthr(i),y->vthr(i),z->vthr(i)); \n\t\tlong pp = gr->AddPnt(p,gr->GetC(ss,c->vthr(i)),mglPoint(NAN),a?gr->GetA(a->vthr(i)):-1); \n\t\tgr->mark_plot(pp, mk); \n\t}", "pragma": "parallel for ", "hash": "4c9a5f12407578337130f3c15fa74308d88af0699cd9a34958bcd820ca6f325d"}
{"code": "for (int i = 0; i < (int) m_attachments.size(); i++) \n\t\t{ \n\t\t\tconst unsigned int pindex = m_attachments[i].m_index; \n\t\t\tconst unsigned int triindex = m_attachments[i].m_triIndex; \n\t\t\tconst Real *bary = m_attachments[i].m_bary; \n \n\t\t\tconst unsigned int indexA = faces[3 * triindex] + m_indexOffset; \n\t\t\tconst unsigned int indexB = faces[3 * triindex + 1] + m_indexOffset; \n\t\t\tconst unsigned int indexC = faces[3 * triindex + 2] + m_indexOffset; \n \n\t\t\tconst Vector3r &a = pd.getPosition(indexA); \n\t\t\tconst Vector3r &b = pd.getPosition(indexB); \n\t\t\tconst Vector3r &c = pd.getPosition(indexC); \n\t\t\tVector3r p2 = bary[0] * a + bary[1] * b + bary[2] * c; \n\t\t\tVector3r n = bary[0] * normals[faces[3 * triindex]] + bary[1] * normals[faces[3 * triindex + 1]] + bary[2] * normals[faces[3 * triindex + 2]]; \n\t\t\tn.normalize(); \n \n\t\t\tVector3r &p = m_visVertices.getPosition(pindex); \n\t\t\tp = p2 - n*m_attachments[i].m_dist; \n\t\t}", "pragma": "for ", "hash": "a7989026a051f7b5d2c042e025ac165aeaaf65e5a8f097898f6a87453c2c4142"}
{"code": "for (i = 0; i < _nx; i++){ \n\t\t\t\tfor (j = 0; j < _ny; j++){ \n\t\t\t\t\tfor (k = 0; k < _nz; k++){ \n\t\t\t\t\t\tdata3D[i][k][nz-1-j] = pmtmp->data3D[i][j][k]; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for private(i j k)", "hash": "92fdbd9d818fc66185555d7b5f7b9dfc535a7c09b2827d962f3f541c9959e7b9"}
{"code": "for (int i=0; i<_N_real; i++){ \n\t\t\t\tparticles[i].ax = 0.;  \n\t\t\t\tparticles[i].ay = 0.;  \n\t\t\t\tparticles[i].az = 0.;  \n\t\t\t\tcs[i].x = 0.; \n\t\t\t\tcs[i].y = 0.; \n\t\t\t\tcs[i].z = 0.; \n\t\t\t}", "pragma": "parallel for ", "hash": "78b4aa4c85c281548d97b461dd290011dbb58642d7b8296886df4982248c0079"}
{"code": "for (i = 0; i < n_cell; i++) { \n            v_array[step * n_cell + i] = calc_iz_c_core(v_array - n_cell, &(u_array[i]), const_table); \n        }", "pragma": "parallel for ", "hash": "2e4c1157ee236891158d04269acd1f3e692181e384d465fd611e192543dfed55"}
{"code": "for (int i = 0; i < nReaches; ++i) \n\t\t{ \n\t\t\tint reachIndex = it->second[i];  \n \n \n\t\t\tNutriChannelRouting(reachIndex); \n\t\t}", "pragma": "parallel for ", "hash": "c14f56d29a04aaf3166717470aa99ae398f23194d4f58ee6532f115aaa0b3b1f"}
{"code": "for (int i = 0; i < height; i++) { \n    auto depth_pixel_index = i * width; \n \n    for (int j = 0; j < width; j++, depth_pixel_index++) { \n      if (p_depth_frame[depth_pixel_index] == 0) { \n        pointcloud->points[(size_t)(depth_pixel_index)].x = m_invalidDepthValue; \n        pointcloud->points[(size_t)(depth_pixel_index)].y = m_invalidDepthValue; \n        pointcloud->points[(size_t)(depth_pixel_index)].z = m_invalidDepthValue; \n        continue; \n      } \n \n       \n \n      auto pixels_distance = m_depthScale * p_depth_frame[depth_pixel_index]; \n \n      float points[3]; \n      const float pixel[] = {(float)j, (float)i}; \n      rs2_deproject_pixel_to_point(points, &m_depthIntrinsics, pixel, pixels_distance); \n \n      if (pixels_distance > m_max_Z) \n        points[0] = points[1] = points[2] = m_invalidDepthValue; \n \n      pointcloud->points[(size_t)(depth_pixel_index)].x = points[0]; \n      pointcloud->points[(size_t)(depth_pixel_index)].y = points[1]; \n      pointcloud->points[(size_t)(depth_pixel_index)].z = points[2]; \n    } \n  }", "pragma": "parallel for ", "hash": "0aca1eb62122e8ea3fe304d27147453c6efb56b2a832e294fc951e222d1cc549"}
{"code": "for(i=0;i<*neq;i++){ \n\t    b[i]=b1[i]; \n\t    for(j=1;j<num_cpus;j++){ \n\t\tb[i]+=b1[i+j**neq]; \n\t    } \n\t}", "pragma": "for ", "hash": "1224fb8362033dfe6fbd4bd9b19fa5087d2a0b314be666a796f3ecf1cc7f7279"}
{"code": "for(int i=0;i<nth;i++) { \n    p[i].resize(3); \n    p[i][0]=new JFDigestor(Pa+Pb); \n    p[i][1]=new KFDigestor(Pa,kfrac,false); \n    p[i][2]=new KFDigestor(Pb,kfrac,false); \n  }", "pragma": "parallel for ", "hash": "d73fe70cf0808a3fd6e50c4d7da6d41d1865a371d1c4bcda3180b1d9f912b0e2"}
{"code": "for (int j = 0; j < row; j++) \n\t\t{ \n\t\t\tfloat* sp1_R0 = src.ptr<float>(j); \n\t\t\tfloat* sp1_R1 = src.ptr<float>(j) + 4; \n\t\t\tfloat* sp1_R2 = src.ptr<float>(j) + 8; \n\t\t\tfloat* sp2_R0 = src.ptr<float>(j) + 12; \n\t\t\tfloat* sp2_R1 = src.ptr<float>(j) + 16; \n\t\t\tfloat* sp2_R2 = src.ptr<float>(j) + 20; \n \n\t\t\tfloat* dp = dest.ptr<float>(0) + j * 12; \n \n\t\t\t__m128 mSum0 = _mm_setzero_ps(); \n\t\t\t__m128 mSum1 = _mm_setzero_ps(); \n\t\t\t__m128 mSum2 = _mm_setzero_ps(); \n\t\t\t__m128 mTmp0, mTmp1, mTmp2; \n \n\t\t\tmTmp0 = _mm_set1_ps((float)(r + 1)); \n\t\t\tmSum0 = _mm_mul_ps(mTmp0, _mm_load_ps(sp1_R0)); \n\t\t\tmSum1 = _mm_mul_ps(mTmp0, _mm_load_ps(sp1_R1)); \n\t\t\tmSum2 = _mm_mul_ps(mTmp0, _mm_load_ps(sp1_R2)); \n\t\t\tfor (int i = 1; i <= r; i++) \n\t\t\t{ \n\t\t\t\tmSum0 = _mm_add_ps(mSum0, _mm_load_ps(sp2_R0)); \n\t\t\t\tsp2_R0 += 12; \n\t\t\t\tmSum1 = _mm_add_ps(mSum1, _mm_load_ps(sp2_R1)); \n\t\t\t\tsp2_R1 += 12; \n\t\t\t\tmSum2 = _mm_add_ps(mSum2, _mm_load_ps(sp2_R2)); \n\t\t\t\tsp2_R2 += 12; \n\t\t\t} \n\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum0, mDiv)); \n\t\t\tdp += 4; \n\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum1, mDiv)); \n\t\t\tdp += 4; \n\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum2, mDiv)); \n\t\t\tdp += step - 8; \n \n\t\t\tmTmp0 = _mm_load_ps(sp1_R0); \n\t\t\tmTmp1 = _mm_load_ps(sp1_R1); \n\t\t\tmTmp2 = _mm_load_ps(sp1_R2); \n\t\t\tfor (int i = 1; i <= r; i++) \n\t\t\t{ \n\t\t\t\tmSum0 = _mm_add_ps(mSum0, _mm_load_ps(sp2_R0)); \n\t\t\t\tsp2_R0 += 12; \n\t\t\t\tmSum0 = _mm_sub_ps(mSum0, mTmp0); \n\t\t\t\tmSum1 = _mm_add_ps(mSum1, _mm_load_ps(sp2_R1)); \n\t\t\t\tsp2_R1 += 12; \n\t\t\t\tmSum1 = _mm_sub_ps(mSum1, mTmp1); \n\t\t\t\tmSum2 = _mm_add_ps(mSum2, _mm_load_ps(sp2_R2)); \n\t\t\t\tsp2_R2 += 12; \n\t\t\t\tmSum2 = _mm_sub_ps(mSum2, mTmp2); \n \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum0, mDiv)); \n\t\t\t\tdp += 4; \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum1, mDiv)); \n\t\t\t\tdp += 4; \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum2, mDiv)); \n\t\t\t\tdp += step - 8; \n\t\t\t} \n\t\t\tfor (int i = r + 1; i < col / 4 - r - 1; i++) \n\t\t\t{ \n\t\t\t\tmSum0 = _mm_add_ps(mSum0, _mm_load_ps(sp2_R0)); \n\t\t\t\tsp2_R0 += 12; \n\t\t\t\tmSum0 = _mm_sub_ps(mSum0, _mm_load_ps(sp1_R0)); \n\t\t\t\tsp1_R0 += 12; \n\t\t\t\tmSum1 = _mm_add_ps(mSum1, _mm_load_ps(sp2_R1)); \n\t\t\t\tsp2_R1 += 12; \n\t\t\t\tmSum1 = _mm_sub_ps(mSum1, _mm_load_ps(sp1_R1)); \n\t\t\t\tsp1_R1 += 12; \n\t\t\t\tmSum2 = _mm_add_ps(mSum2, _mm_load_ps(sp2_R2)); \n\t\t\t\tsp2_R2 += 12; \n\t\t\t\tmSum2 = _mm_sub_ps(mSum2, _mm_load_ps(sp1_R2)); \n\t\t\t\tsp1_R2 += 12; \n \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum0, mDiv)); \n\t\t\t\tdp += 4; \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum1, mDiv)); \n\t\t\t\tdp += 4; \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum2, mDiv)); \n\t\t\t\tdp += step - 8; \n\t\t\t} \n\t\t\tmTmp0 = _mm_load_ps(sp2_R0); \n\t\t\tmTmp1 = _mm_load_ps(sp2_R1); \n\t\t\tmTmp2 = _mm_load_ps(sp2_R2); \n\t\t\tfor (int i = col / 4 - r - 1; i < col / 4; i++) \n\t\t\t{ \n\t\t\t\tmSum0 = _mm_add_ps(mSum0, mTmp0); \n\t\t\t\tmSum0 = _mm_sub_ps(mSum0, _mm_load_ps(sp1_R0)); \n\t\t\t\tsp1_R0 += 12; \n\t\t\t\tmSum1 = _mm_add_ps(mSum1, mTmp1); \n\t\t\t\tmSum1 = _mm_sub_ps(mSum1, _mm_load_ps(sp1_R1)); \n\t\t\t\tsp1_R1 += 12; \n\t\t\t\tmSum2 = _mm_add_ps(mSum2, mTmp2); \n\t\t\t\tmSum2 = _mm_sub_ps(mSum2, _mm_load_ps(sp1_R2)); \n\t\t\t\tsp1_R2 += 12; \n \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum0, mDiv)); \n\t\t\t\tdp += 4; \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum1, mDiv)); \n\t\t\t\tdp += 4; \n\t\t\t\t_mm_stream_ps(dp, _mm_mul_ps(mSum2, mDiv)); \n\t\t\t\tdp += step - 8; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "5b24a55c7a3007c3372a3dbbe458bb9265fa4bac30410789ddf8802f5274e000"}
{"code": "for(int iit=0; iit<objects.size(); iit++) { \n\t  objects[iit]->intProperty[ckey]=(*f)(objects[iit]->intProperty[ckey]); \n\t}", "pragma": "parallel for ", "hash": "7421c9db55f71e469c71bc5861858020290a0ea4d872dc5a33b46a49a2005571"}
{"code": "for (i = 0; i < N; i++) { \n    if (xd[i] == ZERO) \n      val = ONE; \n    else \n      zd[i] = ONE/xd[i]; \n  }", "pragma": "parallel for private(i)", "hash": "7e39e70967c9b07bd5e04eb12d8156e36f8a1ad5b15106ed9cb4409045e3eb66"}
{"code": "for (Iter1 I; I < end1; ++I) { \n  }", "pragma": "for simd ", "hash": "464a8668b2d1d46070969ab9b8b0aa552076ab8061ecac2dbfcdaae96b71a9c9"}
{"code": "for (i = 0; i < dims[2][0]; i++) { \n\tii =  (i+1+xstart[2]-2+NX/2)%NX - NX/2; \n\tii2 = ii*ii; \n\tfor (j = 0; j < dims[2][1]; j++) { \n            jj = (j+1+ystart[2]-2+NY/2)%NY - NY/2; \n            ij2 = jj*jj+ii2; \n            for (k = 0; k < dims[2][2]; k++) { \n\t\tkk = (k+1+zstart[2]-2+NZ/2)%NZ - NZ/2; \n\t\tindexmap[k][j][i] = kk*kk+ij2; \n\t    } \n\t} \n    }", "pragma": "for ", "hash": "9b1e00a4d4445759a46ff6746034b7ab20e8875f9c93d667ee219a395278cf6e"}
{"code": "for (int igloc = 0; igloc < gvec_coarse_p_.gvec().count(); igloc++) { \n             \n \n            veff_vec_[4]->f_pw_local(igloc) = \n                ctx_.theta_pw(gvec_dense_p.gvec().gvec_base_mapping(igloc) + gvec_dense_p.gvec().offset()); \n        }", "pragma": "parallel for ", "hash": "ca26ef3959d3a34516e0b6667dba57fdecfc79cc7554f5f828d2573c553861d7"}
{"code": "for(i = 0; i < 2; ++i) \n\t{ \n\t\tSHA512_Context ctx; \n\t\topt_SHA512_Init(&ctx); \n\t\topt_SHA512_Update(&ctx, pos[i], len[i]); \n\t\topt_SHA512_Final(&ctx, cksum[i]); \n\t}", "pragma": "parallel for ", "hash": "502845b1a36d0f5ebe44133c76b5a3bdc43e763156042644bcc05fc47712586a"}
{"code": "for (ii = 0; ii < numtoread; ii++) { \n            const unsigned char uctmp = ctmp[ii]; \n            const int jj = 4 * ii; \n            cdata[jj] = ((uctmp >> 0x06) & 0x03); \n            cdata[jj + 1] = ((uctmp >> 0x04) & 0x03); \n            cdata[jj + 2] = ((uctmp >> 0x02) & 0x03); \n            cdata[jj + 3] = (uctmp & 0x03); \n        }", "pragma": "parallel for ", "hash": "f6d10d6a5513364f34d0b5b73cb8631c3e4acf18cc7457ad936d5a556dcd52b6"}
{"code": "for (ompIndexType k = 0; k < elementCount; k++) { \n        switch (outputClass) { \n        case NLS_UINT8: { \n            auto* ptrUINT8 = static_cast<uint8*>(ptrVoid); \n            ptrUINT8[k] = ((uint8*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        case NLS_UINT16: { \n            auto* ptrUINT16 = static_cast<uint16*>(ptrVoid); \n            ptrUINT16[k] = ((uint16*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        case NLS_UINT32: { \n            auto* ptrUINT32 = static_cast<uint32*>(ptrVoid); \n            ptrUINT32[k] = ((uint32*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        case NLS_UINT64: { \n            auto* ptrUINT64 = static_cast<uint64*>(ptrVoid); \n            ptrUINT64[k] = ((uint64*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        case NLS_INT8: { \n            int8* ptrINT8 = static_cast<int8*>(ptrVoid); \n            ptrINT8[k] = ((int8*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        case NLS_INT16: { \n            auto* ptrINT16 = static_cast<int16*>(ptrVoid); \n            ptrINT16[k] = ((int16*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        case NLS_INT32: { \n            auto* ptrINT32 = static_cast<int32*>(ptrVoid); \n            ptrINT32[k] = ((int32*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        case NLS_INT64: { \n            auto* ptrINT64 = static_cast<int64*>(ptrVoid); \n            ptrINT64[k] = ((int64*)(data + offset + (sizeType * k)))[0]; \n        } break; \n        default: { \n        } break; \n        } \n    }", "pragma": "parallel for ", "hash": "37028a82bb4c0118e76ea4d5eeee9cf999107b7c73e64a842c1f7d9da225a5cc"}
{"code": "for (j=0; j<N; j++) \n        zd_dev[j] = (a * xd_dev[j]) + yd_dev[j];", "pragma": "parallel for ", "hash": "3c655432f7d09407863c662083bd0101a0cd7f63bcc2f4eca1c5c465f11534b7"}
{"code": "for (index = 0; index < count; index++) \n\t{ \n\t\tSHA512_CTX ctx; \n \n\t\tSHA512_Init( &ctx ); \n\t\tSHA512_Update( &ctx, ipad[index], PAD_SIZE ); \n\t\tSHA512_Update( &ctx, cursalt, strlen( (char*) cursalt) ); \n\t\tSHA512_Final( (unsigned char*) crypt_key[index], &ctx); \n \n\t\tSHA512_Init( &ctx ); \n\t\tSHA512_Update( &ctx, opad[index], PAD_SIZE ); \n\t\tSHA512_Update( &ctx, crypt_key[index], BINARY_SIZE); \n\t\tSHA512_Final( (unsigned char*) crypt_key[index], &ctx); \n\t}", "pragma": "parallel for ", "hash": "fa39772dd4e0f8c67c5aefd57dbd108d579fc48438c19ebbecabec97df8bdb2a"}
{"code": "for (uint32_t rr=0; rr<ph; rr+=stepH) \n\t{ \n\t\tfor (uint32_t cc=0; cc<pw; cc+=stepW) \n\t\t{ \n\t\t\tuint32_t ioi = rr*pw+cc; \n\t\t\tif (ioi<rgbd_size) \n\t\t\t{ \n\t\t\t\tif (std::isnan(points->operator[](ioi).x) or std::isnan(points->operator[](ioi).y) or std::isnan(points->operator[](ioi).z)) \n\t\t\t\t\tcontinue; \n\t\t\t\tif (points->operator[](ioi).z<0) \n\t\t\t\t\tcontinue; \n\t\t\t\tconst QVec pRobot = (TRr * QVec::vec4(points->operator[](ioi).x, points->operator[](ioi).y, points->operator[](ioi).z, 1)).fromHomogeneousCoordinates(); \n\t\t\t\tif (not ( (pRobot(1)>=minHeight and pRobot(1)<=maxHeight) or (pRobot(1)<minHeightNeg) )) \n\t\t\t\t\tcontinue; \n\t\t\t\tconst QVec mapCoord = fromReferenceToImageCoordinates(pRobot, \"robot\"); \n\t\t\t\tif (mapCoord(0)<=2 or mapCoord(0)>=bins-2 or mapCoord(2)<=2 or mapCoord(2)>=bins-2) \n\t\t\t\t\tcontinue; \n\t\t\t\taddToRGBDsCoordinates(mapCoord(0), mapCoord(2)); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "cac737ccef8f2603dbb3aa76b78a4de28e7774494983573f9f4a82ef4a820c0f"}
{"code": "for(int i=1;i<gnr();i++) \n      (*this)[i].invert_2x2();", "pragma": "parallel for ", "hash": "066889354caaf1abd4bfd6926c713ceae2509b12323719779fcf107deaf21b51"}
{"code": "for (size_t i=0; i<env_cells_x; i++) \n\t{ \n\t\tfor (size_t j=0; j<env_cells_y; j++) \n\t\t{ \n\t\t\tfor (size_t k=0; k<env_cells_z; k++) \n\t\t\t{ \n\t\t\t\tC[indexFrom3D(i,j,k)] = 0.0; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "833335f1544bad91fc3fa1619b36ed17a11671801cfff1be45534a48b144179d"}
{"code": "for (int i = 0; i < nlocal; i++) { \n    if (mask[i] & groupbit) { \n      const double dtfm = dtf / rmass[i]; \n      v[i].x += dtfm*f[i].x; \n      v[i].y += dtfm*f[i].y; \n      v[i].z += dtfm*f[i].z; \n      angmom[i].x += dtf*torque[i].x; \n      angmom[i].y += dtf*torque[i].y; \n      angmom[i].z += dtf*torque[i].z; \n    } \n  }", "pragma": "parallel for ", "hash": "1f22a7b8cbca434791b9572f62b748dd9c98ef16a1493004a7d8c0f5343b6c25"}
{"code": "for(long i=0;i<m;i++)\tif(mgl_isnan(x.a[i])) \n\t\tfor(long j=0;j<mm;j++)\ty.a[i+m*j] = NAN;", "pragma": "parallel for ", "hash": "b2417d3cec92b101c90d246a764d2c9ba20d02692d4da9f42d50d6c1b780e91d"}
{"code": "for ( int i = 0; i < n; i++ ) { \n    for ( int j = 0; j < m; j++ ) { \n      z[i][j] = 0; \n      for ( int t = 0; t < k; t++ ) { \n        z[i][j] += x[t][j] * y[i][t];  \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "4adad6a19a3019a77c9660bdc3a1f78b635232988b810021bef1f4c9a88e27a3"}
{"code": "for (v = 0; v < V*K; v++){ \n            c = a/((al_K + al_1*Q[v])*b); \n            if (Ga[v] > c){ Ga[v] = c; } \n        }", "pragma": "parallel for private( c v)", "hash": "b93a6f61ae543654ec7a6430de51b44bc9a63e11ec681fa423ceb2b438ba2c27"}
{"code": "for (i_j = 0; i_j < size * size; i_j++) { \n        size_t i = i_j / size; \n        size_t j = i_j % size; \n        size_t k; \n        double dist = 0; \n        for (k = 0; k < dim; k++) { \n            double diff = vectors[i * dim + k] - vectors[j * dim + k]; \n            dist += diff * diff; \n        } \n        matrix[i_j] = dist; \n    }", "pragma": "parallel for private(i_j)", "hash": "71f014d8aa0e758d47fb59738eb0f38671ebc7f86a0644701b1131197a6b7ada"}
{"code": "for(idx = 0; idx < count; ++idx) \n  { \n    dst[idx] = (short )WLZ_RGBA_MODULUS(src[idx]); \n  }", "pragma": "parallel for ", "hash": "fa6fcb3749d20ab522cc4d5992a071c8edcfc05e979b143ca97a4051842fb263"}
{"code": "for (vertex_t ivert = 0; ivert < vert_count; ++ivert) { \n\t\t\t \n \n\t\t\tsdegree_t m = g->vert_degree[ivert]; \n            if(m < kc && m > 0) { \n                 \n \n                g->vert_degree[ivert] = GONE; \n                ++t_front_count; \n\t\t\t\tactive_vert->set_bit(ivert); \n            }  \n             \n \n        }", "pragma": "for reduction(+:t_front_count) ", "hash": "b72be178093b79dc77873dd4450fa7d0d71ebd31467152644410a7499f06bb63"}
{"code": "for(int i=0;i<blocks.size();i++) \n      blocks[i].reset(new BlockType(blockmat_copy[i]));", "pragma": "parallel for ", "hash": "1ecf536159247f497c597b68e587eb61fd459b63c70529f1aef49ed81fbb0c63"}
{"code": "for (int  _T_i1 = 0; (_T_i1 < (((R + 8) / 32) - 1)); _T_i1 = (_T_i1 + 1)) \n  { \n    float  Ux_lPyramid_L2[4][8][131]; \n    float  U_lPyramid_L2[4][8][262]; \n    float  outLPyramid_L2[8][262]; \n    for (int  _T_i2 = 0; (_T_i2 <= ((C - 48) / 1024)); _T_i2 = (_T_i2 + 1)) \n    { \n      if ((_T_i1 >= 1)) \n      { \n        for (int  _i0 = 0; (_i0 <= 3); _i0 = (_i0 + 1)) \n        { \n          int  _ct32754 = ((((8 * _T_i1) + 6) < ((R / 4) - 14))? ((8 * _T_i1) + 6): ((R / 4) - 14)); \n          for (int  _i1 = (8 * _T_i1); (_i1 <= _ct32754); _i1 = (_i1 + 2)) \n          { \n            int  _ct32755 = ((((256 * _T_i2) + 260) < ((C / 4) - 12))? ((256 * _T_i2) + 260): ((C / 4) - 12)); \n            int  _ct32756 = ((6 > (256 * _T_i2))? 6: (256 * _T_i2)); \n            #pragma ivdep \n            for (int  _i2 = _ct32756; (_i2 <= _ct32755); _i2 = (_i2 + 2)) \n            { \n              Ux_lPyramid_L2[_i0][((-8 * _T_i1) + _i1)][((_i2 / 2) - (128 * _T_i2))] = ((0.25f * D_gPyramid_L3[(((_i0 * (((((R / 8) - 2) - 1) + 1) * ((((C / 8) - 2) - 1) + 1))) + ((((_i1 / 2) - 1) - 1) * ((((C / 8) - 2) - 1) + 1))) + (-1 + (_i2 / 2)))]) + (0.75f * D_gPyramid_L3[(((_i0 * (((((R / 8) - 2) - 1) + 1) * ((((C / 8) - 2) - 1) + 1))) + (((_i1 / 2) - 1) * ((((C / 8) - 2) - 1) + 1))) + (-1 + (_i2 / 2)))])); \n            } \n          } \n        } \n      } \n      for (int  _i0 = 0; (_i0 <= 3); _i0 = (_i0 + 1)) \n      { \n        int  _ct32757 = ((((8 * _T_i1) + 7) < ((R / 4) - 14))? ((8 * _T_i1) + 7): ((R / 4) - 14)); \n        int  _ct32758 = ((7 > ((8 * _T_i1) + 1))? 7: ((8 * _T_i1) + 1)); \n        for (int  _i1 = _ct32758; (_i1 <= _ct32757); _i1 = (_i1 + 2)) \n        { \n          int  _ct32759 = ((((256 * _T_i2) + 260) < ((C / 4) - 12))? ((256 * _T_i2) + 260): ((C / 4) - 12)); \n          int  _ct32760 = ((6 > (256 * _T_i2))? 6: (256 * _T_i2)); \n          #pragma ivdep \n          for (int  _i2 = _ct32760; (_i2 <= _ct32759); _i2 = (_i2 + 2)) \n          { \n            Ux_lPyramid_L2[_i0][((-8 * _T_i1) + _i1)][((_i2 / 2) - (128 * _T_i2))] = ((0.25f * D_gPyramid_L3[(((_i0 * (((((R / 8) - 2) - 1) + 1) * ((((C / 8) - 2) - 1) + 1))) + ((((_i1 / 2) + 1) - 1) * ((((C / 8) - 2) - 1) + 1))) + (-1 + (_i2 / 2)))]) + (0.75f * D_gPyramid_L3[(((_i0 * (((((R / 8) - 2) - 1) + 1) * ((((C / 8) - 2) - 1) + 1))) + (((_i1 / 2) - 1) * ((((C / 8) - 2) - 1) + 1))) + (-1 + (_i2 / 2)))])); \n          } \n        } \n      } \n      for (int  _i0 = 0; (_i0 <= 3); _i0 = (_i0 + 1)) \n      { \n        int  _ct32761 = ((((8 * _T_i1) + 7) < ((R / 4) - 14))? ((8 * _T_i1) + 7): ((R / 4) - 14)); \n        int  _ct32762 = ((7 > (8 * _T_i1))? 7: (8 * _T_i1)); \n        for (int  _i1 = _ct32762; (_i1 <= _ct32761); _i1 = (_i1 + 1)) \n        { \n          int  _ct32763 = ((((256 * _T_i2) + 260) < ((C / 4) - 14))? ((256 * _T_i2) + 260): ((C / 4) - 14)); \n          int  _ct32764 = ((7 > ((256 * _T_i2) + 1))? 7: ((256 * _T_i2) + 1)); \n          #pragma ivdep \n          for (int  _i2 = _ct32764; (_i2 <= _ct32763); _i2 = (_i2 + 1)) \n          { \n            float  _ct32765 = ((0.25f * Ux_lPyramid_L2[_i0][((-8 * _T_i1) + _i1)][((((-256 * _T_i2) + _i2) / 2) - 1)]) + (0.75f * Ux_lPyramid_L2[_i0][((-8 * _T_i1) + _i1)][(((-256 * _T_i2) + _i2) / 2)])); \n            float  _ct32766 = ((0.25f * Ux_lPyramid_L2[_i0][((-8 * _T_i1) + _i1)][((((-256 * _T_i2) + _i2) / 2) + 1)]) + (0.75f * Ux_lPyramid_L2[_i0][((-8 * _T_i1) + _i1)][(((-256 * _T_i2) + _i2) / 2)])); \n            float  _ct32767 = (((_i2 % 2) == 0)? _ct32765: _ct32766); \n            U_lPyramid_L2[_i0][((-8 * _T_i1) + _i1)][((-256 * _T_i2) + _i2)] = (D_gPyramid_L2[(((_i0 * (((((R / 4) - 2) - 1) + 1) * ((((C / 4) - 2) - 1) + 1))) + ((-1 + _i1) * ((((C / 4) - 2) - 1) + 1))) + (-1 + _i2))] - _ct32767); \n          } \n        } \n      } \n      int  _ct32768 = ((((8 * _T_i1) + 7) < ((R / 4) - 14))? ((8 * _T_i1) + 7): ((R / 4) - 14)); \n      int  _ct32769 = ((7 > (8 * _T_i1))? 7: (8 * _T_i1)); \n      for (int  _i1 = _ct32769; (_i1 <= _ct32768); _i1 = (_i1 + 1)) \n      { \n        int  _ct32770 = ((((256 * _T_i2) + 259) < ((C / 4) - 14))? ((256 * _T_i2) + 259): ((C / 4) - 14)); \n        int  _ct32771 = ((7 > ((256 * _T_i2) + 2))? 7: ((256 * _T_i2) + 2)); \n        #pragma ivdep \n        for (int  _i2 = _ct32771; (_i2 <= _ct32770); _i2 = (_i2 + 1)) \n        { \n          int  _ct32772 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32773 = 0; \n          int  _ct32774 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32772: _ct32773); \n          int  _ct32775 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32776 = 0; \n          int  _ct32777 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32775: _ct32776); \n          int  _ct32778 = _ct32777; \n          int  _ct32779 = 2; \n          int  _ct32780 = ((_ct32774 < 2)? _ct32778: _ct32779); \n          int  _ct32781 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32782 = 0; \n          int  _ct32783 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32781: _ct32782); \n          int  _ct32784 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32785 = 0; \n          int  _ct32786 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32784: _ct32785); \n          int  _ct32787 = _ct32786; \n          int  _ct32788 = 2; \n          int  _ct32789 = ((_ct32783 < 2)? _ct32787: _ct32788); \n          int  _ct32790 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32791 = 0; \n          int  _ct32792 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32790: _ct32791); \n          int  _ct32793 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32794 = 0; \n          int  _ct32795 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32793: _ct32794); \n          int  _ct32796 = _ct32795; \n          int  _ct32797 = 2; \n          int  _ct32798 = ((_ct32792 < 2)? _ct32796: _ct32797); \n          int  _ct32799 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32800 = 0; \n          int  _ct32801 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32799: _ct32800); \n          int  _ct32802 = (int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))); \n          int  _ct32803 = 0; \n          int  _ct32804 = (((int ) ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3))) > 0)? _ct32802: _ct32803); \n          int  _ct32805 = _ct32804; \n          int  _ct32806 = 2; \n          int  _ct32807 = ((_ct32801 < 2)? _ct32805: _ct32806); \n          outLPyramid_L2[((-8 * _T_i1) + _i1)][((-256 * _T_i2) + _i2)] = (((1.0f - ((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3)) - _ct32780)) * U_lPyramid_L2[_ct32789][((-8 * _T_i1) + _i1)][((-256 * _T_i2) + _i2)]) + (((D_inGPyramid_L2[(((-1 + _i1) * ((((C / 4) - 2) - 1) + 1)) + (-1 + _i2))] * (float ) (3)) - _ct32798) * U_lPyramid_L2[(_ct32807 + 1)][((-8 * _T_i1) + _i1)][((-256 * _T_i2) + _i2)])); \n        } \n      } \n      int  _ct32808 = ((((8 * _T_i1) + 7) < ((R / 4) - 14))? ((8 * _T_i1) + 7): ((R / 4) - 14)); \n      int  _ct32809 = ((7 > (8 * _T_i1))? 7: (8 * _T_i1)); \n      for (int  _i1 = _ct32809; (_i1 <= _ct32808); _i1 = (_i1 + 1)) \n      { \n        int  _ct32810 = ((((256 * _T_i2) + 258) < ((C / 4) - 14))? ((256 * _T_i2) + 258): ((C / 4) - 14)); \n        int  _ct32811 = ((7 > ((256 * _T_i2) + 3))? 7: ((256 * _T_i2) + 3)); \n        #pragma ivdep \n        for (int  _i2 = _ct32811; (_i2 <= _ct32810); _i2 = (_i2 + 1)) \n        { \n          float  _ct32812 = ((0.25f * Ux_outGPyramid_L2[(((-7 + _i1) * (((((C / 8) - 8) + 2) - 3) + 1)) + (((_i2 / 2) - 1) - 3))]) + (0.75f * Ux_outGPyramid_L2[(((-7 + _i1) * (((((C / 8) - 8) + 2) - 3) + 1)) + ((_i2 / 2) - 3))])); \n          float  _ct32813 = ((0.25f * Ux_outGPyramid_L2[(((-7 + _i1) * (((((C / 8) - 8) + 2) - 3) + 1)) + (((_i2 / 2) + 1) - 3))]) + (0.75f * Ux_outGPyramid_L2[(((-7 + _i1) * (((((C / 8) - 8) + 2) - 3) + 1)) + ((_i2 / 2) - 3))])); \n          float  _ct32814 = (((_i2 % 2) == 0)? _ct32812: _ct32813); \n          outGPyramid_L2[(((_i1 - 7) * (((((C / 4) - 16) + 2) - 7) + 1)) + (_i2 - 7))] = (outLPyramid_L2[((-8 * _T_i1) + _i1)][((-256 * _T_i2) + _i2)] + _ct32814); \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "91c3b5076aa7e9062177366887d6ce2761e0c457632bf01be88b74f94a1839fa"}
{"code": "for (j = 1; j <= grid_points[1]-2; j++) { \n      for (k = 1; k <= grid_points[2]-2; k++) { \n\tn = (m-3+1)*5; \n\trhs[m][i][j][k] = rhs[m][i][j][k] - \n\t  lhs[n+3][i][j][k]*rhs[m][i1][j][k]; \n      } \n    }", "pragma": "for ", "hash": "8d6b045197e9782c52005251f98ff93246f1bcfa45ae208b420d792badeeb064"}
{"code": "for(ix=0; ix<padnx; ix++){ \n\t\t\tfor(iz=0; iz<padnz; iz++){ \n\t\t\t\tcur[ix][iz]=nxt[ix][iz]+ud[ix][iz]/2.0 + v0[ix][iz]*dt; \n\t\t\t} \n\t\t}", "pragma": "parallel for private( ix iz)", "hash": "28483e6a079f9f549035217fbf21a6d8b1431c23602191395ef7ae3ec14e8e21"}
{"code": "for(int i = 0; i < nlocal; i++) { \n      int* neighptr = &neighbors[i * maxneighs]; \n \n \n      int n = 0; \n \n      const MMD_float xtmp = x[i * 3 + 0]; \n      const MMD_float ytmp = x[i * 3 + 1]; \n      const MMD_float ztmp = x[i * 3 + 2]; \n \n \n \n \n      const int ibin = coord2bin(xtmp, ytmp, ztmp); \n \n      for(int k = 0; k < nstencil; k++) { \n        const int jbin = ibin + stencil[k]; \n \n        int* loc_bin = &bins[jbin * atoms_per_bin]; \n \n        if(ibin == jbin) \n          for(int m = 0; m < bincount[jbin]; m++) { \n            const int j = loc_bin[m]; \n \n \n            if(((j == i) || (halfneigh && !ghost_newton && (j < i)) || \n                (halfneigh && ghost_newton && ((j < i) || ((j >= nlocal) && \n                                               ((x[j * 3 + 2] < ztmp) || (x[j * 3 + 2] == ztmp && x[j * 3 + 1] < ytmp) || \n                                                (x[j * 3 + 2] == ztmp && x[j * 3 + 1] == ytmp && x[j * 3 + 0] < xtmp))))))) continue; \n \n            const MMD_float delx = xtmp - x[j * 3 + 0]; \n            const MMD_float dely = ytmp - x[j * 3 + 1]; \n            const MMD_float delz = ztmp - x[j * 3 + 2]; \n            const MMD_float rsq = delx * delx + dely * dely + delz * delz; \n \n            if((rsq <= cutneighsq)) neighptr[n++] = j; \n          } \n        else { \n          for(int m = 0; m < bincount[jbin]; m++) { \n            const int j = loc_bin[m]; \n \n            if(halfneigh && !ghost_newton && (j < i)) continue; \n \n            const MMD_float delx = xtmp - x[j * 3 + 0]; \n            const MMD_float dely = ytmp - x[j * 3 + 1]; \n            const MMD_float delz = ztmp - x[j * 3 + 2]; \n            const MMD_float rsq = delx * delx + dely * dely + delz * delz; \n \n            if((rsq <= cutneighsq)) neighptr[n++] = j; \n          } \n        } \n      } \n \n      numneigh[i] = n; \n \n      if(n >= maxneighs) { \n        resize = 1; \n \n        if(n >= new_maxneighs) new_maxneighs = n; \n      } \n    }", "pragma": "for ", "hash": "4d78c536f8d892866ab3e82454c9a1179b5daa8efc27513e5e483b5dedc61d06"}
{"code": "for (size_t n=0; n < imageBufferSize; n++) \n      { \n         imageBuffer[n] = oneVal; \n      }", "pragma": "parallel for ", "hash": "bf091215737f532ed9d9ed955ff0f3079af7df7defeece054a262bb5f43f8ac5"}
{"code": "for( size_t i = 0; i < inNodes.size(); ++i ) \n    { \n        compactTract meanTract( getMeanTract( inNodes[i] ) ); \n        meanTractFM.writeNodeTract( inNodes[i], meanTract ); \n \n#pragma omp critical \n        progSize += m_tree.getNode( inNodes[i] ).getSize();  \n \n \n#pragma omp single nowait  \n \n        if( m_verbose ) \n        { \n            time_t currentTime( time( NULL ) ); \n            if( currentTime - lastTime > 1 ) \n            { \n                 \n \n                lastTime = currentTime; \n                size_t currentCount( progSize ); \n                float progress = ( currentCount ) * 100. / ( totalSize ); \n                int expected_remain( difftime( currentTime, startTime ) * ( ( 100. - progress ) / progress ) ); \n                std::cout << \"\\r\" << ( int )progress << \" % Completed (\" << currentCount << \" single voxels accounted for)\" \n                                << \". Expected remaining time: \"; \n                std::cout << expected_remain / 3600 << \"h \" << ( expected_remain % 3600 ) / 60 << \"' \" << ( ( expected_remain \n                                % 3600 ) % 60 ) << \"\\\"  \" << std::flush; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "d9ac763a7b632f51c6f1aba1103f589c5fda37e546eb798876d144fe4331e292"}
{"code": "for( int k=0; k<numNeurons; k++ ) V[k] = constantValue;", "pragma": "parallel for ", "hash": "dc1b5ecaca93f2f23e65b2c95ca0436484dbacd8476c66a965ffa3263cfe90bd"}
{"code": "for (int i = 0; i < nlocal; i++) { \n      double buf[3]; \n      if (mask[i] & groupbit) { \n        temperature->remove_bias_thr(i,&v[i].x,buf); \n        v[i].x *= factor0; \n        v[i].y *= factor1; \n        v[i].z *= factor2; \n        if (pstyle == TRICLINIC) { \n          v[i].x += -dthalf*(v[i].y*omega_dot[5] + v[i].z*omega_dot[4]); \n          v[i].y += -dthalf*v[i].z*omega_dot[3]; \n        } \n        v[i].x *= factor0; \n        v[i].y *= factor1; \n        v[i].z *= factor2; \n        temperature->restore_bias_thr(i,&v[i].x,buf); \n      } \n    }", "pragma": "parallel for ", "hash": "cdc39cbd466e32a44d9bf3d3831cf3ea8a70f9c087030abbf2dcbbc0ed891099"}
{"code": "for (int j = 0; j < src.rows; j++) \n\t\t\t\t{ \n\t\t\t\t\tconst float* s = im.ptr<float>(j + r) + r; \n\t\t\t\t\tfloat* dst = destf.ptr<float>(j); \n\t\t\t\t\tfor (int i = 0; i < src.cols; i += 32) \n\t\t\t\t\t{ \n\t\t\t\t\t\tconst float* si = s + i; \n\t\t\t\t\t\tconst __m256 mt0 = _mm256_lddqu_ps(si); \n\t\t\t\t\t\tconst __m256 mt1 = _mm256_lddqu_ps(si + 8); \n\t\t\t\t\t\tconst __m256 mt2 = _mm256_lddqu_ps(si + 16); \n\t\t\t\t\t\tconst __m256 mt3 = _mm256_lddqu_ps(si + 24); \n\t\t\t\t\t\t__m256 msum0 = mt0; \n\t\t\t\t\t\t__m256 msum1 = mt1; \n\t\t\t\t\t\t__m256 msum2 = mt2; \n\t\t\t\t\t\t__m256 msum3 = mt3; \n\t\t\t\t\t\tfor (int k = 0; k < d; k++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t__m256 mv0 = _mm256_sub_ps(_mm256_lddqu_ps(si + offset[k] + 0), mt0); \n\t\t\t\t\t\t\t__m256 mv1 = _mm256_sub_ps(_mm256_lddqu_ps(si + offset[k] + 8), mt1); \n\t\t\t\t\t\t\t__m256 mv2 = _mm256_sub_ps(_mm256_lddqu_ps(si + offset[k] + 16), mt2); \n\t\t\t\t\t\t\t__m256 mv3 = _mm256_sub_ps(_mm256_lddqu_ps(si + offset[k] + 24), mt3); \n\t\t\t\t\t\t\t__m256 mw0 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(mv0)), 4)); \n\t\t\t\t\t\t\t__m256 mw1 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(mv1)), 4)); \n\t\t\t\t\t\t\t__m256 mw2 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(mv2)), 4)); \n\t\t\t\t\t\t\t__m256 mw3 = _mm256_mul_ps(_mm256_set1_ps(space[k]), _mm256_i32gather_ps(rweight, _mm256_cvtps_epi32(_mm256_abs_ps(mv3)), 4)); \n\t\t\t\t\t\t\tmsum0 = _mm256_fmadd_ps(mw0, mv0, msum0); \n\t\t\t\t\t\t\tmsum1 = _mm256_fmadd_ps(mw1, mv1, msum1); \n\t\t\t\t\t\t\tmsum2 = _mm256_fmadd_ps(mw2, mv2, msum2); \n\t\t\t\t\t\t\tmsum3 = _mm256_fmadd_ps(mw3, mv3, msum3); \n\t\t\t\t\t\t} \n\t\t\t\t\t\t_mm256_storeu_ps(dst + i + 0, msum0); \n\t\t\t\t\t\t_mm256_storeu_ps(dst + i + 8, msum1); \n\t\t\t\t\t\t_mm256_storeu_ps(dst + i + 16, msum2); \n\t\t\t\t\t\t_mm256_storeu_ps(dst + i + 24, msum3); \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "parallel for ", "hash": "bbf9a4fd02f3a438cdb1b8caba30efe57b054ec76ad678d806bc86ba4f75cf6f"}
{"code": "for(int j = 0; j < roi_out->height; j++) \n  { \n \n    float *buf_in = in + (size_t)ch * roi_in->width * j; \n    float *buf_out = out + (size_t)ch * roi_out->width * j; \n    dt_aligned_pixel_t cam; \n \n    for(int i = 0; i < roi_out->width; i++, buf_in += ch, buf_out += ch) \n    { \n \n       \n \n       \n \n       \n \n      for(int c = 0; c < 3; c++) \n        cam[c] = (d->lut[c][0] >= 0.0f) ? ((buf_in[c] < 1.0f) ? lerp_lut(d->lut[c], buf_in[c]) \n                                                              : dt_iop_eval_exp(d->unbounded_coeffs[c], buf_in[c])) \n                                        : buf_in[c]; \n \n      if(!clipping) \n      { \n        __m128 xyz \n            = _mm_add_ps(_mm_add_ps(_mm_mul_ps(cm0, _mm_set1_ps(cam[0])), _mm_mul_ps(cm1, _mm_set1_ps(cam[1]))), \n                         _mm_mul_ps(cm2, _mm_set1_ps(cam[2]))); \n        _mm_stream_ps(buf_out, dt_XYZ_to_Lab_sse2(xyz)); \n      } \n      else \n      { \n        __m128 nrgb \n            = _mm_add_ps(_mm_add_ps(_mm_mul_ps(nm0, _mm_set1_ps(cam[0])), _mm_mul_ps(nm1, _mm_set1_ps(cam[1]))), \n                         _mm_mul_ps(nm2, _mm_set1_ps(cam[2]))); \n        __m128 crgb = _mm_min_ps(_mm_max_ps(nrgb, _mm_set1_ps(0.0f)), _mm_set1_ps(1.0f)); \n        __m128 xyz = _mm_add_ps(_mm_add_ps(_mm_mul_ps(lm0, _mm_shuffle_ps(crgb, crgb, _MM_SHUFFLE(0, 0, 0, 0))), \n                                           _mm_mul_ps(lm1, _mm_shuffle_ps(crgb, crgb, _MM_SHUFFLE(1, 1, 1, 1)))), \n                                _mm_mul_ps(lm2, _mm_shuffle_ps(crgb, crgb, _MM_SHUFFLE(2, 2, 2, 2)))); \n        _mm_stream_ps(buf_out, dt_XYZ_to_Lab_sse2(xyz)); \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "a2ea7b0ee7cb6e7cf040d9605afb1ad27b70e69283dbc7ff3ab5877712052e00"}
{"code": "for (int k = 0; k < K; k++) { \n    for (int n = 0; n < TNfp; n++) { \n      const size_t sk = k * TNfp + n; \n      const double nx_ = nx[sk]; \n \n      evaluateSurfFluxTerm(hcrit, gra, fm.h[sk], fm.hu[sk], flux.h + sk, \n                           flux.hu + sk); \n \n      flux.h[sk] *= nx_; \n      flux.hu[sk] *= nx_; \n    } \n  }", "pragma": "parallel for ", "hash": "ae9d3daa9c1ebad9bd9b4950d258b4519f0d8220775586a575bfb4280951db1f"}
{"code": "for (int i=0;i<dat->raw_nchan;i++) \n    for (int j=0;j<dat->ndata;j++) { \n      if (dat->raw_data[i][j]>sigs[i]) \n        dat->raw_data[i][j]=0;        \n    }", "pragma": "parallel for ", "hash": "d74b521366b59a3330b0bca665fa8474798bad659f854ad9f93e87c58c248d28"}
{"code": "for(size_t i = 0; i < pop->n_demes; i++) { \n    evoasm_deme_t *deme = &pop->demes[i]; \n \n    for(size_t j = 0; j < n_minor_gens; j++) { \n      retvals[i] = evoasm_deme_eval(deme, false); \n      if(!retvals[i]) { \n        errors[i] = *evoasm_get_last_error(); \n        break; \n      } \n      retvals[i] = evoasm_deme_next_gen(&pop->demes[i], false); \n      if(!retvals[i]) { \n        errors[i] = *evoasm_get_last_error(); \n        break; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "646f8da6512802c84a47ad518e73f09d0007a6258b0880f37889baa720789fe2"}
{"code": "for ( i = 0; i < n; ++i ) { \n            f = 4 * i; \n            pf = 4 * i * chp; \n            qf = 4 * i * chq; \n            r[f + 0] =  p[pf + 0] * q[qf + 3] + p[pf + 1] * q[qf + 2] \n                - p[pf + 2] * q[qf + 1] + p[pf + 3] * q[qf + 0]; \n            r[f + 1] = -p[pf + 0] * q[qf + 2] + p[pf + 1] * q[qf + 3] \n                + p[pf + 2] * q[qf + 0] + p[pf + 3] * q[qf + 1]; \n            r[f + 2] =  p[pf + 0] * q[qf + 1] - p[pf + 1] * q[qf + 0] \n                + p[pf + 2] * q[qf + 3] + p[pf + 3] * q[qf + 2]; \n            r[f + 3] = -p[pf + 0] * q[qf + 0] - p[pf + 1] * q[qf + 1] \n                - p[pf + 2] * q[qf + 2] + p[pf + 3] * q[qf + 3]; \n        }", "pragma": "parallel for private(   f i pf qf)", "hash": "395c96c2aada9a3954c8836974f69e06ca73c1c6ebea04fc28ee37fd2cafc079"}
{"code": "for (unsigned int iii = 0; iii < statusVec.size(); iii++) { \n\t\tif (statusVec.at(iii) != 0) { \n\t\t\tif (((pts.at(iii).x - floor(pts.at(iii).x)) == 0.0) && ((pts.at(iii).y - floor(pts.at(iii).y)) == 0.0)) statusVec.at(iii) = 0; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "6abdb8c833bf31ead8c7124549bd6d8fd44fbae6ef01243010b68144a1114e4c"}
{"code": "for(int k = 0; k < 4 * npixels; k += 4) \n  { \n    float h, s, l; \n    rgb2hsl(in+k, &h, &s, &l); \n    if(l < data->balance - compress || l > data->balance + compress) \n    { \n      h = l < data->balance ? data->shadow_hue : data->highlight_hue; \n      s = l < data->balance ? data->shadow_saturation : data->highlight_saturation; \n      const double ra = l < data->balance ? CLIP((fabs(-data->balance + compress + l) * 2.0)) \n                               : CLIP((fabs(-data->balance - compress + l) * 2.0)); \n      const double la = (1.0 - ra); \n \n      float DT_ALIGNED_PIXEL mixrgb[3]; \n      hsl2rgb(mixrgb, h, s, l); \n \n      out[k+0] = CLIP(in[k+0] * la + mixrgb[0] * ra); \n      out[k+1] = CLIP(in[k+1] * la + mixrgb[1] * ra); \n      out[k+2] = CLIP(in[k+2] * la + mixrgb[2] * ra); \n      out[k+3] = in[k+3]; \n    } \n    else \n    { \n#pragma omp simd aligned(in, out) \n      for(int c = 0; c < 4; c++) \n      { \n        out[k+c] = in[k+c]; \n      } \n    } \n \n  }", "pragma": "parallel for ", "hash": "5c38b37ce17fe6c8eeffc09e29888fadc4c2ddba26514b4ea7bbdb5554bded1a"}
{"code": "for (size_t i = 0; i < data.get_num_examples(); ++i) \n    { \n        float res = 0; \n        bool goingthrough = true; \n \n        for (size_t l = 0; l < _weak_classifiers.size(); ++l) \n        { \n            res += _weak_classifiers[l]->predict_at_test_time(data.get_integral_image(i)); \n \n            if (use_cascade and res < _weak_classifiers[l]->_cascade_threshold) \n            { \n                goingthrough = false; \n                break; \n            } \n \n        } \n        if (goingthrough) \n        { \n            (data.get_class_label_for_sample(i) == 1) ? tpp++ : fpp++ ; \n        } \n        else \n        { \n            (data.get_class_label_for_sample(i) == -1) ? tnn++ : fnn++ ; \n        } \n    }", "pragma": "parallel for reduction(   +:tpp fnn fpp tnn) ", "hash": "e5e438643b5d14e570f0c333fec6f172f506f080645f07cc3856de36d3951c47"}
{"code": "for (ompIndexType i = 0; i < (ompIndexType)elementCount; i++) { \n        T val = sp[i]; \n        if (!withnan) { \n            if (!std::isnan(val)) { \n                sum += val; \n            } \n        } else { \n            sum += val; \n        } \n    }", "pragma": "parallel for reduction(+ : sum) ", "hash": "130d92ef0fb2deba3d0badd0fd60a1c74a408e7b68a7e9c1064dcc28117e24b8"}
{"code": "for (int i = 0; i < keys.size(); i++){ \n            vector<hash_t> r = calc_hashes(seqs[i], lengths[i], kmer); \n            hashes[i] = &(*r.begin()); \n            hash_lengths[i] = r.size(); \n \n             \n \n            set<hash_t> sample_set (hashes[i], hashes[i] + hash_lengths[i]); \n             \n \n            { \n                for (auto x : sample_set){ \n                     \n \n                     \n \n                    ref_hash_counter.increment( x ); \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "dff5c92f0f41c7049dbb183b6e31e15059f6b533b7d35f4fd0b96fb93dce030b"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t(*res)[i] = (*this)[i] ^ s;", "pragma": "for ", "hash": "170ad17869e22b5239603d79357da229e60dba730e94a5659cb81994b51801a1"}
{"code": "for(int j=0;j<chains;j++) \n    { \n      q = q + double(j); \n      cout << \"Beginning Markov Chain #\" << j << endl; \n      ofstream myfile; \n \n      out << j; \n      s = out.str(); \n      myfile.open ((base+s+end).c_str());      \n       \n      for(int i=0;i<steps;i++) \n\t{ \n\t   \n \n\t  qtilde = nu*nu*(sampleNormal())+q; \n\t   \n\t   \n \n\t  guess = uniform(); \n\t  ratio = std::max(std::min(gauss(mu,std,qtilde)/gauss(mu,std,q), 1.0),0.0); \n\t   \n\t  if(guess < ratio) \n\t    { \n\t       \n \n\t      q=qtilde; \n\t      acc++; \n\t    } \n\t   \n\t  myfile << q << endl; \n\t   \n\t} \n \n      myfile.close();   \n    }", "pragma": "parallel for ", "hash": "3b55b07bc921a2694c605e49821de6b3962ea3e0bef9c1341f567fd65c38d049"}
{"code": "for (i = 0; i < nao; i++) { \n                pao = ao + i * Ngrids; \n                for (j = 0; j < Ngrids; j++) { \n                        aow[i*Ngrids+j] = pao[j] * wv[j]; \n                } \n                for (ic = 1; ic < comp; ic++) { \n                for (j = 0; j < Ngrids; j++) { \n                        aow[i*Ngrids+j] += pao[ic*ao_size+j] * wv[ic*Ngrids+j]; \n                } } \n        }", "pragma": "for ", "hash": "7bfe1ab0a4826dac5127ab9cbf18cb17c920cde5621d43c4be51c33c90d6ebda"}
{"code": "for (ie = 0; ie < nelt; ie++) { \n    for (k = 0; k < LX1; k++) { \n      for (j = 0; j < LX1; j++) { \n        for (i = 0; i < LX1; i++) { \n          pdiff[ie][k][j][i] = dpcelm[ie][k][j][i]*trhs[ie][k][j][i]; \n          rho1               = rho1 + trhs[ie][k][j][i]*pdiff[ie][k][j][i]* \n                                      tmult[ie][k][j][i]; \n        } \n      } \n    } \n  }", "pragma": "for ", "hash": "89d0da719f3d2d6d2485e96990f7a0f078777230874d5b0809ca0d09099aa246"}
{"code": "for (i = 0; i < a_SamplesCount; ++i) \n\t\t{ \n\t\t\ta_InitTime += a_TimeStep; \n\t\t\tdelta = static_cast<double>(i)* InvSamplesCount; \n\t\t\tt = a_InitTime * delta; \n\t\t\ta_Cos.operator[](i) = 2.0 * ::cos((radiolocation::PureCosineWave::TWO_PI*CentralFrequency*t) + a_PhaseTx.operator[](i)); \n\t\t\ta_Sin.operator[](i) = -2.0 * ::sin((radiolocation::PureCosineWave::TWO_PI*CentralFrequency*t) + a_PhaseTx.operator[](i)); \n\t\t\tIQ.operator[](i).operator=({ a_PCTTR.operator[](i).second * a_Cos.operator[](i), \n\t\t\t\ta_PCTTR.operator[](i).second * a_Sin.operator[](i) }); \n\t\t}", "pragma": "parallel for private(  delta i t)", "hash": "c5226b46d063b17caf675279fe99637db721e7a3924e80a43b5656dd71d92716"}
{"code": "for (int i = 0; i < PARTICLESIZE; i++) { \n    bodies[i].r = rand() % 256; \n    bodies[i].g = rand() % 256; \n    bodies[i].b = rand() % 256; \n    bodies[i].pos = vec3((rand() % 1000) - 500, (rand() % 1000) - 500, \n                         (rand() % 1000) - 500); \n    bodiesptrs[i] = &bodies[i]; \n  }", "pragma": "parallel for ", "hash": "1699561d2beb56bff288338d8ca840c2b0c2cb648089345052a2084000f022fa"}
{"code": "for (int32_t i = 0; i < src_dim; i++) { \n      float* cur_col = cols->at(i)->m; \n      vert->at(i)->set(&cur_xyz_data[k][i*3]); \n      cur_col[0] = red_mult * static_cast<float>(cur_image_rgb[k][i*3]) / 255.0f; \n      cur_col[1] = static_cast<float>(cur_image_rgb[k][i*3+1]) / 255.0f; \n      cur_col[2] = green_mult * static_cast<float>(cur_image_rgb[k][i*3+2]) / 255.0f; \n    }", "pragma": "parallel for ", "hash": "f00851b8172c6fd8d7f0edc75bb098062a08b1f516875101644ad61b54ae213a"}
{"code": "for( OMPInt colA=0; colA < nCol; ++colA)  \n \n\t\t    for( OMPInt rIx=0, rowBnCol=0; rIx < rIxEnd; \n\t\t\t rIx += nColEl, rowBnCol += nCol)  \n \n\t\t      { \n\t\t\tTy& resEl = (*res)[ rowBnCol + colA]; \n\t\t\tresEl = 0; \n \n\t\t\tfor( OMPInt i=0; i < nColEl; ++i) \n\t\t\t  resEl += (*this)[ i*nCol+colA] * (*right)[ rIx+i]; \n\t\t      }", "pragma": "for ", "hash": "474039584cf0377d4adb230df3361e2a5d94ddb02f24d7273dc9b579ba19096e"}
{"code": "for (i = 1; i <= 99; i += 1) { \n    for (j = 1; j <= 99; j += 1) { \n      b[i][j] = b[i][j - 1] + 1; \n    } \n  }", "pragma": "parallel for private(i j)", "hash": "32a25d470589d6b593adf83ba4baa22b8832e00952ed80906cffecf9f5db43f9"}
{"code": "for (i = 0; i < Noofelements; i = i + 1) { \n\t\tif (array[i] > cur_max) \n #pragma omp critical \n\t\t\tif (array[i] > cur_max) \n\t\t\t\tcur_max = array[i]; \n\t}", "pragma": "parallel for ", "hash": "8730530054115454d225da7cd19d606357c2ffe0df1d12a80f1f8a06681f16be"}
{"code": "for( int i=0; i<nEl; ++i) \n      (*this)[ i] = log( (*this)[ i]);", "pragma": "parallel for ", "hash": "a43ad3c1074cc3118564dacd85594b1383e74eda215472eb68a3a561ee0483bb"}
{"code": "for (i = 0; i < npx; i++) { \n            if (img[i] < wt) { \n                t = img[i] - y0; \n                s1 = s1 + t; \n                s2 = s2 + t * t; \n                nactive++; \n            } \n        }", "pragma": "parallel for reduction(  + : nactive s1 s2) private(t)", "hash": "8f5387f9b3db84f9eeac5290251ff51d7a28ced10d65033eef9371d1258a91b8"}
{"code": "for(int i = 0; i < numSubspaces(); ++i) \n\t\tgradient.middleRows(from[i], mSubspaces[i].dim()) = \n\t\t\tmSubspaces[i].energyGradient(states.middleRows(from[i], mSubspaces[i].dim()));", "pragma": "parallel for ", "hash": "7d5af0c98de27da69c0f1b2cdd61934b0a9c809b8e83937ce14e48a9ed9d3d5a"}
{"code": "for ( long vIdx = 0; vIdx < static_cast<long>( valCount ); ++vIdx ) \n        { \n            dstFrameData[vIdx] = dsm( se1Data[vIdx], se3Data[vIdx], tanFricAng, cohPrTanFricAngle ); \n        }", "pragma": "parallel for ", "hash": "451316a5c80f4f0ac0092bb6903e2bf58eebb6528f6a2fb3ab9abe2b9db90d0b"}
{"code": "for(i=0;i<imgDim;i++) \n\t\t\t{ \n\t\t\t\tX[0][i] = sol[i] - U1[i] * rhoinv; \n\t\t\t\tX[1][i] = sol[i] - U2[i] * rhoinv; \n\t\t\t\tX[2][i] = sol[i] - U3[i] * rhoinv; \n\t\t\t}", "pragma": "for ", "hash": "35481a8964c506ae1b3fb1f93e9e36d6d886220d6976acded9fcb64c5834120b"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp target enter data map(to: a)  \n \n    ++a; \n  }", "pragma": "for simd ", "hash": "4aa951a2a5346ff1420ab912afe92e49bf1ae20f6c98c659ca48b4a6dffbcd4d"}
{"code": "for (size_t i = 0; i < entries; ++i) { \n            progress.updateProgress(); \n \n            unsigned int key = reader.getDbKey(i); \n            char* data = reader.getData(i, thread_idx); \n            if (*data == '\\0') { \n                continue; \n            } \n \n            bool addStopAtStart = false; \n            bool addStopAtEnd = false; \n            if (addOrfStop == true) { \n                char* headData = header->getDataByDBKey(key, thread_idx); \n                Orf::SequenceLocation loc = Orf::parseOrfHeader(headData); \n                addStopAtStart=!(loc.hasIncompleteStart); \n                addStopAtEnd=!(loc.hasIncompleteEnd); \n            } \n \n             \n \n             \n \n             \n \n            size_t length = reader.getEntryLen(i) - 1; \n            if ((data[length] != '\\n' && length % 3 != 0) && (data[length - 1] == '\\n' && (length - 1) % 3 != 0)) { \n                Debug(Debug::WARNING) << \"Nucleotide sequence entry \" << key << \" length (\" << length << \") is not divisible by three. Adjust length to (length=\" <<  length - (length % 3) << \").\\n\"; \n                length = length - (length % 3); \n            } \n \n            if (length < 3) { \n                Debug(Debug::WARNING) << \"Nucleotide sequence entry \" << key << \" length (\" << length << \") is too short. Skipping entry.\\n\"; \n                continue; \n            } \n \n            if (length > (3 * par.maxSeqLen)) { \n                Debug(Debug::WARNING) << \"Nucleotide sequence entry \" << key << \" length (\" << length << \") is too long. Trimming entry.\\n\"; \n                length = (3 * par.maxSeqLen); \n            } \n \n            char * writeAA; \n            if (addStopAtStart) { \n                aa[0]='*'; \n                writeAA = aa + 1; \n            } else { \n                writeAA = aa; \n            } \n            translateNucl.translate(writeAA, data, length); \n \n            if (addStopAtEnd && writeAA[(length/3)-1]!='*') { \n                writeAA[length/3] = '*'; \n                writeAA[length/3+1] = '\\n'; \n            } else { \n                addStopAtEnd =false; \n                writeAA[length/3] = '\\n'; \n            } \n \n            writer.writeData(aa, (length / 3) + 1 + addStopAtStart + addStopAtEnd, key, thread_idx); \n        }", "pragma": "for ", "hash": "b46f2f041db3ef66c0d2d70b4995997dc31d04d12b49151beb55bc21c14d7742"}
{"code": "for (int i = 0; i < num_threads; ++i) { \n    for (int leaf_num = 0; leaf_num < num_leaves; ++leaf_num) { \n      size_t num_feat = leaf_features[leaf_num].size(); \n      std::fill(XTHX_by_thread_[i][leaf_num].begin(), XTHX_by_thread_[i][leaf_num].begin() + (num_feat + 1) * (num_feat + 2) / 2, 0.0f); \n      std::fill(XTg_by_thread_[i][leaf_num].begin(), XTg_by_thread_[i][leaf_num].begin() + num_feat + 1, 0.0f); \n    } \n  }", "pragma": "parallel for ", "hash": "61a2b33f01b2b716289105efdf0aebedabbd02ce15e51323a82d53ed471056fd"}
{"code": "for (i = 0; i <= MaxRows_ * HalfCols_ - step; i += step) \n\t\tfor (int j = 0; j < nbFilters; ++j) \n\t\t\tfor (int k = 0; k < nbPlanes; ++k) \n\t\t\t\tfor (int l = 0; l < step; ++l) \n\t\t\t\t\tsums[j][k](i + l) = \n\t\t\t\t\t\tfilters[j].first(i + l).cwiseProduct(planes_[k](i + l)).sum();", "pragma": "parallel for private(i)", "hash": "4de2c4261d59009533375095f7ce853cb42f1a1ca8ade5f02ffa7ef338b1d9a5"}
{"code": "for (auto iCol = 0; iCol < iW; ++iCol) { \n        T sum = 0; \n        for (auto oPlane = 0; oPlane < oP; ++oPlane) { \n          for (auto oRow = std::max(0, (iRow - kH + dH) / dH); \n               oRow < std::min(iRow / dH + 1, oH); ++oRow) { \n            for (auto oCol = std::max(0, (iCol - kW + dW ) / dW); \n                 oCol < std::min(iCol / dW + 1, oW); ++oCol) { \n              auto kRow = iRow - dH * oRow; \n              auto kCol = iCol - dW * oCol; \n              sum += gradOutput.at({oPlane, oRow, oCol}) \n                * weight.at({oPlane, oRow, oCol, iPlane, kRow, kCol}); \n            } \n          } \n        } \n        gradInput.at({iPlane, iRow, iCol}) = sum; \n      }", "pragma": "parallel for ", "hash": "5b5335c8af630b2b78f8db6ff0a5bf87bd3554578fdca1474456c5b3c994452c"}
{"code": "for(size_t r = 0; r < STEPS; r++) \n      for(size_t g = 0; g < STEPS; g++) \n        for(size_t b = 0; b < STEPS; b++) \n        { \n          const dt_aligned_pixel_t rgb = { (float)r / (float)(STEPS - 1), (float)g / (float)(STEPS - 1), \n                                           (float)b / (float)(STEPS - 1), 0.f }; \n          dt_aligned_pixel_t XYZ = { 0.f }; \n          dt_aligned_pixel_t Jab = { 0.f }; \n          dt_aligned_pixel_t Jch = { 0.f }; \n \n          dot_product(rgb, input_matrix, XYZ);  \n \n          dt_XYZ_2_JzAzBz(XYZ, Jab);            \n \n          Jch[0] = Jab[0]; \n          Jch[1] = dt_fast_hypotf(Jab[2], Jab[1]); \n          Jch[2] = atan2f(Jab[2], Jab[1]); \n \n          const size_t index = roundf((LUT_ELEM - 1) * (Jch[2] + M_PI_F) / (2.f * M_PI_F)); \n          const float saturation = (Jch[0] > 0.f) ? Jch[1] / Jch[0] : 0.f; \n          LUT[index] = fmaxf(saturation, LUT[index]); \n        }", "pragma": "parallel for ", "hash": "123d5121dfe22f508e07d4e9c640235617d318058a2acfcd43741a0b6aec7ea8"}
{"code": "for (j = 0; j < kBoardWidth; j++ ) \n        { \n            if ( ! board[i][j]) \n                continue; \n            square.y = i * kTileSize; \n            square.x = j * kTileSize; \n            SDL_BlitSurface(game.whiteSquare, NULL, surf, &square); \n        }", "pragma": "parallel for private(j)", "hash": "2bc0a652c7dcd12113410f559cc096b748447a8bfc21ae53e897567db9228465"}
{"code": "for (tt = 1; tt <= num_tilt; tt++) \n  { \n    float t = t_min * pow(t_k, tt-1); \n \n    float t1 = 1; \n    float t2 = 1/t; \n \n     \n \n    if ( t == 1 ) \n    {\t\t\t\t\t \n       \n \n      float *image_tmp1_float = new float[width*height]; \n      for (int cc = 0; cc < width*height; cc++) \n        image_tmp1_float[cc] = image_tmp1[cc]; \n \n      compute_sift_keypoints(image_tmp1_float,keys_all[tt-1][0],width,height,siftparameters); \n       \n \n \n      delete[] image_tmp1_float; \n \n    } \n    else \n    { \n       \n \n      int num_rot1 = round(num_rot_t2*t/2);         \n \n      if ( num_rot1%2 == 1 ) \n      { \n        num_rot1 = num_rot1 + 1; \n      } \n      num_rot1 = num_rot1 / 2; \n      float delta_theta = PI/num_rot1;\t\t \n \n       \n \n#pragma omp parallel for private(rr) \n      for ( int rr = 1; rr <= num_rot1; rr++ )  \n      { \n        float theta = delta_theta * (rr-1); \n        theta = theta * 180 / PI; \n \n        vector<float> image_t; \n        int width_r, height_r; \n \n         \n \n        frot(image, image_t, width, height, &width_r, &height_r, &theta, &frot_b , frot_k); \n \n         \n\t\t\t  \n        int width_t = (int) (width_r * t1); \n        int height_t = (int) (height_r * t2);   \n \n        int fproj_sx = width_t; \n        int fproj_sy = height_t;      \n \n        float fproj_x1 = 0; \n        float fproj_y1 = 0; \n        float fproj_x2 = width_t; \n        float fproj_y2 = 0; \n        float fproj_x3 = 0;\t      \n        float fproj_y3 = height_t; \n \n         \n \n         \n \n        float sigma_aa = InitSigma_aa * t / 2; \n        GaussianBlur1D(image_t,width_r,height_r,sigma_aa,flag_dir); \n \n \n         \n \n        vector<float> image_tmp(width_t*height_t);\t\t\t  \n        fproj (image_t, image_tmp, width_r, height_r, &fproj_sx, &fproj_sy, &fproj_bg, &fproj_o, &fproj_p, &fproj_i , fproj_x1 , fproj_y1 , fproj_x2 , fproj_y2 , fproj_x3 , fproj_y3, fproj_x4, fproj_y4);  \n\t\tvector<float> image_tmp1 = image_tmp;\t \n \n        if ( verb ) \n        { \n          printf(\"Rotation theta = %.2f, Tilt t = %.2f. w=%d, h=%d, sigma_aa=%.2f, \\n\", theta, t, width_t, height_t, sigma_aa); \n        } \n \n \n        float *image_tmp1_float = new float[width_t*height_t]; \n        for (int cc = 0; cc < width_t*height_t; cc++) \n          image_tmp1_float[cc] = image_tmp1[cc];\t  \n \n         \n \n        keypointslist keypoints; \n        keypointslist keypoints_filtered; \n        compute_sift_keypoints(image_tmp1_float,keypoints,width_t,height_t,siftparameters); \n\t\t \n \n\t\t \n\t\t \n \n\t\t\tpro::Image img(width_t,height_t,pro::Image::_8UC1); \n\t\t\timg.setU8Data(vector<uchar>(image_tmp1_float,image_tmp1_float+width_t*height_t),width_t,height_t,1); \n\t\t\t \n \n\t\t\timg.imshow(\"test\"); \n\t\t\tcv::waitKey(0); \n \n        delete[] image_tmp1_float;\t\t \n \n         \n \n        if ( keypoints.size() != 0 ) \n        { \n          for ( int cc = 0; cc < (int) keypoints.size(); cc++ ) \n          {\t\t       \n \n            float x0, y0, x1, y1, x2, y2, x3, y3 ,x4, y4, d1, d2, d3, d4, scale1, theta1, sin_theta1, cos_theta1, BorderTh; \n \n            x0 = keypoints[cc].x; \n            y0 = keypoints[cc].y; \n            scale1= keypoints[cc].scale; \n \n            theta1 = theta * PI / 180; \n            sin_theta1 = sin(theta1); \n            cos_theta1 = cos(theta1); \n \n             \n \n            if ( theta <= 90 ) \n            { \n              x1 = height * sin_theta1; \n              y1 = 0;\t\t\t  \n              y2 = width * sin_theta1; \n              x3 = width * cos_theta1; \n              x4 = 0; \n              y4 = height * cos_theta1; \n              x2 = x1 + x3; \n              y3 = y2 + y4; \n \n               \n \n              y1 = y3 - y1; \n              y2 = y3 - y2; \n              y4 = y3 - y4; \n              y3 = 0; \n \n              y1 = y1 * t2; \n              y2 = y2 * t2; \n              y3 = y3 * t2; \n              y4 = y4 * t2; \n            } \n            else \n            { \n              y1 = -height * cos_theta1; \n              x2 = height * sin_theta1; \n              x3 = 0; \n              y3 = width * sin_theta1;\t\t\t\t  \n              x4 = -width * cos_theta1; \n              y4 = 0; \n              x1 = x2 + x4; \n              y2 = y1 + y3; \n \n               \n \n              y1 = y2 - y1; \n              y3 = y2 - y3; \n              y4 = y2 - y4; \n              y2 = 0; \n \n              y1 = y1 * t2; \n              y2 = y2 * t2; \n              y3 = y3 * t2; \n              y4 = y4 * t2; \n            }\t\t       \t\t     \n \n             \n \n            d1 = ABS((x2-x1)*(y1-y0)-(x1-x0)*(y2-y1)) / sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); \n            d2 = ABS((x3-x2)*(y2-y0)-(x2-x0)*(y3-y2)) / sqrt((x3-x2)*(x3-x2)+(y3-y2)*(y3-y2)); \n            d3 = ABS((x4-x3)*(y3-y0)-(x3-x0)*(y4-y3)) / sqrt((x4-x3)*(x4-x3)+(y4-y3)*(y4-y3)); \n            d4 = ABS((x1-x4)*(y4-y0)-(x4-x0)*(y1-y4)) / sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4)); \n \n            BorderTh = BorderFact*scale1; \n \n            if (!((d1<BorderTh) || (d2<BorderTh) || (d3<BorderTh) || (d4<BorderTh) )) \n            {\t\t\t\t \t\t\t\t\t    \n               \n \n              compensate_affine_coor1(&x0, &y0, width, height, 1/t2, t1, theta); \n              keypoints[cc].x = x0; \n              keypoints[cc].y = y0; \n \n              keypoints_filtered.push_back(keypoints[cc]);\t  \n            }\t\t\t\t    \n          } \n        }\t\t\t  \n        keys_all[tt-1][rr-1] = keypoints_filtered; \n      }\t\t  \n    }          \n  }", "pragma": "parallel for private(tt)", "hash": "771d88123112a79576b5d1fb402bdeb7ac84d3a04e4a3ac106f0732f23cbd921"}
{"code": "for(int i = 0; i < nLat; i++) { \n         for(int j = 0; j < nLon; j++) { \n            int I = nearestI[i][j]; \n            int J = nearestJ[i][j]; \n            for(int e = 0; e < nEns; e++) { \n               if(Util::isValid(I) && Util::isValid(J)) \n                  ofield(i,j,e) = ifield(I,J,e); \n               else \n                  ofield(i,j,e) = Util::MV; \n            } \n         } \n      }", "pragma": "parallel for ", "hash": "8269f39959a22b08f6e1b5574003ecbd410e2e670fc23ee59addb7e75acc9793"}
{"code": "for (r = 0; r < row; r++) {\r \n\t\tfor (c = 0; c < col; c++) {\r \n\t\t\ttemp[r*col+c]=result[r*col+c];\r \n\t\t}\r \n\t}", "pragma": "parallel for private( c r)", "hash": "dc24985a29965f506ad0da76947a875feda90fea756841311acd5424f9cbfb8a"}
{"code": "for(int i = 2; i <= n; ++i) \n\t\tresult *= i;", "pragma": "parallel for reduction(: dot result) ", "hash": "263d7d32001a789c63c8f47e15cc4831cade177900a3837cf336ebf0b5c2cbab"}
{"code": "for(int n = 0; n < N; n++) \n  { \n    int outputIdx = 0; \n    for(int fmo = 0; fmo < fm; fmo++) \n    { \n      for(int ri = 0; ri < maxRow; ri += kernelRows) \n      { \n        int rowBase = fmo * fmInSize + ri * inCols; \n        for(int ci = 0; ci < maxCol; ci += kernelCols, outputIdx++) \n        { \n          double m = -std::numeric_limits<double>::max(); \n          int idx = -1; \n          for(int kr = 0; kr < kernelRows; kr++) \n          { \n            for(int kc = 0, inputIdx = rowBase + ci; kc < kernelCols; \n                kc++, inputIdx++) \n              if((*x)(n, inputIdx) > m) \n              { \n                m = (*x)(n, inputIdx); \n                idx = inputIdx; \n              } \n          } \n          e(n, idx) = deltas(n, outputIdx); \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "ad46d5f16b3ba72960181eb20eac0022aa2dc4d4356e7cb12e43773b9fa08804"}
{"code": "for (int i = 0; i < src_seq_length_max; i++) \n        for (int j = 0; j < batch; j++) \n            alignments[i * batch + j] /= exp_sums[j];", "pragma": "parallel for ", "hash": "71356621ffb155b901ab25e9af447f226df98f37cfacb6365a2f3504004323ee"}
{"code": "for (i = 0; i < iScanSize; i++) { \n\t\tvpAllMS2Scans.at(i)->scoreFeatureCalculation(); \n\t}", "pragma": "parallel for ", "hash": "6b881410bf544aef0ea4bfa87822d21bca3cc474d788582a54ec4258ffedfcd4"}
{"code": "for (int j = 0; j < block_n_points; j++){\r \n\t\t\t\tblock_points_x[j] = block_points[j * 2] + (n_rows / 2 * spacing[0] - offset[0]);\r \n\t\t\t\tblock_points_y[j] = block_points[j * 2 + 1] + (n_cols / 2 * spacing[1] - offset[1]);\r \n\t\t\t}", "pragma": "parallel ", "hash": "84aa1932a73221b7531fefc102973c8fd55eff8a8e8396038b932ac378c796e4"}
{"code": "for (i = 0; i < 64; i++) \n    x += 6;", "pragma": "parallel for ", "hash": "ba678a1691cc4736820f4fe91881edc91de3d7c273c5a2175b580a37b15f7191"}
{"code": "for(i = 0; i < (int)instances_number; i++) \n    { \n        instance = data.arrange_row(i); \n \n        distances[i] = (instance-means/standard_deviations).calculate_norm(); \n    }", "pragma": "parallel for private( i instance)", "hash": "6bc5fe8f0f815c9a1a11e2a26ccc9aeb3640316c9d42cae1c4583b15baae9baf"}
{"code": "for (i = 0; i < n; i++)\r \n\t{\r \n\t\txkp1[i] *= -Dinv[i];\r \n\t\txkp1[i] += C[i];\r \n\t}", "pragma": "parallel for private(i)", "hash": "5ed0b44b89bb73129e4d68b7714dbd625664e3da4a7e1896f3015ae674a11681"}
{"code": "for (t2=lbp;t2<=ubp;t2++) { \n  for (t3=t2+1;t3<=_PB_M-1;t3++) { \n    corr[t3][t2] = corr[t2][t3];; \n  } \n}", "pragma": "parallel for private(lbv t3 t4 ubv)", "hash": "59d419a3c522b3ee332ae06503950f417fbcd2f234abb2e432ca884545634833"}
{"code": "for (int n = 0; n < Ns; n++) \n\t\tfor (int i = 0; i < 2*Nd+1; i++) \n\t\t\tout[i+n*(2*Nd+1)] += s->E[n] * in[i+n*(2*Nd+1)];", "pragma": "parallel for ", "hash": "4e0439dd8be6a555ae2630f60ed18059de86f0e37d759a25209a1b802395c4d1"}
{"code": "for (i = 0; i < size; i ++) { \n        double pos[3]; \n        get_position(p, i, pos); \n        double weight = fastpm_painter_readout(painter, canvas, pos); \n        p->from_double(p, i, attribute, weight); \n    }", "pragma": "parallel for ", "hash": "c70933237c1d9278a76d6efed54b3da83a93edddd6edc012ca588ef270b697c0"}
{"code": "for( int ispin = 0; ispin < geometry->nos; ispin++ ) \n        { \n            Energy[ispin] += 0.5 * spins[ispin].dot(gradients_temp[ispin]); \n             \n \n        }", "pragma": "parallel for ", "hash": "98907cc62e8b0eb9ddef5d7858091a08bb6f6c67ec6f1f1fe1c311b2d3431402"}
{"code": "for(int x=0; x<Get_NX(); x++) \n\t\t{ \n\t\t\tbool\tbShrink = m_pInput->is_NoData(x, y); \n \n\t\t\tfor(int i=0; !bShrink && i<m_Kernel.Get_Count(); i++) \n\t\t\t{ \n\t\t\t\tint\tix\t= m_Kernel.Get_X(i, x); \n\t\t\t\tint\tiy\t= m_Kernel.Get_Y(i, y); \n \n\t\t\t\tif( is_InGrid(ix, iy) && m_pInput->is_NoData(ix, iy) ) \n\t\t\t\t{ \n\t\t\t\t\tbShrink\t= true; \n\t\t\t\t} \n\t\t\t} \n \n\t\t\tif( bShrink ) \n\t\t\t{ \n\t\t\t\tpResult->Set_NoData(x, y); \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tpResult->Set_Value(x, y, m_pInput->asDouble(x, y)); \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "6effc67d2fe1754ede361095665f66ecbda8bb85c598e7679bbc84e6de2959e6"}
{"code": "for (int ii=0; ii<k; ii++) { \n    i = ilist[ii]; \n    if (atom->mask[i] & groupbit) dest[i] += c * v[i]; \n  }", "pragma": "parallel for private(i)", "hash": "704c89a438956d878b309808cc01931c3e3317e7a8615871bb35799db7d8c21a"}
{"code": "for ( i = 0; i < n; ++i ) { \n        offset = 6 * i; \n        dx = vec[offset]; \n        dy = vec[offset + 1]; \n        dz = vec[offset + 2]; \n        ox = vec[offset + 3]; \n        oy = vec[offset + 4]; \n        oz = vec[offset + 5]; \n \n        xysq = dx * dx + dy * dy; \n \n        ypa = ox * dy - oy * dx; \n        xpa = - (ox * dz * dx) - (oy * dz * dy) + ( oz * xysq ); \n \n        xy = ::sqrt ( xysq ); \n \n        theta[i] = ::atan2 ( xy, dz ); \n        phitemp = ::atan2 ( dy, dx ); \n        pa[i] = ::atan2 ( ypa, xpa ); \n \n        phi[i] = ( phitemp < 0 ) ? phitemp + toast::TWOPI : phitemp; \n    }", "pragma": "parallel for private(            dx dy dz i offset ox oy oz phitemp xpa xy xysq ypa)", "hash": "e6e76cf61a32b50769d8da3a9eab68374e34e0f469eb203c2b9e1fa03e4e57cc"}
{"code": "for(i=0; i<(nA+nB); i++) {  \n \n        rx[i] += vx[i]*dt; \n        ry[i] += vy[i]*dt; \n        sum += vx[i]*vx[i]+vy[i]*vy[i]; \n    }", "pragma": "parallel for ", "hash": "bdf6e5c425d9235277123d128de05ef2f8ea9e82e90034f2473bf387e2514140"}
{"code": "for(int y=0; y<Get_NY(); y++) \n\t{ \n\t\tfor(int x=0; x<Get_NX(); x++) \n\t\t{ \n\t\t\tif( m_pDEM->is_NoData(x, y) ) \n\t\t\t{ \n\t\t\t\tm_pDirect->Set_NoData(x, y); \n\t\t\t\tm_pDiffus->Set_NoData(x, y); \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tdouble\tDirect, Diffus; \n \n\t\t\t\tif( Get_Irradiance(x, y, \n\t\t\t\t\t\tm_bBending ? m_Sol_Height .asDouble(x, y) : Sol_Height, \n\t\t\t\t\t\tm_bBending ? m_Sol_Azimuth.asDouble(x, y) : Sol_Azimuth, \n\t\t\t\t\t\tDirect, Diffus) ) \n\t\t\t\t{ \n\t\t\t\t\tm_pDirect->Add_Value(x, y, Direct); \n\t\t\t\t\tm_pDiffus->Add_Value(x, y, Diffus); \n \n\t\t\t\t\tif( Direct > 0.0 ) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif( m_pDuration ) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tif( m_pDuration->is_NoData(x, y) ) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tm_pDuration\t->Set_Value(x, y, m_dHour); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tm_pDuration\t->Add_Value(x, y, m_dHour); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tif( m_pSunrise && (m_pSunrise->is_NoData(x, y) || m_pSunrise->asDouble(x, y) > Hour) ) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tm_pSunrise\t->Set_Value(x, y, Hour); \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tif( m_pSunset ) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tm_pSunset\t->Set_Value(x, y, Hour); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "b3d65a7e989022eca8b0032770cc6c2620524fc66de9f073f09982b3543e2fbc"}
{"code": "for (int xi2 = 0; xi2 < mt_basis_size; xi2++) { \n            int lm2    = atom.type().indexb(xi2).lm; \n            int idxrf2 = atom.type().indexb(xi2).idxrf; \n \n            for (int i = 0; i < ctx_.num_mag_dims(); i++) { \n                for (int xi1 = 0; xi1 <= xi2; xi1++) { \n                    int lm1    = atom.type().indexb(xi1).lm; \n                    int idxrf1 = atom.type().indexb(xi1).idxrf; \n \n                    zm(xi1, xi2, i) = gaunt_coefs_->sum_L3_gaunt(lm1, lm2, atom.b_radial_integrals(idxrf1, idxrf2, i)); \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "1b68f73d385f2a71dde45afc060fde76cef0537d1ff83e756e44b5c3acc79920"}
{"code": "for (uint brkpt_ctr_0 = 0; brkpt_ctr_0 < number_of_haploid_breakpoints_0; ++brkpt_ctr_0) \n\t{ \n\t    for (uint brkpt_ctr_1 = 0; brkpt_ctr_1 < number_of_haploid_breakpoints_1; ++brkpt_ctr_1) \n\t    {\t\t\t     \n\t\tset_breakpoints_using_breakpoint_space(breakpoints__haploid_0, breakpoint_space__hap_0, brkpt_ctr_0); \n\t\tset_breakpoints_using_breakpoint_space(breakpoints__haploid_1, breakpoint_space__hap_1, brkpt_ctr_1);     \n\t\t\t\t \n\t\t \n\t\treal prod_PSF(P__E_diploid__cond_theta); \n \n\t\tfor (uint l_PSF = 0; l_PSF < total_number_of_related_PSF; ++l_PSF )   \n\t\t{ \n\t\t    prod_PSF *= list_of_related_PSF__and__thread_specific____new_PSF[l_PSF] \n\t\t\t\t\t->get_diploid_partial_sum_for_these_sparse_state_vectors_and_breakpoints( \n\t\t\t\t\t\t\t    full_haploid_sparse_state_vector_0, \n\t\t\t\t\t\t\t    full_haploid_sparse_state_vector_1, \n\t\t\t\t\t\t\t    breakpoints__haploid_0, \n\t\t\t\t\t\t\t    breakpoints__haploid_1); \n\t\t} \n \n\t\t     \n\t\ttype_BI__BI diploid_EE_brkpt(empty_BI__BI);                 \n\t\t{ \n\t\t    const type_map_uint_to_BI::const_iterator it_EE_brk = breakpoints__haploid_0.find(EE_UID); \n\t\t    if (it_EE_brk != breakpoints__haploid_0.end())  \n\t\t    { \n\t\t\tdiploid_EE_brkpt.first = it_EE_brk->second; \n\t\t\tprod_PSF *= P__s_haploid__cond__E_haploid_and_theta.first; \n\t\t    } \n\t\t}                 \n\t\t{ \n\t\t    const type_map_uint_to_BI::const_iterator it_EE_brk = breakpoints__haploid_1.find(EE_UID); \n\t\t    if (it_EE_brk != breakpoints__haploid_1.end())   \n\t\t    { \n\t\t\tdiploid_EE_brkpt.second = it_EE_brk->second; \n\t\t\tprod_PSF *= P__s_haploid__cond__E_haploid_and_theta.second; \n\t\t    } \n\t\t} \n\t\t \n\t\t \n\t\t \n\t\ttype_map_uint_to_BI__2 non_EE_haploid_breakpoints(breakpoints__haploid_0, breakpoints__haploid_1); \n\t\tnon_EE_haploid_breakpoints.first.erase(EE_UID); \n\t\tnon_EE_haploid_breakpoints.second.erase(EE_UID);                                 \n\t\t     \n\t\t \n\t\t \n\t\tthread_specific__diploid_breakpoints_to_data[non_EE_haploid_breakpoints] \n\t\t    .map_eliminating_Event_diploid_outcomes_to_hybrid_factor \n\t\t\t[diploid_EE_state] \n\t\t\t    .map_eliminating_Event_diploid_brkpts__to__P_D_cond_diploid_neighbor_states_brkpts__and__eliminating_Event_diploid_states_and_brkpts \n\t\t\t\t[diploid_EE_brkpt] = prod_PSF; \n\t\t\t\t \n\t    } \n \n\t}", "pragma": "for ", "hash": "7efb225792f396bdb7c4d8cf22d3b401a7cf9e538fa7234d42f5b92a695be1eb"}
{"code": "for (unsigned x=0; x<w; x++) { \n\t\t\tfor (unsigned y=0; y<h; y++) { \n\t\t\t\tunsigned pos = x + y*w; \n\t\t\t\timage[pos].r += add; if (clampwhite & image[pos].r > 1.0) image[pos].r = 1.0; \n\t\t\t\timage[pos].g += add; if (clampwhite & image[pos].g > 1.0) image[pos].g = 1.0; \n\t\t\t\timage[pos].b += add; if (clampwhite & image[pos].b > 1.0) image[pos].b = 1.0; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "93bc2c2a6c03ea9451b983797867481d2e5d40d94f91891f85932ec4312777df"}
{"code": "for(int i = 0; i < N; ++i) \n                for(int j = 0; j < N; ++j) \n                    v[i][j] += 1;", "pragma": "for ", "hash": "ae6d4dd2b76a59776111694b9a5e0a78a1f16a604631f31c3b405590b0daeae9"}
{"code": "for(int iit=0; iit<objects.size(); iit++) { \n     Object **it= &(objects[iit]); \n      (*it)->doubleProperty[ckey] = (*f)((*it)->doubleProperty[a1], (*it)->doubleProperty[a2], (*it)->intProperty[a3]); \n    }", "pragma": "parallel for ", "hash": "81f101eaf42bb246452e51ac07b7c3edf07dbe613bf969b020a459730fe04df0"}
{"code": "for (j = d; j <= seq_length; j++) { \n      unsigned int p, q, pq, u, maxp, dij; \n      int type_2, type, tt, no_close, base_d1, base_d2; \n \n      i = j-d+1; \n      dij = j - i - 1; \n      ij = my_iindx[i]-j; \n      type = ptype[ij]; \n \n      no_close = (((type==3)||(type==4))&&no_closingGU); \n \n      if (type) {    \n \n         \n \n        base_d1 = ((unsigned int)reference_pt1[i] != j) ? 1 : -1; \n        base_d2 = ((unsigned int)reference_pt2[i] != j) ? 1 : -1; \n \n         \n \n \n         \n \n        d1 = base_d1 + referenceBPs1[ij]; \n        d2 = base_d2 + referenceBPs2[ij]; \n \n        int min_k, max_k, min_l, max_l; \n        int real_min_k, real_max_k, *min_l_real, *max_l_real; \n \n        min_l = min_k = 0; \n        max_k = mm1[ij] + referenceBPs1[ij]; \n        max_l = mm2[ij] + referenceBPs2[ij]; \n \n        prepareBoundaries(min_k, \n                          max_k, \n                          min_l, \n                          max_l, \n                          bpdist[ij], \n                          &vars->k_min_values[ij], \n                          &vars->k_max_values[ij], \n                          &vars->l_min_values[ij], \n                          &vars->l_max_values[ij] \n                          ); \n \n        preparePosteriorBoundaries( vars->k_max_values[ij] - vars->k_min_values[ij] + 1, \n                                    vars->k_min_values[ij], \n                                    &real_min_k, \n                                    &real_max_k, \n                                    &min_l_real, \n                                    &max_l_real \n                                  ); \n \n        prepareArray( &vars->E_C[ij], \n                      vars->k_min_values[ij], \n                      vars->k_max_values[ij], \n                      vars->l_min_values[ij], \n                      vars->l_max_values[ij] \n                    ); \n \n        prepareArray2( &vars->N_C[ij], \n                      vars->k_min_values[ij], \n                      vars->k_max_values[ij], \n                      vars->l_min_values[ij], \n                      vars->l_max_values[ij] \n                    ); \n \n         \n \n        if((d1 >= 0) && (d2 >= 0)){ \n          if(((unsigned int)d1<=maxD1) && ((unsigned int)d2 <= maxD2)){ \n            vars->E_C[ij][d1][d2/2] = (no_close) ? FORBIDDEN : E_Hairpin(dij, type, S1[i+1], S1[j-1], sequence+i-1, P); \n            updatePosteriorBoundaries(d1, \n                                      d2, \n                                      &real_min_k, \n                                      &real_max_k, \n                                      &min_l_real, \n                                      &max_l_real \n                                      ); \n            vars->N_C[ij][d1][d2/2] = 1; \n          } \n          else{ \n            vars->E_C_rem[ij] = (no_close) ? FORBIDDEN : E_Hairpin(dij, type, S1[i+1], S1[j-1], sequence+i-1, P); \n          } \n        } \n         \n \n        maxp = MIN2(j-2-TURN,i+MAXLOOP+1); \n        for(p = i+1; p <= maxp; p++){ \n          unsigned int minq = p + TURN + 1; \n          unsigned int ln_pre = dij + p; \n          if(ln_pre > minq + MAXLOOP) minq = ln_pre - MAXLOOP - 1; \n          for(q = minq; q < j; q++){ \n            pq = my_iindx[p]-q; \n             \n \n            type_2 = ptype[pq]; \n \n            if (type_2==0) continue; \n            type_2 = rtype[type_2]; \n \n             \n \n            d1 = base_d1 + referenceBPs1[ij] - referenceBPs1[pq]; \n            d2 = base_d2 + referenceBPs2[ij] - referenceBPs2[pq]; \n \n            if(no_closingGU) \n              if(no_close||(type_2==3)||(type_2==4)) \n                if((p>i+1)||(q<j-1)) continue;   \n \n \n            energy = E_IntLoop(p-i-1, j-q-1, type, type_2, S1[i+1], S1[j-1], S1[p-1], S1[q+1], P); \n \n            if(vars->E_C[pq] != NULL){ \n              for(cnt1 = vars->k_min_values[pq]; cnt1 <= vars->k_max_values[pq]; cnt1++){ \n                for(cnt2 = vars->l_min_values[pq][cnt1]; cnt2 <= vars->l_max_values[pq][cnt1]; cnt2+=2){ \n                  if(vars->E_C[pq][cnt1][cnt2/2] != INF){ \n                    if(((cnt1 + d1) <= maxD1) && ((cnt2+d2) <= maxD2)){ \n                        vars->E_C[ij][cnt1 + d1][(cnt2 + d2)/2] = MIN2( vars->E_C[ij][cnt1 + d1][(cnt2 + d2)/2], \n                                                                        vars->E_C[pq][cnt1][cnt2/2] + energy \n                                                                      ); \n                        updatePosteriorBoundaries(cnt1 + d1, \n                                                  cnt2 + d2, \n                                                  &real_min_k, \n                                                  &real_max_k, \n                                                  &min_l_real, \n                                                  &max_l_real \n                                                  ); \n                       vars->N_C[ij][cnt1 + d1][(cnt2 + d2)/2] += vars->N_C[pq][cnt1][cnt2/2]; \n                    } \n                     \n \n                    else{ \n                      vars->E_C_rem[ij] = MIN2(vars->E_C_rem[ij], vars->E_C[pq][cnt1][cnt2/2] + energy); \n                    } \n                  } \n                } \n              } \n            } \n             \n \n            if(vars->E_C_rem[pq] != INF){ \n              vars->E_C_rem[ij] = MIN2(vars->E_C_rem[ij], vars->E_C_rem[pq] + energy); \n            } \n          }  \n \n        }  \n \n \n \n \n         \n \n        if(!no_close){ \n \n           \n \n          tt = rtype[type]; \n          temp2 = P->MLclosing; \n          if(dangles == 2) \n            temp2 += E_MLstem(tt, S1[j-1], S1[i+1], P); \n          else \n            temp2 += E_MLstem(tt, -1, -1, P); \n \n          for(u=i+TURN+2; u<j-TURN-2;u++){ \n            int i1u   = my_iindx[i+1]-u; \n            int u1j1  = my_iindx[u+1]-j+1; \n             \n \n            if(vars->E_M_rem[i1u] != INF){ \n              for(cnt3 = vars->k_min_values_m1[u1j1]; \n                  cnt3 <= vars->k_max_values_m1[u1j1]; \n                  cnt3++) \n                for(cnt4 = vars->l_min_values_m1[u1j1][cnt3]; \n                    cnt4 <= vars->l_max_values_m1[u1j1][cnt3]; \n                    cnt4+=2){ \n                  if(vars->E_M1[u1j1][cnt3][cnt4/2]!= INF){ \n                    vars->E_C_rem[ij] = MIN2(vars->E_C_rem[ij], \n                                              vars->E_M_rem[i1u] \n                                            + vars->E_M1[u1j1][cnt3][cnt4/2] \n                                            + temp2 \n                                              ); \n                  } \n                } \n              if(vars->E_M1_rem[u1j1] != INF){ \n                vars->E_C_rem[ij] = MIN2(vars->E_C_rem[ij], \n                                          vars->E_M_rem[i1u] \n                                        + vars->E_M1_rem[u1j1] \n                                        + temp2 \n                                          ); \n              } \n            } \n            if(vars->E_M1_rem[u1j1] != INF){ \n              for(cnt1 = vars->k_min_values_m[i1u]; \n                  cnt1 <= vars->k_max_values_m[i1u]; \n                  cnt1++) \n                for(cnt2 = vars->l_min_values_m[i1u][cnt1]; \n                    cnt2 <= vars->l_max_values_m[i1u][cnt1]; \n                    cnt2+=2) \n                  if(vars->E_M[i1u][cnt1][cnt2/2] != INF){ \n                    vars->E_C_rem[ij] = MIN2(vars->E_C_rem[ij], \n                                              vars->E_M[i1u][cnt1][cnt2/2] \n                                            + vars->E_M1_rem[u1j1] \n                                            + temp2 \n                                              ); \n                  } \n            } \n             \n \n            if(!vars->E_M[i1u]) continue; \n            if(!vars->E_M1[u1j1]) continue; \n \n            d1 = base_d1 + referenceBPs1[ij] - referenceBPs1[i1u] - referenceBPs1[u1j1]; \n            d2 = base_d2 + referenceBPs2[ij] - referenceBPs2[i1u] - referenceBPs2[u1j1]; \n \n            for(cnt1 = vars->k_min_values_m[i1u]; \n                cnt1 <= vars->k_max_values_m[i1u]; \n                cnt1++) \n              for(cnt2 = vars->l_min_values_m[i1u][cnt1]; \n                  cnt2 <= vars->l_max_values_m[i1u][cnt1]; \n                  cnt2+=2) \n                for(cnt3 = vars->k_min_values_m1[u1j1]; \n                    cnt3 <= vars->k_max_values_m1[u1j1]; \n                    cnt3++) \n                  for(cnt4 = vars->l_min_values_m1[u1j1][cnt3]; \n                      cnt4 <= vars->l_max_values_m1[u1j1][cnt3]; \n                      cnt4+=2){ \n                    if((vars->E_M[i1u][cnt1][cnt2/2] != INF) && (vars->E_M1[u1j1][cnt3][cnt4/2]!= INF)){ \n                      if(((cnt1+cnt3+d1) <= maxD1) && ((cnt2+cnt4+d2) <= maxD2)){ \n                        vars->E_C[ij][cnt1+cnt3+d1][(cnt2+cnt4+d2)/2] = MIN2( vars->E_C[ij][cnt1+cnt3+d1][(cnt2+cnt4+d2)/2], \n                                                                              vars->E_M[i1u][cnt1][cnt2/2] \n                                                                            + vars->E_M1[u1j1][cnt3][cnt4/2] \n                                                                            + temp2 \n                                                                            ); \n                        updatePosteriorBoundaries(cnt1 + cnt3 + d1, \n                                                  cnt2 + cnt4 + d2, \n                                                  &real_min_k, \n                                                  &real_max_k, \n                                                  &min_l_real, \n                                                  &max_l_real \n                                                ); \n                        vars->N_C[ij][cnt1+cnt3+d1][(cnt2+cnt4+d2)/2] += vars->N_M[i1u][cnt1][cnt2/2] * vars->N_M1[u1j1][cnt3][cnt4/2]; \n                      } \n                       \n \n                      else{ \n                        vars->E_C_rem[ij] = MIN2(  vars->E_C_rem[ij], \n                                                    vars->E_M[i1u][cnt1][cnt2/2] \n                                                  + vars->E_M1[u1j1][cnt3][cnt4/2] \n                                                  + temp2 \n                                                  ); \n                      } \n                    } \n                  } \n          } \n        } \n \n         \n \n        adjustArrayBoundaries(&vars->E_C[ij], \n                              &vars->k_min_values[ij], \n                              &vars->k_max_values[ij], \n                              &vars->l_min_values[ij], \n                              &vars->l_max_values[ij], \n                              real_min_k, \n                              real_max_k, \n                              min_l_real, \n                              max_l_real \n                              ); \n         \n \n      }  \n \n \n \n \n       \n \n       \n \n \n \n      dia = referenceBPs1[ij] - referenceBPs1[my_iindx[i+1]-j]; \n      dib = referenceBPs2[ij] - referenceBPs2[my_iindx[i+1]-j]; \n      dja = referenceBPs1[ij] - referenceBPs1[ij+1]; \n      djb = referenceBPs2[ij] - referenceBPs2[ij+1]; \n \n      if(dangles==2) \n        temp2 = E_MLstem(type, ((i > 1) || circ) ? S1[i-1] : -1, ((j < seq_length) || circ) ? S1[j+1] : -1, P); \n      else \n        temp2 = E_MLstem(type, -1, -1, P); \n \n      int min_k_guess, max_k_guess, min_l_guess, max_l_guess; \n      int min_k_real_m, max_k_real_m, *min_l_real_m, *max_l_real_m; \n      int min_k_real_m1, max_k_real_m1, *min_l_real_m1, *max_l_real_m1; \n \n      min_k_guess = min_l_guess = 0; \n      max_k_guess = mm1[ij] + referenceBPs1[ij]; \n      max_l_guess = mm2[ij] + referenceBPs2[ij]; \n \n      prepareBoundaries(min_k_guess, \n                        max_k_guess, \n                        min_l_guess, \n                        max_l_guess, \n                        bpdist[ij], \n                        &vars->k_min_values_m[ij], \n                        &vars->k_max_values_m[ij], \n                        &vars->l_min_values_m[ij], \n                        &vars->l_max_values_m[ij] \n                        ); \n \n      prepareBoundaries(min_k_guess, \n                        max_k_guess, \n                        min_l_guess, \n                        max_l_guess, \n                        bpdist[ij], \n                        &vars->k_min_values_m1[ij], \n                        &vars->k_max_values_m1[ij], \n                        &vars->l_min_values_m1[ij], \n                        &vars->l_max_values_m1[ij] \n                        ); \n \n      preparePosteriorBoundaries( vars->k_max_values_m[ij] - vars->k_min_values_m[ij] + 1, \n                                  vars->k_min_values_m[ij], \n                                  &min_k_real_m, \n                                  &max_k_real_m, \n                                  &min_l_real_m, \n                                  &max_l_real_m \n                                ); \n      preparePosteriorBoundaries( vars->k_max_values_m1[ij] - vars->k_min_values_m1[ij] + 1, \n                                  vars->k_min_values_m1[ij], \n                                  &min_k_real_m1, \n                                  &max_k_real_m1, \n                                  &min_l_real_m1, \n                                  &max_l_real_m1 \n                                ); \n \n      prepareArray( &vars->E_M[ij], \n                    vars->k_min_values_m[ij], \n                    vars->k_max_values_m[ij], \n                    vars->l_min_values_m[ij], \n                    vars->l_max_values_m[ij] \n                  ); \n \n      prepareArray( &vars->E_M1[ij], \n                    vars->k_min_values_m1[ij], \n                    vars->k_max_values_m1[ij], \n                    vars->l_min_values_m1[ij], \n                    vars->l_max_values_m1[ij] \n                  ); \n      prepareArray2( &vars->N_M[ij], \n                    vars->k_min_values_m[ij], \n                    vars->k_max_values_m[ij], \n                    vars->l_min_values_m[ij], \n                    vars->l_max_values_m[ij] \n                  ); \n      prepareArray2( &vars->N_M1[ij], \n                    vars->k_min_values_m1[ij], \n                    vars->k_max_values_m1[ij], \n                    vars->l_min_values_m1[ij], \n                    vars->l_max_values_m1[ij] \n                  ); \n \n       \n \n       \n \n      if(vars->E_C_rem[ij] != INF){ \n        vars->E_M_rem[ij] = vars->E_M1_rem[ij] = temp2 + vars->E_C_rem[ij]; \n      } \n      if(vars->E_C[ij]) \n        for(cnt1 = vars->k_min_values[ij]; cnt1 <= vars->k_max_values[ij]; cnt1++){ \n          for(cnt2 = vars->l_min_values[ij][cnt1]; cnt2 <= vars->l_max_values[ij][cnt1]; cnt2+=2){ \n            if(vars->E_C[ij][cnt1][cnt2/2] != INF){ \n              vars->E_M[ij][cnt1][cnt2/2] = vars->E_M1[ij][cnt1][cnt2/2] = temp2 + vars->E_C[ij][cnt1][cnt2/2]; \n              updatePosteriorBoundaries(cnt1, \n                                        cnt2, \n                                        &min_k_real_m, \n                                        &max_k_real_m, \n                                        &min_l_real_m, \n                                        &max_l_real_m \n                                        ); \n              updatePosteriorBoundaries(cnt1, \n                                        cnt2, \n                                        &min_k_real_m1, \n                                        &max_k_real_m1, \n                                        &min_l_real_m1, \n                                        &max_l_real_m1 \n                                        ); \n             vars->N_M[ij][cnt1][cnt2/2] = vars->N_M1[ij][cnt1][cnt2/2] = vars->N_C[ij][cnt1][cnt2/2]; \n            } \n          } \n        } \n \n       \n \n      if(vars->E_M_rem[my_iindx[i+1]-j] != INF){ \n        vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                  vars->E_M_rem[my_iindx[i+1]-j] + P->MLbase \n                                  ); \n      } \n      if(vars->E_M[my_iindx[i+1]-j]) \n        for(cnt1 = vars->k_min_values_m[my_iindx[i+1]-j]; \n            cnt1 <= vars->k_max_values_m[my_iindx[i+1]-j]; \n            cnt1++){ \n          for(cnt2 = vars->l_min_values_m[my_iindx[i+1]-j][cnt1]; \n              cnt2 <= vars->l_max_values_m[my_iindx[i+1]-j][cnt1]; \n              cnt2+=2){ \n            if(vars->E_M[my_iindx[i+1]-j][cnt1][cnt2/2] != INF){ \n              if(((cnt1 + dia) <= maxD1) && ((cnt2 + dib) <= maxD2)){ \n                vars->E_M[ij][cnt1+dia][(cnt2+dib)/2] = MIN2( vars->E_M[ij][cnt1+dia][(cnt2+dib)/2], \n                                                              vars->E_M[my_iindx[i+1]-j][cnt1][cnt2/2] + P->MLbase \n                                                            ); \n                updatePosteriorBoundaries(cnt1 + dia, \n                                          cnt2 + dib, \n                                          &min_k_real_m, \n                                          &max_k_real_m, \n                                          &min_l_real_m, \n                                          &max_l_real_m \n                                          ); \n                vars->N_M[ij][cnt1+dia][(cnt2+dib)/2] += vars->N_M[my_iindx[i+1]-j][cnt1][cnt2/2]; \n              } \n               \n \n              else{ \n                vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                          vars->E_M[my_iindx[i+1]-j][cnt1][cnt2/2] + P->MLbase \n                                          ); \n              } \n            } \n          } \n        } \n \n       \n \n      if(vars->E_M_rem[ij+1] != INF){ \n        vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                  vars->E_M_rem[ij+1] + P->MLbase \n                                  ); \n      } \n      if(vars->E_M[ij+1]) \n        for(cnt1 = vars->k_min_values_m[ij+1]; \n            cnt1 <= vars->k_max_values_m[ij+1]; \n            cnt1++){ \n          for(cnt2 = vars->l_min_values_m[ij+1][cnt1]; \n              cnt2 <= vars->l_max_values_m[ij+1][cnt1]; \n              cnt2+=2){ \n            if(vars->E_M[ij+1][cnt1][cnt2/2] != INF){ \n              if(((cnt1 + dja) <= maxD1) && ((cnt2 + djb) <= maxD2)){ \n                vars->E_M[ij][cnt1+dja][(cnt2+djb)/2] = MIN2( vars->E_M[ij][cnt1+dja][(cnt2+djb)/2], \n                                                              vars->E_M[ij+1][cnt1][cnt2/2] + P->MLbase \n                                                            ); \n                updatePosteriorBoundaries(cnt1 + dja, \n                                          cnt2 + djb, \n                                          &min_k_real_m, \n                                          &max_k_real_m, \n                                          &min_l_real_m, \n                                          &max_l_real_m \n                                          ); \n                vars->N_M[ij][cnt1+dja][(cnt2+djb)/2] += vars->N_M[ij+1][cnt1][cnt2/2]; \n              } \n               \n \n              else{ \n                vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                          vars->E_M[ij+1][cnt1][cnt2/2] + P->MLbase \n                                          ); \n              } \n            } \n          } \n        } \n \n       \n \n      if(vars->E_M1_rem[ij+1] != INF){ \n        vars->E_M1_rem[ij] = MIN2( vars->E_M1_rem[ij], \n                                    vars->E_M1_rem[ij+1] + P->MLbase \n                                  ); \n      } \n      if(vars->E_M1[ij+1]) \n        for(cnt1 = vars->k_min_values_m1[ij+1]; \n            cnt1 <= vars->k_max_values_m1[ij+1]; \n            cnt1++){ \n          for(cnt2 = vars->l_min_values_m1[ij+1][cnt1]; \n              cnt2 <= vars->l_max_values_m1[ij+1][cnt1]; \n              cnt2+=2){ \n            if(vars->E_M1[ij+1][cnt1][cnt2/2] != INF){ \n              if(((cnt1 + dja) <= maxD1) && ((cnt2 + djb) <= maxD2)){ \n                vars->E_M1[ij][cnt1+dja][(cnt2+djb)/2]  = MIN2( vars->E_M1[ij][cnt1+dja][(cnt2+djb)/2], \n                                                                vars->E_M1[ij+1][cnt1][cnt2/2] + P->MLbase \n                                                              ); \n                updatePosteriorBoundaries(cnt1 + dja, \n                                          cnt2 + djb, \n                                          &min_k_real_m1, \n                                          &max_k_real_m1, \n                                          &min_l_real_m1, \n                                          &max_l_real_m1 \n                                          ); \n                vars->N_M1[ij][cnt1+dja][(cnt2+djb)/2]  += vars->N_M1[ij+1][cnt1][cnt2/2]; \n              } \n               \n \n              else{ \n                vars->E_M1_rem[ij] = MIN2( vars->E_M1_rem[ij], \n                                            vars->E_M1[ij+1][cnt1][cnt2/2] + P->MLbase \n                                          ); \n              } \n            } \n          } \n        } \n \n \n       \n \n      if(j > TURN + 2) \n      for (u = i+1+TURN; u <= j-2-TURN; u++){ \n         \n \n        if(vars->E_M_rem[my_iindx[i]-u] != INF){ \n          for(cnt3 = vars->k_min_values_m[my_iindx[u+1]-j]; \n              cnt3 <= vars->k_max_values_m[my_iindx[u+1]-j]; \n              cnt3++){ \n            for(cnt4 = vars->l_min_values_m[my_iindx[u+1]-j][cnt3]; \n                cnt4 <= vars->l_max_values_m[my_iindx[u+1]-j][cnt3]; \n                cnt4+=2){ \n              if(vars->E_M[my_iindx[u+1]-j][cnt3][cnt4/2] != INF){ \n                  vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                            vars->E_M_rem[my_iindx[i]-u] + vars->E_M[my_iindx[u+1]-j][cnt3][cnt4/2] \n                                            ); \n              } \n            } \n          } \n          if(vars->E_M_rem[my_iindx[u+1]-j] != INF){ \n            vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                      vars->E_M_rem[my_iindx[i]-u] + vars->E_M_rem[my_iindx[u+1]-j] \n                                      ); \n          } \n        } \n        if(vars->E_M_rem[my_iindx[u+1]-j] != INF){ \n          for(cnt1 = vars->k_min_values_m[my_iindx[i]-u]; \n              cnt1 <= vars->k_max_values_m[my_iindx[i]-u]; \n              cnt1++){ \n            for(cnt2 = vars->l_min_values_m[my_iindx[i]-u][cnt1]; \n                cnt2 <= vars->l_max_values_m[my_iindx[i]-u][cnt1]; \n                cnt2+=2){ \n              if(vars->E_M[my_iindx[i]-u][cnt1][cnt2/2] != INF){ \n                vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                          vars->E_M[my_iindx[i]-u][cnt1][cnt2/2] + vars->E_M_rem[my_iindx[u+1]-j] \n                                          ); \n              } \n            } \n          } \n        } \n        if(!vars->E_M[my_iindx[i]-u]) continue; \n        if(!vars->E_M[my_iindx[u+1]-j]) continue; \n \n        dia = referenceBPs1[ij] - referenceBPs1[my_iindx[i]-u] - referenceBPs1[my_iindx[u+1]-j]; \n        dib = referenceBPs2[ij] - referenceBPs2[my_iindx[i]-u] - referenceBPs2[my_iindx[u+1]-j]; \n \n        for(cnt1 = vars->k_min_values_m[my_iindx[i]-u]; \n            cnt1 <= vars->k_max_values_m[my_iindx[i]-u]; \n            cnt1++){ \n          for(cnt2 = vars->l_min_values_m[my_iindx[i]-u][cnt1]; \n              cnt2 <= vars->l_max_values_m[my_iindx[i]-u][cnt1]; \n              cnt2+=2){ \n            for(cnt3 = vars->k_min_values_m[my_iindx[u+1]-j]; \n                cnt3 <= vars->k_max_values_m[my_iindx[u+1]-j]; \n                cnt3++){ \n              for(cnt4 = vars->l_min_values_m[my_iindx[u+1]-j][cnt3]; \n                  cnt4 <= vars->l_max_values_m[my_iindx[u+1]-j][cnt3]; \n                  cnt4+=2){ \n                if((vars->E_M[my_iindx[i]-u][cnt1][cnt2/2] != INF) && (vars->E_M[my_iindx[u+1]-j][cnt3][cnt4/2] != INF)){ \n                  if(((cnt1 + cnt3 + dia) <= maxD1) && ((cnt2 + cnt4 + dib) <= maxD2)){ \n                    vars->E_M[ij][cnt1+cnt3+dia][(cnt2+cnt4+dib)/2] = MIN2( vars->E_M[ij][cnt1+cnt3+dia][(cnt2+cnt4+dib)/2], \n                                                                            vars->E_M[my_iindx[i]-u][cnt1][cnt2/2] \n                                                                          + vars->E_M[my_iindx[u+1]-j][cnt3][cnt4/2] \n                                                                          ); \n                    updatePosteriorBoundaries(cnt1 + cnt3 + dia, \n                                              cnt2 + cnt4 + dib, \n                                              &min_k_real_m, \n                                              &max_k_real_m, \n                                              &min_l_real_m, \n                                              &max_l_real_m \n                                              ); \n                    vars->N_M[ij][cnt1+cnt3+dia][(cnt2+cnt4+dib)/2] += vars->N_M[my_iindx[i]-u][cnt1][cnt2/2] * vars->N_M1[my_iindx[u+1]-j][cnt3][cnt4/2]; \n                  } \n                   \n \n                  else{ \n                    vars->E_M_rem[ij] = MIN2(vars->E_M_rem[ij], \n                                              vars->E_M[my_iindx[i]-u][cnt1][cnt2/2] + vars->E_M[my_iindx[u+1]-j][cnt3][cnt4/2] \n                                              ); \n                  } \n                } \n              } \n            } \n          } \n        } \n      } \n \n       \n \n \n      adjustArrayBoundaries(&vars->E_M[ij], \n                            &vars->k_min_values_m[ij], \n                            &vars->k_max_values_m[ij], \n                            &vars->l_min_values_m[ij], \n                            &vars->l_max_values_m[ij], \n                            min_k_real_m, \n                            max_k_real_m, \n                            min_l_real_m, \n                            max_l_real_m \n                            ); \n \n      adjustArrayBoundaries(&vars->E_M1[ij], \n                            &vars->k_min_values_m1[ij], \n                            &vars->k_max_values_m1[ij], \n                            &vars->l_min_values_m1[ij], \n                            &vars->l_max_values_m1[ij], \n                            min_k_real_m1, \n                            max_k_real_m1, \n                            min_l_real_m1, \n                            max_l_real_m1 \n                            ); \n \n         \n \n    }", "pragma": "parallel for private(        additional_en cnt1 cnt2 cnt3 cnt4 d1 d2 dia dib dja djb energy i ij j temp2)", "hash": "773451e0a9227cc37dbd49da59e4d9e95c6b0c0a51432d8d8086f169cf0adbeb"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tb[i] = -(3*a[i]-4*a[i+nn]+a[i+2*nn])*dd;\r \n\t\tb[i+(nz-1)*nn] = (3*a[i+(nz-1)*nn]-4*a[i+(nz-2)*nn]+a[i+(nz-3)*nn])*dd;\r \n\t\tfor(long j=1;j<nz-1;j++)\t\tb[i+j*nn] = (a[i+j*nn+nn]-a[i+j*nn-nn])*dd;\r \n\t}", "pragma": "parallel ", "hash": "8a8d280d8767edccaee45d236ff44b6672770873ba0776986aa43c2fbf73b16f"}
{"code": "for (int i = 0; i < (int)numParticles; i++) \n\t\t{ \n\t\t\tconst Vector3r &xi = m_model->getPosition(i); \n\t\t\tVector3r gradC_i; \n\t\t\tgradC_i.setZero(); \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tforall_fluid_neighbors_in_same_phase( \n\t\t\t\tconst Real &density_j = m_model->getDensity(neighborIndex); \n\t\t\t\tgradC_i += m_model->getMass(neighborIndex) / density_j * getColor(neighborIndex) * sim->gradW(xi - xj); \n\t\t\t) \n\t\t\tgradC_i *= (static_cast<Real>(1.0) / getColor(i)); \n\t\t\tReal &gradC2_i = getGradC2(i); \n\t\t\tgradC2_i = gradC_i.squaredNorm(); \n\t\t}", "pragma": "for ", "hash": "ca84105b210010254b3a40027d3beda26d8b634256f1b2484d381a394802d3ca"}
{"code": "for(j=0; j<N_COMPARTMENT; j++) \n\t  { \n\t    if(!(v_i_array[j] >= TABLE_SIZE || v_i_array[j]<0) ){ \n\t      ; \n\t    }else if(v_i_array[j] >= TABLE_SIZE){ \n\t      v_i_array[j]=TABLE_SIZE-1; theta_array[j]=1.0; \n\t    }else if(v_i_array[j] <  0){ \n\t      v_i_array[j]=0; theta_array[j]=0.0; \n\t    } \n\t  }", "pragma": "for ", "hash": "0153f901152f35e59cf7aeecb7fc9353730e86e3e142edcfeb51805f0b1b4d2a"}
{"code": "for (i3=0; i3<local_n0; i3++) { \n    for (i2=0; i2<n2; i2++) { \n      for (i1=0; i1<nk; i1++) { \n        cc[(i3*n2+i2)*n1+i1]=inp[(i3*n2+i2)*n1+i1]; \n      } \n    } \n  }", "pragma": "parallel for private(i1 i2 i3)", "hash": "431021331af2c7c2b5d5e4ca88ddb6ccbfc5543e6a991b44ca1940f53833fffe"}
{"code": "for (i = 0; i < nr_fold; i++) { \n    int begin = fold_start[i]; \n    int end = fold_start[i + 1]; \n    int j, k; \n    struct problem subprob; \n \n    subprob.bias = prob->bias; \n    subprob.n = prob->n; \n    subprob.l = l - (end - begin); \n    subprob.x = Malloc(struct feature_node *, subprob.l); \n    subprob.y = Malloc(double, subprob.l); \n \n    k = 0; \n    for (j = 0; j < begin; j++) { \n      subprob.x[k] = prob->x[perm[j]]; \n      subprob.y[k] = prob->y[perm[j]]; \n      ++k; \n    } \n    for (j = end; j < l; j++) { \n      subprob.x[k] = prob->x[perm[j]]; \n      subprob.y[k] = prob->y[perm[j]]; \n      ++k; \n    } \n    struct model *submodel = train(&subprob, param); \n    for (j = begin; j < end; j++) \n      target[perm[j]] = predict(submodel, prob->x[perm[j]]); \n    free_and_destroy_model(&submodel); \n    free(subprob.x); \n    free(subprob.y); \n  }", "pragma": "parallel for private(i)", "hash": "e1921cfe148f1ac5006bbde9a9b13ef1eb7b612809b09f9ec0564833e34f4618"}
{"code": "for (long int i=0;i<NumberofCommands;i++) {\r \n        string command = commandsArray[i];         \r \n        \r \n        if (VERBOSE_LEVEL == 2) {\r \n\r \n            int thread_no = omp_get_thread_num();\r \n\r \n            #pragma omp critical (standard_error)\r \n            {\r \n                cerr << \"CMD[\" << i << \"], thread[\" << thread_no << \"]: \" << command << endl;\r \n            }\r \n        }\r \n        \r \n        int ret = system(command.c_str());\r \n\r \n         \n \n        if (WIFSIGNALED(ret) &&\r \n            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)) {\r \n            #pragma omp critical (exit_critical)\r \n            exit(ret);  \n \n        }\r \n        else if (ret != 0) {\r \n                        \r \n            #pragma omp critical (capture_failed_command)\r \n            {\r \n                num_failed_commands++;\r \n                failedCommands.push_back(command);\r \n            }\r \n            \r \n\r \n            if (VERBOSE_LEVEL == 2) {\r \n                #pragma omp critical (standard_error)\r \n                {\r \n                    cerr << \"FAILURE:[\" << i << \"]  \" << command << endl;\r \n                }\r \n            }\r \n\r \n        }\r \n        else {\r \n            #pragma omp critical (report_success)\r \n            {\r \n                num_succeeded_commands++;\r \n            \r \n                successfully_completed_fh << command << endl;\r \n            }\r \n                \r \n            if (VERBOSE_LEVEL == 2) {\r \n            #pragma omp critical (standard_error)\r \n                cerr << \"SUCCESS:[\" << i << \"]  \" << command << endl;\r \n            }\r \n        }\r \n        \r \n        if (VERBOSE_LEVEL == 1) {\r \n            \r \n            stringstream ss;\r \n            ss << \"\\rsucceeded(\" << num_succeeded_commands << \")\";\r \n            if (num_failed_commands > 0) {\r \n                ss << \", failed(\" << num_failed_commands << \")\";\r \n            }\r \n            int total_executed = num_succeeded_commands + num_failed_commands;\r \n            float percent_done = (float)total_executed/NumberofCommands * 100;\r \n            \r \n            ss << \"   \" << percent_done << \"% completed.    \";\r \n\r \n            #pragma omp critical (standard_error)\r \n            cerr << ss.str();\r \n        }\r \n    }", "pragma": "parallel for ", "hash": "b6a55b6e97beb147741165c68d267b8db74d4783757ccf078e62eba444d296f3"}
{"code": "for(uint j=0; j<topSimplexes[i].size(); j++){ \n \n            TopSimplex tS = topSimplexes[i][j]; \n            vector<int> topVertices = tS.getVertices(); \n            for(int f=0; f<tS.getDimension()+1; f++){ \n                set<int> copy(topVertices.begin(), topVertices.end()); \n                copy.erase(topVertices[f]); \n                vector<int> face(copy.begin(), copy.end()); \n                face.push_back(j); \n                face.push_back(f); \n \n                #pragma omp critical \n                sorted_faces[(j*(dim+1))+f]=face; \n            } \n        }", "pragma": "parallel for ", "hash": "488acc2cab1d21badfe9a56a2232ab788b37b9d772b5230bbbbfffde43849419"}
{"code": "for(int k = 0; k < roi_out->height; k++) \n  { \n    const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n    float *out = ((float *)o) + (size_t)ch * k * roi_out->width; \n    for(int j = 0; j < roi_out->width; j++, in += 4, out += 4) \n      _mm_store_ps(out, _mm_mul_ps(_mm_sub_ps(_mm_load_ps(in), blackv), scalev)); \n  }", "pragma": "parallel for ", "hash": "608b4e55722505073bf94e80b4e47b4f8fe29f8478ed2244ac75a0ee14a0f3a7"}
{"code": "for(size_t stixel_index = 0; stixel_index < num_stixels; stixel_index += 1) \n        {  \n \n \n            row_given_stixel_and_row_step_t::const_reference \n                    bottom_v_given_stixel_and_row_step_at_stixel_index = bottom_v_given_stixel_and_row_step[stixel_index], \n                    top_v_given_stixel_and_row_step_at_stixel_index = top_v_given_stixel_and_row_step[stixel_index]; \n \n            disparity_given_stixel_and_row_step_t::const_reference \n                    disparity_given_stixel_and_row_step_at_stixel_index = disparity_given_stixel_and_row_step[stixel_index]; \n \n            compute_object_cost_stixel_using_slim_left( \n                        stixel_index, \n                        stixel_width, \n                        num_row_steps, \n                        num_columns, disparity_offset, \n                        transposed_slim_left_view, transposed_right_view, \n                        bottom_v_given_stixel_and_row_step_at_stixel_index, \n                        top_v_given_stixel_and_row_step_at_stixel_index, \n                        disparity_given_stixel_and_row_step_at_stixel_index, \n                        object_cost); \n \n        }", "pragma": "parallel for ", "hash": "e0215f9960ce4199a79c696d9f14599ac940ba555fb24319593deae6cfa5182f"}
{"code": "for (int i = 0; i < static_cast<int>(numVoxels); i++) \n\t\t\t{ \n\t\t\t\tauto rec = reconstructed[vec_i][i]; \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tmax_thread = max_thread > rec ? max_thread : rec; \n\t\t\t\tmin_thread = min_thread < rec ? min_thread : rec; \n\t\t\t}", "pragma": "for ", "hash": "f87179516e1f85a5f719de93b4100d2de87c711ad793b896ff588c2a1e5da65b"}
{"code": "for (int jout = 0; jout < win; jout++) { \n        if (jout % 13 == 0) { \n            fprintf(stderr, \"%d \", jout); \n            fflush(stderr); \n        } \n        for (int iout = 0; iout < hout; iout++) { \n            int min_iin = (int) ceilf(.5f*sw*(2.f*iout+1.f-s)-.5f); \n            int max_iin = (int) floorf(.5f*sw*(2.f*iout+1.f+s)-.5f); \n            if (min_iin > max_iin)  \n \n                min_iin = max_iin = (int)(.5f*sw*(2.f*iout+1.f)); \n            float sum_r = 0.f, sum_g = 0.f, \n                  sum_b = 0.f, sum_a = 0.f, \n                  sum_w = 0.f; \n            for (int iin = min_iin; iin <= max_iin; iin++) { \n                float kj = 0.5+iout-(iin+0.5f)*inv_sw; \n                float w = pre->value(kj); \n                int q = clamp.wrap(ext->wrap(iin, hin), hin)*win+jout; \n                float r = input.r[q], g = input.g[q], \n                      b = input.b[q], a = input.a[q]; \n                sum_r += r*w; sum_g += g*w; \n                sum_b += b*w; sum_a += a*w; \n                sum_w += w; \n            } \n             \n \n            int p = iout*win+jout; \n            output->r[p] = sum_r/sum_w; output->g[p] = sum_g/sum_w; \n            output->b[p] = sum_b/sum_w; output->a[p] = sum_a/sum_w; \n        } \n    }", "pragma": "parallel for ", "hash": "c3b82812d377ade08dcdcd9a1243af0f97c46bb1c86974c2a871a586163df9ec"}
{"code": "for (j = 0; j < h; j++) \n      for (i = 0; i < w; i++) { \n        uint16_t Temp = CLIP((int32_t) outimage[i+overlap + (j+overlap) * tilesize * nrtilesw]); \n        if (Temp <= 0x7fff) \n          Image->m_Image[i + j * w][0] = \n            CLIP((int32_t) ((1.-Mask[i+j*w])*Temp + Mask[i+j*w]*Image->m_Image[i + j * w][0])); \n        else \n          Image->m_Image[i + j * w][0] = \n            CLIP((int32_t) ((1.-Mask[i+j*w])*((Temp - (float)Image->m_Image[i+j*w][0])/3. + Image->m_Image[i+j*w][0]) + \n                            Mask[i+j*w]*Image->m_Image[i + j * w][0])); \n      }", "pragma": "for private(i j)", "hash": "7751ca0f7c08bd2bedf4e31e7c101c620e3edb3bae7a53f05ab3cfe4e5754f04"}
{"code": "for (auto e = slices.cbegin(); e < slices.cend(); ++e) { \n    DeflateDecompressor z(e->bs, mRaw, mPredictor, mBps); \n    try { \n      z.decode(&uBuffer, iPoint2D(mRaw->getCpp() * e->dsc.tileW, e->dsc.tileH), \n               iPoint2D(mRaw->getCpp() * e->width, e->height), \n               iPoint2D(mRaw->getCpp() * e->offX, e->offY)); \n    } catch (RawDecoderException& err) { \n      mRaw->setError(err.what()); \n    } catch (IOException& err) { \n      mRaw->setError(err.what()); \n    } \n  }", "pragma": "for ", "hash": "cb32b3668429557121d16ed604376d9a08924655eb48ea5935c35c004f832c86"}
{"code": "for(long ii=0;ii<nn;ii++)\r \n\t\t{\r \n\t\t\tmreal v = d->vthr(ii);\r \n\t\t\tif(m < v)\r \n\t\t\t{\tm=v;\tim=ii%nx;\tjm=(ii/nx)%ny;\tkm=ii/(nx*ny);   }\r \n\t\t}", "pragma": "for ", "hash": "a8e1692a14546d6741a9cc48cb662f7f4d18d70e20f7556c81527223a1a6919f"}
{"code": "for(iat=0;iat<nheavyat;iat++){ \n    if(error) continue; \n    while(nnl + nsym*natoms >= near_nl->neighl_size){ \n      nlsize = agbnp3_mymax(nlsize_increment*near_nl->neighl_size, nnl + nsym*natoms); \n      if(nblist_reallocate_neighbor_list(near_nl,natoms,nlsize) != NBLIST_OK){ \n\terror = 2; \n      } \n      if (error) continue; \n    } \n     \n \n    near_nl->nne[iat] = 0;   \n \n     \n \n    near_nl->neighl[iat] = &(near_nl->neighl1[nnl]);  \n    for(jat=iat+1;jat<nheavyat;jat++){ \n      dx = x[jat] - x[iat]; \n      dy = y[jat] - y[iat]; \n      dz = z[jat] - z[iat]; \n      d2 = dx*dx + dy*dy + dz*dz; \n      u = (r[iat]+r[jat])*nboffset; \n       \n \n      if(d2<u*u){ \n\t \n \n\tnear_nl->neighl1[nnl] = jat;     \n \n\tnnl += 1;                        \n \n\tnl_r2v[near_nl->nne[iat]] = d2;  \n \n\tnear_nl->nne[iat] += 1;          \n \n      }else{ \n\t \n \n\tnnlrc += 1;                      \n \n      } \n    } \n     \n \n    nnlrc += natoms - nheavyat + 1; \n \n    if(near_nl->nne[iat] > 0){ \n       \n \n      agbnp3_fsortindx(near_nl->nne[iat], nl_r2v, nl_indx ); \n      agbnp3_nblist_reorder(agbw, near_nl, iat, nl_indx); \n    } \n \n  }", "pragma": "for ", "hash": "ec0764a3e92b35353f22060392a503c788bbf8417664527f492732276b3a56a7"}
{"code": "for(i=1; i<=loaderObj->numberOfUniqueReads; i++) \n\t\t{ \n\t\t\tmate_pair_1=i; \n\t\t\tfor(a=matePairList[mate_pair_1]; a!=NULL; a=a->next) \n\t\t\t{ \n\t\t\t\tmate_pair_2=a->ID; \n\t\t\t\tif(a->flag==0 && mate_pair_1<mate_pair_2 && a->library==library) \n\t\t\t\t{ \n\t\t\t\t\tfor(u=readToEdgeList[mate_pair_1]; u!=NULL; u=u->next) \n\t\t\t\t\t{ \n\t\t\t\t\t\tfor(v=readToEdgeList[mate_pair_2]; v!=NULL; v=v->next) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tif(u->edge==v->edge || u->edge==v->edge->twinEdge)  \n \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tdistance1 = findDistanceOnEdge(v->edge, mate_pair_1); \n\t\t\t\t\t\t\t\tdistance2 = findDistanceOnEdge(v->edge, mate_pair_2); \n\t\t\t\t\t\t\t\tdistance=llabs(llabs(distance1[1])-llabs(distance2[1])); \n\t\t\t\t\t\t\t\tif(distance1[0]==1 && distance2[0]==1 && distance<(uint64_t)(4*mu)) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tsqrd_error_local+=(mu-distance)*(mu-distance); \n\t\t\t\t\t\t\t\t\tcounter_local++; \n\t\t\t\t\t\t\t\t\tsum_local+=distance; \n\t\t\t\t\t\t\t\t\tfree(distance1); \n\t\t\t\t\t\t\t\t\tfree(distance2); \n\t\t\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tfree(distance1); \n\t\t\t\t\t\t\t\tfree(distance2); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "29f5fb0ee6cbf6b23b5cf1163140f727b5cccbf41f62488d860a0bd752c580a3"}
{"code": "for (uint32_t i=0; i < m_Size; i++) {\r \n      Y[i] = ToFloatTable[m_Image[i][0]];\r \n    }", "pragma": "parallel for ", "hash": "f4a9d83463c5fbf87227dfea6a1850aff849e1d10f1f0c8e4d179c88a53b0974"}
{"code": "for (int channel=0; channel<m_intClass->numOfKu3; channel++){ \n        unsigned long int lowBound_hhh  = m_intClass->boundsHolder_hhhppp_hhh(0,channel); \n        unsigned long int highBound_hhh = m_intClass->boundsHolder_hhhppp_hhh(1,channel); \n        unsigned long int lowBound_ppp  = m_intClass->boundsHolder_hhhppp_ppp(0,channel); \n        unsigned long int highBound_ppp = m_intClass->boundsHolder_hhhppp_ppp(1,channel); \n \n        unsigned long int dim_hhh = highBound_hhh - lowBound_hhh; \n        unsigned long int dim_ppp = highBound_ppp - lowBound_ppp; \n        MakeAmpMat::MatrixX newMat; \n        newMat.conservativeResize(dim_hhh, dim_ppp); \n \n        int i; int j; int k; \n        int a; int b; int c; \n \n        for (unsigned long int ppp=lowBound_ppp; ppp<highBound_ppp; ppp++){ \n            a = m_intClass->blockArrays_ppp_ppp(0,ppp); \n            b = m_intClass->blockArrays_ppp_ppp(1,ppp); \n            c = m_intClass->blockArrays_ppp_ppp(2,ppp); \n            for (unsigned long int hhh=lowBound_hhh; hhh<highBound_hhh; hhh++){ \n                i = m_intClass->blockArrays_ppp_hhh(0,hhh); \n                j = m_intClass->blockArrays_ppp_hhh(1,hhh); \n                k = m_intClass->blockArrays_ppp_hhh(2,hhh); \n \n                id = m_intClass->Identity_hhhppp(i,j,k,a,b,c); \n                index = T3_elements_I.find(id)->second; \n \n                denom3_elements[index] = 1./( (FockMap_h[i] + FockMap_h[j] + FockMap_h[k] - FockMap_p[a] - FockMap_p[b] - FockMap_p[c] ) ); \n            } \n        } \n    }", "pragma": "parallel for private( id index)", "hash": "5cc7971448fcdbc097810a9cdab006870c15f649d8ed4cd0d5e1f93c57bf437d"}
{"code": "for (j = 1; j < grid_points[1]-1; j++) { \n      for (k = 1; k < grid_points[2]-1; k++) { \n\tfor (m = 0; m < BLOCK_SIZE; m++) { \n\t  for (n = 0; n < BLOCK_SIZE; n++) { \n\t    rhs[i][j][k][m] = rhs[i][j][k][m] \n\t      - lhs[i][j][k][CC][m][n]*rhs[i+1][j][k][n]; \n\t  } \n\t} \n      } \n    }", "pragma": "for private(k m n)", "hash": "2d6e72df951d612b81c1993461374d2eb0b22261f72195f935128d155d7dcb2c"}
{"code": "for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) { \n          register float complex temp = zero; \n          for (size_t l = 0; l < k; l++) \n            temp += conjf(A[i * lda + l]) * conjf(B[l * ldb + j]); \n          if (beta == zero) \n            C[j * ldc + i] = alpha * temp; \n          else \n            C[j * ldc + i] = alpha * temp + beta * C[j * ldc + i]; \n        } \n      }", "pragma": "parallel for ", "hash": "245389e05a47d049188b89601016551a423618508559d53e671df21accc8444b"}
{"code": "for (int i = 0; i < particleAmount; ++i) { \n\t\tthis->particleList[i].id = i; \n\t\tthis->previousParticleList[i].id = i; \n \n\t\t \n \n\t\tstd::random_device rd; \n\t\tstd::mt19937_64 mt(rd()); \n\t\tstd::uniform_int_distribution<int> distribution(0, clusterAmount - 1); \n\t\tthis->particleList[i].clusterID = distribution(mt); \n \n\t\tint streuung = 1; \n\t\tstd::uniform_int_distribution<int> distribution2(std::max(0, this->particleList[i].clusterID - streuung), std::min(clusterAmount - 1, this->particleList[i].clusterID + streuung)); \n\t\tthis->previousParticleList[i].clusterID = distribution2(mt); \n \n\t\t \n \n\t\tstd::uniform_real_distribution<float> disPos(0, 500); \n\t\tthis->particleList[i].x = disPos(mt); \n\t\tthis->particleList[i].y = disPos(mt); \n\t\tthis->particleList[i].z = disPos(mt); \n\t}", "pragma": "parallel for ", "hash": "ea6ce60ce4275a21eb61556fb6a36927f9d2fabf0de41e102967f1f20bef0e53"}
{"code": "for (int i = 0; i < matrix->row_count; ++i) {\r \n        delete[] matrix->values[i];  \n \n    }", "pragma": "parallel ", "hash": "0ab783ccb8d7160fcc62ece58bbafabe498bdd92a77eb7361961622753ff06d5"}
{"code": "for (i = 0; i < batchSize; ++i) { \n            Array currentA = As+(i*n); \n            Array currentB = Bs+(i*n*n); \n            Array currentC = Cs+(i*n); \n            Array currentD = Ds+(i*n); \n \n             \n \n            for (j = 0; j < n; ++j) { \n                currentB[j + j*n] += currentC[j]; \n            } \n \n            int error; \n            int one = 1; \n \n            spotrf_(\"U\", &n, currentB, &n, &error); \n             \n \n            ensure(!error, \"Error code %d in cholesky factorization\", error); \n \n            spotrs_(\"U\", \n                &n,  \n \n                &one,  \n \n                currentB,  \n \n                &n,  \n \n                currentD,  \n \n                &n,  \n \n                &error \n            ); \n            ensure(!error, \"Error code %d while solving linear system of equations\", error); \n \n            Means[i] = cblas_sdot ( \n                n,  \n \n                currentA,  \n \n                1,  \n \n                currentC,  \n \n                1  \n \n            ); \n        }", "pragma": "for ", "hash": "b5ead648563bbe9ef4d51259524f2cb5429b5469032e9e95536468c3827ecd9f"}
{"code": "for (i=0; i<thds; i++) { \n    prvt.i = i; \n    barrier (t); \n    if (prvt.i != i) { \n      #pragma omp critical \n      errors += 1; \n    } \n    if (sizeof(prvt) != sizeof(union x)) { \n      #pragma omp critical \n      errors += 1; \n    } \n    if (i==0) { \n      waittime (1); \n    } \n    prvt.i = i; \n  }", "pragma": "for private(prvt)", "hash": "a97287a54f6524dded4411ba6b394f95757098f66719c892b96e3427cb4c67ee"}
{"code": "for (j = 0; j < m->width; j++) \n\t{ \n\t\ttmp = MATRIX(m, i1, j); \n\t\tMATRIX(m, i1, j) = MATRIX(m, i2, j); \n\t\tMATRIX(m, i2, j) = tmp; \n\t}", "pragma": "parallel for private( j tmp)", "hash": "5bae47e3b711eb2323c56323ca5b256aabc71e60a3cda26eab52db0c05c7171a"}
{"code": "for (j = 1; j <= lastcol-firstcol+1; j++) { \n\td = x[j] - r[j]; \n\tsum = sum + d*d; \n    }", "pragma": "for reduction(+:sum) private(d)", "hash": "f98b02bcbb6b5753e058855a57864b08b1904f6b1a5c2d1c9bf2634c167bf186"}
{"code": "for (int i = 0; i < size; ++i) { \n      if (j > i) { \n\tcout << \"uhoh\\n\"; \n\tLOG_FAIL(\"replacement for throw call\"); \n\tthrow; \n      } \n      while (j < i) { \n\t++iter; \n\t++j; \n      } \n      iter->second->CullAllBut(num); \n    }", "pragma": "for ", "hash": "bdce840f76297601c9d68af95b382a5b97490310bf2d5f9b7cbe1a17e04868ca"}
{"code": "for (index j = 0; j < bands.size(); j++) { \n            Band& band = bands[j]; \n             \n            if (j+1 < bands.size()) { \n                for (index i = 0; i < n; i++) { \n                    if (radii[i] >= bandRadii[j] && radii[i] < bandRadii[j+1]) { \n                        band.pt_id.push_back(i); \n                        band.pt_theta.push_back(angles[i]); \n                        band.pt_invsinh.push_back(pt_invsinh[i]); \n                        band.pt_cosh.push_back(pt_cosh[i]); \n                    } \n                } \n            } \n             \n            band.band_id = j; \n            band.rad_cosh = std::cosh(bandRadii[j]); \n            band.rad_invsinh = 1.0 / std::sinh(bandRadii[j]); \n            band.avg_spacing = band.pt_id.size() / (2.0 * M_PI); \n        }", "pragma": "parallel for ", "hash": "8859a2259ee90b54cb1abfde89f0dd6e72c77125c22b95d3c6023280853454d2"}
{"code": "for(i = 0; i < dim; i++) \n\t\tpivot[i] = i;", "pragma": "parallel for ", "hash": "88a7c970f35e39c219113964db6ea88977fbbc479caa8a014fd673ccddc3d628"}
{"code": "for (int j = ymin; j < ymax; j++) \n      for (int i = xmin; i < xmax; i++) \n      { \n        colors.clear(); \n \n         \n \n        for (int p = 0; p < nrank; p++) \n        { \n          const int xminr = tilesBndRecv[p].x; \n          const int yminr = tilesBndRecv[p].y; \n          const int xmaxr = tilesBndRecv[p].z + xminr; \n          const int ymaxr = tilesBndRecv[p].w + yminr; \n          if (i >= xminr && i < xmaxr && j >= yminr && j < ymaxr) \n          { \n            const int iloc = i - xminr; \n            const int jloc = j - yminr; \n            assert(iloc >= 0); \n            assert(jloc >= 0); \n            assert(iloc <  localTile.z); \n            assert(jloc <  localTile.w); \n            const int idx = jloc*(xmaxr - xminr) + iloc; \n            assert(recvdispl[p] + idx < recvdispl[p+1]); \n            colors.push_back(recvbuf[recvdispl[p] + idx]); \n          } \n        } \n \n         \n \n        std::sort( \n            colors.begin(), colors.end(), \n            [](const vec5 &a, const vec5 &b){ return a[4] < b[4]; } \n            ); \n \n         \n \n        float4 dst = make_float4(0.0f); \n        for (auto &src : colors) \n        { \n          src[0] *= 1.0f - dst.w; \n          src[1] *= 1.0f - dst.w; \n          src[2] *= 1.0f - dst.w; \n          src[3] *= 1.0f - dst.w; \n \n          dst.x += src[0]; \n          dst.y += src[1]; \n          dst.z += src[2]; \n          dst.w += src[3]; \n \n          dst.w = std::min(dst.w, 1.0f); \n        } \n        imgLoc[(j-ymin)*(xmax-xmin)+(i-xmin)] = dst; \n      }", "pragma": "for ", "hash": "b4f4765a4f47885650b0179ddedce15da6c3a6fb74c114994656534ed71ccfd4"}
{"code": "for(ix=0; ix<nx; ix++){ \n\t\t\t\tfor(iz=0; iz<nz; iz++){ \n\t\t\t\t\tfwf[wfit][ix][iz]=txxn0[ix+nfd+pmlsize][iz+nfd+pmlsize]; \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for private(ix iz)", "hash": "b15dd32ee3f014374c3576d1a5274bb1155e3d0a4c19db51a13cf739da862ae5"}
{"code": "for (int i = 0; i < (int)radial_functions_desc__.size(); i++) \n        { \n            for (int ispn: {0, 1}) \n            { \n                sirius::Bound_state bound_state(relativity_t::none, zn__, radial_functions_desc__[i].n, radial_functions_desc__[i].l,  \n                                                0, rgrid__, veff_spherical__[ispn], enu__(i, ispn)); \n                enu__(i, ispn) = bound_state.enu(); \n                STOP(); \n                 \n \n                 \n \n \n                 \n \n                 \n \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n            } \n        }", "pragma": "for ", "hash": "acdd2b086f30698fcd52d4b3fc335e8e7691c5b04a6b5e3ead4019ad46e7c627"}
{"code": "for (i = 0; i < N; i++) { \n    md[i] = ZERO; \n \n     \n \n    if (cd[i] == ZERO) \n      continue; \n \n     \n \n    test = (SUNRabs(cd[i]) > ONEPT5 && xd[i]*cd[i] <= ZERO) || \n           (SUNRabs(cd[i]) > HALF   && xd[i]*cd[i] <  ZERO); \n    if (test) { \n      temp = md[i] = ONE;  \n \n    } \n  }", "pragma": "parallel for private(i test)", "hash": "41b58671cd99914f6513ee1234bfdb3ddd0757fcb885ecadd2e39b5a9346a9a5"}
{"code": "for(long i=0;i<n;i+=tx)\tfor(long j=0;j<m;j+=ty)\r \n\t\t{\r \n\t\t\tlong i0 = i+n*j;\r \n\t\t\txx = s.x.a[i0];\tyy = s.y.a[i0];\tzz = s.z.a[i0];\r \n\t\t\tp1 = i<n-1 ? mglPoint(s.x.a[i0+tx]-xx, s.y.a[i0+tx]-yy, s.z.a[i0+tx]-zz) : mglPoint(xx-s.x.a[i0-tx], yy-s.y.a[i0-tx], zz-s.z.a[i0-tx]);\r \n\t\t\tp2 = j<m-1 ? mglPoint(s.x.a[i0+tn]-xx, s.y.a[i0+tn]-yy, s.z.a[i0+tn]-zz) : mglPoint(xx-s.x.a[i0-tn], yy-s.y.a[i0-tn], zz-s.z.a[i0-tn]);\r \n\t\t\tv.Set(s.ax.a[i0], s.ay.a[i0], s.az.a[i0]);\r \n\t\t\tc1 = v.norm();\txm1 = xm1<c1 ? c1:xm1;\t \n \n\t\t\tyy = fabs(v*d);\txx = d.norm();\tyy *= xx?1/(xx*xx):0;\r \n\t\t\tc1 = fabs(v*p1);\txx = p1.norm();\tc1 *= xx?1/(xx*xx):0;\r \n\t\t\tc2 = fabs(v*p2);\txx = p2.norm();\tc2 *= xx?1/(xx*xx):0;\r \n\t\t\tc1 = c1<c2 ? c2:c1;\tc1 = c1<yy ? yy:c1;\r \n\t\t\tca+=c1;\tcm1 = cm1<c1 ? c1:cm1;\r \n\t\t}", "pragma": "for reduction(+:ca) ", "hash": "ed9e28a1660e66ddc78eb8cb742a7b61dd30859abba66b65a2798f7281eb8054"}
{"code": "for (int i = 0; i < numHiddenUnits; i++) \n  { \n    sum += exp(x[i]); \n  }", "pragma": "parallel for reduction(+:sum) ", "hash": "6d5592fc6f4b689857f4d02cefc4339cb8d961266b60dbc0ad143d867bd6d138"}
{"code": "for(unsigned long n=0; n<ncell; n++)\t\t\t\t\t\t \n\t\t{ \n\t\t \n\t\t \n \n\t\tif( CellVector[n].Get_phase() != dead )  \n\t\t\t{ \n\t\t\tint code = CellVector[n].CheckMVA(); \n\t\t\tif(code < 0) errorlog_file << \"Errore \" << code << \" all'inizio di CellSystem::Diff nel controllo di consistenza per la cellula \" << n << \"\\n\" << endl; \n\t\t\t} \n \n\t\t \n \n\t\tvolumeOld[n] = volumeNew[n] = CellVector[n].Get_volume(); \n\t\tvolume_extraOld[n] = volume_extraNew[n] = CellVector[n].Get_volume_extra(); \n\t\t \n\t\t \n \n\t\tMitOld[n] = MitNew[n] = CellVector[n].Get_M(); \n\t\t \n\t\t \n \n\t\tpHiOld[n] = pHiNew[n] = CellVector[n].Get_pHi(); \n\t\tpHOld[n] = pHNew[n] = CellVector[n].Get_pH(); \n\t\t\t\t \n\t\t \n \n\t\tmGinOld[n] = mGinNew[n] = CellVector[n].Get_G(); \n\t\tmGextOld[n] = mGextNew[n] = CellVector[n].Get_G_extra(); \n\t\t \n\t\t \n \n\t\tmG6POld[n] = mG6PNew[n] = CellVector[n].Get_G6P(); \n\t\t \n\t\t \n \n\t\tmO2Old[n] = mO2New[n] = CellVector[n].Get_O2(); \n\t\t \n\t\t \n \n\t\tStoreOld[n] = StoreNew[n] = CellVector[n].Get_store(); \n\t\t \n\t\t \n \n\t\tmAinOld[n] = mAinNew[n] = CellVector[n].Get_A(); \n\t\tmAextOld[n] = mAextNew[n] = CellVector[n].Get_A_extra(); \n\t\t \n\t\t \n \n\t\tmAcLinOld[n] = mAcLinNew[n] = CellVector[n].Get_AcL(); \n\t\tmAcLextOld[n] = mAcLextNew[n] = CellVector[n].Get_AcL_extra(); \n\t\t \n\t\t \n \n\t\tATPpOld[n] = ATPpNew[n] = CellVector[n].Get_ATPp(); \n \n\t\t}", "pragma": "parallel for ", "hash": "a6020f4063f1d39a2273ed5b6d9afcffdd17a28f3be5ab4b7381458e7225fc82"}
{"code": "for (int i=0;i<dat->raw_nchan;i++) { \n      for (int j=0;j<dat->ndata;j++) { \n        mytot[j]+=dat->raw_data[i][j]*weights[i]; \n      } \n    }", "pragma": "for ", "hash": "531596d6f4ceb3e7c07cef7c3da8944062d65d4bc97a0e6de9cca54d3b21d6ab"}
{"code": "for(size_t iy=0; iy<local_nky; iy++) { \n    for(size_t ix=0; ix<nc; ix++) { \n      for(size_t iz=0; iz<nckz; iz++){ \n\tsize_t index= (nc*iy + ix)*nckz + iz; \n\tdelta_k[index][0]= pm_k[index][0]; \n\tdelta_k[index][1]= pm_k[index][1];\t \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "7e0c001aabeb86bbdf3a8dd55465ef0f165b4c06c7407f30a499e51e344ffe1f"}
{"code": "for (size_t i = 0; i < sz; ++i) { \n    n_kmers += \n        (refseq_.GetSeqView(i).length() - seed_kmer_size + sparsity) / sparsity; \n  }", "pragma": "parallel for reduction(+ : n_kmers) ", "hash": "b2c8c9bc42b5a5fc1216ad7e75e5749394137ae0564f6990210497ae06368c6d"}
{"code": "for (i=0;i<N;i++) { \n         \n \n        x = (X[i]     - omega[0]) / h[0] + .5 - 1; \n        y = (X[i+N]   - omega[2]) / h[1] + .5 - 1; \n        z = (X[i+2*N] - omega[4]) / h[2] + .5 - 1; \n         \n        xf = floor(x); \n        yf = floor(y); \n        zf = floor(z); \n         \n        if (boundary) { \n             \n \n            x1 = min(m[0]-1,max(0,xf)); \n            x2 = min(m[0]-1,max(0,xf+1)); \n            y1 = min(m[1]-1,max(0,yf)); \n            y2 = min(m[1]-1,max(0,yf+1)); \n            z1 = min(m[2]-1,max(0,zf)); \n            z2 = min(m[2]-1,max(0,zf+1)); \n \n            p[0] = T[x1 + i2 * y1 + i3 * z1]; \n            p[1] = T[x2 + i2 * y1 + i3 * z1]; \n            p[2] = T[x1 + i2 * y2 + i3 * z1]; \n            p[3] = T[x2 + i2 * y2 + i3 * z1]; \n            p[4] = T[x1 + i2 * y1 + i3 * z2]; \n            p[5] = T[x2 + i2 * y1 + i3 * z2]; \n            p[6] = T[x1 + i2 * y2 + i3 * z2]; \n            p[7] = T[x2 + i2 * y2 + i3 * z2]; \n        } else { \n             \n \n             \n \n            if (x<-1 || y<-1 || z<-1 || x>=m[0] || y>=m[1] || z>=m[2]) \n                continue; \n             \n            p[0] = (xf<0        || yf<0        || zf<0)?        0: T[xf  +i2*yf    +i3*zf]; \n            p[1] = (xf+1>m[0]-1 || yf<0        || zf<0)?        0: T[xf+1+i2*yf    +i3*zf]; \n            p[2] = (xf<0        || yf+1>m[1]-1 || zf<0)?        0: T[xf  +i2*(yf+1)+i3*zf]; \n            p[3] = (xf+1>m[0]-1 || yf+1>m[1]-1 || zf<0)?        0: T[xf+1+i2*(yf+1)+i3*zf]; \n            p[4] = (xf<0        || yf<0        || zf+1>m[2]-1)? 0: T[xf  +i2*yf    +i3*(zf+1)]; \n            p[5] = (xf+1>m[0]-1 || yf<0        || zf+1>m[2]-1)? 0: T[xf+1+i2*yf    +i3*(zf+1)]; \n            p[6] = (xf<0        || yf+1>m[1]-1 || zf+1>m[2]-1)? 0: T[xf  +i2*(yf+1)+i3*(zf+1)]; \n            p[7] = (xf+1>m[0]-1 || yf+1>m[1]-1 || zf+1>m[2]-1)? 0: T[xf+1+i2*(yf+1)+i3*(zf+1)]; \n        } \n \n         \n \n        x = x - xf; \n        y = y - yf; \n        z = z - zf; \n         \n        Tc[i] = ((p[0] * (1-x) + p[1] * x) * (1-y) \n              +  (p[2] * (1-x) + p[3] * x) *    y) * (1-z) \n              + ((p[4] * (1-x) + p[5] * x) * (1-y) \n              +  (p[6] * (1-x) + p[7] * x) *    y) *    z; \n         \n        if (mxIsNaN(Tc[i])) \n            mexPrintf(\"Is NAN\"); \n         \n        if (doDerivative) { \n            dT[i]     = (((p[1] - p[0]) * (1-y) + (p[3] - p[2]) * y) * (1-z) \n                      +  ((p[5] - p[4]) * (1-y) + (p[7] - p[6]) * y) *    z) / h[0]; \n             \n            dT[i+N]   = (((p[2] - p[0]) * (1-x) + (p[3] - p[1]) * x) * (1-z) \n                      +  ((p[6] - p[4]) * (1-x) + (p[7] - p[5]) * x) *    z) / h[1]; \n             \n            dT[i+2*N] = (((p[4] * (1-x) + p[5] * x) * (1-y) \n                      +   (p[6] * (1-x) + p[7] * x) *    y) \n                      -  ((p[0] * (1-x) + p[1] * x) * (1-y) \n                      +   (p[2] * (1-x) + p[3] * x) *    y)) / h[2]; \n        } \n    }", "pragma": "parallel for private(             i p x x1 x2 xf y y1 y2 yf z z1 z2 zf)", "hash": "a601a05e6b35be16f6f2cd4cc9608d7e9cedece65f901de31195ad3f79719ebe"}
{"code": "for(size_type i = 0; i < this->index->sequences(); i++) \n  { \n    std::vector<sample_record> head_buffer, tail_buffer; \n    size_type seq_offset = 0, run_id = endmarker_runs[i]; \n    if(i == 0 || run_id != endmarker_runs[i - 1]) \n    { \n      head_buffer.push_back({ i, seq_offset, this->globalRunId(ENDMARKER, run_id) }); \n    } \n    if(i + 1 >= this->index->sequences() || run_id != endmarker_runs[i + 1]) \n    { \n      tail_buffer.push_back({ i, seq_offset, this->globalRunId(ENDMARKER, run_id) }); \n    } \n    edge_type curr = this->index->start(i); seq_offset++; \n    range_type run(0, 0); \n    while(curr.first != ENDMARKER) \n    { \n      edge_type next = this->index->record(curr.first).LF(curr.second, run, run_id); \n      if(curr.second == run.first) \n      { \n        head_buffer.push_back({ i, seq_offset, this->globalRunId(curr.first, run_id) }); \n      } \n      if(curr.second == run.second) \n      { \n        tail_buffer.push_back({ i, seq_offset, this->globalRunId(curr.first, run_id) }); \n      } \n      curr = next; seq_offset++; \n    } \n     \n \n     \n \n     \n \n    for(sample_record& record : head_buffer) { record.seq_offset = seq_offset - 1 - record.seq_offset; } \n    for(sample_record& record : tail_buffer) { record.seq_offset = seq_offset - 1 - record.seq_offset; } \n    #pragma omp critical \n    { \n      this->header.max_length = std::max(this->header.max_length, seq_offset); \n      head_samples.insert(head_samples.end(), head_buffer.begin(), head_buffer.end()); \n      tail_samples.insert(tail_samples.end(), tail_buffer.begin(), tail_buffer.end()); \n    } \n  }", "pragma": "parallel for ", "hash": "a8ee098cfe87813126cbde714e502d535bc8d11f9712ad37ecaaff2b38a389fb"}
{"code": "for (k = 0; k < xrs->nz; k++) { \n\t \n \n\t \n \n\t \n \n\ttmp = vol->data[i][xrs->ny-1-j][xrs->nz-1-k] * 256; \n\tif (tmp < 0.) { tmp = 0.; } \n\tif (tmp > 255.999) { tmp = 255.999; } \n\txrs->data[(long)k * w * h + j * w + i] = (unsigned char)(floorf(tmp)); \n      }", "pragma": "parallel for private(k tmp)", "hash": "28e36a5e982785d1ec0718d18899df813a46227dd1c41c00b3c25a4d91eafa82"}
{"code": "for (int i = 0; i < inUrls.size(); ++i) \n    { \n \n        if (error) \n        { \n            continue; \n        } \n \n        KUrl url = inUrls.at(i); \n \n        if (isRawFile(url.toLocalFile())) \n        { \n            KUrl preprocessedUrl, previewUrl; \n \n            if (!convertRaw(url, preprocessedUrl, settings)) \n            { \n                error = true; \n                continue; \n            } \n \n            if (!computePreview(preprocessedUrl, previewUrl)) \n            { \n                error = true; \n                continue; \n            } \n \n \n            #pragma omp critical (listAppend) \n            { \n                mixedUrls.append(preprocessedUrl); \n                 \n \n                preProcessedUrlsMap.insert(url, ItemPreprocessedUrls(preprocessedUrl, previewUrl)); \n            } \n        } \n        else \n        { \n             \n \n            KUrl previewUrl; \n            if (!computePreview(url, previewUrl)) \n            { \n                error = true; \n                continue; \n            } \n \n            #pragma omp critical (listAppend) \n            { \n                mixedUrls.append(url); \n                 \n \n                preProcessedUrlsMap.insert(url, ItemPreprocessedUrls(url, previewUrl)); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "8cc2b878087f7c8000d4422fa348d8ccab4704228d4e0d1c7ab2bf418ea07ea1"}
{"code": "for (int fragIndex = 0; fragIndex < numCols; ++fragIndex)\r \n        {\r \n            solver.solve(signal->col(fragIndex));\r \n            solution->col(fragIndex).noalias() = solver.x();\r \n        }", "pragma": "parallel for private(solver)", "hash": "c9a390b1a8bb2ecdbbbba570ecaa004bd6961fad84c982749047a987e9d4f6be"}
{"code": "for (int i = 0; i < nAtoms_; ++i) { \n    Eigen::MatrixXd chemicalEnvironment = calculateChemicalEnvironment(i); \n    MachineLearning::PrincipalComponentAnalysis pca(chemicalEnvironment); \n    Eigen::MatrixXd matrix = pca.calculate(3).first; \n \n     \n \n     \n \n    Eigen::MatrixXd inverseMatrix = matrix.inverse(); \n    Eigen::Vector3d internalCenterOfCharge = inverseMatrix * (centerOfCharge - currentPositions_.row(i)).transpose(); \n    for (int d = 0; d < 3; ++d) { \n      if (internalCenterOfCharge(d) < 0.0) { \n        matrix.col(d) *= -1; \n      } \n    } \n \n    transformationMatrices_[i] = matrix; \n  }", "pragma": "parallel for ", "hash": "1c896697cf7e7246ed74be44de0930e8245aaa3a4cb801a535d48f5c303f54f5"}
{"code": "for (int i = 0; i < N; i++) { \n \n    const int nnz = Ymat.outerIndexPtr()[i + 1] - Ymat.outerIndexPtr()[i]; \n    VectorXd Yhat(nnz); \n \n     \n \n    int idx = 0; \n    VectorXd Qi = lambda; \n    for (SparseMatrix<double>::InnerIterator it(Ymat, i); it; ++it, idx++) { \n      Qi.noalias() += alpha * V.col(it.row()).cwiseAbs2(); \n      Yhat(idx)     = mean_value + U.col(i).dot( V.col(it.row()) ); \n    } \n    VectorXd rnorms(num_latent); \n    bmrandn_single(rnorms); \n \n    for (int d = 0; d < D; d++) { \n       \n \n      const double uid = U(d, i); \n      double Lid = lambda(d) * (mu(d) + Uhat(d, i)); \n \n      idx = 0; \n      for ( SparseMatrix<double>::InnerIterator it(Ymat, i); it; ++it, idx++) { \n        const double vjd = V(d, it.row()); \n         \n \n        Lid += alpha * (it.value() - (Yhat(idx) - uid*vjd)) * vjd; \n      } \n       \n \n      double uid_old = U(d, i); \n      double uid_var = 1.0 / Qi(d); \n \n       \n \n      U(d, i) = Lid * uid_var + sqrt(uid_var) * rnorms(d); \n \n       \n \n      double uid_delta = U(d, i) - uid_old; \n      idx = 0; \n      for (SparseMatrix<double>::InnerIterator it(Ymat, i); it; ++it, idx++) { \n        Yhat(idx) += uid_delta * V(d, it.row()); \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "29f80b3e6bbc49290df75a5697ce30446383782ddb3cf3acb881cc084a05e3e8"}
{"code": "for (ompIndexType i = 0; i < (ompIndexType)count; i = i + 1) { \n        dstPtr[i << 1] = (TOUT)ptr[i]; \n    }", "pragma": "parallel for ", "hash": "7f209bdbd53ed7aa1625e39872cec42611823f738c6fd4935309a7ba5311a37b"}
{"code": "for(unsigned i=0;i<param.numAnts;i++){ \n    float pheromonesAmount=float(param.Q)/antCost[i]; \n    for(unsigned j=0;j<(tam-1);j++){ \n      unsigned a=antPath[i][j]; \n      unsigned b=antPath[i][j+1]; \n      float newPheromones=pheromones[a][b] + pheromonesAmount; \n      pheromones[a][b]=newPheromones; \n      pheromones[b][a]=newPheromones; \n    } \n    unsigned a=antPath[i][0]; \n    unsigned b=antPath[i][tam-1]; \n    float newPheromones=pheromones[a][b] + pheromonesAmount; \n     \n \n    int itMin = min(a, b); \n    int itMax = max(a, b); \n    omp_set_lock(matrixSemaphore[itMin][itMax]); \n    pheromones[a][b]=newPheromones;    \n    pheromones[b][a]=newPheromones; \n    omp_unset_lock(matrixSemaphore[itMin][itMax]); \n  }", "pragma": "parallel for ", "hash": "f25a2cb14ed32195c4440d0600778781855853d7c5d72b70e8efe00446592289"}
{"code": "for (int i=0; i<N; i++) if (omask[i]) \n   { \n      int proc = omp_get_thread_num(); \n      double* tprobabilities = probsArr[proc].data(); \n      double tphi; \n      double phii = phi[i]; \n      int k; \n       \n \n      double maxProb = -mxGetInf(); \n      if (K==1) \n      { \n         k = k0; \n      } \n      else if (useSuperclusters) \n      { \n         int ki = z2k[(int)phii]; \n         int sci = superclusters[ki]; \n         for (int k2i=0; k2i<supercluster_labels_count[sci]; k2i++) \n         { \n            int k2 = supercluster_labels[sci*K + k2i]; \n            int m = k2z[k2]; \n \n             \n \n            double prob = params[m]->get_params()->predictive_loglikelihood(data+i*D) + sticks[m]; \n            maxProb = max(maxProb, prob); \n            tprobabilities[k2i] = prob; \n         } \n \n          \n \n         int k2i = max_categorical(tprobabilities, supercluster_labels_count[sci]); \n         k = supercluster_labels[sci*K+k2i]; \n      } \n      else \n      { \n         for (int k2=0; k2<K; k2++) \n         { \n            int m = k2z[k2]; \n \n             \n \n            double prob = params[m]->get_params()->predictive_loglikelihood(data+i*D) + sticks[m]; \n            maxProb = max(maxProb, prob); \n            tprobabilities[k2] = prob; \n         } \n \n          \n \n         k = max_categorical(tprobabilities, K); \n      } \n      int m = k2z[k]; \n \n      double loglikelihood, lognorm; \n      double logpl = params[m]->get_paramsl()->predictive_loglikelihood(data+i*D); \n      double logpr = params[m]->get_paramsr()->predictive_loglikelihood(data+i*D); \n       \n \n      tphi = params[m]->max_subcluster_label(logpl, logpr, rArr[proc], loglikelihood, lognorm); \n \n       \n \n      likelihoodArr.reduce_add(proc, k, loglikelihood); \n      likelihoodzArr.reduce_add(proc, k, loglikelihood-lognorm); \n \n       \n \n      phi[i] = m + tphi; \n \n       \n \n      int bin = k*2 + (int)(tphi*2); \n      NArr.reduce_inc(proc, bin); \n      tArr.reduce_add(proc, bin, data+(i*D)); \n      TArr.reduce_add_outerprod(proc, bin, data+i*D); \n \n      double pz = tprobabilities[k]; \n      for (int k2=0; k2<K; k2++) \n      { \n         double temp = pz; \n         if (k!=k2) \n            temp = logsumexp(pz, tprobabilities[k2]); \n             \n \n         likelihoodzMtx.reduce_add(proc, k*K + k2, temp); \n      } \n   }", "pragma": "parallel for ", "hash": "3016b49f36b703df42d689b9759d2b75b4d499adc722658c997b5d8dd0b33b88"}
{"code": "for (int i = 0; i < N; i++) { \n    res += a[i] * b[i]; \n  }", "pragma": "parallel for reduction(+:res) ", "hash": "105a445dc04c75bb0bbde730f5dfb03620b3a30443b74a814fffeb9716660064"}
{"code": "for (int x1 = 1; (x1 <= 8); x1 = (x1 + 1)) \n    { \n      #pragma ivdep \n       for (int x2 = 1; (x2 <= (8 - 7)); x2 = (x2 + (1 * 8))) \n       { \n         x3 = _out_grid_array_macro(x1, x2); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), (x2 + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), (x2 + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), (x2 + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), (x2 + 1))]); \n         x3 = _out_grid_array_macro(x1, (x2 + 1)); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 1) + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), ((x2 + 1) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), ((x2 + 1) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 1) + 1))]); \n         x3 = _out_grid_array_macro(x1, (x2 + 2)); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 2) + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), ((x2 + 2) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), ((x2 + 2) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 2) + 1))]); \n         x3 = _out_grid_array_macro(x1, (x2 + 3)); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 3) + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), ((x2 + 3) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), ((x2 + 3) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 3) + 1))]); \n         x3 = _out_grid_array_macro(x1, (x2 + 4)); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 4) + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), ((x2 + 4) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), ((x2 + 4) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 4) + 1))]); \n         x3 = _out_grid_array_macro(x1, (x2 + 5)); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 5) + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), ((x2 + 5) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), ((x2 + 5) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 5) + 1))]); \n         x3 = _out_grid_array_macro(x1, (x2 + 6)); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 6) + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), ((x2 + 6) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), ((x2 + 6) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 6) + 1))]); \n         x3 = _out_grid_array_macro(x1, (x2 + 7)); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 7) + -1))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + -1), ((x2 + 7) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 1), ((x2 + 7) + 0))]); \n          _my_out_grid[x3] = (_my_out_grid[x3] + _my_in_grid[_in_grid_array_macro((x1 + 0), ((x2 + 7) + 1))]); \n       } \n    }", "pragma": "parallel for ", "hash": "0d89b7d324435a066b487a40018620db8029720d7bb7b3eb5a229dd09c8b1346"}
{"code": "for (k = 0; k < M; k++) \n    { \n      INT j = (ths->flags & NFFT_SORT_NODES) ? ths->index_x[2*k+1] : k; \n      INT u, o, l; \n      R fg_psij0, fg_psij1, fg_psij2; \n      R psij_const[m2p2]; \n \n      uo(ths, (INT)j, &u, &o, (INT)0); \n      fg_psij0 = (PHI(ths->n[0], ths->x[j] - ((R)(u))/(R)(n), 0)); \n      fg_psij1 = EXP(K(2.0) * ((R)(n) * ths->x[j] - (R)(u)) / ths->b[0]); \n      fg_psij2  = K(1.0); \n \n      psij_const[0] = fg_psij0; \n \n      for (l = 1; l < m2p2; l++) \n      { \n        fg_psij2 *= fg_psij1; \n        psij_const[l] = fg_psij0 * fg_psij2 * fg_exp_l[l]; \n      } \n \n      nfft_trafo_1d_compute(&ths->f[j], g, psij_const, &ths->x[j], n, m); \n    }", "pragma": "parallel for private(k)", "hash": "645da30d1bffdeeceed7a8cec790eb4ebe2740b4c839c6edbeb781b08cc38f1b"}
{"code": "for (size_t i = 0;i < byteArraySize;i++) \n\t\t\tresultant.push_back((BYTE)i);", "pragma": "parallel for ", "hash": "066ea15337eb6c4ce4d1d267f3e21e38f4b51b92a98bdfe81496440451cad7c3"}
{"code": "for (ix=nx+ibnd-ntaper; ix<nx+ibnd; ix++) { \n#pragma ivdep \n            for (iz=ibnd; iz<nz+ibnd; iz++) { \n                vx[ix*n1+iz] *= bnd.tapx[ix-ib]; \n                vz[ix*n1+iz] *= bnd.tapz[ix-ib]; \n            } \n        }", "pragma": "for private(ix iz)", "hash": "c4601fde2ce807655746f09f5c5f22dfeda288e2e07c79d699b5d568affc96f8"}
{"code": "for(size_t j = 0; j < rows; ++j) { \n      const float* xRow = x + j * cols; \n      const float* yRow = y + j * cols; \n      const float* adjRow = adj + j * cols; \n      float* gradXRow = gradX + j * cols; \n \n      float sum_x = 0.f; \n      float sum_adj = 0.f; \n      float sum_adj_x = 0.f; \n      float sum_sqr = 0.f; \n \n      #pragma omp simd reduction(+ : sum_x, sum_adj_x, sum_adj) \n      for(size_t i = 0; i < cols; ++i) { \n        sum_x += xRow[i]; \n        sum_adj_x += adjRow[i] * yRow[i] / gamma[gammaStride * i]; \n        sum_adj += adjRow[i]; \n      } \n \n      float mean = sum_x / cols; \n      #pragma omp simd reduction(+ : sum_sqr) \n      for(size_t i = 0; i < cols; ++i) { \n        float ex = xRow[i] - mean; \n        sum_sqr += ex * ex; \n      } \n \n      float sigma = std::sqrt(sum_sqr / cols + eps); \n      #pragma omp simd \n      for(size_t i = 0; i < cols; ++i) { \n        float grad_x = 0.f; \n        float x_hat = yRow[i] / gamma[gammaStride * i]; \n        grad_x += cols * adjRow[i]; \n        grad_x -= sum_adj; \n        grad_x -= sum_adj_x * x_hat; \n        grad_x /= cols * sigma; \n \n        gradXRow[i] += gamma[gammaStride * i] * grad_x; \n        gradGamma[gammaStride * i] += adjRow[i] * x_hat; \n      } \n    }", "pragma": "parallel for reduction(+ : gradgamma[:cols]) ", "hash": "f01e545a771db8ae1068c292e428e07bfba02297d987798c642cb2178d28ce0b"}
{"code": "for (int icell = 1; icell <= ncells; icell++) { \n            int i = m_rteLyrs[ilyr][icell];  \n \n            if (m_rchID[i] > 0) continue;             \n \n            NitrateLoss(i); \n            PhosphorusLoss(i); \n            SubbasinWaterQuality(i);  \n \n        }", "pragma": "parallel for ", "hash": "4e3c855b90e7bc1b623e70ba2040ae22fd9fa365daeb53c861b3667362fdb8e0"}
{"code": "for (m = 0; m < 3; m++) { \n      for (j = 1; j <= grid_points[1]-2; j++) { \n\tfor (k = 1; k <= grid_points[2]-2; k++) { \n\t  rhs[m][i][j][k] = rhs[m][i][j][k] -  \n\t    lhs[n+3][i][j][k]*rhs[m][i1][j][k] - \n\t    lhs[n+4][i][j][k]*rhs[m][i2][j][k]; \n\t} \n      } \n    }", "pragma": "for ", "hash": "8aa22fc78b844aac9bb0aae8937734702000feeffd9ec1c4663cdea399e3db2b"}
{"code": "for (int i = 0; i < sim_data.get_N(); ++i) { \n\t\t\ttheta = this->kinetic_energy[i] * sim_data.get_dt(); \n\t\t\tthis->mom_time_evolution[i].real = exp(-1.0 * theta); \n\t\t\tthis->mom_time_evolution[i].imag = 0; \n\t\t}", "pragma": "parallel for private(theta)", "hash": "34dc18d3f9fa4e881d2a4e65924755f6a5e04e6dbaf079211291c86d9ca1cf20"}
{"code": "for(int Y = 0; Y < iLength; Y++) {\t\t \n \n  #pragma omp parallel for \n\t\tfor(int X = 0; X < iLength; X++) {\t \n \n\t\t\tif(Y == X)\t{\t\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tcontinue; \n\t\t\t} \n\t\t\telse { \n\t\t\t\tfloat fSum = 0.f; \n\t\t\t\tfor(unsigned int i = 0; i < m_pTrainingData->GetNrElements(); i++) { \n\t\t\t\t\tfSum += m_pTrainingData->GetInput(i)[X] * m_pTrainingData->GetInput(i)[Y]; \n\t\t\t\t} \n\t\t\t\tpMat[X*iLength+Y] = fSum; \n\t\t\t\tpMat[Y*iLength+X] = fSum; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "07f07af13e212bbd781363a8e28e861db715c7353cb6a52bbeef30c6163b2994"}
{"code": "for( size_t i = 0; i < insertions; ++i ) { \n      values[i] = distribution(generator); \n   }", "pragma": "parallel for ", "hash": "7f0af6fd70f8632a2214e1fdb89fd23b6e9fc11c4173b534c77f2f74a311d8ae"}
{"code": "for (int i = 0; i < 65536; ++i) \n    { \n        double pixel_value \n; \n \n         \n \n        pixel_value = (double)i / (double)65535.0; \n \n         \n \n        pixel_value = add_contrast( pixel_value, \n                                    processing->dark_contrast_range,  \n                                    processing->dark_contrast_factor,  \n                                    processing->light_contrast_range,  \n                                    processing->light_contrast_factor ); \n \n         \n \n        pixel_value = pow(pixel_value, lighten_pow); \n \n         \n \n \n         \n \n         \n \n         \n \n         \n \n \n         \n \n         \n \n         \n \n         \n \n \n        pixel_value *= 65535.0; \n \n        processing->pre_calc_curve_r[i] = (uint16_t)pixel_value; \n        processing->pre_calc_curve_g[i] = (uint16_t)pixel_value; \n        processing->pre_calc_curve_b[i] = (uint16_t)pixel_value; \n    }", "pragma": "parallel for ", "hash": "3f3d2bc55b19d6386ef9eedfb58fb6d165b11e2e25384fed329c011c95d0b64d"}
{"code": "for(long i0=t->id;i0<t->n;i0+=mglNumThr) \n\t{ \n\t\tregister long i=i0%nx, j=((i0/nx)%ny), k=i0/(nx*ny); \n\t\tb[i0] = f->Calc(x[0]+i*x[1], x[2]+j*x[3], x[4]+k*x[5], \n\t\t\t\t\t\tb[i0], v?v->vthr(i0):0, w?w->vthr(i0):0); \n\t}", "pragma": "parallel for ", "hash": "4ccf73de155632961a60c0224b460c9c799420e275b8fd7c2033cb866e355011"}
{"code": "for(index_t i = 0; i < (index_t)(size-1); i++){ \n\t\tattachedPoints[i] = FALSE; \n\t}", "pragma": "parallel for ", "hash": "7fc48cc3d660da950ef3f89f8a4c2a95522023f617c6b403b4d91cdfda27e70c"}
{"code": "for(i=0; i<np; i++) { \n        int d; \n        for(d = 0; d < 3; d ++) { \n            p->x[i][d] += D1 * p->dx1[i][d] + D2 * p->dx2[i][d]; \n \n            if(p->v) { \n                p->v[i][d] += p->dx2[i][d]*Dv2; \n                if (p->dv1) { \n                    p->v[i][d] += dv1_prefac * p->dv1[i][d]; \n                } else { \n                    p->v[i][d] += Dv1 * p->dx1[i][d]; \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "44e91fb31a381097559bd4f54b69f5c92628340f8e961035580b7748c34f6833"}
{"code": "for ( int ikappa = 0; ikappa < nKappa; ikappa++ ){ \n \n      int dim = kappa2index[ ikappa + 1 ] - kappa2index[ ikappa ]; \n      double alpha = sqrt( sectorTwoSR[ ikappa ] + 1.0 ); \n      int inc = 1; \n      dscal_( &dim, &alpha, storage + kappa2index[ ikappa ], &inc ); \n \n   }", "pragma": "parallel for ", "hash": "0eed92eccac894a38f0c1d62594aad78159197551544ae159264530968cbdd26"}
{"code": "for (i = 0; i < _sp.sizeX(); i++) { \n        for (j = 0; j < _sp.sizeY(); j++) { \n            for (k = 0; k < _sp.sizeZ(); k++) { \n                sum += real(conj((*this)(i, j, k)) * f(i, j, k) * (*this)(i, j, k)); \n            } \n        } \n    }", "pragma": "parallel for reduction(+:sum) private(  i j k)", "hash": "aa5e694ff3a2d8c8433ed013d64c8b8f8d673948a947229932cd7ef09ace4eef"}
{"code": "for (size_t i = 0; i < parts.size(); i++) \n            parts[i] = crtParts_[i].sym_dot(vec.getCRTPartAt(i));", "pragma": "parallel for ", "hash": "d1edd565988c290405c3d8bd97aec430d91e1a4bcc23ab49a450cdcc272479b0"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr) \n\t{ \n\t\tregister mreal x = d*(i%(nx*ns)), y = d*((i/(nx*ns))%(ny*ns)), z = d*(i/(nx*ny*ns*ns)); \n\t\tregister mreal f = sp ? a->value(x,y,z) : a->linear(x,y,z), w=1; \n\t\tif(c)\tw = sp ? c->value(x,y,z) : c->linear(x,y,z); \n\t\tif(mgl_isnan(f) || mgl_isnan(w))\tcontinue; \n\t\tregister long k = long(n*(f-v[0])/(v[1]-v[0])); \n\t\tif(k>=0 && k<n) \n#pragma omp critical(hist) \n\t\t\tb[k] += w * d*d*d; \n\t}", "pragma": "parallel for ", "hash": "eb0de4e9c7b331093cca882985f9506b2afe17127eddc307c5ea082f901eced2"}
{"code": "for (j=0; j<ths->M_total; j++) \n  { \n    ths->f[j]=0.0; \n    for (k=0; k<ths->N_total; k++) \n    { \n      if (ths->d==1) \n        r = ths->y[j] - ths->x[k]; \n      else \n      { \n        r=0.0; \n        for (t=0; t<ths->d; t++) \n          r += (ths->y[j*ths->d+t]-ths->x[k*ths->d+t])*(ths->y[j*ths->d+t]-ths->x[k*ths->d+t]); \n        r=sqrt(r); \n      } \n      ths->f[j] += ths->alpha[k] * ths->k(r,0,ths->kernel_param); \n    } \n  }", "pragma": "parallel for private(j k r t)", "hash": "68b5b2781c505f76bd12e011b7f2a555daca964e0c7b743999010e55e605c741"}
{"code": "for(size_t ip=0;ip<orbpairs.size();ip++) \n\tfor(size_t ias=0;ias<auxshells.size();ias++) { \n \n\t  size_t imus=orbpairs[ip].is; \n\t  size_t inus=orbpairs[ip].js; \n \n\t  size_t Na=auxshells[ias].get_Nbf(); \n\t  size_t Nmu=orbshells[imus].get_Nbf(); \n\t  size_t Nnu=orbshells[inus].get_Nbf(); \n \n \n\t  double symfac=1.0; \n\t  if(imus==inus) \n\t    symfac=0.0; \n \n\t   \n \n\t  eri->compute(&auxshells[ias],&dummy,&orbshells[imus],&orbshells[inus]); \n\t  erip=eri->getp(); \n \n\t   \n \n\t  for(size_t iia=0;iia<Na;iia++) { \n\t     \n \n\t    size_t ia=auxshells[ias].get_first_ind()+iia; \n \n\t    for(size_t iimu=0;iimu<Nmu;iimu++) { \n\t      size_t imu=orbshells[imus].get_first_ind()+iimu; \n \n\t      for(size_t iinu=0;iinu<Nnu;iinu++) { \n\t\tsize_t inu=orbshells[inus].get_first_ind()+iinu; \n \n\t\tfor(size_t ig=0;ig<P.size();ig++) { \n\t\t   \n \n\t\t  double tmp=(*erip)[(iia*Nmu+iimu)*Nnu+iinu]*c[ig](ia); \n \n\t\t  J[ig](imu,inu)+=tmp; \n\t\t   \n \n\t\t  J[ig](inu,imu)+=symfac*tmp; \n\t\t} \n\t      } \n\t    } \n\t  } \n\t}", "pragma": "for ", "hash": "12912d8349d52b0e477ee987d3e6efd870655ed404907356c38ae36deb3decd8"}
{"code": "for (int i = 0; i < nDimensions; ++i) { \n      if (!exception) { \n        try { \n          Eigen::VectorXd gradientDifference = addGradientContribution(dG, i, positions, delta, *localCalculator, state); \n          H.col(i) = gradientDifference; \n        } \n        catch (const std::exception& e) { \n#pragma omp critical \n          { exception = std::current_exception(); } \n        } \n      } \n    }", "pragma": "for ", "hash": "976d93229a14ea773479dc51e67792dc63b13597112ed08c7189cd6647499dc9"}
{"code": "for (uint_fast32_t i = 1; i < ncell + 1; ++i) { \n      cells[i]._m += cells[i]._left_flux[0] + cells[i]._right_flux[0]; \n      cells[i]._p += cells[i]._left_flux[1] + cells[i]._right_flux[1]; \n      cells[i]._E += cells[i]._left_flux[2] + cells[i]._right_flux[2]; \n    }", "pragma": "parallel for ", "hash": "7d4656999642eba9b718f7679e00a20453736d17ab40ad7a8584f6945deaf593"}
{"code": "for (i = 0; i < ncols; i++) { \n                    cscale[i] = (collen[i] > 0 ? log(1.0 * nrows / collen[i]) : 0.0); \n                }", "pragma": "for ", "hash": "20b9aa598cd71e991151a7a86ddbbf846783270c6fe96f8522384f1673491b4c"}
{"code": "for (i = 0; i < num_gp; i++) { \n    inv_sinh = (double*)malloc(sizeof(double) * num_band); \n    ti = gp2tp_map[triplets_map[i]]; \n    get_inv_sinh(inv_sinh, \n                 i, \n                 temperature, \n                 frequencies, \n                 triplets[ti], \n                 triplets_map, \n                 map_q, \n                 num_band, \n                 cutoff_frequency); \n \n    for (j = 0; j < num_band0; j++) { \n      for (k = 0; k < num_band; k++) { \n        collision = 0; \n        for (l = 0; l < num_band; l++) { \n          collision += \n            fc3_normal_squared[ti * num_band0 * num_band * num_band + \n                               j * num_band * num_band + \n                               k * num_band + l] * \n            g[ti * num_band0 * num_band * num_band + \n              j * num_band * num_band + \n              k * num_band + l] * \n            inv_sinh[l] * unit_conversion_factor; \n        } \n        collision_matrix[j * num_gp * num_band + i * num_band + k] += collision; \n      } \n    } \n \n    free(inv_sinh); \n    inv_sinh = NULL; \n  }", "pragma": "parallel for private(     collision inv_sinh j k l ti)", "hash": "4b8112b842bdf9bf823017eff09e6ad8bee4e7833bb681ed7a9a3b8388d9abc4"}
{"code": "for(size_t i=0;i<mgl_numg;i++) \n\t{ \n\t\tmglGlyphDescr &g = glyphs[i]; \n\t\tg.id = mgl_gen_fnt[i][0]; \n\t\tg.width[0] = g.width[1] = g.width[2] = g.width[3] = mgl_gen_fnt[i][1]; \n\t\tg.numl[0] = g.numl[1] = g.numl[2] = g.numl[3] = mgl_gen_fnt[i][2]; \n\t\tg.ln[0] = g.ln[1] = g.ln[2] = g.ln[3] = mgl_gen_fnt[i][3]; \n\t\tg.numt[0] = g.numt[1] = g.numt[2] = g.numt[3] = mgl_gen_fnt[i][4]; \n\t\tg.tr[0] = g.tr[1] = g.tr[2] = g.tr[3] = mgl_gen_fnt[i][5]; \n\t}", "pragma": "parallel for ", "hash": "c6f7ae5e1c67ffc39767a65422fe45159d0f2e7c9ecc9e38748455b66beb8a4b"}
{"code": "for (int y = 0; y < height; y++)\r \n\t\t{\r \n\t\t\tfor (int x = 0; x < width; x++)\r \n\t\t\t{\r \n\t\t\t\tint offset = y * width + x;\r \n\t\t\t\tint sx, ex, sy, ey;\r \n\t\t\t\tsx = x == 0? x: x - 1;\r \n\t\t\t\tex = x == width - 1? x: x + 1; \r \n\t\t\t\tsy = y == 0? y: y - 1;\r \n\t\t\t\tey = y == height - 1? y: y + 1;\r \n\t\t\t\tint n = (ex - sx + 1)*(ey - sy + 1);\r \n\t\t\t\tnKernel[offset] = n;\r \n\t\t\t\tif (x > 0)\r \n\t\t\t\t{\r \n\t\t\t\t\tfor(int k = 0; k < ncomp; k++)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\ttempCoeff[offset*ncomp+k] = tempCoeff[(offset-1)*ncomp +k];\r \n\t\t\t\t\t\tif (x <= dist)\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\tfor(int jj = sy; jj <= ey; jj++)\r \n\t\t\t\t\t\t\t\ttempCoeff[offset*ncomp+k] += smootCoeff[(jj*width + x + dist)*ncomp + k];\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t\telse\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\tfor(int jj = sy; jj <= ey; jj++)\r \n\t\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\t\ttempCoeff[offset*ncomp+k] -= smootCoeff[(jj*width + x - dist - 1)*ncomp + k];\r \n\t\t\t\t\t\t\t\tif (x + dist < width)\r \n\t\t\t\t\t\t\t\t\ttempCoeff[offset*ncomp+k] += smootCoeff[(jj*width + x + dist)*ncomp + k];\r \n\t\t\t\t\t\t\t}\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t}\r \n\r \n\t\t\t\t}\r \n\t\t\t\telse\r \n\t\t\t\t{\r \n\t\t\t\t\tfor (int ii = sx; ii <= ex; ii++)\r \n\t\t\t\t\t\tfor(int jj = sy; jj <= ey; jj++)\r \n\t\t\t\t\t\t\tfor(int k = 0; k < ncomp; k++)\r \n\t\t\t\t\t\t\t\ttempCoeff[offset*ncomp+k] += smootCoeff[(jj*width + ii)*ncomp +k];\t\t\t\t\t\r \n\t\t\t\t}\r \n\t\t\t}\r \n\t\t}", "pragma": "parallel for ", "hash": "daa9cf58804edeab72ac5fb3253a2b5a484f941d46cc95febfa5cdf17d772092"}
{"code": "for(iy=0; iy<sy; iy++){\r \n        for(ix=0;ix<sx; ix++){\r \n            output_image[iy][ix] = input_image[iy][ix]; \r \n            if(binary_M[iy][ix]!=0) continue; \r \n            central_pixel = input_image[iy][ix];\r \n            iymin = iy-filter_size; if(iymin<0)      iymin = 0;\r \n            iymax = iy+filter_size; if(iymax>(sy-1)) iymax = (sy-1);\r \n\r \n             \n \n            sum_weights    = 0.0;\r \n            sum_weightximg = 0.0;\r \n            for(iybuf=iymin; iybuf<iymax; iybuf++){\r \n                weight = exp((-(input_image[iybuf][ix]-central_pixel)*\r \n                               (input_image[iybuf][ix]-central_pixel))/NEdT);\r \n\r \n                sum_weightximg = sum_weightximg + weight*input_image[iybuf][ix];\r \n                sum_weights    = sum_weights    + weight;\r \n            }\r \n            output_image[iy][ix] = sum_weightximg / sum_weights;\r \n        }  \n \n    }", "pragma": "parallel for private(       central_pixel ix iy iymax iymin sum_weights sum_weightximg weight)", "hash": "0538137ab3ff34ca4ebdbad549f82256277faeda4f9faa758683b709a03a6c16"}
{"code": "for (i32 y = 0; y < world->header.size.y; y++) { \n\t\tfor (i32 x = 0; x < world->header.size.x; x++) { \n\t\t\ti32 blockIndex = y * world->header.size.x + x; \n\t\t\tint nbs = countAliveNeighbours(world, { x,y }, emptyTile); \n \n\t\t\tif (world->blocks[blockIndex] != emptyTile) { \n\t\t\t\tnewBlocks[blockIndex] = (nbs < deathLimit) ? emptyTile : fillTile; \n\t\t\t} \n\t\t\telse { \n\t\t\t\tnewBlocks[blockIndex] = (nbs > birthLimit) ? fillTile : emptyTile; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "22314c2c7b569689f7b1959f61a3997a01c3258e5b90066dbd31f9555170575d"}
{"code": "for (__int64 ll = 0; ll < (__int64)locPos.size(); ll++)\r \n\t\t{\r \n#pragma omp flush(msg)\r \n\t\t\tif (msg)\r \n\t\t\t{\r \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tsize_t l = locPos[ll];\r \n\t\t\t\tCWeatherGenerator WG = WGBase;\r \n\t\t\t\tWG.SetTarget(locations[l]);\r \n\t\t\t\tmsg = WG.Initialize(); \n \n\r \n\t\t\t\tif (msg)\r \n\t\t\t\t{\r \n\t\t\t\t\tCNormalsStation simStation;\r \n\t\t\t\t\tWG.GetNormals(simStation, callback);\r \n\t\t\t\t\tCModelStatVector section(12, CTRef(YEAR_NOT_INIT, 0, 0, 0, CTM(CTRef::MONTHLY, CTRef::OVERALL_YEARS)), NORMALS_DATA::NB_FIELDS);\r \n\r \n\t\t\t\t\tfor (size_t f = 0; f < NORMALS_DATA::NB_FIELDS&&msg; f++)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tfor (size_t m = 0; m < 12; m++)\r \n\t\t\t\t\t\t\tsection[m][f] = simStation[m][f];\r \n\t\t\t\t\t}\r \n\r \n\t\t\t\t\tresultDB.SetSection(l, section);\r \n\t\t\t\t\tmsg += callback.StepIt();\r \n#pragma omp flush(msg)\r \n\t\t\t\t}\r \n\t\t\t}\r \n\t\t}", "pragma": "parallel for ", "hash": "567344a745a39e7e65b794ecf53a1c2befdef0c8c649414eb279cf40cc23a6a8"}
{"code": "for(size_t i=0; i< p; ++i) { \n \n\t\t\tX.col(i).array() /= sqrt(vars(i)); \n \n\t\t}", "pragma": "parallel for ", "hash": "26fe5d162ecdc253c1c785e9fdc23ae524da99eca1b6171ec0721d7ccf4a30d0"}
{"code": "for(int cpIdx=0; cpIdx < items; cpIdx++) \n                extraBodyBuffer[extractOffset+cpIdx] = bodyBuffer[cpIdx];", "pragma": "parallel for ", "hash": "cca74937b017916f086841eafbc659b5b55b9951bb8efc5302eab3864491910d"}
{"code": "for(size_t i = 0; i < numImisSamples; i++){ \n      imp_weight_denom[i] = (InitSamples*prior_all[i] + StepSamples*gaussian_sum[i])/(InitSamples + StepSamples * imisStep); \n      imp_weights[i] = likelihood_all[i]*prior_all[i]/imp_weight_denom[i]; \n    }", "pragma": "parallel for ", "hash": "c6fce0ff23962892dae794003e98e4e8b9be0e602b76e5586b24d33b0fae127c"}
{"code": "for (unsigned n = 0; n < oracle.size(); ++n) { \n                size_t uu = 0; \n                nhoods[n].found = false; \n                nhoods[n].join([&](unsigned i, unsigned j) { \n                        float dist = oracle(i, j); \n                        ++cc; \n                        unsigned r; \n                        r = nhoods[i].parallel_try_insert(j, dist); \n                        if (r < params.K) ++uu; \n                        nhoods[j].parallel_try_insert(i, dist); \n                        if (r < params.K) ++uu; \n                }); \n                nhoods[n].found = uu > 0; \n            }", "pragma": "parallel for reduction(+:cc) ", "hash": "54e6ff9e10deb2501b7c39e999ccc715dfb975914d095616ea0b11c88339b9f3"}
{"code": "for (i=0; i<sizeofBuffer; i++){ \n\tfinalRecvBuf[i] = pingRecvBuf[i]; \n      }", "pragma": "parallel for private(i)", "hash": "c99c3c6c953f1661da3d768e79e9bb8e6abbf23fd46f912c60ce76c33f21fd3d"}
{"code": "for( int i=0;i<max;++i ) \n    applyLocalGlobal((*p)[i],res[i],*m_SP.Qx(),'N','N',0);", "pragma": "parallel for ", "hash": "d0a2b9d83746c0df42fc42ecd0a6b80aef7ff1ef80da27511a56933e58c71e52"}
{"code": "for(i=0;i<width();i++) { \n            samples[i] = -(buffer[i] & 0xFF); \n        }", "pragma": "parallel for ", "hash": "aef360bd48d2dc988935126aede2e27f3c36d2414875a2efd1b10b2422455159"}
{"code": "for (int c = 1; c <= grid.NCM; c++) \n\t{ \n#pragma ivdep \n\t\tfor (int i = 0;  i<= grid.cells[c].data1D(indexQ).numData-1; i++) \n\t\t{ \n\t\t\tgrid.cells[c].data1D(indexQ)(i)\t= grid.cells[c].data1D(indexQ)(i) + relaxation_min*grid.cells[c].data1D(indexdQ)(i); \n\t\t} \n \n#pragma ivdep \n\t\tfor (int s = 0; s <= species_set.NS-1; s++) \n\t\t{ \n\t\t\tif (Math::fabs<double>(grid.cells[c].data1D(indexQ)(s)) <= 1.0e-16) \n\t\t\t{ \n\t\t\t\tgrid.cells[c].data1D(indexQ)(s) = 0.0; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "75d204a7c8be2f1a39d86973a076d53c2161bc5f71015ef6dccfa6215ffe50dd"}
{"code": "for (i = 0; i < nmor; i++) { \n    umor[i] = 0.0; \n  }", "pragma": "parallel for private(i)", "hash": "4ee81ee8a905df58efaf6c3268e7a724b40da07c4a8d630892ce461fbbb353f9"}
{"code": "for (int y = info.offy; y < info.offy + info.height; y++)\r \n\t\t\t{\r \n\t\t\t\tint offsetBuf = (y-info.offy)*info.width<<2;\r \n\t\t\t\tint offset = y * width + info.offx;\r \n\t\t\t\tint offset2 = (y - info.offy)*info.width;\r \n\t\t\t\tfor (int x = info.offx; x < info.offx + info.width; x++)\r \n\t\t\t\t{\r \n\t\t\t\t\tfloat lum = lumMap[offset2];\r \n\t\t\t\t\tbuffer[offsetBuf] = tobyte(redPtr[offset].evalPoly(lVec)*lum); \n \n\t\t\t\t\tbuffer[offsetBuf + 1] = tobyte(greenPtr[offset].evalPoly(lVec)*lum); \n \n\t\t\t\t\tbuffer[offsetBuf + 2] = tobyte(bluePtr[offset].evalPoly(lVec)*lum); \n \n\t\t\t\t\tbuffer[offsetBuf + 3] = 255;\r \n\t\t\t\t\toffsetBuf += 4;\r \n\t\t\t\t\toffset++;\r \n\t\t\t\t\toffset2++;\r \n\t\t\t\t}\r \n\t\t\t}", "pragma": "parallel for ", "hash": "8146881905bde73788f1faecec86d8b08a66a0646893a8ab12facc2dd6ba0339"}
{"code": "for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        const int \n          id = GetOpenMPThreadId(); \n \n        while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH) \n        { \n          MagickBooleanType \n            atDepth; \n \n          QuantumAny \n            range; \n \n          atDepth=MagickTrue; \n          range=GetQuantumRange(current_depth[id]); \n          if ((atDepth != MagickFalse) && \n              (GetPixelRedTraits(image) & UpdatePixelTrait) != 0) \n            if (IsPixelAtDepth(image->colormap[i].red,range) == MagickFalse) \n              atDepth=MagickFalse; \n          if ((atDepth != MagickFalse) && \n              (GetPixelGreenTraits(image) & UpdatePixelTrait) != 0) \n            if (IsPixelAtDepth(image->colormap[i].green,range) == MagickFalse) \n              atDepth=MagickFalse; \n          if ((atDepth != MagickFalse) && \n              (GetPixelBlueTraits(image) & UpdatePixelTrait) != 0) \n            if (IsPixelAtDepth(image->colormap[i].blue,range) == MagickFalse) \n              atDepth=MagickFalse; \n          if ((atDepth != MagickFalse)) \n            break; \n          current_depth[id]++; \n        } \n      }", "pragma": "parallel for ", "hash": "292d9edfa7b9a5c65dd740d1addc734ef238ce5d09f1052c88c0f28d518c8130"}
{"code": "for (int  _i1 = off_left; (_i1 < _R+off_left); _i1 = (_i1 + 1)) \n  { \n    #pragma ivdep \n    for (int  _i2 = off_left; (_i2 < _C+off_left); _i2 = (_i2 + 1)) \n    { \n      img[((_i1 * C) + _i2)] = ((((0.299f * img_colour[((((_i1-off_left) * _C * 3)) + (_i2-off_left) * 3 + 2)]) + (0.587f * img_colour[((((_i1-off_left) * _C * 3)) + (_i2-off_left) * 3 + 1)])) + (0.114f * img_colour[((((_i1-off_left) * _C * 3)) + (_i2-off_left) * 3)])))/255.0; \n    } \n  }", "pragma": "parallel for ", "hash": "40cca9463abec56b00ffa3058baa299d46f5dfce5492d4d57e82d5b85a6d9adb"}
{"code": "for(msize i=0;i<num;i++)\r \n\t\t{\tgr->AddPntQ(kq+i,pp[i].p, gr->GetC(ss,pp[i].p.c));\t}", "pragma": "parallel ", "hash": "89a022254ca527e461e0cd331cb92fa99add7331e9de15ab240b72e82d405bdd"}
{"code": "for (index i = 0; i < sampledNodes.size(); ++i) { \n\t\tcomputeDependencies(sampledNodes[i]); \n\t}", "pragma": "parallel for ", "hash": "b55435c0f225f29d33e394bd76b53eaa7ed77389e716e5f9836aeb12251987ea"}
{"code": "for (i = 0; i < ngroup_v4; ++i) { \n \n            ret_in = std::complex<double>(0.0, 0.0); \n            nsize_group = fcs_group_v4[i].size(); \n \n            for (j = 0; j < nsize_group; ++j) { \n                phase = relvec_v4[i][j].vecs[0][0] * xk1[0] \n                        + relvec_v4[i][j].vecs[0][1] * xk1[1] \n                        + relvec_v4[i][j].vecs[0][2] * xk1[2] \n                        + relvec_v4[i][j].vecs[1][0] * xk2[0] \n                        + relvec_v4[i][j].vecs[1][1] * xk2[1] \n                        + relvec_v4[i][j].vecs[1][2] * xk2[2] \n                        + relvec_v4[i][j].vecs[2][0] * xk3[0] \n                        + relvec_v4[i][j].vecs[2][1] * xk3[1] \n                        + relvec_v4[i][j].vecs[2][2] * xk3[2]; \n \n                ret_in += fcs_group_v4[i][j] * phase_storage_in->get_exp_type1(phase); \n            } \n            ret[i] = ret_in; \n        }", "pragma": "parallel for private(   j nsize_group phase ret_in)", "hash": "24f3175911eb424ebc6cf0ff25fba3b897900c95a2ae44d176fba792583fa221"}
{"code": "for( int i=0;i<max;++i ) { \n      basics::Field2<basics::Matrix> foo(&field->X().at(l)[i],&field->Y().at(l)[i]); \n      deformedConvectionEvaluator \n        eval(m_geometry[m_grid[m_rank].elements[i]].getGH().getGeometryDerivatives(), \n            m_D,m_weight,foo,(*m_buffer)[i],(*m_buffer2)[i]); \n      eval.evaluate(m_buffer3->at(l)[i],u.at(l)[i]); \n    }", "pragma": "parallel for ", "hash": "9eceec67954cc1949b5a4769c566208de81085e92848e1d2a0dcca1a605efaad"}
{"code": "for(size_t chunk=0; chunk<(even?chunks:chunks-1); chunk++){ \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tsize_t start(pass==0?s[chunk]:(even?splits1[chunk]:splits0[chunk+1])); \n\t\t\t\tinsertionSort_part(v,doCollide,ax,s[chunk],s[chunk+1],start); \n\t\t\t}", "pragma": "parallel for ", "hash": "9783ad7fbb0b977d9d7e7f1fdd494dfaf5f2fa4d403231912a1999ca4ee13efb"}
{"code": "for(int j = 0; j < static_cast<int>(m_pOPLayer->GetNeurons().size() ); j++) { \n\t\tvOutDelta[j] = m_pOPLayer->GetNeuron(j)->GetErrorDelta(); \n\t}", "pragma": "parallel for ", "hash": "3264b3938df2e5633d7194ac498df1ff4178c887415b02ccccdd22b5a2926984"}
{"code": "for (int y = 0; y<m_Height; ++y) \n        for (int c = 0; c<Channels; c++) \n          { uint16_t *ptrX = &m_Image[y*m_Width+0][Channel[c]]; _cimg_deriche2_apply; }", "pragma": "for ", "hash": "48439c0f24946cdf6d623f739efe84ff059a97144bc4048cee601a734321e48c"}
{"code": "for (int i = 0; i < explen; i += BLOCK_SIZE) { \n        encrypt_block(expbytes + i); \n    }", "pragma": "parallel for ", "hash": "d05c42784f4be957361bd1a033585a3641cbf63d7def24393457847d8c407c14"}
{"code": "for( i = 0 ; i < TRUE_HERM ; i ++  ) { \n    free( FFTW.in[i] ) ; \n  }", "pragma": "parallel for private(i)", "hash": "a45797bd8a8f27d5a0536e70082a6b4e582aa333cf6e9e6386c7e34d140252e0"}
{"code": "for (size_t i=0; i < n_pop; ++i) { \n            size_t thread_num = 0; \n \n            thread_num = omp_get_thread_num(); \n \n            bmo::stats::internal::runif_vec_inplace<fp_t>(n_vals, rand_engines_vec[thread_num], rand_vec_1); \n            bmo::stats::internal::runif_vec_inplace<fp_t>(n_vals, rand_engines_vec[thread_num], rand_vec_2); \n \n            V.row(i) = par_w * V.row(i) + par_c_cog * BMO_MATOPS_HADAMARD_PROD( rand_vec_1, (best_vecs.row(i) - P.row(i)) )                  + par_c_soc * BMO_MATOPS_HADAMARD_PROD( rand_vec_2, (best_sol_running - P.row(i)) ); \n \n            P.row(i) += V.row(i); \n             \n             \n \n \n            fp_t prop_objfn_val = box_objfn( BMO_MATOPS_TRANSPOSE(P.row(i)), nullptr, opt_data); \n \n            if (!std::isfinite(prop_objfn_val)) { \n                prop_objfn_val = inf; \n            } \n         \n            objfn_vals(i) = prop_objfn_val; \n                 \n            if (objfn_vals(i) < best_vals(i)) { \n                best_vals(i) = objfn_vals(i); \n                best_vecs.row(i) = P.row(i); \n            } \n        }", "pragma": "parallel for private(rand_vec_1 rand_vec_2)", "hash": "4ec6c3e005f194e22ba9345228e4a88646ed48029924c43578d0636005fb77d0"}
{"code": "for(int i = 0; i < nelr; i++) \n\t{ \n\t\tdouble density = variables[NVAR*i + VAR_DENSITY]; \n \n\t\tcfd_double3 momentum; \n\t\tmomentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)]; \n\t\tmomentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)]; \n\t\tmomentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)]; \n \n\t\tdouble density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY]; \n\t\tcfd_double3 velocity;\t   compute_velocity(density, momentum, velocity); \n\t\tdouble speed_sqd      = compute_speed_sqd(velocity); \n\t\tdouble pressure       = compute_pressure(density, density_energy, speed_sqd); \n\t\tdouble speed_of_sound = compute_speed_of_sound(density, pressure); \n \n\t\t \n \n\t\tstep_factors[i] = double(0.5) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound)); \n\t}", "pragma": "parallel for ", "hash": "f62b71b348f24ea4de1e94cb60c575612b2342ed3e2ba61c35ed3c2e1153bb7b"}
{"code": "for (ibody = 0; ibody < nbody; ibody++) { \n    double mbody[3],tbody[3],fquat[4]; \n \n    fcm[ibody][0] = all[ibody][0] + langextra[ibody][0]; \n    fcm[ibody][1] = all[ibody][1] + langextra[ibody][1]; \n    fcm[ibody][2] = all[ibody][2] + langextra[ibody][2]; \n    torque[ibody][0] = all[ibody][3] + langextra[ibody][3]; \n    torque[ibody][1] = all[ibody][4] + langextra[ibody][4]; \n    torque[ibody][2] = all[ibody][5] + langextra[ibody][5]; \n \n     \n \n \n    const double dtfm = dtf / masstotal[ibody]; \n    if (tstat_flag || pstat_flag) { \n      vcm[ibody][0] *= scale_t[0]; \n      vcm[ibody][1] *= scale_t[1]; \n      vcm[ibody][2] *= scale_t[2]; \n    } \n     \n    vcm[ibody][0] += dtfm * fcm[ibody][0] * fflag[ibody][0]; \n    vcm[ibody][1] += dtfm * fcm[ibody][1] * fflag[ibody][1]; \n    vcm[ibody][2] += dtfm * fcm[ibody][2] * fflag[ibody][2]; \n     \n    if (pstat_flag) { \n      double tmp = vcm[ibody][0]*vcm[ibody][0] + vcm[ibody][1]*vcm[ibody][1] + \n        vcm[ibody][2]*vcm[ibody][2]; \n      akt += masstotal[ibody]*tmp; \n    } \n     \n     \n \n     \n \n     \n    torque[ibody][0] *= tflag[ibody][0]; \n    torque[ibody][1] *= tflag[ibody][1]; \n    torque[ibody][2] *= tflag[ibody][2]; \n     \n    MathExtra::transpose_matvec(ex_space[ibody],ey_space[ibody], \n                                ez_space[ibody],torque[ibody],tbody); \n    MathExtra::quatvec(quat[ibody],tbody,fquat); \n     \n    if (tstat_flag || pstat_flag) { \n      conjqm[ibody][0] = scale_r * conjqm[ibody][0] + dtf2 * fquat[0]; \n      conjqm[ibody][1] = scale_r * conjqm[ibody][1] + dtf2 * fquat[1]; \n      conjqm[ibody][2] = scale_r * conjqm[ibody][2] + dtf2 * fquat[2]; \n      conjqm[ibody][3] = scale_r * conjqm[ibody][3] + dtf2 * fquat[3]; \n    } else { \n      conjqm[ibody][0] += dtf2 * fquat[0]; \n      conjqm[ibody][1] += dtf2 * fquat[1]; \n      conjqm[ibody][2] += dtf2 * fquat[2]; \n      conjqm[ibody][3] += dtf2 * fquat[3]; \n    } \n \n    MathExtra::invquatvec(quat[ibody],conjqm[ibody],mbody); \n    MathExtra::matvec(ex_space[ibody],ey_space[ibody],ez_space[ibody], \n                      mbody,angmom[ibody]); \n     \n    angmom[ibody][0] *= 0.5; \n    angmom[ibody][1] *= 0.5; \n    angmom[ibody][2] *= 0.5;   \n     \n    MathExtra::angmom_to_omega(angmom[ibody],ex_space[ibody],ey_space[ibody], \n                               ez_space[ibody],inertia[ibody],omega[ibody]); \n     \n    if (pstat_flag) { \n      akr += angmom[ibody][0]*omega[ibody][0] +  \n        angmom[ibody][1]*omega[ibody][1] +  \n        angmom[ibody][2]*omega[ibody][2]; \n    } \n  }", "pragma": "parallel for reduction(+:akt akr) private(ibody)", "hash": "4e7f348473a1ac8673a5eb41864cbf1c264d3fa0b389057e2836268374565efa"}
{"code": "for(int i = 0; i < nsrc; ++i) \n    { \n\tkeysorted[i] = kv[i].first; \n \n\tconst int entry = kv[i].second; \n\tassert(entry >= 0 && entry < nsrc); \n \n\txsorted[i] = xsrc[entry]; \n\tysorted[i] = ysrc[entry]; \n\tvsorted[i] = vsrc[entry]; \n    }", "pragma": "parallel for ", "hash": "84c6da7e58755a950d053820c03df50e38fdfdfc59998fa6a8f70512d5a50a08"}
{"code": "for(size_t i=0;i<grids.size();i++) { \n       \n \n      wrk[ith].set_grid(grids[i]); \n      wrk[ith].form_grid(); \n       \n       \n \n      if(P.size()==1) \n\twrk[ith].update_density(P[0]); \n      else \n\twrk[ith].update_density(P[0],P[1]); \n       \n \n      wrk[ith].eval_fxc(x_func,c_func); \n       \n       \n \n      wrk[ith].compute_orbs(C); \n       \n       \n \n#pragma omp critical \n      wrk[ith].Kxc(pairs, Kx); \n       \n       \n \n      wrk[ith].free(); \n    }", "pragma": "for ", "hash": "585526fade30fbfb659d9a0e46e7f5102599dbb3f250db4ffa68a7c78b3966d8"}
{"code": "for (i = 0; i < m; ++i){ \n            for (j = 0; j < n; j++) { \n                for (w = 0; w < k; w++) { \n                    mat[i][j] += mat1[i][w] * mat2[w][j]; \n                }  \n \n            } \n \n        }", "pragma": "parallel for private(w)", "hash": "61d18464d7afa8d71b92d74c1eebb52cc4bfbd0477445dede239a584d9f3d12b"}
{"code": "for(node=0;node<nodeNumber;++node){ \n                velValues[0]=propVelFieldPtrX[node]; \n                velValues[1]=propVelFieldPtrY[node]; \n                velValues[2]=propVelFieldPtrZ[node]; \n                reoriented[0] = \n                         forward2backward_matrix->m[0][0] * velValues[0] + \n                         forward2backward_matrix->m[0][1] * velValues[1] + \n                         forward2backward_matrix->m[0][2] * velValues[2] ; \n                reoriented[1] = \n                         forward2backward_matrix->m[1][0] * velValues[0] + \n                         forward2backward_matrix->m[1][1] * velValues[1] + \n                         forward2backward_matrix->m[1][2] * velValues[2] ; \n                reoriented[2] = \n                         forward2backward_matrix->m[2][0] * velValues[0] + \n                         forward2backward_matrix->m[2][1] * velValues[1] + \n                         forward2backward_matrix->m[2][2] * velValues[2] ; \n \n                propVelFieldPtrX[node] = reoriented[0] * normRatio; \n                propVelFieldPtrY[node] = reoriented[1] * normRatio; \n                propVelFieldPtrZ[node] = reoriented[2] * normRatio; \n            }", "pragma": "parallel for private(  node reoriented velvalues)", "hash": "44ca23de8f10b44f22908c13d965fc8873caf6b12dc44bb590f44fb239d4dfc8"}
{"code": "for (unsigned int y = 1; y < jmax; ++y) \n    { \n      int inc = 1; \n      while (down_scan[y][inc] > 0) \n      { \n        unsigned x = down_scan[y][inc]; \n        inc++; \n \n \n         \n \n        Vel[x][y] = 0; \n        Tau[x][y] = 0; \n \n        for (unsigned n = 0; n < G_MAX; n++) \n        { \n          sr[x][y][n] = 0; \n          sl[x][y][n] = 0; \n          su[x][y][n] = 0; \n          sd[x][y][n] = 0; \n        } \n        ss[x][y] = 0; \n \n        if (water_depth[x][y] > water_depth_erosion_threshold) \n        { \n \n          double temptot2 = 0; \n          double veltot = 0; \n          double vel = 0; \n          double qtot = 0; \n          double tau = 0; \n          double velnum = 0; \n          double slopetot = 0; \n \n          double tempdir[11] = {}; \n          double temp_dist[11] = {}; \n \n \n \n \n \n \n \n \n \n \n \n \n           \n \n          if (spatially_var_mannings) \n          { \n             mannings = spat_var_mannings[x][y]; \n          } \n \n           \n \n          if (index[x][y] == -9999) addGS(x, y); \n \n           \n \n          for (int p = 1; p <= 8; p+=2) \n          { \n            int x2 = x + deltaX[p]; \n            int y2 = y + deltaY[p]; \n            if (water_depth[x2][y2] > water_depth_erosion_threshold) \n            { \n              if (edge[x][y] > edge[x2][y2]) \n              { \n                temptot2 += (edge[x][y] - edge[x2][y2]); \n              } \n \n              if (vel_dir[x][y][p] > 0 ) \n              { \n                 \n \n                vel = vel_dir[x][y][p]; \n                if (vel > max_vel) \n                { \n                  vel = max_vel;  \n \n                } \n                tempdir[p] = vel * vel; \n                veltot += tempdir[p]; \n                velnum++; \n                qtot += (vel * vel); \n                 \n \n                slopetot += ((elev[x][y] - elev[x2][y2]) / DX) * vel; \n              } \n            } \n          } \n \n          if (qtot > 0) \n          { \n            vel = (std::sqrt(qtot)); \n            Vel[x][y] = vel; \n \n            if (vel > max_vel) vel = max_vel;  \n \n            double ci = gravity * (mannings * mannings) * std::pow(water_depth[x][y], -0.33); \n             \n \n            if (slopetot > 0) slopetot = 0; \n             \n \n            tau = 1000 * ci * vel * vel * (1 + (1 * (slopetot / vel))); \n            Tau[x][y] = tau; \n          } \n \n           \n \n          if (tau > 0) \n          { \n            double d_50 = 0; \n            double Fs = 0; \n            double Di = 0; \n            double graintot = 0; \n            if (wilcock == 1) \n            { \n              d_50 = d50(index[x][y]); \n              if (d_50 < d1) d_50 = d1; \n              Fs = sand_fraction(index[x][y]); \n              for (unsigned n = 1; n <= G_MAX; n++)graintot += (grain[index[x][y]][n]); \n            } \n \n            double temptot1 = 0; \n \n            for (unsigned int n = 1; n <= G_MAX-1; n++) \n            { \n              switch (n) \n              { \n                case 1: Di = d1; break; \n                case 2: Di = d2; break; \n                case 3: Di = d3; break; \n                case 4: Di = d4; break; \n                case 5: Di = d5; break; \n                case 6: Di = d6; break; \n                case 7: Di = d7; break; \n                case 8: Di = d8; break; \n                case 9: Di = d9; break; \n              } \n \n               \n \n \n              if (wilcock == 1) \n              { \n                double tau_ri = 0, U_star, Wi_star; \n                tau_ri = (0.021 + (0.015 * std::exp(-20 * Fs))) * (rho * gravity * d_50) * std::pow((Di / d_50), (0.67 / (1 + std::exp(1.5 - (Di / d_50))))); \n                U_star = std::pow(tau / rho, 0.5); \n                double Fi = grain[index[x][y]][n] / graintot; \n \n                if ((tau / tau_ri) < 1.35) \n                { \n                  Wi_star = 0.002 * std::pow(tau / tau_ri, 7.5); \n                } \n                else \n                { \n                  Wi_star = 14 * std::pow(1 - (0.894 / std::pow(tau / tau_ri, 0.5)), 4.5); \n                } \n                 \n \n                temp_dist[n] = mult_factor * time_step * \n                               ((Fi * (U_star * U_star * U_star)) / ((2.65 - 1) * gravity)) * Wi_star / DX; \n              } \n               \n \n              if (einstein == 1) \n              { \n                 \n \n                temp_dist[n] = mult_factor * time_step * (40 * std::pow((1 / (((2650 - 1000) * Di) / (tau / gravity))), 3)) \n                               / std::sqrt(1000 / ((2250 - 1000) * gravity * (Di * Di * Di))) / DX; \n              } \n \n               \n \n \n               \n \n              if (temp_dist[n] > grain[index[x][y]][n]) \n              { \n                temp_dist[n] = grain[index[x][y]][n]; \n              } \n               \n \n              if (isSuspended[n] && n == 1) \n              { \n                if ((temp_dist[n] + Vsusptot[x][y]) / water_depth[x][y] > Csuspmax) \n                { \n                   \n \n                   \n \n                  temp_dist[n] = (water_depth[x][y] * Csuspmax) - Vsusptot[x][y]; \n                } \n              } \n              if (temp_dist[n] < 0) temp_dist[n] = 0; \n \n               \n \n              temptot1 += temp_dist[n]; \n            } \n \n             \n \n            if (elev[x][y] - temptot1 <= bedrock[x][y]) \n            { \n               \n \n               \n \n              double elevdiff = elev[x][y] - bedrock[x][y]; \n              double temptot3 = temptot1; \n              temptot1 = 0; \n              for (unsigned int n = 1; n <= G_MAX-1; n++) \n              { \n                if (elev[x][y] <= bedrock[x][y]) \n                { \n                  temp_dist[n] = 0; \n                } \n                else \n                { \n                  temp_dist[n] = elevdiff * (temp_dist[n] / temptot3); \n                  if (temp_dist[n] < 0) temp_dist[n] = 0; \n                } \n                temptot1 += temp_dist[n]; \n              } \n \n               \n \n              if (tau > bedrock_erosion_threshold) \n              { \n                double amount = 0;  \n \n                amount = std::pow(bedrock_erosion_rate * tau, 1.5) * time_step * mult_factor * 0.000000317;  \n \n                bedrock[x][y] -= amount; \n                 \n \n                for (unsigned int n2 = 1; n2 <= G_MAX - 1; n2++) \n                { \n                  grain[index[x][y]][n2] += amount * dprop[n2]; \n                } \n              } \n            } \n \n \n             \n \n             \n \n            if (veg[x][y][1] > 0 && tau > vegTauCrit) \n            { \n               \n \n              veg[x][y][1] -= mult_factor * time_step * std::pow(tau - vegTauCrit, 0.5) * 0.00001; \n              if (veg[x][y][1] < 0) veg[x][y][1] = 0; \n            } \n \n             \n \n            if (veg[x][y][1] > 0.25) \n            { \n               \n \n              if (elev[x][y] - temptot1 <= veg[x][y][0]) \n              { \n                 \n \n                 \n \n                double elevdiff = 0; \n                elevdiff = elev[x][y] - veg[x][y][0]; \n                if (elevdiff < 0) elevdiff = 0; \n                double temptot3 = temptot1; \n                temptot1 = 0; \n                for (unsigned n = 1; n <= G_MAX-1; n++) \n                { \n                  temp_dist[n] = elevdiff * (temp_dist[n] / temptot3); \n                  if (elev[x][y] <= veg[x][y][0]) temp_dist[n] = 0; \n                  temptot1 += temp_dist[n]; \n                } \n                 \n \n                if (temptot1 < 0) temptot1 = 0; \n              } \n            } \n \n            if (temptot1 > tempbmax) \n            { \n              tempbmax = temptot1; \n            } \n \n             \n \n             \n \n            if(temptot1>0) \n            { \n              for (int p = 1; p <= 8; p += 2) \n              { \n                int x2 = x + deltaX[p]; \n                int y2 = y + deltaY[p]; \n \n                if (water_depth[x2][y2] > water_depth_erosion_threshold) \n                { \n                  if (index[x2][y2] == -9999) addGS(x2, y2); \n                  double factor = 0; \n \n                   \n \n                  if (vel_dir[x][y][p] > 0) \n                  { \n                    factor += 0.75 * tempdir[p] / veltot; \n                  } \n                   \n \n                  if (edge[x][y] > edge[x2][y2]) \n                  { \n                    factor += 0.25 * ((edge[x][y] - edge[x2][y2]) / temptot2); \n                  } \n \n                   \n \n                  for (unsigned n = 1; n <= G_MAX-1; n++) \n                  { \n                    if (temp_dist[n] > 0) \n                    { \n                      if (n == 1 && isSuspended[n]) \n                      { \n                         \n \n                        ss[x][y] = temp_dist[n]; \n                      } \n                      else \n                      { \n                        switch (p) \n                        { \n                          case 1: su[x][y][n] = temp_dist[n] * factor; break; \n                          case 3: sr[x][y][n] = temp_dist[n] * factor; break; \n                          case 5: sd[x][y][n] = temp_dist[n] * factor; break; \n                          case 7: sl[x][y][n] = temp_dist[n] * factor; break; \n                        } \n                      } \n                    } \n                  } \n                } \n              } \n            } \n          } \n        } \n      } \n    }", "pragma": "parallel for reduction(max:tempbmax) ", "hash": "1a46a2b1e38c3f9537843129a5d17dfc7e2349de124da595fbf31f3e3bcea632"}
{"code": "for(int x = 0 ; x < grid.getWidth() ; ++x) \n\t\t{ \n\t\t\tconst int id = omp_get_thread_num(); \n\t\t\tif (backups[id] == NULL) \n\t\t\t\tbackups[id] = new float[maxSize]; \n\t\t\tfloat *backup = backups[id]; \n\t\t\tfor(int y = 0 ; y < grid.getHeight() ; ++y) \n\t\t\t\tbackup[y] = grid(x, y); \n\t\t\tfor(int y = 0 ; y < grid.getHeight() ; ++y) \n\t\t\t{ \n\t\t\t\tfloat acc(static_cast<float>((2 * s - (Math::Min(s, grid.getHeight() - 1 - x) - Math::Max(-s, -y))) * 255)); \n\t\t\t\tfor(int i = Math::Max(-s, -y) ; i <= Math::Min(s, grid.getHeight() - 1 - y) ; ++i) \n\t\t\t\t\tacc += kernel[i + s] * backup[y + i]; \n\t\t\t\tgrid(x,y) = acc; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "bf0dd71994d7f85067178a652cc4e1169504dac3ba724c5216e07555cc230ba8"}
{"code": "for (int i = 0; i < static_cast<int>(sfm_data.views.size()); ++i) \n    { \n      if (iNumThreads == 0) omp_set_num_threads(nb_max_thread); \n      Views::const_iterator iterViews = sfm_data.views.begin(); \n      std::advance(iterViews, i); \n \n      const View * view = iterViews->second.get(); \n       \n \n      if (bExportOnlyReconstructedViews && !sfm_data.IsPoseAndIntrinsicDefined(view)) \n        continue; \n \n      const bool bIntrinsicDefined = view->id_intrinsic != UndefinedIndexT && \n        sfm_data.GetIntrinsics().find(view->id_intrinsic) != sfm_data.GetIntrinsics().end(); \n      if (!bIntrinsicDefined) \n        continue; \n \n      Intrinsics::const_iterator iterIntrinsic = sfm_data.GetIntrinsics().find(view->id_intrinsic); \n \n      const std::string srcImage = stlplus::create_filespec(sfm_data.s_root_path, view->s_Img_path); \n      const std::string dstImage = stlplus::create_filespec( \n        sOutDir, stlplus::filename_part(srcImage)); \n \n      const IntrinsicBase * cam = iterIntrinsic->second.get(); \n      if (cam->have_disto()) \n      { \n         \n \n        if (ReadImage( srcImage.c_str(), &image)) \n        { \n          UndistortImage(image, cam, image_ud, BLACK); \n          const bool bRes = WriteImage(dstImage.c_str(), image_ud); \n          #pragma omp critical \n          bOk &= bRes; \n        } \n        else  \n \n        if (ReadImage( srcImage.c_str(), &image_gray)) \n        { \n          UndistortImage(image_gray, cam, image_gray_ud, BLACK); \n          const bool bRes = WriteImage(dstImage.c_str(), image_gray_ud); \n          #pragma omp critical \n          bOk &= bRes; \n        } \n      } \n      else  \n \n      { \n         \n \n        stlplus::file_copy(srcImage, dstImage); \n      } \n      ++my_progress_bar; \n    }", "pragma": "parallel for private(   image image_gray image_gray_ud image_ud)", "hash": "2c387a6a41fb9565569c51c30902ac3817bfa3339715978e155cb8bd539d5ae2"}
{"code": "for (unsigned i = 0; i < stack_size; ++i) { \n      stack_[i]->Backward(debug, *in_deltas[i], scratch, i == 0 ? back_deltas : out_deltas[i]); \n    }", "pragma": "parallel for ", "hash": "f82f57600fc9fc983cfb70027d02a8184472a9c86193e2ef60b1864a08c3695a"}
{"code": "for(uint32_t j=padding;j<h-padding;j++) \n  { \n    const float *in2  = in  + j*w + padding; \n    float *out2 = out + j*w + padding; \n     \n \n    const float *const beg = (float *)((size_t)(out2+3)&(size_t)0x10ul); \n    const float *const end = (float *)((size_t)(out2+w-padding)&(size_t)0x10ul); \n    const float *const fin = out2+w-padding; \n    const __m128 g4 = _mm_set1_ps(g); \n    const __m128 sig4 = _mm_set1_ps(sigma); \n    const __m128 shd4 = _mm_set1_ps(shadows); \n    const __m128 hil4 = _mm_set1_ps(highlights); \n    const __m128 clr4 = _mm_set1_ps(clarity); \n    for(;out2<beg;out2++,in2++) \n      *out2 = curve_scalar(*in2, g, sigma, shadows, highlights, clarity); \n    for(;out2<end;out2+=4,in2+=4) \n      _mm_stream_ps(out2, curve_vec4(_mm_load_ps(in2), g4, sig4, shd4, hil4, clr4)); \n    for(;out2<fin;out2++,in2++) \n      *out2 = curve_scalar(*in2, g, sigma, shadows, highlights, clarity); \n    out2 = out + j*w; \n    for(int i=0;i<padding;i++)   out2[i] = out2[padding]; \n    for(int i=w-padding;i<w;i++) out2[i] = out2[w-padding-1]; \n  }", "pragma": "parallel for ", "hash": "fad2e64c965498c76660d399b83fb251522c14984cf733cba1e7cb5332978f80"}
{"code": "for (size_t i = 0; i < YALL_SIZE; i++) \n    tmp += fabs(buf[i]);", "pragma": "parallel for reduction(+:tmp) ", "hash": "1594712e9067e069b49fcb5c451943e8c11f4dd55a546cbcf8d3b4ae8eb7f106"}
{"code": "for (size_t i = 0; i < evalBase.kpps_end_index(); ++i) \n            updateFV(*evalBase.oneArrayKPP(i), *lowerDimentionedEvaluatorGradient.oneArrayKPP(i), *meanSquareOfLowerDimensionedEvaluatorGradient.oneArrayKPP(i), max);", "pragma": "for ", "hash": "a5840b26da3d4e160eece4fbd731ae9672508db2b1e7d750fcde40309057aa33"}
{"code": "for(long j=0;j<ny;j++)\tfor(long i=0;i<nx;i++) \n\t\t\t{ \n\t\t\t\tregister long i0 = i+nx*j;\ts.y.a[i0] = v; \n\t\t\t\ts.x.a[i0] = x->v(i);\ts.z.a[i0] = z->v(j); \n\t\t\t\ts.a.a[i0] = a->v(i,p,j)*(1-d) + a->v(i,p+1,j)*d; \n\t\t\t}", "pragma": "parallel for ", "hash": "f07c12a6327abe10bd26f90ad92dba4f6d7cc240e5575b9aa3a5baaf99c81287"}
{"code": "for (int i = 0; i < size; i++) \n        phi_b[i] += omega_rf0 * dt[i];", "pragma": "parallel for ", "hash": "444ad29dcb9db2c351a742052cc942d1af8e80b1ebff8d69b6f4304f57fac313"}
{"code": "for (p = s; p != r; p = p + o)\t \n \n    bar (p);", "pragma": "for ", "hash": "bef833fb8aea332453a173274709f84a66e83186a85408f5bd788fc8234b73a5"}
{"code": "for (int i=0; i<inElementsSize; i++) {\r \n      for (int j=0; j<8; j++){\r \n\tfloat ss = 0;\r \n\tfor (int k=0; k<8; k++){\r \n\t  ss += AL[i*64+j*8+k] * ff[i*8+k]; \r \n\t}\r \n\r \n\tint threadId = omp_get_thread_num();\r \n\r \n\tif (fabs(ss - v1[i*8+j]) > thread_step_diff[threadId]){\r \n\t  thread_step_diff[threadId] = fabs(ss - v1[i*8+j]);\r \n\t}\r \n\r \n\tv1[i*8+j] = ss;\r \n      }\r \n    }", "pragma": "parallel for private(vox)", "hash": "9f7fb24a7de23a0d62e14a94476e9985e0e9fea4d7495128b5025af1263709e3"}
{"code": "for (a = 0; a < 2; ++a) \n      [&]() { \n        ++this->a; \n#pragma omp parallel \n#pragma omp for \n        for (a = 0; a < 2; ++(this)->a) \n          ++(this)->a; \n      }();", "pragma": "for ", "hash": "7ee05972f3b553902c139fd93a0f7dd3bebd94d02a5cb14c0455266f0648207f"}
{"code": "for(long k=0;k<nz;k++)\tfor(long i=0;i<nx;i++)\tfor(long j=0;j<ny;j++) \n\t\t\tb[j+ny*(i+nx*k)] = a[i+nx*(j+ny*k)];", "pragma": "parallel for ", "hash": "aee4171684ef8ee3d58657cd8e5e4e5bd04c197037c3be24c093d4d2630a51ca"}
{"code": "for (int i = 0; i < count; i++) \n  { \n    dst_map[i] = (DSTT)(src_map[i]); \n  }", "pragma": "parallel for ", "hash": "a0c6d18a2ed66e67aeb2081fd54f8cc7dc58a013cd5a1b6de4e4aa4e9b891608"}
{"code": "for (int i = 0; i < n; ++i) \n\t{ \n\t\tImage image = images[i]; \n \n\t\tKeyPoints key_points; \n\t\tDescriptors descriptors; \n \n\t\t \n \n\t\tsift_detector->detectAndCompute(image.gray, noArray(), key_points, descriptors); \n \n\t\tKeyPoints   keep_key_points; \n\t\tDescriptors keep_descriptors; \n\t\tDepths      keep_depths; \n \n\t\t \n \n\t\t \n \n\t\tfor (size_t k = 0; k < key_points.size(); k++) \n\t\t{ \n\t\t\tfloat d = image.dep.at<float>(key_points[k].pt); \n\t\t\tif (d < 400.f || d > 8000) continue; \n \n\t\t\tkeep_key_points.push_back(key_points[k]); \n\t\t\tkeep_descriptors.push_back(descriptors.row(k)); \n\t\t\tkeep_depths.push_back(d); \n\t\t} \n \n\t\t \n \n\t\tcam_Frames[i]      = (CamFrame) {i, keep_key_points,keep_depths}; \n\t\tdescriptors_vec[i] = keep_descriptors; \n \n\t\t_log(\"Found %d key points in image %d.\", keep_key_points.size(), i); \n\t}", "pragma": "parallel for ", "hash": "66459bd48330bdefe1eb05a8279949db5006f79eb0f023675bc376afda9aae3c"}
{"code": "for (i=0; i<2; i++) { \n        if (i == 0) SumRadiationField(level,radcell[cell.c1]); \n        else if (i == 1) SumRadiationField(level,radcell[cell.c2]); \n      }", "pragma": "parallel for private(i)", "hash": "5f6830ca983e0d21f3671aac457bd4b1b0d83abd3e6eafa9cd0c79fdd3c40a49"}
{"code": "for (k = 0; k < lr->k; ++k) { \n\t\t\t\tswitch (param.reg_type) { \n                case NV_LR_REG_NONE: \n\t\t\t\t\tfor (n = 0; n < lr->n; ++n) { \n\t\t\t\t\t\tNV_MAT_V(lr->w, k, n) -=  \n\t\t\t\t\t\t\twe * param.grad_w * NV_MAT_LIST_V(dw, 0, k, n); \n\t\t\t\t\t} \n\t\t\t\t\tbreak; \n\t\t\t\tcase NV_LR_REG_L1: \n\t\t\t\t\t \n \n\t\t\t\t\tfor (n = 0; n < lr->n; ++n) { \n\t\t\t\t\t\tNV_MAT_V(lr->w, k, n) -=  \n\t\t\t\t\t\t\twe * param.grad_w * NV_MAT_LIST_V(dw, 0, k, n); \n\t\t\t\t\t} \n\t\t\t\t\tfor (n = 0; n < lr->n; ++n) { \n\t\t\t\t\t\tfloat w_i = NV_MAT_V(lr->w, k, n); \n\t\t\t\t\t\tfloat lambda = we * param.reg_w * (1.0f / (1.0f + epoch)); \n\t\t\t\t\t\tNV_MAT_V(lr->w, k, n) = nv_sign(w_i) * NV_MAX(0.0f, (fabsf(w_i) - lambda)); \n\t\t\t\t\t} \n\t\t\t\t\tbreak; \n\t\t\t\tcase NV_LR_REG_L2: \n\t\t\t\t\tfor (n = 0; n < lr->n; ++n) { \n\t\t\t\t\t\tNV_MAT_V(lr->w, k, n) -=  \n\t\t\t\t\t\t\twe * (param.grad_w * (NV_MAT_LIST_V(dw, 0, k, n) \n\t\t\t\t\t\t\t\t\t\t\t\t  + param.reg_w * NV_MAT_V(lr->w, k, n))); \n\t\t\t\t\t} \n\t\t\t\t\tbreak; \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for private(n)", "hash": "6dc59ae41125dd40e8354a1b0e1117d12a834e3040308cbe27a947a342a91eab"}
{"code": "for(int i = 0; i < n; ++i) \n\t{ \n\t    float xf = 0, yf = 0, zf = 0; \n \n\t    const int dpid = giddstart + i; \n \n\t    for(int j = 0; j < nsrc; ++j) \n\t    { \n\t\tconst int spid = gidsstart + j; \n \n\t\tif (spid == dpid) \n\t\t    continue; \n \n\t\tconst float xdiff = xp[i] - srcxp[j]; \n\t\tconst float ydiff = yp[i] - srcyp[j]; \n\t\tconst float zdiff = zp[i] - srczp[j]; \n \n\t\tconst float _xr = xdiff - xdomainsize * floorf(0.5f + xdiff * xinvdomainsize); \n\t\tconst float _yr = ydiff - ydomainsize * floorf(0.5f + ydiff * yinvdomainsize); \n\t\tconst float _zr = zdiff - zdomainsize * floorf(0.5f + zdiff * zinvdomainsize); \n \n\t\tconst float rij2 = _xr * _xr + _yr * _yr + _zr * _zr; \n\t\tfloat invrij = 1./sqrtf(rij2); \n \n\t\tif (rij2 == 0) \n\t\t    invrij = 100000; \n \n\t\tconst float rij = rij2 * invrij; \n\t\tconst float wr = max((float)0, 1 - rij * invrc); \n \n\t\tconst float xr = _xr * invrij; \n\t\tconst float yr = _yr * invrij; \n\t\tconst float zr = _zr * invrij; \n \n\t\tconst float rdotv = \n\t\t    xr * (xv[i] - srcxv[j]) + \n\t\t    yr * (yv[i] - srcyv[j]) + \n\t\t    zr * (zv[i] - srczv[j]); \n \n\t\tconst float mysaru = saru(min(spid, dpid), max(spid, dpid), saru_tag); \n\t\tconst float myrandnr = 3.464101615f * mysaru - 1.732050807f; \n \n\t\tconst float strength = (aij - gamma * wr * rdotv + sigmaf * myrandnr) * wr; \n \n\t\txf += strength * xr; \n\t\tyf += strength * yr; \n\t\tzf += strength * zr; \n\t    } \n \n\t    xa[i] += xf; \n\t    ya[i] += yf; \n\t    za[i] += zf; \n\t}", "pragma": "parallel for ", "hash": "a7ce60500ffd2329ac1a06b282cd007b01b1f5e1313b9907fa940d132ca127ad"}
{"code": "for (y = 1; y < yoff; ++y)  \n \n\t\t\t\t\tmemcpy(tmp_buffer + y*surface->stride, tmp_buffer, \n\t\t\t\t\t\tm_filepara->max_x * surface->bypp);", "pragma": "parallel for ", "hash": "7d94d2e0e49a4049ed0d21a470bcb93e2e3d3abbb9c58756612e47042eb9acdb"}
{"code": "for ( int64_t intersectionIdx = 0; intersectionIdx < (int64_t)m_intersections.size(); ++intersectionIdx ) \n    { \n        size_t         elmIdx  = m_intersectedCellsGlobIdx[intersectionIdx]; \n        RigElementType elmType = femPart->elementType( elmIdx ); \n        if ( !( elmType == HEX8 || elmType == HEX8P ) ) continue; \n \n        interpolatedInterfaceValues[intersectionIdx] = \n            interpolateGridResultValue<T>( nativeAddr.resultPosType, unscaledResultValues, intersectionIdx ); \n    }", "pragma": "parallel for ", "hash": "e59e7c2b13e1710ed6cbd8a4bccf717db4e5eda80b07680cfc54b7537ad7504c"}
{"code": "for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < j; i++) { \n          register double complex temp = czero; \n          for (size_t l = 0; l < k; l++) \n            temp += conj(A[i * lda + l]) * A[j * lda + l]; \n          if (beta == zero) \n            C[j * ldc + i] = alpha * temp; \n          else \n            C[j * ldc + i] = alpha * temp + beta * C[j * ldc + i]; \n        } \n        register double rtemp = zero; \n        for (size_t l = 0; l < k; l++) \n          rtemp += conj(A[j * lda + l]) * A[j * lda + l]; \n        if (beta == zero) \n          C[j * ldc + j] = alpha * rtemp; \n        else \n          C[j * ldc + j] = alpha * rtemp + beta * creal(C[j * ldc + j]); \n      }", "pragma": "parallel for ", "hash": "6aa275fbbfa9dc4ce994d65162ca8307d2b67daeccdf708f1afc6f046a3aae33"}
{"code": "for (int i = 0; i < (int)values.size(); i++) { \n    unsigned int i_ = static_cast<unsigned int>(i); \n    values[i_]->update(A, B, C); \n  }", "pragma": "parallel for ", "hash": "27adc6e7dce09355448190bc23ab0eda36f8e526cea66d9bd3cf86b10414da46"}
{"code": "for (int y = 0; y < dst.rows; ++y) { \n        for (int x = 0; x < dst.cols; ++x) { \n            dst.at<uchar>(y, x) = binary2color.at(src.at<float>(y, x) < tau); \n        } \n    }", "pragma": "parallel for ", "hash": "08468a71387a9a84a932b57a25cac7eb7a6c9eb949b81118397e5b0f2129eaff"}
{"code": "for (int p = 0; p < pc; p++) \n    { \n        std::cout << p << std::endl; \n \n        DynamoParticle& pp = cat.particles[p]; \n        std::string index = \"000000\"; \n \n        const int tag = pp.tag; \n        if (tag >= 0) index[5] = '0' + tag%10; \n        if (tag >= 10) index[4] = '0' + (tag/10)%10; \n        if (tag >= 100) index[3] = '0' + (tag/100)%10; \n        if (tag >= 1000) index[2] = '0' + (tag/1000)%10; \n        if (tag >= 10000) index[1] = '0' + (tag/10000)%10; \n        if (tag >= 100000) index[0] = '0' + (tag/100000)%10; \n \n        std::string fn = dir + \"particle_\" + index + \".mrc\"; \n \n        try \n        { \n            BufferedImage<float> box; \n            box.read(fn); \n \n            const int w = box.xdim; \n            const int h = box.ydim; \n            const int d = box.zdim; \n \n            d4Matrix A = pp.getAlignmentMatrixAlias4x4(w,h,d); \n            A.invert(); \n \n             \n \n \n            MembraneFit mf(box, 15.0); \n \n             \n \n \n            d3Vector north(A(0,2), A(1,2), A(2,2)); \n \n             \n \n \n            std::vector<double> initial(9, 0.0); \n            initial[3] = north[0]; \n            initial[6] = north[1]; \n            initial[8] = north[2]; \n \n            BufferedImage<float> reconst0 = mf.expand(initial); \n            reconst0.write(\"debug/\"+index+\"_reconst0.mrc\"); \n \n            std::vector<double> opt = NelderMead::optimize( \n                initial, mf, 0.001, 1e-8, 1000, \n                1, 2, 0.5, 0.5, false); \n \n            BufferedImage<float> reconst = mf.expand(opt); \n \n            reconst.write(\"membrane_erased/\"+index+\"_membrane.mrc\"); \n            (box - reconst).write(\"membrane_erased/\"+index+\"_rest.mrc\"); \n \n            std::ofstream os(\"membrane_erased/\"+index+\"_coeffs.dat\"); \n \n            for (int i = 0; i < 9; i++) \n            { \n                os << opt[i] << ' '; \n            } \n \n            os << '\\n'; \n \n        } \n        catch (RelionError e) \n        { \n        } \n    }", "pragma": "parallel for ", "hash": "33ae987eb683ce7217f720abdc8f2b57cdbe83e90f423df65af083cbd02947e1"}
{"code": "for (int32_t j = 0; j < g; j++) { \n                    if (g * i + j != int32_t(numRotations)) { \n                        uint32_t rot = ReduceRotation(-g * i * (1 << (s * layersCollapse)), M / 4); \n                         \n \n                        auto clearTemp  = coeff[s][g * i + j]; \n                        auto clearTempi = coeffi[s][g * i + j]; \n                        clearTemp.insert(clearTemp.end(), clearTempi.begin(), clearTempi.end()); \n                        if ((flagRem == 0) && (s == levelBudget - flagRem - 1)) { \n                             \n \n                            for (uint32_t k = 0; k < clearTemp.size(); k++) { \n                                clearTemp[k] *= scale; \n                            } \n                        } \n \n                        auto rotateTemp = Rotate(clearTemp, rot); \n                        result[s][g * i + j] = \n                            MakeAuxPlaintext(cc, paramsVector[s], rotateTemp, 1, level0 + s, rotateTemp.size()); \n                    } \n                }", "pragma": "parallel for ", "hash": "5df9794d2932fe015f5347a4c0905a513d9303a4a8664517345193d5d98d6373"}
{"code": "for(size_t ibz=NPOP; ibz<(nz-NPOP); ibz+=BSIZEZ) \n  for(size_t iby=0;    iby<ny;        iby+=BSIZEY) \n  { \n   \n  for(size_t iz=ibz; iz<MIN(ibz+BSIZEZ, nz-NPOP); iz++) \n  { \n    size_t ind = iz*nx_ny; \n    for(size_t iy=iby; iy<MIN(iby+BSIZEY, ny); iy++) \n    { \n      size_t i=ind+iy*nx; \n      for(size_t ix=0; ix<nx; ix+=OV_FLOAT_WIDTH*UNROLL) \n      { \n \n        ov_float curr, u0, u1, p; \n \n        LOOP_BODY(0); \n        LOOP_BODY(OV_FLOAT_WIDTH); \n        LOOP_BODY(1*OV_FLOAT_WIDTH); \n        LOOP_BODY(2*OV_FLOAT_WIDTH); \n \n        i+=OV_FLOAT_WIDTH*UNROLL; \n      } \n    } \n  } \n  }", "pragma": "parallel for ", "hash": "2f8c8dcebfd3d1e6eb4d715135adc14d4613e21bbbb8ab572e6c92b51eed1291"}
{"code": "for (uint64_t i = 0; i < d->numParticles; i++) { \n\t\tfor(int k = 0; k<3; k++) { \n\t\t\td->pos[i*3 + k] += box/2 - (newCenter[k]*box); \n\t\t\tif(d->pos[i*3 + k] > box) d->pos[i*3 + k] -= box; \n\t\t\tif(d->pos[i*3 + k] < 0) d->pos[i*3 + k] += box; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "71df0a86925211ba66f60744f9841f90ca56073edc9e5951c7256435544103c8"}
{"code": "for(long i=0;i<n;i++)\r \n\t{\tmreal b = abs(a[i]);\tif(b>v)\ta[i] *= v/b;\t}", "pragma": "parallel ", "hash": "e0e0a73ee9aa849d2f23ff316e9c65e250e62696ae1ac89156ea91381995eb12"}
{"code": "for (uint i = 0; i < positions.size()/3; ++i) { \n        uint x = positions[i * 3] * RESOLUTION; \n        uint y = positions[i * 3 + 1] * RESOLUTION; \n        uint z = positions[i * 3 + 2] * RESOLUTION; \n \n        double density = 0; \n        double near_density = 0; \n \n        for (int xx = -1; xx <=1; ++xx) \n            for (int yy = -1; yy <= 1; ++yy) \n                for (int zz = -1; zz <= 1; ++zz) { \n                    int idx = (z + zz) * (SCENE_WIDTH * RESOLUTION * SCENE_HEIGHT * RESOLUTION) + (y + yy) * (SCENE_WIDTH * RESOLUTION) + (x + xx); \n                    if (idx >= 0 && idx < grid.size()) \n                        for (std::list<uint>::iterator it = grid[idx].begin(); it != grid[idx].end(); ++it) { \n                            double dx = positions[*it * 3]     - positions[i * 3]; \n                            double dy = positions[*it * 3 + 1] - positions[i * 3 + 1]; \n                            double dz = positions[*it * 3 + 2] - positions[i * 3 + 2]; \n                            double r = sqrt(dx*dx + dy*dy + dz*dz + 0.01); \n \n                            double influence = 1 - r/H; \n \n                            if (influence < 0) \n                                continue; \n \n                            density += PARTICLE_MASS * influence * influence * influence * NORM; \n                            near_density += PARTICLE_MASS * influence * influence * influence * influence * NEAR_NORM; \n                        } \n                } \n \n        densities[i] = density; \n        near_densities[i] = near_density; \n        pressures[i] = this->stiffness * (density - PARTICLE_MASS*this->density); \n        near_pressures[i] = this->near_stiffness * near_density; \n    }", "pragma": "parallel for ", "hash": "f7c27c4f3428d01212d3abb103f6dac7ecec88dccfef8b5c2b61fc0633358a6a"}
{"code": "for (int i = 0; i < ar.used; i++) \n\t{ \n \n\t\t \n \n\t\tif (stop < my_time) \n\t\t{ \n \n\t\t\t \n \n\t\t\tj = ar.array[i]; \n \n\t\t\t \n \n\t\t\tread_neigbourhood(j, maxi, coloured_graph_); \n \n\t\t\t \n \n\t\t\tif (branching.size() >= 2 && branching.size() <= maxbranch && all_elem_key.size() >= ((kamer * 2) + 2)) \n\t\t\t{ \n    #pragma omp parallel for schedule (static) \n\t\t\t\tfor (int i = 0; i < branching.size(); i++) \n\t\t\t\t{ \n \n\t\t\t\t\tvector<u64>::iterator ist = find(demi_cyc.begin(), demi_cyc.end(), branching[i]); \n\t\t\t\t\tif(ist == demi_cyc.end()) \n\t\t\t\t\t{ \n         #pragma omp parallel for schedule (static) \n\t\t\t\t\t \n \n\t\t\t\t\t\tfor (int k = 0; k < kamer; k++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tint nps_cycle = (((kamer + k) * 2) + 2); \n\t\t\t\t\t\t\tsearch_snps(branching[i], 0, nps_cycle, P); \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tvisited.clear(); \n\t\t\t\t\t\t\tfor (int i = 0; i < all_elem_key.size(); i++) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tvisited.insert(pair<u64, bool>(all_elem_key[i], 0)); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n\t\t\t\t} \n \n \n\t\t\t} \n \n \n\t\t\t \n \n\t\t\tnp = omp_get_num_threads(); \n\t\t\ttid = omp_get_thread_num(); \n\t\t\tpip = omp_get_max_threads(); \n \n\t\t\tif (((cycles_.size() > cyclesize) && tid == 0) || (i == ar.used - 1)) { \n \n \n\t\t\t\ttotalsnps = totalsnps + (cycles_.size() - cyclesize); \n\t\t\t\t \n \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\tout << all_elem_key.size() << ' '; \n\t\t\t\tout << cycles_.size() << ' ';   \n \n\t\t\t\tout << cycles_.size() - cyclesize << ' '; \n\t\t\t\tout << ar.used - call << ' '; \n\t\t\t\t \n \n\t\t\t\t \n \n \n\t\t\t\tstd::clock_t c_end = std::clock(); \n \n\t\t\t\tout << std::fixed << std::setprecision(2)  \n \n\t\t\t\t\t<< ((c_end - c_start) / (double)CLOCKS_PER_SEC) << ' '; \n \n\t\t\t\tdouble end = omp_get_wtime(); \n \n\t\t\t\tdif = end - start;  \n \n\t\t\t\tout << dif << endl; \n \n\t\t\t\tcyclesize = cycles_.size(); \n \n\t\t\t\tstep++; \n \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif (tid == 0) { \n \n\t\t\t\tauto t_end = std::chrono::high_resolution_clock::now(); \n \n\t\t\t\tstop = std::chrono::duration<double, std::ratio<60>>(t_end - t_start).count(); \n\t\t\t} \n \n \n\t\t\t \n \n\t\t\tbranching.clear(); \n\t\t\tall_elem_key.clear(); \n\t\t\tm.clear(); \n\t\t\tcall++;  \n \n \n\t\t} \n \n \n\t}", "pragma": "parallel for private(j)", "hash": "3e8be09ced8dd22b68ff0f67239ce82825507bfe84c5e0b5cbaebe7c96ea6b90"}
{"code": "for (int i = 0; i < (int)num_primitives; ++i) { \n                        triangle t{(float*)vertices[3*i+0], (float*)vertices[3*i+1], (float*)vertices[3*i+2]}; \n \n                        transform_triangle(t); \n \n                        if (!cull_triangle(t)) { \n                                local_indexes.emplace_back(i); \n                        } \n                }", "pragma": "for ", "hash": "3f2f80e31092eaa810328b4fb20b2ad11ad18850c3a1294a918d57d3095418bc"}
{"code": "for (j = 0; j < npoints; ++j) { \n      ydata[j] = eval_brakhage_werner_c(bem, x, eta_bw, xdata[j]); \n    }", "pragma": "parallel for ", "hash": "fc6f13c75595e2405df89398fb707ac4ff43e8c6c00816ff940f19886e15b39a"}
{"code": "for (ix = marg; ix<nx+pmlout*2+marg; ix++) { \n\t    for (iz = marg; iz<nz+pmlout*2+marg; iz++) { \n\t\tdn0[ix][iz]  = dn1[ix][iz]; \n\t    } \n\t}", "pragma": "parallel for private( ix iz)", "hash": "a2fb0b076934287178063fdffe501612c51bd31865834db93005cb98988558ff"}
{"code": "for(long i=1;i<n;i++)\tif(kk[i]!=kk[i-1])\ta[i] = NAN;", "pragma": "parallel ", "hash": "ae0b784b7cb949a82597cc040726957e1353bbd2d01b2074787a22dbc74a08de"}
{"code": "for(int i = 0; i < static_cast<int>( m_lLayers.size() ); i++) { \n\t\tm_lLayers.at(i)->EraseAll(); \n\t}", "pragma": "parallel for ", "hash": "bfcf13e0be0ce06c348c5c0ad633c8e8a13ad4e8a03e34c1799e707fc0843dc2"}
{"code": "for (int i = 0; i < mGridSize; ++i) \n      { \n        mCellTypeAux[i] = kCellTypeAir; \n \n        if (mCellType[i] == kCellTypeAir) \n        { \n          const int column = (i % mGridWidth); \n          const int row = (i / mGridWidth); \n          int adjacentNonAirCells = 0; \n \n          if ((column == 0) || (mCellType[i - 1] != kCellTypeAir)) \n          { \n            ++adjacentNonAirCells; \n          } \n          if ((column == (mGridWidth - 1)) || (mCellType[i + 1] != kCellTypeAir)) \n          { \n            ++adjacentNonAirCells; \n          } \n          if ((row == 0) || (mCellType[i - mGridWidth] != kCellTypeAir)) \n          { \n            ++adjacentNonAirCells; \n          } \n          if ((row == (mGridHeight - 1)) || (mCellType[i + mGridWidth] != kCellTypeAir)) \n          { \n            ++adjacentNonAirCells; \n          } \n          if (adjacentNonAirCells >= 3) \n          { \n            mCellTypeAux[i] = kCellTypeFluid; \n          } \n        } \n      }", "pragma": "for ", "hash": "51de8399eb87cfc7ea0d05c8ebf4becc7bd3d09577fce4742fd273eb89fda50f"}
{"code": "for (int i = 0; i <= m_I-1; i++) \n\t{ \n#pragma ivdep \n\t\tfor (int j = 0; j <= m_J-1; j++) \n\t\t{ \n\t\t\tm_data[i][j] -= s; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "d1828f04b93011d86b0ecae9b07edfa03c9535004cce4d4ad496075d97d025e5"}
{"code": "for(k=1; k<splineControlPoint->nz-1; k++){ \n        for(j=1; j<splineControlPoint->ny-1; j++){ \n            jacIndex = (k*splineControlPoint->ny+j)*splineControlPoint->nx+1; \n            for(i=1; i<splineControlPoint->nx-1; i++){ \n                logDet = log(jacobianDeterminant[jacIndex++]); \n                penaltyTerm += logDet*logDet; \n                penaltyTerm +=  fabs(log(logDet)); \n            } \n        } \n    }", "pragma": "parallel for reduction(+:penaltyterm) private(    i j jacindex k logdet)", "hash": "70bbb5d38c512e1ddd3f0a5eba25ed1b3413fa03a8095624033920e24acd31ae"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t(*res)[i] = (*this)[i] + (*right)[i];", "pragma": "for ", "hash": "4195c9cd1a942d44e8a9277d6be02a3de5a054b00ee50af4378165e86cb700c5"}
{"code": "for(int i=0;i<num_islands;i++){ \n\t\t\t\t\tfloat worstfit; \n\t\t\t\t\tfloat bestfit; \n\t\t\t\t\tvector<ind> tmppop; \n \n\t\t\t\t\tFitness(T.at(i).pop,p,d,s,FE[0]); \n\t\t\t\t\tworstfit = T.at(i).worstFit(); \n\t\t\t\t\tbestfit = T.at(i).bestFit(); \n \n\t\t\t\t\t \n\t\t\t\t\tint counter=0; \n\t\t\t\t\twhile(worstfit == p.max_fit && counter<100) \n\t\t\t\t\t{ \n\t\t\t\t\t\tfor (vector<ind>::iterator j=T.at(i).pop.begin();j!=T.at(i).pop.end();) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tif ( (*j).fitness == p.max_fit) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tj=T.at(i).pop.erase(j); \n\t\t\t\t\t\t\t\ttmppop.push_back(ind()); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tj++; \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tInitPop(tmppop,p,r); \n\t\t\t\t\t\tFitness(tmppop,p,d,s,FE[0]); \n\t\t\t\t\t\tT.at(i).pop.insert(T.at(i).pop.end(),tmppop.begin(),tmppop.end()); \n\t\t\t\t\t\ttmppop.clear(); \n\t\t\t\t\t\tworstfit = T.at(i).worstFit(); \n\t\t\t\t\t\tcounter++; \n\t\t\t\t\t\tif(counter==100) \n\t\t\t\t\t\t\ts.out << \"initial population count exceeded. Starting evolution...\\n\"; \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "parallel for ", "hash": "fd64733c723002f09d786f1b7a1430de571df38cfad4629704a9628c4076a4cf"}
{"code": "for (i = 0; i < natoms; ++i) { \n    start_i = Start_Index(i, bonds); \n    end_i = End_Index(i, bonds); \n \n    for (pj = start_i; pj < end_i; ++pj) { \n      j = bonds->select.bond_list[pj].nbr; \n \n      if( system->my_atoms[i].orig_id > system->my_atoms[j].orig_id ) continue; \n \n      if( system->my_atoms[i].orig_id == system->my_atoms[j].orig_id ) { \n        if (system->my_atoms[j].x[2] <  system->my_atoms[i].x[2]) continue; \n      \tif (system->my_atoms[j].x[2] == system->my_atoms[i].x[2] && \n      \t    system->my_atoms[j].x[1] <  system->my_atoms[i].x[1]) continue; \n        if (system->my_atoms[j].x[2] == system->my_atoms[i].x[2] && \n      \t    system->my_atoms[j].x[1] == system->my_atoms[i].x[1] && \n      \t    system->my_atoms[j].x[0] <  system->my_atoms[i].x[0]) continue; \n      } \n \n       \n \n      type_i = system->my_atoms[i].type; \n      type_j = system->my_atoms[j].type; \n      sbp_i = &( system->reax_param.sbp[type_i] ); \n      sbp_j = &( system->reax_param.sbp[type_j] ); \n      twbp = &( system->reax_param.tbp[type_i][type_j] ); \n      bo_ij = &( bonds->select.bond_list[pj].bo_data ); \n \n       \n \n      pow_BOs_be2 = pow( bo_ij->BO_s, twbp->p_be2 ); \n      exp_be12 = exp( twbp->p_be1 * ( 1.0 - pow_BOs_be2 ) ); \n      CEbo = -twbp->De_s * exp_be12 * \n\t( 1.0 - twbp->p_be1 * twbp->p_be2 * pow_BOs_be2 ); \n \n       \n \n      total_Ebond += ebond = \n\t-twbp->De_s * bo_ij->BO_s * exp_be12 \n\t-twbp->De_p * bo_ij->BO_pi \n\t-twbp->De_pp * bo_ij->BO_pi2; \n \n       \n \n      if (system->pair_ptr->evflag) \n\tpair_reax_ptr->ev_tally_thr_proxy(system->pair_ptr, i, j, natoms, 1, \n\t\t\t\t\t  ebond, 0.0, 0.0, 0.0, 0.0, 0.0, thr); \n \n       \n \n      bo_ij->Cdbo += CEbo; \n      bo_ij->Cdbopi -= (CEbo + twbp->De_p); \n      bo_ij->Cdbopi2 -= (CEbo + twbp->De_pp); \n \n       \n \n      if (bo_ij->BO >= 1.00) { \n\tif (gp37 == 2 || \n\t    (sbp_i->mass == 12.0000 && sbp_j->mass == 15.9990) || \n\t    (sbp_j->mass == 12.0000 && sbp_i->mass == 15.9990)) { \n\t  exphu = exp( -gp7 * SQR(bo_ij->BO - 2.50) ); \n\t  exphua1 = exp(-gp3 * (workspace->total_bond_order[i]-bo_ij->BO)); \n\t  exphub1 = exp(-gp3 * (workspace->total_bond_order[j]-bo_ij->BO)); \n\t  exphuov = exp(gp4 * (workspace->Delta[i] + workspace->Delta[j])); \n\t  hulpov = 1.0 / (1.0 + 25.0 * exphuov); \n\t \n\t  estriph = gp10 * exphu * hulpov * (exphua1 + exphub1); \n\t  total_Ebond += estriph; \n\t \n\t  decobdbo = gp10 * exphu * hulpov * (exphua1 + exphub1) * \n\t    ( gp3 - 2.0 * gp7 * (bo_ij->BO-2.50) ); \n\t  decobdboua = -gp10 * exphu * hulpov * \n\t    (gp3*exphua1 + 25.0*gp4*exphuov*hulpov*(exphua1+exphub1)); \n\t  decobdboub = -gp10 * exphu * hulpov * \n\t    (gp3*exphub1 + 25.0*gp4*exphuov*hulpov*(exphua1+exphub1)); \n\t \n\t   \n \n\t  if (system->pair_ptr->evflag) \n\t    pair_reax_ptr->ev_tally_thr_proxy(system->pair_ptr, i, j, natoms, 1, \n\t\t\t\t\t      estriph, 0.0, 0.0, 0.0, 0.0, 0.0, thr); \n\t \n\t  bo_ij->Cdbo += decobdbo; \n\t  workspace->CdDelta[i] += decobdboua; \n\t  workspace->CdDeltaReduction[reductionOffset+j] += decobdboub; \n        } \n      } \n    } \n  }", "pragma": "for ", "hash": "b9388a00957b42ae72c71ff30c7a47716c56d4b87ccbf6015fe03fde801456a7"}
{"code": "for (int i = 0; i < img_s; ++i) img[i] = processing->pre_calc_levels[ img[i] ];", "pragma": "parallel for ", "hash": "aac4fe1d35f81b7b38dfc1f86fe7b16c76b9e0cbe824c5242d0b50e28ed71a96"}
{"code": "for (int64_t i = 0; i < n; i++) \n        fvec2bitvec(x + i * d, b + i * ncodes, d);", "pragma": "parallel for ", "hash": "dbc4870427ca37b14bf451e978a1c12502e80732df88ac656af0203aaf05be39"}
{"code": "for (int j = 0; j < N; ++j) \n                { \n\t\tint tid = omp_get_thread_num(); \n                int seed = (j+1)*(tid+1)*time(0); \n                std::minstd_rand0 generator (seed); \n                rval[j] =  distribution(generator); \n                }", "pragma": "parallel for private(n)", "hash": "19c02de7ee4d41f7134a03c04941df1c2e1e93b80fb7ef1b0fef169659d3ae6b"}
{"code": "for (int i = 0; i < 1024; i++) \n    { \n      { y = s; b[i] = y + x + 12; } \n      #pragma omp scan exclusive(s) \n      { y = 2 * a[i]; s += y; z = y; } \n    }", "pragma": "for reduction( +:s inscan) private(x y z)", "hash": "4bad67af9fab63fa7f08204de783d4863ffcef79e3f00ec01ee3c6a14794d0d2"}
{"code": "for (unsigned int i=0; i<vf.size(); ++i) \n                vf[i] *= sf[i];", "pragma": "parallel for ", "hash": "28b62b6132fa6b7fd2b9f98e1fa778708e7225d48c4c9b116b1707b712fe0773"}
{"code": "for (int vertex = 0; vertex < sortedVertices.size(); vertex++) \n\t\t{ \n \n\t\t\t \n \n\t\t\tif (graph.getColor(vertex) != 0) \n\t\t\t\tcontinue; \n \n\t\t\t \n \n\t\t\tGraph::Vertex vertexNumber = vertexNumbers.at(vertex); \n\t\t\tGraph::VertexVector neighbors = graph.getNeighbors(vertex); \n\t\t\tbool localMax = true; \n \n\t\t\tfor (Graph::Vertex neighbor : neighbors) \n\t\t\t{ \n\t\t\t\tGraph::Color neighborColor = graph.getColor(neighbor); \n\t\t\t\tif (vertexNumbers.at(neighbor) > vertexNumber && (neighborColor == 0 || neighborColor == round)) \n\t\t\t\t{ \n\t\t\t\t\tlocalMax = false; \n\t\t\t\t\tbreak; \n\t\t\t\t} \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif (localMax) \n\t\t\t{ \n\t\t\t\tgraph.setColor(vertex, round); \n\t\t\t\tcolored++; \n\t\t\t} \n\t\t}", "pragma": "parallel for reduction(+:colored) ", "hash": "1c4e0f475a0cf4cb2f07b1e2b112bc09ca603b5b67ecfbea46a0606a004fcb13"}
{"code": "for(i=0; i<n_inputs; i++){ \n      idx = input[i] - 1; \n      real s = (count) ? (scale / (real)count[idx]) : scale; \n      real *w = weight + dim * idx; \n      nn_(FasterLookup_addVec)(w, s, gradOutput + dim * i, dim); \n    }", "pragma": "parallel for private( i idx)", "hash": "85ff4621787055245392ccf3621a35aa56324ce112d93418fc55a598ae4ba477"}
{"code": "for(long i = 0; i < jac.rows(); i++) { \n        for(long j = i; j < jac.cols(); j++) { \n            auto id   = static_cast<double>(i == j); \n            auto res  = (id - v[i] * v[j] * one_over_nn) * one_over_n; \n            jac(i, j) = res; \n            jac(j, i) = res; \n        } \n    }", "pragma": "parallel for ", "hash": "ae4070f20ce7f70fe60fad5b9adda50422d61eb2803ff8467fdfe9e4f9635fc3"}
{"code": "for ( int j = 0; j < int( m_newFaceVertexOps[i].size() ); ++j ) \n        { \n            Ra::Core::Vector3 pos( 0, 0, 0 ); \n            const auto& ops = m_newFaceVertexOps[i][j]; \n            for ( const auto& op : ops.second ) \n            { \n                pos += op.first * mesh.point( op.second ); \n            } \n            mesh.set_point( ops.first, pos ); \n        }", "pragma": "parallel for ", "hash": "4aba807b1c6856492592ef52efc655ac718e235fa1079ecafed2303191d87824"}
{"code": "for (int i = 0; i < m_nCells; i++) \n    { \n        int curFactoryID = -1; \n        vector<int> curOps; \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n        if (GetOperationCode(i, curFactoryID, curOps)) \n        { \n            for (vector<int>::iterator it = curOps.begin(); it != curOps.end(); it++) \n            { \n                 \n \n                ScheduledManagement(i, curFactoryID, *it); \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n\t\t\t\t \n \n            } \n        } \n\t}", "pragma": "parallel for ", "hash": "5b807a440ade997ee6a927bdd6ff4793a4ebf97bf39b046770aef3937ec4c32d"}
{"code": "for (i = 0; i <= 99; i += 1) { \n    y = x + 1 + g; \n    b[i] = x + 1 + g; \n \n \n \n \n  }", "pragma": "parallel for private(i x y)", "hash": "55335526c0518f80858edb6690c70143641cb002112a45afabc44f2ffefdba41"}
{"code": "for (int ix = 0; ix < N; ++ix) { \n    s=(double*)((spinor *) S + ix); \n    r=(double*)((spinor *) R + ix); \n    __prefetch_by_load(S + ix + 1); \n    __prefetch_by_load(R + ix + 1); \n    x0 = vec_ld(0, s); \n    x1 = vec_ld(0, s+4); \n    x2 = vec_ld(0, s+8); \n    x3 = vec_ld(0, s+12); \n    x4 = vec_ld(0, s+16); \n    x5 = vec_ld(0, s+20); \n    y0 = vec_ld(0, r); \n    y1 = vec_ld(0, r+4); \n    y2 = vec_ld(0, r+8); \n    y3 = vec_ld(0, r+12); \n    y4 = vec_ld(0, r+16); \n    y5 = vec_ld(0, r+20); \n    z0 = vec_mul(x0, y0); \n    z1 = vec_mul(x1, y1); \n    z2 = vec_mul(x2, y2); \n    z3 = vec_mul(x3, y3); \n    z4 = vec_mul(x4, y4); \n    z5 = vec_mul(x5, y5); \n    x0 = vec_add(z0, z1); \n    x1 = vec_add(z2, z3); \n    x2 = vec_add(z4, z5); \n    x3 = vec_add(x0, x1); \n    ds = vec_add(x2, x3); \n \n    tr = vec_add(ds, kc); \n    ts = vec_add(tr, ks); \n    tt = vec_sub(ts, ks); \n    ks = ts; \n    kc = vec_sub(tr, tt); \n  }", "pragma": "for ", "hash": "dde901ace89fe64d8c31a1a8fd1796628c4218904a63f4e227706e90de65ebf0"}
{"code": "for (i = 0; i < 16; i++) \n      b[i + 16] = i + 16;", "pragma": "parallel for ", "hash": "9b49313b2f69cf91f9e9754283a636c585687262edf86f8b2f69a12f3b3d3752"}
{"code": "for (int s = 0; s < numSamples; ++s) \n    exp_y.row(s) /= sum_exp.at<real>(s);", "pragma": "parallel for ", "hash": "0d8c66a1d4f6270f82094f35328ed78ff646d2266ada212c4388673a3114856b"}
{"code": "for ( int threadNum = 0; threadNum < subsetThreadCount * alphabetSize; ++threadNum ) \n        { \n            const int subsetThreadNum = threadNum / alphabetSize;  \n \n             \n \n \n            CountWords_parallelSubsetThread( \n                threadNum \n                , cycle \n                , *( rangeStoresA[subsetThreadNum] ) \n                , *( rangeStoresB[subsetThreadNum] ) \n            ); \n        }", "pragma": "parallel for ", "hash": "c5dd2c73c53bf8c379cbc3b5ac25e7505c167b5c8f05255b75776510b0b5a99b"}
{"code": "for(i=0; i<(int)threadnumb; i++) \n\t\t{ \n\t\t\tann_vect[i]=fann_copy(ann); \n\t\t}", "pragma": "for ", "hash": "00256e40b6af6c6229bb74d442e6021213e0612630fd032cb6e829bf6a9a96e6"}
{"code": "for(int thread = current; thread <= target; thread++){ \n\t\t\t\texecute_sequential_search_worker(thread, &founds, order); \n\t\t\t}", "pragma": "parallel for ", "hash": "bfcd4ba8146785fcf0742e20027d142464128c7d9da5723cd0504d9d68fa8858"}
{"code": "for(long i=0;i<n;i++)\tpp[i] = mglPoint(x->v(i), y->v(i), z->v(i));", "pragma": "parallel for ", "hash": "e950c66e7348f43378d5e8aeb29e050c9c7f22ffc57ee5fb124efbb6d368b706"}
{"code": "for(long j=0;j<n2;j++)\tfor(long i=0;i<n1;i++)\r \n\t\t\tr->a[i+n1*j] = d1->vthr(i)*d2->vthr(j);", "pragma": "parallel for ", "hash": "790e03a8118d197e170fd90e7eee91fcc2f9648d51e02059e626bffc7beab6c8"}
{"code": "for (int iCell = 1; iCell <= nCells; ++iCell) \n\t\t{ \n\t\t\tint id = (int)m_routingLayers[iLayer][iCell]; \n\t\t\tOverlandFlow(id); \n\t\t}", "pragma": "parallel for ", "hash": "29c3edd40a7e26a23246fd4e025a8c6769a1fdc3476cab020763089923ea689c"}
{"code": "for (int i = 0; i < (int)numParticles; i++) \n\t\t{ \n\t\t\tconst Vector3r &xi = model->getPosition(i); \n\t\t\tconst Real density_i = model->getDensity(i) / density0; \n \n\t\t\tVector3r &ai = m_simulationData.getPressureAccel(fluidModelIndex, i); \n\t\t\tai.setZero(); \n \n\t\t\tconst Real density2 = density_i*density_i; \n\t\t\tconst Real dpi = (m_simulationData.getPressure(fluidModelIndex, i)/density0) / density2; \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tforall_fluid_neighbors( \n\t\t\t\t \n \n\t\t\t\tconst Real Vj = fm_neighbor->getMass(neighborIndex) / fm_neighbor->getDensity(neighborIndex); \n\t\t\t\tconst Real density_j = fm_neighbor->getDensity(neighborIndex) / fm_neighbor->getDensity0(); \n\t\t\t\tconst Real densityj2 = density_j*density_j; \n\t\t\t\tconst Real dpj = (m_simulationData.getPressure(pid, neighborIndex)/ fm_neighbor->getDensity0())  / densityj2; \n\t\t\t\tai -= Vj * (dpi + fm_neighbor->getDensity0() / density0 * dpj) * sim->gradW(xi - xj); \n\t\t\t); \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tif (sim->getBoundaryHandlingMethod() == BoundaryHandlingMethods::Akinci2012) \n\t\t\t{ \n\t\t\t\tforall_boundary_neighbors( \n\t\t\t\t\tconst Vector3r a = bm_neighbor->getVolume(neighborIndex) * dpi * sim->gradW(xi - xj); \n\t\t\t\t\tai -= a; \n\t\t\t\t\tbm_neighbor->addForce(xj, model->getMass(i) * a); \n\t\t\t\t); \n\t\t\t} \n\t\t\telse if (sim->getBoundaryHandlingMethod() == BoundaryHandlingMethods::Koschier2017) \n\t\t\t{ \n\t\t\t\tforall_density_maps( \n\t\t\t\t\tconst Vector3r a = -dpi * gradRho; \n\t\t\t\t\tai -= a; \n\t\t\t\t\tbm_neighbor->addForce(xj, model->getMass(i) * a); \n\t\t\t\t); \n\t\t\t} \n\t\t\telse if (sim->getBoundaryHandlingMethod() == BoundaryHandlingMethods::Bender2019) \n\t\t\t{ \n\t\t\t\tforall_volume_maps( \n\t\t\t\t\tconst Vector3r a = Vj * dpi* sim->gradW(xi - xj); \n\t\t\t\t\tai -= a; \n\t\t\t\t\tbm_neighbor->addForce(xj, model->getMass(i) * a); \n\t\t\t\t); \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "accc75ac1175cc99721bc6f6168737193655c108c52bcab04f01ab4eccb9a7bf"}
{"code": "for (i=0;i<d-1;i++) \n            { \n                PairCopulaFit(Vine->Thetas+Vine->NumbParams[d*j-j*(j+1)/2+i], Vine->Families[d*j-j*(j+1)/2+i], &U[0], &U[(i+1)*n], n); \n            }", "pragma": "parallel for private(i)", "hash": "c21a0b83da404298e91b189cb473799421a9f72569bbcb61f06bff4d541f6810"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      #pragma omp critical   \n \n      foo (); \n    }", "pragma": "for simd ", "hash": "3fa8aa2e18247d36cedee4daac42505391f92d8cbb811073338d064c0a6f07d2"}
{"code": "for (long k = 0; k < nModelVals; k++) { \n    j = k % nModelColumns; \n    i = k / nModelColumns; \n    y = y1_region + startY_offset + (i - nPSFRows)*subpixFrac; \n    x = x1_region + startX_offset + (j - nPSFColumns)*subpixFrac; \n    newValSum = 0.0; \n    storedError = 0.0; \n    for (n = 0; n < nFunctions; n++) { \n      if (functionObjectVect[n]->IsPointSource()) { \n        if ((k == 0) || (k == (nModelVals - 1))) { \n          LOG_F(3, \"   k = %d; i,j = %d,%d; x,y = %.2f,%.2f\", k,i,j,x,y); \n          LOG_F(3, \"      x1_region = %d, startX_offset = %.2f\", x1_region,startX_offset); \n        } \n         \n \n        adjVal = functionObjectVect[n]->GetValue(x, y) - storedError; \n        tempSum = newValSum + adjVal; \n        storedError = (tempSum - newValSum) - adjVal; \n        newValSum = tempSum; \n      } \n    } \n    modelVector[i*nModelColumns + j] += newValSum; \n  }", "pragma": "for ", "hash": "fd1b833628ccd547856072f7d01af35abb0010775e7a782439dac2a998f18ff7"}
{"code": "for(size_t i = 0; i < buffsize; i++) mask[i] = 1.0f - mask[i];", "pragma": "parallel for ", "hash": "999aaa58d6d0292eb47db2743b1f861f6fe003879bba4ad18db93e43f2d72d67"}
{"code": "for (int i = 0; i <= setup.NS-1; \ti++)\tdrho_dQ[i]\t= 1.0;", "pragma": "parallel for ", "hash": "e8659aee99c72c059f6e5ed54e8854845a0f165f7b9e0f2ea2ac92aa55dc4a7a"}
{"code": "for (i3 = 1; i3 < n3-1; i3++) { \n\tfor (i2 = 1; i2 < n2-1; i2++) { \n            for (i1 = 1; i1 < n1-1; i1++) { \n\t\tp_s = p_s + r[i3][i2][i1] * r[i3][i2][i1]; \n\t\ttmp = fabs(r[i3][i2][i1]); \n\t\tif (tmp > p_a) p_a = tmp; \n\t    } \n\t} \n    }", "pragma": "for ", "hash": "fb5fc5fe564a12ee883d7235e920a93c3ae954990713b52cc3db779eeaafc5a2"}
{"code": "for(unsigned int i=0; i<rgbMatrix.size(); i++) \n\t\t{ \n\t\t\tint row = (i/640), column = i-(row*640); \n\t\t\trgb_image.at<cv::Vec3b>(row, column) = cv::Vec3b(rgbMatrix[i].blue, rgbMatrix[i].green, rgbMatrix[i].red); \n\t\t}", "pragma": "parallel for ", "hash": "e6d4a7f6073f27be5e8a634c33201c3ee02d2701d4d8e7cff1a5986d07f09cab"}
{"code": "for (i = 0; i < (int)n_a; i++) {\r \n            result[i] = a[i] + b[i];\r \n        }", "pragma": "parallel for private(i)", "hash": "ee65e7ad6297182351c1b99d3793b49cf9cf53e8a05b611a4f2887391f3d13ba"}
{"code": "for (k_L = 0; k_L < ths->N_total; k_L++) \n    { \n      INT k[ths->d], k_temp, t; \n \n      k_temp = k_L; \n \n      for (t = ths->d - 1; t >= 0; t--) \n      { \n        k[t] = k_temp % ths->N[t]; \n        k_temp /= ths->N[t]; \n      } \n \n      for (j = 0; j < ths->M_total; j++) \n      { \n        R omega = K(1.0); \n        for (t = 0; t < ths->d; t++) \n          omega *= BASE(K2PI * (k[t] + OFFSET) * ths->x[j * ths->d + t]); \n        f_hat[k_L] += f[j] * omega; \n      } \n    }", "pragma": "parallel for private( j k_l)", "hash": "46c14abf70ba311cf0ddbcbe57fd69d8d419e2455f04c6c08ecb8d36a7a1bc14"}
{"code": "for (int j = 0; j < nRowVisited; ++j) { \n        rowPerm[rowInversePerm[rowPermIdx + j]] = rowPermIdx + j; \n      }", "pragma": "parallel for ", "hash": "45183f19686f486c57295ae8ecf1aa1757bc9d61fe4adc3b1a3c38e1318b3589"}
{"code": "for (p = s; p != r; p = o + p)\t \n \n    bar (p);", "pragma": "for ", "hash": "349654602e2e4bbf3088e91994aaeb07074bdd76708f604005ace17e04595b4c"}
{"code": "for (i1 = A[k]; i1 <= B[k]; i1++) { \n\t\t\t\ttmpA = tmpB = 0; \n\t\t\t\t \n \n\t\t\t\tfor (i2 = max(A[k+1],i1); i2 <= B[k+1]; i2++) { \n\t\t\t\t\tvalA = factorA*(i2 + 1 - mu_a_b[idxANumRows + i1])*(i2 + 1 - mu_a_b[idxANumRows + i1]); \n\t\t\t\t\tvalB = factorB*(i2 + 1 - mu_a_b[idxBNumRows + i1])*(i2 + 1 - mu_a_b[idxBNumRows + i1]); \n\t\t\t \n\t\t\t\t    if (valA > limit2) {tmpA += preCalcA[i2]*hashTable[(int)(-valA*1000 + 0.5)];} \n                    if (valB > limit2) {tmpB += preCalcA[i2]*hashTable[(int)(-valB*1000 + 0.5)];} \n\t\t\t\t} \n\t\t\t\tbeta[idx + i1] = (colAFac[idxPred]*tmpA + colBFac[idxPred]*tmpB)*cInv; \n\t\t\t\tq_c[idxQC + idx + i1] = alpha[idx + i1]*beta[idx + i1]; \n\t\t\t\tq_c_total += q_c[idxQC + idx + i1]; \n\t\t\t}", "pragma": "parallel for reduction(+:q_c_total) private(i2 tmpa tmpb vala valb)", "hash": "067eecace38ecc2a0fb936e5989c75987bf6b6a51d4f4691d5319f492e0fb1b9"}
{"code": "for (m = 1; m <= LOOPCOUNT; m++) { \n        tids2[m-1] = omp_get_thread_num(); \n      }", "pragma": "for ", "hash": "2f7360c8144d823212e054cd3e35709cb092dc6341d5ed0d6057de50e850af21"}
{"code": "for (i = 0; i < system->n; ++i) { \n        type_i = system->my_atoms[i].type; \n        if (type_i < 0) continue; \n        sbp_i = &(system->reax_param.sbp[type_i]); \n \n         \n \n        p_lp2 = sbp_i->p_lp2; \n        expvd2 = exp(-75 * workspace->Delta_lp[i]); \n        inv_expvd2 = 1. / (1. + expvd2); \n \n        numbonds = 0; \n        e_lp = 0.0; \n        for (pj = Start_Index(i, bonds); pj < End_Index(i, bonds); ++pj) \n          numbonds ++; \n \n         \n \n        if (numbonds > 0) \n          total_Elp += e_lp = \n            p_lp2 * workspace->Delta_lp[i] * inv_expvd2; \n \n        dElp = p_lp2 * inv_expvd2 + \n          75 * p_lp2 * workspace->Delta_lp[i] * expvd2 * SQR(inv_expvd2); \n        CElp = dElp * workspace->dDelta_lp[i]; \n \n        if (numbonds > 0) workspace->CdDelta[i] += CElp;   \n \n \n         \n \n        if (system->pair_ptr->eflag_either) \n          pair_reax_ptr->ev_tally_thr_proxy( i, i, system->n, 1, \n                                            e_lp, 0.0, 0.0, 0.0, 0.0, 0.0, thr); \n \n         \n \n        if (p_lp3 > 0.001 && !strcmp(system->reax_param.sbp[type_i].name, \"C\")) \n          for (pj = Start_Index(i, bonds); pj < End_Index(i, bonds); ++pj) { \n            j = bonds->select.bond_list[pj].nbr; \n            type_j = system->my_atoms[j].type; \n            if (type_j < 0) continue; \n \n            if (!strcmp(system->reax_param.sbp[type_j].name, \"C\")) { \n              twbp = &(system->reax_param.tbp[type_i][type_j]); \n              bo_ij = &(bonds->select.bond_list[pj].bo_data); \n              Di = workspace->Delta[i]; \n              vov3 = bo_ij->BO - Di - 0.040*pow(Di, 4.); \n \n              if (vov3 > 3.) { \n                total_Elp += e_lph = p_lp3 * SQR(vov3-3.0); \n \n                deahu2dbo = 2.*p_lp3*(vov3 - 3.); \n                deahu2dsbo = 2.*p_lp3*(vov3 - 3.)*(-1. - 0.16*pow(Di, 3.)); \n \n                bo_ij->Cdbo += deahu2dbo; \n                workspace->CdDelta[i] += deahu2dsbo; \n \n                 \n \n                if (system->pair_ptr->eflag_either) \n                  pair_reax_ptr->ev_tally_thr_proxy( i, j, system->n, 1, \n                                                    e_lph, 0.0, 0.0, 0.0, 0.0, 0.0, thr); \n              } \n            } \n          } \n      }", "pragma": "for ", "hash": "b51d842827ae9fb1e05e83ffd8676d883623da9a4d64e70a1ec780359eb87f85"}
{"code": "for (int ia = 0; ia < unit_cell.num_atoms(); ia++) { \n        for (int i = 1; i < unit_cell.num_nearest_neighbours(ia); i++) { \n            int ja = unit_cell.nearest_neighbour(i, ia).atom_id; \n \n            double d  = unit_cell.nearest_neighbour(i, ia).distance; \n            double d2 = d * d; \n \n            vector3d<double> t = \n                unit_cell.lattice_vectors() * vector3d<int>(unit_cell.nearest_neighbour(i, ia).translation); \n \n            double scalar_part = \n                static_cast<double>(unit_cell.atom(ia).zn() * unit_cell.atom(ja).zn()) / d2 * \n                (std::erfc(std::sqrt(alpha) * d) / d + 2.0 * std::sqrt(alpha * invpi) * std::exp(-d2 * alpha)); \n \n            for (int x : {0, 1, 2}) { \n                forces_ewald_(x, ia) += scalar_part * t[x]; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "472ed99b490c0759fd79b6fc5943e913da7d200373711ff07552aa698d78da5d"}
{"code": "for (int i = 0; i < (int)numParticles; i++) \n\t\t{ \n\t\t\t \n \n\t\t\tconst Vector3r &xi = model->getPosition(i); \n\t\t\tresult[i] = (visco->m_density[i] - model->getMass(i) * sim->W_zero()) * vec[i]; \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tforall_fluid_neighbors_in_same_phase( \n\t\t\t\tresult[i] -= model->getMass(neighborIndex) * sim->W(xi - xj) * vec[neighborIndex]; \n\t\t\t) \n\t\t}", "pragma": "for ", "hash": "21d0590ae720ade94304cafb770ab49fff0fdbab1e7ac9d98f4d18c4db2eec34"}
{"code": "for(int i = 0; i < G->nrows; ++i) if(degree[i] > 0) { \n\t\tlong index = G->vtx_pointer[i]; \n        long rhsOffset = G->vtx_pointer[i + G->nrows] - index; \n\t\tfor(int neighbor: neighbors[i]) if(inGraph.Contains(neighbor)) { \n             \n \n            G->endV[rhsOffset + index] = neighbor; \n\t\t\tG->endV[index++] = neighbor + G->nrows; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "fe10626042814640c0e0066cbed43a5449a4bd7fda903c85d47182802ea06151"}
{"code": "for (size_t nodeCount = 0; nodeCount < octreeNodes.size(); ++nodeCount) { \n\t\tfor (PlanePatches::iterator planes_iter = extractedPlanes.begin(); planes_iter != extractedPlanes.end(); ++planes_iter) { \n\t\t\tif ((*planes_iter)->getPlane3D().checkDistance(octreeNodes[nodeCount]->value_.meanPos, \n\t\t\t\t\t(*planes_iter)->getDistanceThreshold())) \n\t\t\t{ \n\t\t\t\tconst Vec3& nodeCoG = octreeNodes[nodeCount]->value_.meanPos; \n\t\t\t\tif (((*planes_iter)->distanceToOBB(nodeCoG) < std::sqrt((*planes_iter)->getArea()) * mParams.mNodeToBBDistance)) \n\t\t\t\t{ \n\t\t\t\t\tif((*planes_iter)->checkPointConnection(nodeCoG, mParams.mConnectionNeighbors)) \n\t\t\t\t\t{ \n\t\t\t\t\t\tnodeToPlaneCandidates[nodeCount].push_back(*planes_iter); \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "3747907dc64c7e9415934201db79a06cb42bcfe587737a472f68f5dce957f7e0"}
{"code": "for (int y = 1; y < fimSeg.getHeight()-1; y++) { \n\t\tfor (int x = 1; x < fimSeg.getWidth()-1; x++) { \n\t\t\tfloat Ix = fimSeg.get(x+1, y) - fimSeg.get(x-1, y); \n\t\t\tfloat Iy = fimSeg.get(x, y+1) - fimSeg.get(x, y-1); \n \n\t\t\tfloat mag = Ix*Ix + Iy*Iy; \n \n\t\t\tfloat theta = atan2(Iy, Ix); \n \n\t\t\tfimTheta.set(x, y, theta); \n\t\t\tfimMag.set(x, y, mag); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "5f1480dd20d9159c7873cad2198e9cc9dd20b7ce36e6f769375ff4519f8eff18"}
{"code": "for (unsigned int i = 0; i < vf1.size(); ++i) \n                vf1[i] -= vf3[i];", "pragma": "parallel for ", "hash": "82c0cdc0112d20d4f77050ae606301a29d43d0b02cf7f369df779a4ef7bbe98b"}
{"code": "for (i = 0; i < K; i++) \n    { \n        if ((cell_type)EToR[i] == REFINE) \n            continue; \n        int ind = i * Nfp; \n        for (j = 0; j < Nfp; j++) \n        { \n            int iM = (int)eidM[ind] - 1;  \n \n            int iP = (int)eidP[ind] - 1; \n            double f_M = h[iM];  \n \n            double hP = h[iP]; \n            double uM = u[iM], vM = v[iM]; \n \n             \n \n            double nx_ = nx[ind]; \n            double ny_ = ny[ind]; \n \n            double f_ext;  \n \n            f_ext = h_ext[iM]; \n \n            bc_type type = (bc_type)eidtype[ind]; \n             \n \n             \n \n            double f_P; \n            int info = bound_cond(f_M, hP, f_ext, nx_, ny_, type, &f_P); \n             \n \n \n            double numflux, E, G; \n            upwind_flux(f_M, f_P, uM, vM, nx_, ny_, &numflux); \n            nodal_flux(f_M, uM, vM, &E, &G); \n \n            mexPrintf(\"n = %d, k = %d, num_flux = %e, E = %f, G = %f\\n\", \n                      j, i, numflux, E, G); \n            dflux[ind] = -numflux + nx_ * E + ny_ * G; \n            ind++; \n        } \n    }", "pragma": "parallel for private(j)", "hash": "edaf32cc0c9fe7d332283f83d449b655ca8f9f420646eb296df6e62fb599831d"}
{"code": "for(k = 0; k < (int64_t)nInputPlane*kH*kW; k++) { \n    int64_t nip = k / (kH*kW); \n    int64_t rest = k % (kH*kW); \n    int64_t kh = rest / kW; \n    int64_t kw = rest % kW; \n    int x, y; \n    int64_t ix, iy; \n    real *dst = finput_data + nip*((size_t)kH*kW*outputHeight*outputWidth) + kh*((size_t)kW*outputHeight*outputWidth) + kw*((size_t)outputHeight*outputWidth); \n    real *src = input_data + nip*((size_t)inputHeight*inputWidth); \n    if (padW > 0 || padH > 0) { \n      int64_t lpad,rpad; \n      for(y = 0; y < outputHeight; y++) { \n        iy = (int64_t)y*dH - padH + kh; \n        if (iy < 0 || iy >= inputHeight) { \n          memset(dst+(size_t)y*outputWidth, 0, sizeof(real)*outputWidth); \n        } else { \n          if (dW==1){ \n             ix = 0 - padW + kw; \n             lpad = fmaxf(0,padW-kw); \n             rpad = fmaxf(0,padW-(kW-kw-1)); \n             if (outputWidth-rpad-lpad <= 0) { \n                memset(dst+(size_t)y*outputWidth, 0, sizeof(real)*outputWidth); \n             } else { \n                if (lpad > 0) memset(dst+(size_t)y*outputWidth, 0, sizeof(real)*lpad); \n                memcpy(dst+(size_t)y*outputWidth+lpad, src+(size_t)iy*inputWidth+ix+lpad, sizeof(real)*(outputWidth-rpad-lpad)); \n                if (rpad > 0) memset(dst+(size_t)y*outputWidth + outputWidth - rpad, 0, sizeof(real)*rpad); \n             } \n          } \n          else{ \n            for (x=0; x<outputWidth; x++){ \n               ix = (int64_t)x*dW - padW + kw; \n               if (ix < 0 || ix >= inputWidth) \n                 memset(dst+(size_t)y*outputWidth+x, 0, sizeof(real)*1); \n               else \n                 memcpy(dst+(size_t)y*outputWidth+x, src+(size_t)iy*inputWidth+ix, sizeof(real)*(1)); \n            } \n          } \n        } \n      } \n    } else { \n      for(y = 0; y < outputHeight; y++) { \n        iy = (int64_t)y*dH + kh; \n        ix = 0 + kw; \n        if (dW == 1) \n           memcpy(dst+(size_t)y*outputWidth, src+(size_t)iy*inputWidth+ix, sizeof(real)*outputWidth); \n        else{ \n          for (x=0; x<outputWidth; x++) \n             memcpy(dst+(size_t)y*outputWidth+x, src+(size_t)iy*inputWidth+ix+(int64_t)x*dW, sizeof(real)*(1)); \n         } \n      } \n    } \n  }", "pragma": "parallel for private(k)", "hash": "87cfbe578c31bc83a52c5e5a53d1abff787d4137661dc179ba0e9ec330f5b597"}
{"code": "for(i=0; i<100; i++) \n    { \n        s += (i+1); \n        f += (i+1.0f); \n    }", "pragma": "simd for reduction(+:s t) ", "hash": "712e200caf0e19ccf7164414138bf5952d91820e5c7d7dd77dda5676e0964cbc"}
{"code": "for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) || !dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                    d->sub[BL(roi_out, d, j, i + 1)], d->sub[BL(roi_out, d, j, i)]); \n \n      const __m128 div = _mm_set_ps(d->div[BL(roi_out, d, j, i + 3)], d->div[BL(roi_out, d, j, i + 2)], \n                                    d->div[BL(roi_out, d, j, i + 1)], d->div[BL(roi_out, d, j, i)]); \n \n       \n \n      for(; i < roi_out->width - (8 - 1); i += 8, in += 8) \n      { \n        const __m128i input = _mm_load_si128((__m128i *)in); \n \n        __m128i ilo = _mm_unpacklo_epi16(input, _mm_set1_epi16(0)); \n        __m128i ihi = _mm_unpackhi_epi16(input, _mm_set1_epi16(0)); \n \n        __m128 flo = _mm_cvtepi32_ps(ilo); \n        __m128 fhi = _mm_cvtepi32_ps(ihi); \n \n        flo = _mm_div_ps(_mm_sub_ps(flo, sub), div); \n        fhi = _mm_div_ps(_mm_sub_ps(fhi, sub), div); \n \n        _mm_stream_ps(out, flo); \n        out += 4; \n        _mm_stream_ps(out, fhi); \n        out += 4; \n      } \n \n       \n \n      for(; i < roi_out->width; i++, in++, out++) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n      } \n    }", "pragma": "parallel for ", "hash": "706641d7a9eca5542029210bf8ff620bb53e80c848447bf75fe5b954891df1d4"}
{"code": "for (int i=0; i<sizeY; i++) { \n \n        double* temp2 = buffer + omp_get_thread_num()*(buffSizeX+buffSizeY); \n \n        temp2[0] = B*(double)src(i,0,0) + b1*(double)src(i,0,0) + b2*(double)src(i,0,0) + b3*(double)src(i,0,0); \n        temp2[1] = B*(double)src(i,1,0) + b1*temp2[0]  + b2*(double)src(i,0,0) + b3*(double)src(i,0,0); \n        temp2[2] = B*(double)src(i,2,0) + b1*temp2[1]  + b2*temp2[0]  + b3*(double)src(i,0,0); \n \n        for (int j=3; j<buffSizeX; j++) \n            temp2[j] = B*(double)src(i,j,0) + b1*temp2[j-1] + b2*temp2[j-2] + b3*temp2[j-3]; \n \n        double temp2Wm1 = (double)src(i,buffSizeX-1,0) + M[0][0]*(temp2[buffSizeX-1] - (double)src(i,buffSizeX-1,0)) + M[0][1]*(temp2[buffSizeX-2] - (double)src(i,buffSizeX-1,0)) + M[0][2]*(temp2[buffSizeX-3] - (double)src(i,buffSizeX-1,0)); \n        double temp2W   = (double)src(i,buffSizeX-1,0) + M[1][0]*(temp2[buffSizeX-1] - (double)src(i,buffSizeX-1,0)) + M[1][1]*(temp2[buffSizeX-2] - (double)src(i,buffSizeX-1,0)) + M[1][2]*(temp2[buffSizeX-3] - (double)src(i,buffSizeX-1,0)); \n        double temp2Wp1 = (double)src(i,buffSizeX-1,0) + M[2][0]*(temp2[buffSizeX-1] - (double)src(i,buffSizeX-1,0)) + M[2][1]*(temp2[buffSizeX-2] - (double)src(i,buffSizeX-1,0)) + M[2][2]*(temp2[buffSizeX-3] - (double)src(i,buffSizeX-1,0)); \n \n        temp2[buffSizeX-1] = temp2Wm1; \n        temp2[buffSizeX-2] = B * temp2[buffSizeX-2] + b1*temp2[buffSizeX-1] + b2*temp2W + b3*temp2Wp1; \n        temp2[buffSizeX-3] = B * temp2[buffSizeX-3] + b1*temp2[buffSizeX-2] + b2*temp2[buffSizeX-1] + b3*temp2W; \n \n        for (int j=buffSizeX-4; j>=0; j--) \n            temp2[j] = B * temp2[j] + b1*temp2[j+1] + b2*temp2[j+2] + b3*temp2[j+3]; \n        for (int j=0; j<buffSizeX; j++) \n            src(i,j,0) = (double)temp2[j]; \n    }", "pragma": "parallel for ", "hash": "797431de50a778fba609afb3258f98761552902109983fe40f7072d6f0aad367"}
{"code": "for (int i = 0; i < samples.cols(); i++) { \n    frames[i] = \n        calculateFrame(cloud_cam.getNormals(), samples.col(i), radius, kdtree); \n  }", "pragma": "parallel for ", "hash": "8db8c6fec3e86781033ee30c5ba849c17245f5b0e0665e8485b4f9b8a02782ea"}
{"code": "for (size_t i = 0; i < edges.size(); i++) { \n        int u = edges[i].first; \n        int v = edges[i].second; \n \n        if (!binary_search(g.edge_dst + g.node_off[u], g.edge_dst + g.node_off[u + 1], v)) { \n        if (!binary_search(g.edge_dst + g.node_off[u], g.edge_dst + g.node_off[u + 1], v) || \n            !binary_search(g.edge_dst + g.node_off[v], g.edge_dst + g.node_off[v + 1], u)) { \n            is_correct = false; \n            log_info(\"%d, %d\", u, v); \n        } \n    } \n    assert(is_correct); \n    log_info(\"Correct\"); \n \n    fflush(log_f); \n    fclose(log_f); \n}", "pragma": "parallel for ", "hash": "17b52a7979ad96ef2616e2c71f3f85e2d9a78b11f318d33803dd0cfad3b06496"}
{"code": "for (i = 0; i < 5; i++) \n\t{ \n  #pragma patus compute_stencil \n  #pragma omp barrier \n\t}", "pragma": "parallel private(i)", "hash": "6ca859486edfa7058103e7b9d49b0284a70dd4def22e5295f4b78593eed52ea1"}
{"code": "for(long long int i=0; i<size; i++) \n      ptr[i] = filler_val_;", "pragma": "parallel for ", "hash": "a55643071ece0b627a28843857bef0aff47d3b03240406ae03e117bd3e007b33"}
{"code": "for (k=1; k< mNz1; k++) {\r \n        \r \n    buffer *buff = _buff + omp_get_thread_num() * mNmax;\r \n    \r \n    for (j=1; j< mNy1; j++) {\r \n      \r \n      buff[1].Al = 0;\r \n      buff[1].Be = 0;\r \n      \r \n      for (i=1; i< mNx1; i++) {\r \n\t\r \n\tGridPoint* m  = &mpGrid[Index(i,j,k)];\r \n\tGridPoint* mm = &mpGrid[Index(i-1,j,k)];\r \n\tGridPoint* mp = &mpGrid[Index(i+1,j,k)];\r \n                \r \n\tbuff[i].A = H1*(*mm->sigmap + *m->sigmap);\r \n\tbuff[i].B = H1*(*mp->sigmap + *m->sigmap);\r \n                \r \n\tfloat F0 = m->PP*tau +(m->R[1] + m->R[2] +m->source);\r \n\tfloat Zn = 1./(buff[i].A+buff[i].B+ tau - buff[i].Al*buff[i].A);\r \n\tbuff[i+1].Al = buff[i].B*Zn;\r \n\tbuff[i+1].Be = (buff[i].A*buff[i].Be+F0 )*Zn;\r \n      }\r \n            \r \n      mpGrid[Index(mNx1,j,k)].P[0] = 0;\r \n      \r \n      for (i=mNx1-1; i>= 0; i--) {\r \n\tGridPoint* ii = &mpGrid[Index(i,j,k)];\r \n\tGridPoint* ip = &mpGrid[Index(i+1,j,k)];\r \n\tii->P[0] = buff[i+1].Al * ip->P[0] + buff[i+1].Be;\r \n      }\r \n            \r \n      for (i=1; i< mNx1; i++) {\r \n\tGridPoint* m  = &mpGrid[Index(i,j,k)];\r \n\tGridPoint* mm = &mpGrid[Index(i-1,j,k)];\r \n\tGridPoint* mp = &mpGrid[Index(i+1,j,k)];\r \n\tm->R[0] = buff[i].A* mm->P[0] - (buff[i].A+buff[i].B)* m->P[0] + buff[i].B * mp->P[0];\t    \r \n      }\r \n    }\r \n  }", "pragma": "for private(  i j k)", "hash": "21d9beaddd810b9b034fc0234ec4798107241d22403ef06022db3d9342fbeed2"}
{"code": "for ( j=0; j < ny; j++) \n    ecl_grid_init_GRDECL_data_jslice( ecl_grid , zcorn, coord , actnum , corsnum , j );", "pragma": "parallel for ", "hash": "9fca123c40faf12779a3b3e6056ee6aa2b1cdc056d717c9d92159886c5afd998"}
{"code": "for(int k = (int)GetFirstIndex(); k < (int)GetLastIndex(); ++k) \n\t\t{ \n\t\t\tINMOST_DATA_REAL_TYPE norm = 0.0; \n\t\t\tif( p == ENUMUNDEF )  \n \n\t\t\t{ \n\t\t\t\tfor(INMOST_DATA_ENUM_TYPE q = 0; q < jacobian[k].Size(); ++q) \n\t\t\t\t\tif( norm < fabs(jacobian[k].GetValue(q)) ) \n\t\t\t\t\t\tnorm = fabs(jacobian[k].GetValue(q)); \n\t\t\t} \n\t\t\telse  \n \n\t\t\t{ \n\t\t\t\tfor(INMOST_DATA_ENUM_TYPE q = 0; q < jacobian[k].Size(); ++q) \n\t\t\t\t\tnorm += pow(fabs(jacobian[k].GetValue(q)),p); \n\t\t\t\tnorm = pow(norm,1.0/p); \n\t\t\t} \n\t\t\tif( norm ) \n\t\t\t{ \n\t\t\t\tnorm = 1.0/norm; \n\t\t\t\tresidual[k] *= norm; \n\t\t\t\tfor(INMOST_DATA_ENUM_TYPE q = 0; q < jacobian[k].Size(); ++q) \n\t\t\t\t\tjacobian[k].GetValue(q) *= norm; \n\t\t\t\tif( !hessian.Empty() ) \n\t\t\t\t\tfor(INMOST_DATA_ENUM_TYPE q = 0; q < hessian[k].Size(); ++q) \n\t\t\t\t\t\thessian[k].GetValue(q) *= norm; \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "26bbca090329cb332b20143c77ce89031e62c7a6bf82d4d57460a56699b430b6"}
{"code": "for (int i = 0; i < Bank.size(); i++) \n\t\t\t{ \n\t\t\t\tint Guard = 0; \n\t\t\t\twhile (!Bank[i].died && Guard < 1000) \n\t\t\t\t{ \n\t\t\t\t\tFindNucleusGeometry(i); \n\t\t\t\t\tGuard++; \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "df2c3ef272d9c0e5c51112a321d61c2f7185cffaa2a5b1ef63ccdef96fa66e16"}
{"code": "for (y = 0; y < m_height; y++) \n        for (x = 0; x < m_width; x++) { \n            i = x + y * m_width; \n            w = m_wetMap[i]; \n            if (w > 0) { \n                m_wetMap[i]--; \n            } else { \n                m_waterVelocitiesX[i] = 0; \n                m_waterVelocitiesY[i] = 0; \n            } \n        }", "pragma": "for ", "hash": "976a3f7284482824fdca58c2432118b9eb045bfd1d6fe5267dc4d6bb74802bf1"}
{"code": "for(long iter_count = 0 ; iter_count < numofpts ; iter_count++) \n        { \n            long pts_row = floor(iter_count/plevelinfo.Size_Grid2D->width); \n            long pts_col = iter_count % plevelinfo.Size_Grid2D->width; \n            long pt_index = pts_row*(long)plevelinfo.Size_Grid2D->width + pts_col; \n             \n            if(pts_row >= 0 && pts_row < plevelinfo.Size_Grid2D->height && pts_col >= 0 && pts_col < plevelinfo.Size_Grid2D->width && pt_index >= 0 && pt_index < numofpts) \n            { \n                double max_1stroh = -1.0; \n                 \n                int kernel_size = proinfo.SDM_SS; \n                 \n                if(GridPT3[pt_index].ortho_ncc > 0.6) \n                    kernel_size = kernel_size - 1; \n                else if(GridPT3[pt_index].ortho_ncc > 0.2) \n                    kernel_size = proinfo.SDM_SS; \n                else \n                    kernel_size = kernel_size + 1; \n                 \n                if(GridPT3[pt_index].ortho_ncc < 0.8) \n                { \n                    bool check_false_h = false; \n \n                    KernelPatchArg patch{ \n                        rsetkernel, \n                        plevelinfo.py_Sizes[rsetkernel.reference_id][*plevelinfo.Pyramid_step], \n                        plevelinfo.py_Sizes[rsetkernel.ti][*plevelinfo.Pyramid_step], \n                        plevelinfo.py_Images[rsetkernel.reference_id], \n                        plevelinfo.py_MagImages[rsetkernel.reference_id], \n                        plevelinfo.py_Images[rsetkernel.ti], \n                        plevelinfo.py_MagImages[rsetkernel.ti]}; \n \n                    for(int kernel_row = -kernel_size ; kernel_row <= kernel_size ; kernel_row++) \n                    { \n                        for(int kernel_col = -kernel_size ; kernel_col <= kernel_size ; kernel_col++) \n                        { \n                            if(!check_false_h) \n                            { \n                                nccresult[pt_index].result0 = (-1.0); \n                                check_false_h = true; \n                            } \n                            const CSize LImagesize(plevelinfo.py_Sizes[reference_id][Pyramid_step]); \n                            const CSize RImagesize(plevelinfo.py_Sizes[target_id][Pyramid_step]); \n                             \n                            D2DPOINT temp_GP(plevelinfo.GridPts[pt_index]),temp_GP_R(plevelinfo.GridPts[pt_index]); \n                             \n                            D2DPOINT Left_Imagecoord        = GetObjectToImage_single(1,temp_GP,proinfo.LBoundary,proinfo.resolution); \n                            D2DPOINT Right_Imagecoord        = GetObjectToImage_single(1,temp_GP_R,proinfo.RBoundary,proinfo.resolution); \n                             \n                            D2DPOINT Left_Imagecoord_py     = OriginalToPyramid_single(Left_Imagecoord,plevelinfo.py_Startpos[reference_id],Pyramid_step); \n                            D2DPOINT Right_Imagecoord_py    = OriginalToPyramid_single(Right_Imagecoord,plevelinfo.py_Startpos[target_id],Pyramid_step); \n                             \n                            Right_Imagecoord_py.m_Y += (kernel_row + (GridPT3[pt_index].row_shift + Coreg_param[0])/pwrtwo(Pyramid_step)); \n                            Right_Imagecoord_py.m_X += (kernel_col + (GridPT3[pt_index].col_shift + Coreg_param[1])/pwrtwo(Pyramid_step)); \n                             \n                            if( Right_Imagecoord_py.m_Y >= 0 && Right_Imagecoord_py.m_Y < RImagesize.height && Right_Imagecoord_py.m_X >= 0 && Right_Imagecoord_py.m_X < RImagesize.width && Left_Imagecoord_py.m_Y >= 0 && Left_Imagecoord_py.m_Y < LImagesize.height && Left_Imagecoord_py.m_X >= 0 && Left_Imagecoord_py.m_X < LImagesize.width) \n                            { \n                                int Count_N[3] = {0}; \n                                double total_NCC = 0; \n                                double temp_INCC_roh = 0; \n                                 \n                                double im_resolution_mask = (gsd_image1.pro_GSD + gsd_image2.pro_GSD)/2.0; \n                                 \n                                for(int row = -Half_template_size; row <= Half_template_size ; row++) \n                                { \n                                    for(int col = -Half_template_size; col <= Half_template_size ; col++) \n                                    { \n                                        double row_distance = row*im_resolution_mask*pwrtwo(Pyramid_step); \n                                        double col_distance = col*im_resolution_mask*pwrtwo(Pyramid_step); \n                                         \n                                        double row_pixel_left = row_distance/(gsd_image1.row_GSD*pwrtwo(Pyramid_step)); \n                                        double col_pixel_left = col_distance/(gsd_image1.col_GSD*pwrtwo(Pyramid_step)); \n                                         \n                                        double row_pixel_right = row_distance/(gsd_image2.row_GSD*pwrtwo(Pyramid_step)); \n                                        double col_pixel_right = col_distance/(gsd_image2.col_GSD*pwrtwo(Pyramid_step)); \n                                         \n                                        const int radius2  = (row*row + col*col); \n                                        if(radius2 <= (Half_template_size+1)*(Half_template_size+1)) \n                                        { \n                                            D2DPOINT pos_left(Left_Imagecoord_py.m_X + col_pixel_left, Left_Imagecoord_py.m_Y + row_pixel_left); \n                                            D2DPOINT pos_right(Right_Imagecoord_py.m_X + col_pixel_right, Right_Imagecoord_py.m_Y + row_pixel_right); \n                                             \n                                            SetVecKernelValue(patch, row, col, pos_left,pos_right, radius2, Count_N); \n                                        } \n                                    } \n                                } \n                                 \n                                ComputeMultiNCC(rsetkernel, 0, Count_N, total_NCC, temp_INCC_roh); \n                                 \n                                if(max_1stroh < temp_INCC_roh) \n                                { \n                                    max_1stroh = temp_INCC_roh; \n                                    nccresult[pt_index].result0 = max_1stroh; \n                                     \n                                    nccresult[pt_index].result2.m_X = Left_Imagecoord_py.m_X; \n                                    nccresult[pt_index].result2.m_Y = Left_Imagecoord_py.m_Y; \n                                    nccresult[pt_index].result3.m_X = kernel_col + GridPT3[pt_index].col_shift/pwrtwo(Pyramid_step); \n                                    nccresult[pt_index].result3.m_Y = kernel_row + GridPT3[pt_index].row_shift/pwrtwo(Pyramid_step); \n                                } \n                            } \n                        } \n                    } \n                } \n                else \n                { \n                    nccresult[pt_index].result0 = GridPT3[pt_index].ortho_ncc; \n                    nccresult[pt_index].result3.m_X = GridPT3[pt_index].col_shift/pwrtwo(Pyramid_step); \n                    nccresult[pt_index].result3.m_Y = GridPT3[pt_index].row_shift/pwrtwo(Pyramid_step); \n                } \n            } \n        }", "pragma": "for ", "hash": "1ac91bf6b4636140b7013f20415f349d3eb45ebf586ac4d8e98f6ba12bfd2c2a"}
{"code": "for( i = 0 ; i < LVOLUME ; i++ ) { \n    GLU_malloc( (void**)&gauge[i] , ALIGNMENT , NCNC * sizeof( GLU_complex ) ) ; \n    Sunitary_gen( gauge[i] , get_GLU_thread( ) ) ; \n  }", "pragma": "parallel for private(i)", "hash": "7e57f8a24c268dcbb7ec8aaec357b21912bf00ca24fcb7bc9335e63a4371af5b"}
{"code": "for (k = 0; k < M; k++) \n  { \n    int u,o,l; \n    R psij_const[2 * m + 2]; \n    int j = (ths->nfft_flags & NFFT_SORT_NODES) ? ths->index_x[2*k+1] : k; \n \n    nfft_uo(ths, j, &u, &o, 0); \n \n    for (l = 0; l <= 2 * m + 1; l++) \n      psij_const[l] = (PHI(ths->x[j]-((R)((u+l)))/n,0)); \n \n    nfft_adjoint_1d_compute_omp_atomic(ths->f[j], g, psij_const, ths->x + j, n, m); \n    nfft_adjoint_1d_compute_serial(ths->f + j, g, psij_const, ths->x + j, n, m); \n  }", "pragma": "parallel for private(k)", "hash": "6dbb8aee5c5907ea8f3a98bca8a8d1aef5b942442abc2752fe9301dca59b3781"}
{"code": "for (iel = 0; iel < nelt; iel++) { \n    skip[iel] = false; \n  }", "pragma": "parallel for private(iel)", "hash": "3161fc68b90cca9ece338b73abb02bd6e906d4ef1a8dfb6f5e9e983d5775d94d"}
{"code": "for (int i=0; i<mInElementsSize; i++){\r \n     \n \n     \n \n     \n \n     \n \n    mInIJNZ[i*8] /= 10;\r \n    mInIJNZ[i*8] *= 10;\r \n\r \n  }", "pragma": "parallel for ", "hash": "ab921d070c5c2a3e1c9729dbd4e31b272bad9e565eeeeefeb0fab71e3ad37ff9"}
{"code": "for (i3 = 1; i3 < n3-1; i3++) { \n    double (*zi3)[n1] = z[i3]; \n    for (i2 = 1; i2 < n2-1; i2++) { \n      for (i1 = 1; i1 < n1-1; i1++) { \n        if (zi3[i2][i1] > ten[0][1]) { \n          ten[0][1] = zi3[i2][i1]; \n          j1[0][1] = i1; \n          j2[0][1] = i2; \n          j3[0][1] = i3; \n          bubble(ten, j1, j2, j3, mm, 1); \n        } \n        if (zi3[i2][i1] < ten[0][0]) { \n          ten[0][0] = zi3[i2][i1]; \n          j1[0][0] = i1; \n          j2[0][0] = i2; \n          j3[0][0] = i3; \n          bubble(ten, j1, j2, j3, mm, 0); \n        } \n      } \n    } \n  }", "pragma": "for ", "hash": "bf6406f0e2bcdacd974027e4b7d8ae79168a8516ec78ccbac09bd6d6c6a974be"}
{"code": "for(i = 0; i < n; i++) \n    { \n      result = rlcsa.count(rows[i]); \n      occurrences = length(result); \n      #pragma omp critical \n      { \n        if(occurrences <= MAX_OCCURRENCES) { total += occurrences; } \n        else { ignored++; } \n        total_size += rows[i].length(); \n      } \n      if(occurrences <= MAX_OCCURRENCES) \n      { \n        matches = rlcsa.locate(result); \n        delete[] matches; \n      } \n    }", "pragma": "for ", "hash": "191f784b8443206c0abebe07c717eaa71d114c679ecbe830e5e58d1936df10aa"}
{"code": "for (int k=0; k<K; k++) \n   { \n      int proc = omp_get_thread_num(); \n      int m = k2z[k]; \n \n      for (int numSigma=0; numSigma<numSigmas; numSigma++) \n      { \n         double loglikelihood = params[m]->get_params()->data_loglikelihood_marginalized(numSigma); \n         loglikelihoodsArr.reduce_add(proc, numSigma, loglikelihood); \n      } \n   }", "pragma": "parallel for ", "hash": "c19ad9c878dff87fbbd6a5fd0bc8558d02cab27b18426ed5437fe9d248ba45d6"}
{"code": "for (libxsmm_blasint i = 0; i < s; ++i) { \n            const ITYPE *const ai = a + static_cast<size_t>(asize) * helper.shuffle(i); \n            OTYPE *const ci = c + static_cast<size_t>(csize) * i; \n            smm_xsmm_specialized<ITYPE,OTYPE>(xmm, ai, b, ci, \n              LIBXSMM_GEMM_PREFETCH_A(ai + asize), LIBXSMM_GEMM_PREFETCH_B(b), \n              LIBXSMM_GEMM_PREFETCH_C(ci + csize)); \n          }", "pragma": "parallel for ", "hash": "e94f1b3adedb3e1fef39fd287ae47e32ceedadb5b384aac97ba8ab57713d69fc"}
{"code": "for (ie = 0; ie < noe; ie = ie + 1 ) \n    { \n         \n        double gradphi[dim][nln][NumQuadPoints]; \n \n        int d1, d2; \n        for (k = 0; k < nln; k = k + 1 ) \n        { \n            for (q = 0; q < NumQuadPoints; q = q + 1 ) \n            { \n                for (d1 = 0; d1 < dim; d1 = d1 + 1 ) \n                { \n                    gradphi[d1][k][q] = 0; \n                    for (d2 = 0; d2 < dim; d2 = d2 + 1 ) \n                    { \n                        gradphi[d1][k][q] = gradphi[d1][k][q] + INVJAC(ie,d1,d2)*GRADREFPHI(k,q,d2); \n                    } \n                } \n            } \n        } \n         \n          \n \n        double G[dim][dim]; \n        double g[dim]; \n        for (d1 = 0; d1 < dim; d1 = d1 + 1 ) \n        { \n            g[d1] = 0; \n            for (d2 = 0; d2 < dim; d2 = d2 + 1 ) \n            { \n                G[d1][d2] = 0.0; \n                int d3; \n                for (d3 = 0; d3 < dim; d3 = d3 + 1 ) \n                { \n                    G[d1][d2] += INVJAC(ie,d1,d3) * INVJAC(ie,d2,d3); \n                } \n                g[d1] = g[d1] + INVJAC(ie,d1,d2); \n            } \n        } \n         \n        double traceGtG = Mdot(dim, G, G); \n        double tauK[NumQuadPoints]; \n         \n        for (q = 0; q < NumQuadPoints; q = q + 1 ) \n        { \n            double b_hq[dim]; \n            for (d1 = 0; d1 < dim; d1 = d1 + 1 ) \n            { \n                b_hq[d1] = conv_field[ie+(q+d1*NumQuadPoints)*noe]; \n            } \n             \n            double G_U_hq[dim]; \n            MatrixVector(dim, dim, G, b_hq, G_U_hq); \n              \n            tauK[q] = pow( flag_t * 4/(dt*dt) + ScalarProduct(dim, b_hq, G_U_hq) + 9*mu[ie+q*noe]*mu[ie+q*noe]*traceGtG, -0.5); \n        } \n         \n        int iii = 0; \n        int ii = 0; \n        int a, b; \n     \n        double bh_gradPHI[nln][NumQuadPoints]; \n        for (k = 0; k < nln; k = k + 1 ) \n        { \n            for (q = 0; q < NumQuadPoints; q = q + 1 ) \n            { \n                bh_gradPHI[k][q] = 0; \n                for (d1 = 0; d1 < dim; d1 = d1 + 1 ) \n                { \n                    bh_gradPHI[k][q] += conv_field[ie+(q+d1*NumQuadPoints)*noe] * gradphi[d1][k][q]; \n                } \n            } \n        } \n         \n         \n \n        for (a = 0; a < nln; a = a + 1 ) \n        { \n            for (b = 0; b < nln; b = b + 1 ) \n            { \n                double aloc = 0; \n                double mloc = 0; \n                for (q = 0; q < NumQuadPoints; q = q + 1 ) \n                { \n                    aloc +=  (bh_gradPHI[b][q] + si[ie+q*noe] * phi[b+q*nln]) * bh_gradPHI[a][q] * tauK[q] * w[q]; \n                     \n                    mloc +=  phi[b+q*nln] * bh_gradPHI[a][q] * tauK[q] * w[q]; \n                } \n  \n                myArows[ie*nln2+iii] = elements[a+ie*numRowsElements]; \n                myAcols[ie*nln2+iii] = elements[b+ie*numRowsElements]; \n                myAcoef[ie*nln2+iii] = aloc*detjac[ie]; \n                myMcoef[ie*nln2+iii] = mloc*detjac[ie]; \n                 \n                iii = iii + 1; \n            } \n             \n            double floc = 0; \n            for (q = 0; q < NumQuadPoints; q = q + 1 ) \n            { \n                floc += ( bh_gradPHI[a][q] * f[ie+q*noe] * tauK[q] ) * w[q]; \n            } \n            myRrows[ie*nln+ii] = elements[a+ie*numRowsElements]; \n            myRcoef[ie*nln+ii] = floc*detjac[ie]; \n     \n            ii = ii + 1; \n        } \n         \n    }", "pragma": "parallel for private(    gradrefphi ie k l nln nln2 numrowselements phi q w)", "hash": "5db88017b02b46806ffa88741eaee7d54f5326123e689cc94526ea370b3406f2"}
{"code": "for (j = 0; j < k; j++) \n        a[j + 96] = j + 96;", "pragma": "for ", "hash": "770ae308b7986021e05b241b63a9c7335455812ebbe0d22a3a8c62c6c96be4c7"}
{"code": "for(int n = 0; n < N_t; n++) { \n        int last_block=0; \n \n        libxsmm_meltw_unary_param copy_params_1;                        \n \n        libxsmm_meltw_unary_param copy_params_2; \n        libxsmm_meltw_unary_param trans_param_1; \n        libxsmm_meltw_unary_param trans_param_2; \n \n        for(int wb = 0; wb < Win_t - XS_TILE_DBACKWARD + 1; wb += XS_TILE_DBACKWARD) { \n \n            copy_params_1.out.primary = &d_input_a[n*C_t*Win_t + wb];              \n \n            copy_kernel_1(&copy_params_1); \n \n            if (wb >= (WW_t-1)*dial && wb < Win_t - (WW_t-1)*dial - XS_TILE_DBACKWARD){ \n                 \n \n \n                 \n \n                trans_param_1.in.primary  = &grad_a[n*F_t*W_t + 0*W_t + wb - (WW_t-1)*dial]; \n                trans_param_1.out.primary = &grad_a_shortvnni[n*F_t*short_width]; \n                trans_shortvnni_kernel_1( &trans_param_1 ); \n \n                 \n \n                bmmshortkernel(&grad_a_shortvnni[n*F_t*short_width], &flip_weight_a[0], &d_input_a[n*C_t*Win_t + 0*Win_t + wb], &l_br); \n            } \n            else if (wb < (WW_t-1)*dial){ \n                 \n \n \n                 \n \n                trans_param_2.in.primary  = &grad_a_shortpad[n*F_t*2*pad_tile_multiple + wb]; \n                trans_param_2.out.primary = &grad_a_shortvnni[n*F_t*short_width]; \n                trans_shortvnni_kernel_2( &trans_param_2 ); \n \n                 \n \n                bmmshortkernel(&grad_a_shortvnni[n*F_t*short_width], &flip_weight_a[0], &d_input_a[n*C_t*Win_t + 0*Win_t + wb], &l_br); \n            } \n            else{ \n                 \n \n \n                 \n \n                trans_param_2.in.primary  = &grad_a_shortpad[n*F_t*2*pad_tile_multiple + wb - Wpad_t + 2*pad_tile_multiple]; \n                trans_param_2.out.primary = &grad_a_shortvnni[n*F_t*short_width]; \n                trans_shortvnni_kernel_2( &trans_param_2 ); \n \n                 \n \n                bmmshortkernel(&grad_a_shortvnni[n*F_t*short_width], &flip_weight_a[0], &d_input_a[n*C_t*Win_t + 0*Win_t + wb], &l_br); \n            } \n            last_block = wb; \n        } \n \n        if (Win_t % XS_TILE_DBACKWARD != 0){                                 \n \n \n             \n \n \n            copy_params_2.out.primary = &d_input_a[n*C_t*Win_t + last_block + XS_TILE_DBACKWARD];              \n \n            copy_kernel_2(&copy_params_2); \n \n             \n \n            trans_param_2.in.primary  = &grad_a_shortpad[n*F_t*2*pad_tile_multiple + last_block + XS_TILE_DBACKWARD - Wpad_t + 2*pad_tile_multiple]; \n            trans_param_2.out.primary = &grad_a_shortvnni[n*F_t*short_width]; \n            trans_shortvnni_kernel_2( &trans_param_2 ); \n \n             \n \n            bmmshortkernel2(&grad_a_shortvnni[n*F_t*short_width], &flip_weight_a[0], &d_input_a[n*C_t*Win_t + last_block + XS_TILE_DBACKWARD], &l_br); \n        } \n    }", "pragma": "parallel for ", "hash": "f839bd543d5c11c2e3a11e6788f0f99912817692113dadd14c3a13ac8a4d1aa1"}
{"code": "for (j = 0; j < ctx.samples->sample_count; j++) { \n             \n \n \n            VALUE_TYPE dist; \n            uint64_t cluster_id, sample_id; \n            struct sparse_vector bv; \n            bv.nnz = 0; \n            bv.keys = NULL; \n            bv.values = NULL; \n \n            if (omp_get_thread_num() == 0) check_signals(&(prms->stop)); \n \n            if (!prms->stop) { \n                sample_id = j; \n \n                for (cluster_id = 0; cluster_id < ctx.no_clusters; cluster_id++) { \n                     \n \n \n                     \n \n                    if (i != 0 && ctx.cluster_counts[cluster_id] == 0) continue; \n \n                    if (!disable_optimizations) { \n                         \n \n \n                         \n \n                        if (cluster_id == ctx.previous_cluster_assignments[sample_id]) continue; \n \n                         \n \n                        if (eligible_for_cluster_no_change_optimization[sample_id] && ctx.clusters_not_changed[cluster_id]) { \n                             \n \n                            saved_calculations_prev_cluster += 1; \n                            goto end; \n                        } \n \n                         \n \n                        dist = lower_bound_euclid(ctx.vector_lengths_clusters[cluster_id] \n                                                  , ctx.vector_lengths_samples[sample_id]); \n \n                        if (dist >= ctx.cluster_distances[sample_id]) { \n                             \n \n                            saved_calculations_cauchy += 1; \n                            goto end; \n                        } \n                        if (prms->kmeans_algorithm_id == ALGORITHM_BV_KMEANS) { \n                             \n \n                            dist = euclid_vector_list(&block_vectors_samples, sample_id \n                                          , block_vectors_clusters, cluster_id \n                                          , ctx.vector_lengths_samples \n                                          , ctx.vector_lengths_clusters); \n                        } else { \n                            if (bv.keys == NULL) { \n                                create_block_vector_from_csr_matrix_vector(ctx.samples \n                                                                           , sample_id \n                                                                           , keys_per_block \n                                                                           , &bv); \n                            } \n \n                            dist = euclid_vector(bv.keys, bv.values, bv.nnz \n                                                 , block_vectors_clusters[cluster_id].keys \n                                                 , block_vectors_clusters[cluster_id].values \n                                                 , block_vectors_clusters[cluster_id].nnz \n                                                 , ctx.vector_lengths_samples[sample_id] \n                                                 , ctx.vector_lengths_clusters[cluster_id]); \n                        } \n \n                        done_blockvector_calcs += 1; \n \n                        if (dist >= ctx.cluster_distances[sample_id] && fabs(dist - ctx.cluster_distances[sample_id]) >= 1e-6) { \n                             \n \n                            saved_calculations_bv += 1; \n                            goto end; \n                        } \n                    } \n \n                     \n \n                    dist = euclid_vector_list(ctx.samples, sample_id, ctx.cluster_vectors, cluster_id \n                            , ctx.vector_lengths_samples, ctx.vector_lengths_clusters); \n \n                    ctx.done_calculations += 1; \n \n                    if (dist < ctx.cluster_distances[sample_id]) { \n                         \n \n                        ctx.cluster_distances[sample_id] = dist; \n                        ctx.cluster_assignments[sample_id] = cluster_id; \n                    } \n                    end:; \n                } \n            } \n \n            if (!disable_optimizations) { \n                free_null(bv.keys); \n                free_null(bv.values); \n            } \n        }", "pragma": "parallel for ", "hash": "5973acb22b91d195c878ef8dc1bcf1c58547efe4fd8f39915b07d61fe26a844b"}
{"code": "for (unsigned i = 0; i < query.size(); ++i) { \n            auto Q = oracle.query(query[i]); \n            float *gs_dist_row = gs_dist[i]; \n            float *result_dist_row = result_dist[i]; \n            unsigned const *gs_row = gs[i]; \n            unsigned const *result_row = result[i]; \n            for (unsigned k = 0; k < K; ++k) { \n                gs_dist_row[k] = Q(gs_row[k]); \n                result_dist_row[k] = Q(result_row[k]); \n            } \n            sort(gs_dist_row, gs_dist_row + K); \n            sort(result_dist_row, result_dist_row + K); \n        }", "pragma": "parallel for ", "hash": "cab6903c0d83b00f6892dc6c005c6ce8dd6b4c408a739dfe93b0a27e055ae1d3"}
{"code": "for (int y = 0; y < image.height; ++y) { \n      for (int x = 0; x < image.width; ++x) { \n        dvec3 color{}; \n \n         \n \n        for (unsigned int i = 0; i < samples; ++i) { \n          auto ray = camera.generateRay(x, y, image.width, image.height); \n          color = color + trace(ray, depth); \n        } \n         \n \n        color = color / (double) samples; \n        image.setPixel(x, y, (float)color.r, (float)color.g, (float)color.b); \n      } \n    }", "pragma": "parallel for ", "hash": "0b79c2da005d5c269e027ed0106f130063b36b857e1601586ecedf6d379620d7"}
{"code": "for (int bofm = 0; bofm < jcp.oc_block; bofm++) { \n                    PRAGMA_OMP_SIMD() \n                    for (int v = 0; v < simd_w; v++) \n                        diff_bias(ofm1, bofm, v) = 0.0f; \n                }", "pragma": "for ", "hash": "d4280efc40bbbe0dc5e1555d8dee7e2b6effa0c0a18d4fec62a1671dc3563e97"}
{"code": "for(i2=0; i2<n2; i2++)    \t\t \n\tfor(i1=0; i1<n1; i1++)  \n\t{\t \n\t\tif (mask[i1+i2*n1]) drec[i1+n1*i2]=dobs[i1+n1*i2]; \n\t}", "pragma": "parallel for private(i1 i2)", "hash": "c3ad1473804f909c9c3dd87ef3492bc57dbd60a10a1594a4bc2c9910f6ba683d"}
{"code": "for (int i = 0; i < (int) nTrials; ++i) { \n    data->angleEnergy[i] = data->ff.angles->Calc(kind, data->angles[i]); \n \n    double distSq = newMol.AngleDist(anchorBond, bondLength[bType], \n                                     data->angles[i]); \n    nonbonded_1_3[i] = \n      data->calc.IntraEnergy_1_3(distSq, prev, bonded[bType], molIndex); \n \n    data->angleWeights[i] = exp((data->angleEnergy[i] + nonbonded_1_3[i]) \n                                * -data->ff.beta); \n  }", "pragma": "parallel for ", "hash": "f1651d7716972d88a485cb118ebe13aa0e56a7951c27e77401ba6605d5b3c915"}
{"code": "for (int n = 0 ; n < nN ; n++) { \n            for (int j = 0 ; nJ < nJ ; j++) { \n                double low = y(n,j) == 1 ? 0.0 : R_NegInf ; \n                double high = y(n,j) == -1 ? 0.0 : R_PosInf ; \n \n                 \n \n \n \n                double q1 = (vtn1(mu(n, j), 1.0, low, high) + \n                             pow(Eystar(n, j), 2)  \n \n                             ) ; \n \n                 \n \n                double q2_ = arma::as_scalar(Ex.row(n) * \n                                             (Vb2.submat(1, 0, nD + 1, 0) + \n                                              Eb2.submat(j, 1, j, nD).t() * Eb2(j, 0) \n                                              ) \n                                             ) ;  \n \n \n                 \n \n                double q2 = (trace((Vx + Ex.row(n).t() * Ex.row(n)) * \n                                   (Vb2.submat(1, 1, nJ, nJ) + \n                                    Eb2.submat(j, 1, j, nD + 1).t() * Eb2.submat(j, 1, j, nD + 1)) \n                                   ) + \n                             Vb2(0, 0) + pow(Eb2(j, 0), 2) + \n                             2 * q2_ \n                             ) ; \n \n                 \n \n                double q3 = 2 * Eystar(n, j) * mu(n, j) ;  \n \n \n                 \n \n                elpystar += -(1/2) * (q1 + q2 - q3) ; \n            } \n        }", "pragma": "parallel for reduction(+:elpystar) ", "hash": "ecd5dc4eb16422ac8ec5fe27eaabe12da29dce8bd007e0ee745eb9c7260dd9cf"}
{"code": "for (i = pi->samples; i <= 0; i--) { \n         \n \n        x = random_range(1.0); \n        y = random_range(1.0); \n \n        if (sqr(x) + sqr(y) <= 1) { \n            hits++; \n        } \n    }", "pragma": "for ", "hash": "db34f2d1669ae140443fe53fa1afcc37647ba3c759f6a0521e5e5b60e513ee6b"}
{"code": "for( index = 0; index < ca2D->contiguousLinkedList->numberOfThreads; index++ ) \n    { \n        current = contiguousLinkedList->_heads[index]; \n        while( current != NULL ) \n        { \n            c = ca2D->columns * ( current->cell.i ) + current->cell.j; \n            if (M_dest[c] != M_src[c]) \n                M_dest[c] = M_src[c]; \n            current = calGetNextBufferElement2D( contiguousLinkedList, current ); \n        } \n    }", "pragma": "parallel for private(    c ca2d contiguouslinkedlist current)", "hash": "7b9bc7d317baa540c695045d7c836eee7d996da791c667c2980a6a85eb2cf1a2"}
{"code": "for(i=first_weight; i < (int)past_end; i++) \n\t\t\t\t{ \n\t\t\t\t\tfann_type prev_slope, same_sign; \n\t\t    \t\tconst fann_type prev_step = fann_max(prev_steps[i], (fann_type) 0.0001);\t \n \n \n\t\t    \t\tfann_type temp_slopes=0.0; \n\t\t\t\t\tunsigned int k; \n\t\t\t\t\tfann_type *train_slopes; \n\t\t\t\t\tfor(k=0;k<threadnumb;++k) \n\t\t\t\t\t{ \n\t\t\t\t\t\ttrain_slopes=ann_vect[k]->train_slopes; \n\t\t\t\t\t\ttemp_slopes+= train_slopes[i]; \n\t\t\t\t\t\ttrain_slopes[i]=0.0; \n\t\t\t\t\t} \n \n\t\t    \t\tprev_slope = prev_train_slopes[i]; \n \n\t\t    \t\tsame_sign = prev_slope * temp_slopes; \n \n\t\t    \t\tif(same_sign >= 0.0) \n\t\t    \t\t\tnext_step = fann_min(prev_step * increase_factor, delta_max); \n\t\t    \t\telse \n\t\t    \t\t{ \n\t\t    \t\t\tnext_step = fann_max(prev_step * decrease_factor, delta_min); \n\t\t    \t\t\ttemp_slopes = 0; \n\t\t    \t\t} \n \n\t\t    \t\tif(temp_slopes < 0) \n\t\t    \t\t{ \n\t\t    \t\t\tweights[i] -= next_step; \n\t\t    \t\t\tif(weights[i] < -1500) \n\t\t    \t\t\t\tweights[i] = -1500; \n\t\t    \t\t} \n\t\t    \t\telse \n\t\t    \t\t{ \n\t\t    \t\t\tweights[i] += next_step; \n\t\t    \t\t\tif(weights[i] > 1500) \n\t\t    \t\t\t\tweights[i] = 1500; \n\t\t    \t\t} \n \n\t\t    \t\t \n \n\t\t    \t\tprev_steps[i] = next_step; \n\t\t    \t\tprev_train_slopes[i] = temp_slopes; \n \n\t\t\t\t}", "pragma": "for ", "hash": "7046cde193f8996262f140e33ca71c96501eb7b852c928b5a0c1351f635d53b6"}
{"code": "for (n=0; n<N; n++)\r \n    {\r \n        sum0 = 0;\r \n        sum1 = 0;\r \n        for (k=0; k<rsctrellis.numStates; k++)\r \n        {\r \n            sum1 += std::exp(A1[k+n*rsctrellis.numStates]+B1[k+n*rsctrellis.numStates]);\r \n            sum0 += std::exp(A0[k+n*rsctrellis.numStates]+B0[k+n*rsctrellis.numStates]);\r \n        }\r \n        extrinsic_data[n] = std::log(sum1/sum0)-apriori_data[n]; \n \n        extrinsic_coded[2*n] = std::log(sum1/sum0)-Lc1I[n]; \n \n    }", "pragma": "parallel for private(   k n sum0 sum1)", "hash": "3c47d1182060084e23eb4445f6ca13816424dbf4e2d7fb9f2cd1957121db205f"}
{"code": "for (int c = 0; c <= grid.NCM-1; c++) \n\t{ \n\t\tdouble Volume\t= grid.cells.data_ptr[c]->S * (1.0 + flag_axis*(grid.cells.data_ptr[c]->x[1]- 1.0)); \n \n\t\tdouble T_tra\t= Solution.Vc[c][ne+Solution.setup.ID_T[TRA]]; \n\t\tdouble T_rot\t= Solution.Vc[c][ne+Solution.setup.ID_T[ROT]]; \n\t\tdouble T_vib\t= Solution.Vc[c][ne+Solution.setup.ID_T[VIB]]; \n\t\tdouble T_e\t\t= Solution.Vc[c][ne+Solution.setup.ID_T[ELE]]; \n \n\t\tdouble n_mix = 0.0; \n\t\tfor (int s = 0; s <= Solution.setup.NS-1; s++)\tn_mix\t+= Solution.Qc[c][s] / reactions.species_data[s].basic_data.m; \n \n\t\t \n \n\t\tfor (int s = 0; s <= Solution.setup.NS-1; s++) \n\t\t\tfor (int i = 0; i <= Solution.setup.VAR-1; i++) dS_chem_dQ[c][s][i]\t= 0.0; \n \n \n\t\tfor (int k = 0; k <= reactions.NR-1; k++) \n\t\t{ \n\t\t\tdouble Tcf\t= pow(T_tra, reactions.reaction_k[k].temperature_coeff_f[TRA])\t* pow(T_rot, reactions.reaction_k[k].temperature_coeff_f[ROT]) * pow(T_vib, reactions.reaction_k[k].temperature_coeff_f[VIB]) * pow(T_e, reactions.reaction_k[k].temperature_coeff_f[ELE]); \n\t\t\tdouble Tcb\t= pow(T_tra, reactions.reaction_k[k].temperature_coeff_b[TRA])\t* pow(T_rot, reactions.reaction_k[k].temperature_coeff_b[ROT]) * pow(T_vib, reactions.reaction_k[k].temperature_coeff_b[VIB]) * pow(T_e, reactions.reaction_k[k].temperature_coeff_b[ELE]); \n \n\t\t\t \n \n\t\t\tvector <double>\tdTcf_dQ(Solution.setup.VAR, 0.0); \n\t\t\tvector <double>\tdTcb_dQ(Solution.setup.VAR, 0.0); \n \n\t\t\tfor (int i = 0; i <= Solution.setup.VAR-1; i++) \n\t\t\t{ \n\t\t\t\tdTcf_dQ[i]\t= Tcf * (reactions.reaction_k[k].temperature_coeff_f[0]/T_tra*Solution.dT_dQ[c][Solution.setup.ID_T[TRA]][i] \n\t\t\t\t          \t       + reactions.reaction_k[k].temperature_coeff_f[1]/T_rot*Solution.dT_dQ[c][Solution.setup.ID_T[ROT]][i] \n\t\t\t\t\t\t\t\t   + reactions.reaction_k[k].temperature_coeff_f[2]/T_rot*Solution.dT_dQ[c][Solution.setup.ID_T[VIB]][i] \n\t\t\t\t\t\t\t\t   + reactions.reaction_k[k].temperature_coeff_f[3]/T_rot*Solution.dT_dQ[c][Solution.setup.ID_T[ELE]][i]); \n \n\t\t\t\tdTcb_dQ[i]\t= Tcb * (reactions.reaction_k[k].temperature_coeff_b[0]/T_tra*Solution.dT_dQ[c][Solution.setup.ID_T[TRA]][i] \n\t\t\t\t\t\t\t\t   + reactions.reaction_k[k].temperature_coeff_b[1]/T_rot*Solution.dT_dQ[c][Solution.setup.ID_T[ROT]][i] \n\t\t\t\t\t\t\t\t   + reactions.reaction_k[k].temperature_coeff_b[2]/T_rot*Solution.dT_dQ[c][Solution.setup.ID_T[VIB]][i] \n\t\t\t\t\t\t\t\t   + reactions.reaction_k[k].temperature_coeff_b[3]/T_rot*Solution.dT_dQ[c][Solution.setup.ID_T[ELE]][i]); \n \n\t\t\t} \n \n \n\t\t\t \n \n\t\t\tvector <double>\tdkf_dQ(Solution.setup.VAR, 0.0); \n\t\t\tvector <double>\tdkb_dQ(Solution.setup.VAR, 0.0); \n \n\t\t\tdouble dKeq_dT_over_Keq\t= reactions.reaction_k[k].Keq_data.calculate_dKeq_dT_over_Keq(Tcb, n_mix); \n\t\t\tCFD_Calculate_dkf_dQ(kf[c][k], Tcf, reactions.reaction_k[k].kf_coeff[1], reactions.reaction_k[k].kf_coeff[2], dTcf_dQ, Solution.setup.VAR, dkf_dQ); \n\t\t\tCFD_Calculate_dkb_dQ(kb[c][k], Tcb, reactions.reaction_k[k].kf_coeff[1], reactions.reaction_k[k].kf_coeff[2], dKeq_dT_over_Keq, dTcb_dQ, Solution.setup.VAR, dkb_dQ); \n \n\t\t\t \n \n\t\t\tvector <double>\tdRf_dQ(Solution.setup.VAR, 0.0); \n\t\t\tvector <double>\tdRb_dQ(Solution.setup.VAR, 0.0); \n \n\t\t\tCFD_Calculate_dRfb_dQ(kf[c][k], Rf[c][k], dkf_dQ, reactions.reaction_k[k].Reactant_coeff, Solution.Vc[c], Solution.setup.NS, Solution.setup.VAR, dRf_dQ); \n\t\t\tCFD_Calculate_dRfb_dQ(kb[c][k], Rb[c][k], dkb_dQ, reactions.reaction_k[k].Product_coeff,  Solution.Vc[c], Solution.setup.NS, Solution.setup.VAR, dRb_dQ); \n \n \n \n\t\t\tfor (int i = 0; i <= Solution.setup.VAR-1; i++) \n\t\t\t{ \n\t\t\t\tfor (int s = 0; s <= Solution.setup.NS-1; s++) \n\t\t\t\t{ \n\t\t\t\t\tdS_chem_dQ[c][s][i]\t+= Volume * reactions.species_data[s].basic_data.M * (reactions.reaction_k[k].Product_coeff[s] - reactions.reaction_k[k].Reactant_coeff[s]) * (dRf_dQ[i] - dRb_dQ[i]); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "72aeff99c1da04475409eb5b85ed4a5506280e3c1558c08a2a8a56edaf479086"}
{"code": "for(rocsparse_int j = 0; j < batch_count; j++) \n        { \n            T ak_1 = dl[batch_stride * (i + 1) + j]; \n            T bk   = r0[batch_count * i + j]; \n            T bk_1 = r0[batch_count * (i + 1) + j]; \n            T ck   = r1[batch_count * i + j]; \n            T ck_1 = r1[batch_count * (i + 1) + j]; \n \n            T radius = std::sqrt(std::abs(bk * rocsparse_conj(bk) + ak_1 * rocsparse_conj(ak_1))); \n \n             \n \n             \n \n             \n \n            T cos_theta = rocsparse_conj(bk) / radius; \n            T sin_theta = rocsparse_conj(ak_1) / radius; \n \n            r0[batch_count * i + j] = std::fma(bk, cos_theta, ak_1 * sin_theta); \n            r0[batch_count * (i + 1) + j] \n                = std::fma(-ck, rocsparse_conj(sin_theta), bk_1 * rocsparse_conj(cos_theta)); \n            r1[batch_count * i + j]       = std::fma(ck, cos_theta, bk_1 * sin_theta); \n            r1[batch_count * (i + 1) + j] = ck_1 * rocsparse_conj(cos_theta); \n            r2[batch_count * i + j]       = ck_1 * sin_theta; \n \n             \n \n             \n \n             \n \n            T xk                    = x[batch_stride * i + j]; \n            T xk_1                  = x[batch_stride * (i + 1) + j]; \n            x[batch_stride * i + j] = std::fma(xk, cos_theta, xk_1 * sin_theta); \n            x[batch_stride * (i + 1) + j] \n                = std::fma(-xk, rocsparse_conj(sin_theta), xk_1 * rocsparse_conj(cos_theta)); \n        }", "pragma": "parallel for ", "hash": "f936aef2e7097531a20c0dbd3894022c90b3f5d069693902b9f24897bde57469"}
{"code": "for (unsigned y=0; y<h; y++) { \n\t\tfor (unsigned x=0; x<w; x++) { \n\t\t\tunsigned spos = x + y*w; \n\t\t\t \n \n\t\t\tunsigned dpos = (dw-y-1) + x * dw; \n\t\t\timage[dpos] = src[spos]; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "68e5ab5525a588243db541d3ac61f5d7db50df8637644f4282d2ef841615eac5"}
{"code": "for (int i = 0; i < 10; ++i) { \n        s_a = s_b[0] = s_c[0]; \n        p_a = p_b[0] = p_c[0]; \n        fp_a = fp_b[0] = fp_c[0]; \n        l_a = l_b[0] = l_c[0]; \n        flp_a = flp_b[0] = flp_c[0]; \n    }", "pragma": "for private(            flp_a flp_a flp_b flp_b flp_c flp_c fp_a fp_b fp_c l_a l_b l_c p_a p_b p_c)", "hash": "616b447460a1ad4aa265b0a7ae35beba5e7319ebe3908f70961d54968358ab1d"}
{"code": "for (int i = 0; i < (width * height); i++) { \n    valid_mask_[i] = ((depth[i] > min_depth) && (depth[i] < max_depth)) ? \n                     true : false; \n  }", "pragma": "parallel for ", "hash": "c83f01ca71f41f58c35e44875da60f4791af2abc0ea2124aec8b20a6769c3a44"}
{"code": "for (int init = 0; init < omp_get_max_threads(); ++init) { \n        vol[init].resize(sx * sy * sz * (is_vector ? 3 : 1)); \n        std::fill(vol[init].begin(), vol[init].end(), 0.0f); \n \n        weights[init].resize(sx * sy * sz); \n        std::fill(weights[init].begin(), weights[init].end(), 0.0f); \n    }", "pragma": "parallel for ", "hash": "332f6e09d730a17e269100ed60a28a8fd8db88748dcde323fba31b1548a378c4"}
{"code": "for (cl = 0; cl < ncluster; cl++){ \n        if (!ayb->notthinned[cl]) { continue; } \n        th_id = omp_get_thread_num(); \n \n        cl_bases = ayb->bases.elt + cl * ayb->ncycle; \n        cl_quals = ayb->quals.elt + cl * ayb->ncycle; \n        pcl_int[th_id] = processNew(AtLU, ayb->N, nodearry[cl]->elt->signals, pcl_int[th_id]); \n        if (NULL == pcl_int[th_id]) { \n            ret = false; \n        } \n        else { \n \n    if (showdebug) { \n        if (!xfisnull(fpout)) { \n            xfprintf(fpout, \"cluster: %u\\n\", cl + 1); \n            show_MAT(fpout, pcl_int[th_id], pcl_int[th_id]->nrow, pcl_int[th_id]->ncol); \n        } \n    } \n \n             \n \n            count = 0; \n            for ( cy = 0; cy < ayb->ncycle; cy++){ \n \n                 \n \n                if (!ayb->spiked[cl]) { \n                    cl_bases[cy] = call_base_simple(pcl_int[th_id]->x + cy * NBASE); \n                     \n \n                    if (nodata(nodearry[cl]->elt->signals->xint + cy * NBASE, NBASE)) { \n                        count++; \n                    } \n                } \n                cl_quals[cy] = MIN_PHRED; \n            } \n             \n \n \n \n            ayb->lambda->x[cl] = estimate_lambda_A (nodearry[cl]->elt->signals, ayb->N, ayb->At, cl_bases); \n \n             \n \n            store_cluster_error(ayb, pcl_int[th_id], cl); \n            if (count >= ZeroThin) { \n                 \n \n                ayb->notthinned[cl] = false; \n            } \n        } \n    }", "pragma": "parallel for private(     cl cl_bases cl_quals count cy th_id)", "hash": "deec7a57f09a9cfeed56cc5de4c7a07252d07e7b513de74f28d9889ef0f4c185"}
{"code": "for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    MagickBooleanType \n      sync; \n \n    MagickPixelPacket \n      channel_bias, \n      channel_sum; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p, \n      *restrict r; \n \n    register IndexPacket \n      *restrict threshold_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    ssize_t \n      u, \n      v; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t) \n      height/2L,image->columns+width,height,exception); \n    q=GetCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,1, \n      exception); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(image_view); \n    threshold_indexes=GetCacheViewAuthenticIndexQueue(threshold_view); \n    channel_bias=zero; \n    channel_sum=zero; \n    r=p; \n    for (v=0; v < (ssize_t) height; v++) \n    { \n      for (u=0; u < (ssize_t) width; u++) \n      { \n        if (u == (ssize_t) (width-1)) \n          { \n            channel_bias.red+=r[u].red; \n            channel_bias.green+=r[u].green; \n            channel_bias.blue+=r[u].blue; \n            channel_bias.opacity+=r[u].opacity; \n            if (image->colorspace == CMYKColorspace) \n              channel_bias.index=(MagickRealType) \n                GetPixelIndex(indexes+(r-p)+u); \n          } \n        channel_sum.red+=r[u].red; \n        channel_sum.green+=r[u].green; \n        channel_sum.blue+=r[u].blue; \n        channel_sum.opacity+=r[u].opacity; \n        if (image->colorspace == CMYKColorspace) \n          channel_sum.index=(MagickRealType) GetPixelIndex(indexes+(r-p)+u); \n      } \n      r+=image->columns+width; \n    } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      MagickPixelPacket \n        mean; \n \n      mean=zero; \n      r=p; \n      channel_sum.red-=channel_bias.red; \n      channel_sum.green-=channel_bias.green; \n      channel_sum.blue-=channel_bias.blue; \n      channel_sum.opacity-=channel_bias.opacity; \n      channel_sum.index-=channel_bias.index; \n      channel_bias=zero; \n      for (v=0; v < (ssize_t) height; v++) \n      { \n        channel_bias.red+=r[0].red; \n        channel_bias.green+=r[0].green; \n        channel_bias.blue+=r[0].blue; \n        channel_bias.opacity+=r[0].opacity; \n        if (image->colorspace == CMYKColorspace) \n          channel_bias.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+0); \n        channel_sum.red+=r[width-1].red; \n        channel_sum.green+=r[width-1].green; \n        channel_sum.blue+=r[width-1].blue; \n        channel_sum.opacity+=r[width-1].opacity; \n        if (image->colorspace == CMYKColorspace) \n          channel_sum.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+ \n            width-1); \n        r+=image->columns+width; \n      } \n      mean.red=(MagickRealType) (channel_sum.red/number_pixels+offset); \n      mean.green=(MagickRealType) (channel_sum.green/number_pixels+offset); \n      mean.blue=(MagickRealType) (channel_sum.blue/number_pixels+offset); \n      mean.opacity=(MagickRealType) (channel_sum.opacity/number_pixels+offset); \n      if (image->colorspace == CMYKColorspace) \n        mean.index=(MagickRealType) (channel_sum.index/number_pixels+offset); \n      SetPixelRed(q,((MagickRealType) GetPixelRed(q) <= mean.red) ? \n        0 : QuantumRange); \n      SetPixelGreen(q,((MagickRealType) GetPixelGreen(q) <= mean.green) ? \n        0 : QuantumRange); \n      SetPixelBlue(q,((MagickRealType) GetPixelBlue(q) <= mean.blue) ? \n        0 : QuantumRange); \n      SetPixelOpacity(q,((MagickRealType) GetPixelOpacity(q) <= mean.opacity) ? \n        0 : QuantumRange); \n      if (image->colorspace == CMYKColorspace) \n        SetPixelIndex(threshold_indexes+x,(((MagickRealType) GetPixelIndex( \n          threshold_indexes+x) <= mean.index) ? 0 : QuantumRange)); \n      p++; \n      q++; \n    } \n    sync=SyncCacheViewAuthenticPixels(threshold_view,exception); \n    if (sync == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor != (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_AdaptiveThresholdImage) \n        proceed=SetImageProgress(image,ThresholdImageTag,progress++, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  }", "pragma": "parallel for ", "hash": "7752f5a8d685dd15fe5440d8d272c065961485c0254f35c7958a0e98077ffe24"}
{"code": "for( int i = 0; i < kpts.size(); i++ ) \n                { \n                    kpts[i].angle = 0.0; \n                    Get_SURF_Upright_Descriptor_128(kpts[i]); \n                }", "pragma": "parallel for ", "hash": "ad62ba055fbf7ff4bcf07aca33e8458a53444a83818b7c860912efb726db4790"}
{"code": "for (i = a; i < b; i += c) \n    for (j = d * i + e; j < g + i * f; j += h) \n      { \n\tif (i != 4 || j < -41 || j > -11 || k[0][-j] != 2) \n\t  abort (); \n\tk[0][-j]++; \n\tx = i * 1024 + (j & 1023); \n\tniters++; \n      }", "pragma": "parallel for reduction(+:niters) private(  i j x)", "hash": "0e008d8f80324dcd56ca3941e82b119221278ce05e0363a340cc9c95640220e1"}
{"code": "for (int i = 0; i < (int) numParticles; i++) \n\t\t{ \n\t\t\tVector3r &pos = m_model->getPosition(0, i); \n\t\t\tVector3r &vel = m_model->getVelocity(0, i); \n\t\t\tvel += m_simulationData.getPressureAccel(i) * h; \n\t\t\tpos += vel * h; \n\t\t}", "pragma": "for ", "hash": "3ce418cb47217bf671579cecad0b7ab6b1e3fa263679a9bf937b5f7ecac45fb1"}
{"code": "for(int64_t i = 0 ; i < world::size(); ++i) { \n   if(creatures_[i].is_alive()) te += creatures_[i].get_energy() ; \n}", "pragma": "parallel for reduction(+:te) ", "hash": "68cad0a00d4b365028623d460e1270934d75f5701c525a64a5d9c633249f5457"}
{"code": "for (k=0; k<N; k++) { \n          zd[k] += c[i] * xd[k]; \n        }", "pragma": "for ", "hash": "0bb26ad883974ea265fb0a1494e21c87c6b97f319879c98bceb9aa52b288d4b6"}
{"code": "for(long k=0;k<nz;k++)\tfor(long j=0;j<ny;j++)\tfor(long i=0;i<nx;i++)\r \n\t\t\td->a[i+nx*(j+ny*k)] /= v;", "pragma": "parallel for ", "hash": "8b1b6dba2f22b3e9912fd79ba00efd9e1be3b560c8cc8199770894bb3b6a4ce0"}
{"code": "for (int i=0; i<fit->ndata; i++) { \n      vecs[0][i]=1; \n      for (int j=1;j<fit->np_poly;j++) \n        vecs[j][i]=vecs[j-1][i]*ivec[i]; \n    }", "pragma": "parallel for ", "hash": "319878dc39c8ef98f64488bde67bab927bb1006a7347e55818fb998fe277e4ad"}
{"code": "for (j = 0; j < img_h; j++) \n        secure_free(imageNG[j]);", "pragma": "parallel for ", "hash": "c9fcfb16363a76a1629fa85e9cc0f56b36aaa1c02ba01cd5f009d9cce88eb61e"}
{"code": "for (unsigned int i = 0; i < surfels.size(); i++) \n  { \n    if (!useSurfel[i]) \n      continue; \n \n    if (checkNormal && surfels[i].normal.z() > 0) \n      continue; \n \n    std::vector<std::pair<int, int> > area = projectSurfelArea(surfels[i].location, surfels[i].radius, camParams); \n    for (unsigned int j = 0; j < area.size(); j++) \n    { \n      int pixel = area[j].first + area[j].second * camParams.xRes; \n#pragma omp critical \n      { \n      resultMap[pixel].push_back(i); \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "6c3fda69923a2d1c3c4efbbabb15a954ffe42a4e7c563529d0acf0eac4a76ba9"}
{"code": "for(    ix=0; ix<nx; ix++) { \n\t\t\tfor(iz=0; iz<nz; iz++) {     \n\t\t\t    ii[ix][iz] += us[ib][ix][iz] \n\t\t\t\t*         ur[ib][ix][iz]; \n\t\t\t}  \n \n\t\t    }", "pragma": "parallel for private(ix iz)", "hash": "581fadeb6bc72605cba2de9eca197d6d70681ac1b8431578c9c12d9b8394b4f0"}
{"code": "for (j=0; j < numColumnsPred; j++) { \n\t\tfor (k=0; k < numBounds-1; k++) { \n\t\t\tidxA = colA[j]+k*numColumnsShape; idxB = colB[j]+k*numColumnsShape; \n\t\t\tmuMean = (float) (colAFac[j]*mu[idxA+numColumnsShape] + colBFac[j]*mu[idxB+numColumnsShape]); \n\t\t\tfactor1 = (float) (colAFac[j]*prec[idxA] + colBFac[j]*prec[idxB]); \n\t\t\tfactor2 = (float) (colAFac[j]*mu[idxA]*prec[idxA] + colBFac[j]*mu[idxB]*prec[idxB]); \n\t\t\tidx = (k*numColumnsPred + j)*numRows; \n\t\t\tfor (i=boundsPred[j*2]; i <= boundsPred[j*2+1]; i++) { \n\t\t\t\tmu_a_b2[idx + i] = muMean - (factor1*(i+1) - factor2); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(factor1 factor2 i idx idxa idxb k mumean)", "hash": "137dab4d76e00567df60479f34b3940a0283fd171d7d958e776f5ac2b77c2db8"}
{"code": "for(rowcol=0;rowcol<N;rowcol++){ \n\t\tif(mat2[rowcol]==-28768||mat8[rowcol]==28768|| \n\t\t  mat17[rowcol]==-28768||isnan(mat17[rowcol])|| \n\t\t  mat16[rowcol]==-28768||isnan(mat16[rowcol])){ \n\t\t\t \n \n\t\t} else { \n\t\t\ttempk = mat8[rowcol] * 0.02; \n\t\t\tRn = mat16[rowcol]; \n\t\t\tg0 = mat17[rowcol]; \n\t\t\talbedo = mat2[rowcol]*0.001; \n\t\t\tdem = mat14[rowcol]; \n\t\t\th0=Rn-g0; \n\t\t\tt0dem = tempk + 0.00627 * dem; \n\t\t\tif(t0dem<t0dem_min&&albedo<0.15&& \n\t\t\t  t0dem>274.0&&Rn>10.0&&g0>1.0){ \n\t\t\t\tt0dem_min=t0dem; \n\t\t\t\tt0dem_wet=t0dem; \n\t\t\t\ttempk_min=tempk; \n\t\t\t\ttempk_wet=tempk; \n\t\t\t\tRn_wet=Rn; \n\t\t\t\tg0_wet=g0; \n\t\t\t\trowcol_wet=rowcol; \n\t\t\t} \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\t\t\tif(t0dem>t0dem_max&&h0>h0_max&&t0dem>t0dem_min+1.0&&Rn>0.0){ \n\t\t\t\tt0dem_max=t0dem; \n\t\t\t\tt0dem_dry=t0dem; \n\t\t\t\ttempk_max=tempk; \n\t\t\t\ttempk_dry=tempk; \n\t\t\t\tRn_dry=Rn; \n\t\t\t\tg0_dry=g0; \n\t\t\t\tdem_dry=dem; \n\t\t\t\trowcol_dry=rowcol; \n\t\t\t} \n\t\t\tif(tempk>=(float)i_peak3-0.0&&tempk<(float)i_peak3+7.0&& \n\t\t\th0>10.0&&h0>h0_max&&g0>1.0&&Rn>0.0&&albedo>0.5*albedo_max){ \n\t\t\t\ttempk_max=tempk; \n\t\t\t\ttempk_dry=tempk; \n\t\t\t\tt0dem_max=t0dem; \n\t\t\t\tt0dem_dry=t0dem; \n\t\t\t\tRn_dry=Rn; \n\t\t\t\tg0_dry=g0; \n\t\t\t\th0_max=h0; \n\t\t\t\tdem_dry=dem; \n\t\t\t\trowcol_dry=rowcol; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(       albedo dem g0 h0 rn rowcol t0dem tempk)", "hash": "f1a905ed75c55d650f5024fba84703d1befa00cb0a8114ba74be3049729269fe"}
{"code": "for (i=0; i < (long) image->colors; i++) \n    { \n       \n \n      if ((channel & RedChannel) != 0) \n        image->colormap[i].red=LevelizeValue(image->colormap[i].red); \n      if ((channel & GreenChannel) != 0) \n        image->colormap[i].green=LevelizeValue(image->colormap[i].green); \n      if ((channel & BlueChannel) != 0) \n        image->colormap[i].blue=LevelizeValue(image->colormap[i].blue); \n      if ((channel & OpacityChannel) != 0) \n        image->colormap[i].opacity=LevelizeValue(image->colormap[i].opacity); \n    }", "pragma": "parallel for ", "hash": "91c19e86b887d985b1b17ff40ab9b04bf86d0a93288bfc321ae958a37a1b1cd5"}
{"code": "for (int i = 0; i < num_verts; ++i) \n    if (has_vwgts) \n      part_sizes_thread[parts[i]] += g.vertex_weights[i]; \n    else  \n      ++part_sizes_thread[parts[i]];", "pragma": "for ", "hash": "3fa69026b1aa1a9c8acd4c0845cf944f3f0eb39f13c9c001e0254ae0349fead4"}
{"code": "for (int iq = 0; iq < nq(); iq++) { \n            jl(iq) = Spherical_Bessel_functions(atom_type.lmax_ps_atomic_wf(), atom_type.radial_grid(), grid_q_[iq]); \n        }", "pragma": "parallel for ", "hash": "9d2433b0244791e98ab726fedf2945260ad578a962b3ddb251b96bdd0ef12dc6"}
{"code": "for(int j=0; j<sdirections.size(); j++){ \n            float A_0, theta_max; \n            A_0 = 0.0; \n            std::vector< std::pair<float, float> > ADAs_As; \n            std::vector<float> theta_cr, A_theta_cr, Big_Y, Big_X; \n            for(int k=0; k<dataLibrary::Fracture_Triangles[i]->polygons.size(); k++) \n            { \n                pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_polygon(new pcl::PointCloud<pcl::PointXYZ>); \n                for(int r=0; r<dataLibrary::Fracture_Triangles[i]->polygons[k].vertices.size(); r++) \n                { \n                    cloud_polygon->push_back(cloud_ptr->at(dataLibrary::Fracture_Triangles[i]->polygons[k].vertices[r])); \n                } \n                float apparentDA = ApparentDipAngle(*cloud_polygon, plane_normal, sdirections[j]); \n                if(apparentDA>0) \n                { \n                    Eigen::Vector3f trinormal = PolygonNormal(*cloud_polygon); \n                    float temp_area = PolygonArea(*cloud_polygon, trinormal); \n                    ADAs_As.push_back(make_pair(apparentDA, temp_area)); \n                    A_0 += temp_area; \n                } \n            } \n            std::sort(ADAs_As.begin(), ADAs_As.end()); \n            theta_max = ADAs_As.back().first; \n            float temp_cr[18] = {0.0, 1.2, 2.5, 3.9, 5.32, 6.82, 8.41, 10.0, 12.5, 15.0, 17.5, 20.0, 23.0, 26.3, 30.0, 34.0, 40.0, 50.0}; \n            for(int k=0; k<18; k++) \n            { \n                if((temp_cr[k]/360*TWOPI)<theta_max) \n                    theta_cr.push_back(temp_cr[k]/360*TWOPI); \n            } \n            float sum_X = 0.0; \n            float sum_Y = 0.0; \n            for(int k=0; k<theta_cr.size(); k++) \n            { \n                float temp_X = log((theta_max-theta_cr[k])/theta_max); \n                Big_X.push_back(temp_X); \n                sum_X += temp_X; \n                float temp_A_theta_cr = 0.0; \n                int r=ADAs_As.size()-1; \n                while((r>=0)&&(ADAs_As[r].first>=theta_cr[k])) \n                { \n                    temp_A_theta_cr += ADAs_As[r].second; \n                    r--; \n                } \n                A_theta_cr.push_back(temp_A_theta_cr); \n                float temp_Y = log(temp_A_theta_cr); \n                Big_Y.push_back(temp_Y); \n                sum_Y += temp_Y; \n            } \n            float mean_X = sum_X/Big_X.size(); \n            float mean_Y = sum_Y/Big_Y.size(); \n            float S_xy = 0.0; \n            float S_x = 0.0; \n            for(int k=0; k<Big_X.size(); k++) \n            { \n                S_x += (Big_X[k] - mean_X)*(Big_X[k] - mean_X); \n                S_xy += (Big_X[k] - mean_X)*(Big_Y[k] - mean_Y); \n            } \n            float SP = (theta_max*S_x/S_xy)*360/TWOPI; \n            float reci_big_c = S_x/S_xy; \n            SP_arr[j] = SP; \n            reci_big_c_arr[j] = reci_big_c; \n            theta_max_arr[j] = theta_max; \n        }", "pragma": "parallel for ", "hash": "45bfe28128881fe54d8fc547fbe558de2d6109974f42d8a5bfa270a644f0015b"}
{"code": "for ( int j = 0; j < weight.cols(); ++j ) \n    { \n        poseDQ[j] = DualQuaternion( pose[j] ); \n    }", "pragma": "parallel for ", "hash": "6229482319a9b4202b7020f84ab159157dc4d0369732b897de402ca412f8d0c2"}
{"code": "for(i = 0; i < 4; ++i) \n\t{ \n\t\tuint64_t byt; \n \n\t\tbyt = i * BLKSZ; \n\t\trv[i] |= Keccak_Init(&ctx[i], 512); \n\t\twhile (byt < _bytes) { \n\t\t\trv[i] |= Keccak_Update(&ctx[i], buf + byt, BLKSZ * 8); \n\t\t\tbyt += 4 * BLKSZ; \n\t\t} \n\t\tif (i>0) \n\t\t\trv[i] |= Keccak_Final(&ctx[i], cksum[i]); \n\t}", "pragma": "parallel for ", "hash": "d5e0ef0095c44c53a938d55fadc1de49f23291e133f5af2649a38ac339109e76"}
{"code": "for( int j = 1; j < n-1; j++) \n          { \n              for( int i = 1; i < m-1; i++ ) \n              { \n                  A[j][i] = Anew[j][i];     \n              } \n          }", "pragma": "parallel for ", "hash": "901b32a900008d87b40443c89bbf2083b7734e56535f446a4deaa2c31dc69026"}
{"code": "for (long j = 1; j < ny - 1; ++j) {\r \n\t\t\tfor (long i = 1; i < nx - 1; ++i) {\r \n\t\t\t\tb(i, j) = (1 / dt)*((f(i + 1, j) - f(i, j))/dx + (g(i, j + 1) - g(i, j))/dy);\r \n\t\t\t}\r \n\t\t}", "pragma": "parallel ", "hash": "c9e8d0ea1bba286b9e9b4642e5167298548a4ba597e718714e80ea2e79838078"}
{"code": "for (jj = 0; jj < nn; jj++) { \n        ii = ilist[jj]; \n        if (atom->mask[ii] & groupbit) { \n          int indxI = 2 * ii; \n          tmp1 += d[indxI  ] * q[indxI  ]; \n          tmp2 += d[indxI+1] * q[indxI+1]; \n        } \n      }", "pragma": "for reduction(+:tmp1 tmp2) private(ii)", "hash": "f93181285a324696e55f76a5a1079647739c2760c78d3081b239d0e7ca8f8a78"}
{"code": "for (j = 0; j < NX; j++) \n    for (i = 0; i < NX; i++) \n    aa[j][i] = 2.0E0 * aa[j][i];", "pragma": "parallel for ", "hash": "c35f5412dfbee9d9299cda26ac7d1ef453f80165a8bccd252438d4f33be355b7"}
{"code": "for(int k=0;k<NumDown;k++) \n        { \n             \n \n            y[i*NumDown+k] = alpha*y[i*NumDown+k] + U * CountBits(baseUp[i] & baseDown[k]) * x[i*NumDown+k]; \n \n             \n \n            for(unsigned int l=Down_row[k];l<Down_row[k+1];l++) \n                y[i*NumDown+k] += Down_data_CSR[l] * x[i*NumDown + Down_col[l]]; \n        }", "pragma": "parallel for ", "hash": "2dfb90d7ad1e1d5209434717744af22ea48c061f233e75eda049382fdffb476d"}
{"code": "for (int share = 0; share < num_shares; share++) { \n\t\t\t\t\tfor (int k = (share_workload*share)/4; k < (share_workload*(share+1))/4 && k < throughput/4; k++) { \n\t\t\t\t\t\tfor (int l = 0; l < 8; l++) \n\t\t\t\t\t\t\ttstatex4[nxt][k * 8 + l] = uint32x4_t(midstate[l]); \n\t\t\t\t\t\t\tHMAC_SHA256_80_initx4(&datax4[nxt][k * 20], &tstatex4[nxt][k * 8], &ostatex4[nxt][k * 8]); \n\t\t\t\t\t\t\tPBKDF2_SHA256_80_128x4(&tstatex4[nxt][k * 8], &ostatex4[nxt][k * 8], &datax4[nxt][k * 20], &Xx4[nxt][k * 32]); \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "parallel for ", "hash": "1e2691f264a212f08c78b9b158d59be72f8082c4854589135660a8aa2233899c"}
{"code": "for(int i=0;i<x_vec.size();i++){ \n\t            const double a = x_vec[i] - mn; \n\t            const double b = mx - x_vec[i]; \n\t            double scaledX = (0.5 * ( a - b))/(a + b); \n\t            x_vec[i] = scaledX; \n\t        }", "pragma": "for ", "hash": "e8890f7680e6e7e57dd4ce3079a11912d9d6425de709c20ee6359c9728e265fe"}
{"code": "for(int i1 = 0; i1 < img2.height; i1++) \n      { \n        memcpy(img2_bak.data, img2.data + (size_t)i1 * img2.width, sizeof(float) * img2.width); \n        box_max_1d(img2.width, img2_bak.data, img2.data + (size_t)i1 * img2.width, 1, w); \n      }", "pragma": "for ", "hash": "b85cb8b267606beea2c7e9efc85cd38cebe319afe392ac1e275154925adb459b"}
{"code": "for (uint64_t i = 0; i < nstates; i++) { \n        c[i] = 1.0 / sqrt((double) nstates); \n        q[i] = 0; \n    }", "pragma": "parallel for ", "hash": "f37ed07f24a495a60d45a521c98c18e4a6707c917794cb28ac13170902854335"}
{"code": "for (unsigned long long it = 2000; it >= 600; it-=400) { \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    *g_ptr++ = 0.0; \n \n \n \n \n    a[it + lin]++; \n \n \n \n \n \n \n \n \n \n \n  }", "pragma": "parallel for simd ", "hash": "77acf50c9e0290832fae3595b4c3269baaba9ff9a7d081e810257c6181538fb6"}
{"code": "for(int i=0;i<mesh.numTet;i++){\r \n            AR[i] = AR[i].exp();\r \n            AS[i] = Matrix3d::Identity();\r \n        }", "pragma": "parallel ", "hash": "5fb9b932909bc55b340e79c9a1e928426e5de78879ea37b0ac99bfe8a4be79a2"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp target exit data map(from: a)  \n \n    ++a; \n  }", "pragma": "for simd ", "hash": "5dd9b352543ccb598d5c39d278620667000a1c52c1ec98d340a1e64494abd0d6"}
{"code": "for (size_t i=0; i < x.size(); i++) { \n        result[i] = Median(x[i]); \n    }", "pragma": "parallel for ", "hash": "cbb703201a56366937ebb5f90b8f7d8b2c6c4c6f2601d397ad35cc445d51b9c1"}
{"code": "for (size_t l3_x = 0; l3_x < X_size; l3_x += L3_X) { \n      for (size_t l3_y = 0; l3_y < Y_size; l3_y += L3_Y) { \n        for (size_t l3_k = 0; l3_k < K_size; l3_k += L3_K_STEP) { \n           \n \n          for (size_t l2_x = l3_x; l2_x < l3_x + L3_X; l2_x += L2_X) { \n            for (size_t l2_y = l3_y; l2_y < l3_y + L3_Y; l2_y += L2_Y) { \n              for (size_t l2_k = l3_k; l2_k < l3_k + L3_K_STEP; \n                   l2_k += L2_K_STEP) { \n                 \n \n                for (size_t l1_x = l2_x; l1_x < l2_x + L2_X; l1_x += L1_X) { \n                  size_t l1_block_x = l1_x / L1_X; \n                  for (size_t l1_y = l2_y; l1_y < l2_y + L2_Y; l1_y += L1_Y) { \n                    size_t l1_block_y = l1_y / L1_Y; \n                    size_t C_base_index = \n                        (L1_X * L1_Y) * \n                        (l1_block_x * (Y_size / L1_Y) + l1_block_y); \n                    for (size_t l1_k = l2_k; l1_k < l2_k + L2_K_STEP; \n                         l1_k += L1_K_STEP) { \n                      size_t l1_block_k = l1_k / L1_K_STEP; \n                      size_t A_base_index = \n                          (L1_X * L1_K_STEP) * \n                          (l1_block_k * (X_size / L1_X) + l1_block_x); \n                      size_t B_base_index = \n                          (L1_Y * L1_K_STEP) * \n                          (l1_block_k * (Y_size / L1_Y) + l1_block_y); \n                       \n \n                      for (size_t x = 0; x < L1_X; x += X_REG) { \n                        for (size_t y = 0; y < L1_Y; y += Y_REG) { \n \n                          double_v acc_11 = 0.0; \n                          double_v acc_21 = 0.0; \n                          double_v acc_31 = 0.0; \n                          double_v acc_41 = 0.0; \n \n                          double_v acc_51 = 0.0; \n \n                          double_v acc_12 = 0.0; \n                          double_v acc_22 = 0.0; \n                          double_v acc_32 = 0.0; \n                          double_v acc_42 = 0.0; \n \n                          double_v acc_52 = 0.0; \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n \n                           \n \n                           \n \n                           \n \n                           \n \n \n                           \n \n                           \n \n                           \n \n                           \n \n \n                          for (size_t k_inner = 0; k_inner < L1_K_STEP; \n                               k_inner += 1) { \n \n                            double_v b_temp_1 = double_v( \n                                &B_padded[B_base_index + k_inner * L1_Y + y], \n                                Vc::flags::vector_aligned); \n                            double_v b_temp_2 = \n                                double_v(&B_padded[B_base_index + \n                                                   k_inner * L1_Y + (y + 4)], \n                                         Vc::flags::vector_aligned); \n \n                            double_v a_temp_1 = \n                                A_trans[A_base_index + k_inner * L1_X + \n                                        (x + 0)]; \n                            double_v a_temp_2 = \n                                A_trans[A_base_index + k_inner * L1_X + \n                                        (x + 1)]; \n                            double_v a_temp_3 = \n                                A_trans[A_base_index + k_inner * L1_X + \n                                        (x + 2)]; \n \n                            acc_11 += a_temp_1 * b_temp_1; \n                            acc_21 += a_temp_2 * b_temp_1; \n \n                            acc_12 += a_temp_1 * b_temp_2; \n                            acc_22 += a_temp_2 * b_temp_2; \n \n                            double_v a_temp_4 = \n                                A_trans[A_base_index + k_inner * L1_X + \n                                        (x + 3)]; \n                            double_v a_temp_5 = \n                                A_trans[A_base_index + k_inner * L1_X + \n                                        (x + 4)]; \n \n                            acc_31 += a_temp_3 * b_temp_1; \n                            acc_32 += a_temp_3 * b_temp_2; \n \n                            acc_41 += a_temp_4 * b_temp_1; \n                            acc_51 += a_temp_5 * b_temp_1; \n \n                            acc_42 += a_temp_4 * b_temp_2; \n                            acc_52 += a_temp_5 * b_temp_2; \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n                             \n \n \n                             \n \n                             \n \n                             \n \n \n                             \n \n                             \n \n                             \n \n \n                             \n \n                             \n \n                             \n \n \n                             \n \n                             \n \n                             \n \n                          } \n \n                          double_v res_11 = double_v( \n                              &C_padded[C_base_index + (x + 0) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          res_11 += acc_11; \n                          res_11.memstore( \n                              &C_padded[C_base_index + (x + 0) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          double_v res_21 = double_v( \n                              &C_padded[C_base_index + (x + 1) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          res_21 += acc_21; \n                          res_21.memstore( \n                              &C_padded[C_base_index + (x + 1) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          double_v res_31 = double_v( \n                              &C_padded[C_base_index + (x + 2) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          res_31 += acc_31; \n                          res_31.memstore( \n                              &C_padded[C_base_index + (x + 2) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          double_v res_41 = double_v( \n                              &C_padded[C_base_index + (x + 3) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          res_41 += acc_41; \n                          res_41.memstore( \n                              &C_padded[C_base_index + (x + 3) * L1_Y + y], \n                              Vc::flags::element_aligned); \n \n                           \n \n                          double_v res_51 = double_v( \n                              &C_padded[C_base_index + (x + 4) * L1_Y + y], \n                              Vc::flags::element_aligned); \n                          res_51 += acc_51; \n                          res_51.memstore( \n                              &C_padded[C_base_index + (x + 4) * L1_Y + y], \n                              Vc::flags::element_aligned); \n \n                          double_v res_12 = \n                              double_v(&C_padded[C_base_index + (x + 0) * L1_Y + \n                                                 (y + 4)], \n                                       Vc::flags::element_aligned); \n                          res_12 += acc_12; \n                          res_12.memstore(&C_padded[C_base_index + \n                                                    (x + 0) * L1_Y + (y + 4)], \n                                          Vc::flags::element_aligned); \n                          double_v res_22 = \n                              double_v(&C_padded[C_base_index + (x + 1) * L1_Y + \n                                                 (y + 4)], \n                                       Vc::flags::element_aligned); \n                          res_22 += acc_22; \n                          res_22.memstore(&C_padded[C_base_index + \n                                                    (x + 1) * L1_Y + (y + 4)], \n                                          Vc::flags::element_aligned); \n                          double_v res_32 = \n                              double_v(&C_padded[C_base_index + (x + 2) * L1_Y + \n                                                 (y + 4)], \n                                       Vc::flags::element_aligned); \n                          res_32 += acc_32; \n                          res_32.memstore(&C_padded[C_base_index + \n                                                    (x + 2) * L1_Y + (y + 4)], \n                                          Vc::flags::element_aligned); \n                          double_v res_42 = \n                              double_v(&C_padded[C_base_index + (x + 3) * L1_Y + \n                                                 (y + 4)], \n                                       Vc::flags::element_aligned); \n                          res_42 += acc_42; \n                          res_42.memstore(&C_padded[C_base_index + \n                                                    (x + 3) * L1_Y + (y + 4)], \n                                          Vc::flags::element_aligned); \n \n                           \n \n                          double_v res_52 = \n                              double_v(&C_padded[C_base_index + (x + 4) * L1_Y + \n                                                 (y + 4)], \n                                       Vc::flags::element_aligned); \n                          res_52 += acc_52; \n                          res_52.memstore(&C_padded[C_base_index + \n                                                    (x + 4) * L1_Y + (y + 4)], \n                                          Vc::flags::element_aligned); \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                           \n \n                        } \n                      } \n                    } \n                  } \n                } \n              } \n            } \n          } \n        } \n      } \n    }", "pragma": "parallel for ", "hash": "c3d30324d555c8ea00345029171c56092b2df346ed140c34a62e20eb7b7ee31d"}
{"code": "for (x = 0 ; x < (signed)numData ; ++ x) { \n       \n \n      if (((self->distance == VlDistanceL1) ? 2.0 : 4.0) * \n          pointToClosestCenterUB[x] <= nextCenterDistances[assignments[x]]) { \n        continue ; \n      } \n \n      for (c = 0 ; c < self->numCenters ; ++c) { \n        vl_uint32 cx = assignments[x] ; \n        TYPE distance ; \n \n         \n \n        if (cx == c) { \n          continue ; \n        } \n        if (((self->distance == VlDistanceL1) ? 2.0 : 4.0) * \n            pointToClosestCenterUB[x] <= ((TYPE*)self->centerDistances) \n            [c + cx * self->numCenters]) { \n          continue ; \n        } \n        if (pointToClosestCenterUB[x] <= pointToCenterLB \n            [c + x * self->numCenters]) { \n          continue ; \n        } \n \n         \n \n        if (! pointToClosestCenterUBIsStrict[x]) { \n          distance = distFn(self->dimension, \n                            data + self->dimension * x, \n                            (TYPE*)self->centers + self->dimension * cx) ; \n          pointToClosestCenterUB[x] = distance ; \n          pointToClosestCenterUBIsStrict[x] = VL_TRUE ; \n          pointToCenterLB[cx + x * self->numCenters] = distance ; \n          numDistanceComputationsToRefreshUB += 1 ; \n \n          if (((self->distance == VlDistanceL1) ? 2.0 : 4.0) * \n              pointToClosestCenterUB[x] <= ((TYPE*)self->centerDistances) \n              [c + cx * self->numCenters]) { \n            continue ; \n          } \n          if (pointToClosestCenterUB[x] <= pointToCenterLB \n              [c + x * self->numCenters]) { \n            continue ; \n          } \n        } \n \n         \n \n        distance = distFn(self->dimension, \n                          data + x * self->dimension, \n                          (TYPE*)self->centers + c *  self->dimension) ; \n        numDistanceComputationsToRefreshLB += 1 ; \n        pointToCenterLB[c + x * self->numCenters] = distance ; \n \n        if (distance < pointToClosestCenterUB[x]) { \n          assignments[x] = c ; \n          pointToClosestCenterUB[x] = distance ; \n          allDone = VL_FALSE ; \n           \n \n        } \n \n      }  \n \n    }", "pragma": "parallel for reduction(+:numdistancecomputationstorefreshub numdistancecomputationstorefreshlb) private(c x)", "hash": "0849067ca51f69a810e2ea0b9c9c429680dc40eb8b261c91b3cb5aae4b1d027a"}
{"code": "for (i=0;i<props.size;i++){ \n        int j=0; \n        for (j=0;j<props.size;j++){ \n            KC[i*(props.size)+j]=kernelFunction(dataset,indexes[i], indexes[j], props); \n            if(i==j) KC[i*(props.size)+j]+=pow(10,-5); \n        } \n    }", "pragma": "parallel for ", "hash": "fe3bc9fa47888d31651a8b3f8761500704048911ffa490e6b8a01102828038d1"}
{"code": "for (i = 0; i < 16; i++) \n        c[i + 80] = i + 80;", "pragma": "for ", "hash": "c86af8bc5d0d07ef42c16c5749aa68caac50f37f83ffaf795de54a22976e156d"}
{"code": "for (int mi=0; mi<job->ainfo->nm; ++mi) \n      { \n \n \n      alm2almtmp (&ljob, lmax, mi); \n \n      inner_loop (&ljob, ispair, cth, sth, llim, ulim, &generator, mi, idx); \n \n \n \n      almtmp2alm (&ljob, lmax, mi); \n      }", "pragma": "for ", "hash": "1d92c8905ad1dcd344cc0957043e705e3ab0d4476c49bc9992f7eca3218c0fcf"}
{"code": "for (int  _i1 = 2; (_i1 <= (R + 1)); _i1 = (_i1 + 1)) \n    { \n          #pragma ivdep \n      for (int  _i2 = 0; (_i2 <= (C + 3)); _i2 = (_i2 + 1)) \n      { \n        blurx[(((_i0 * (R * (4 + C))) + ((_i1 - 2) * (4 + C))) + _i2)] = (((((img[(((_i0 * ((R + 4) * (C + 4))) + ((-2 + _i1) * (C + 4))) + _i2)] * 0.0625f) + (img[(((_i0 * ((R + 4) * (C + 4))) + ((-1 + _i1) * (C + 4))) + _i2)] * 0.25f)) + (img[(((_i0 * ((R + 4) * (C + 4))) + (_i1 * (C + 4))) + _i2)] * 0.375f)) + (img[(((_i0 * ((R + 4) * (C + 4))) + ((1 + _i1) * (C + 4))) + _i2)] * 0.25f)) + (img[(((_i0 * ((R + 4) * (C + 4))) + ((2 + _i1) * (C + 4))) + _i2)] * 0.0625f)); \n      } \n    }", "pragma": "parallel for ", "hash": "032c7df7a324a6130b3455d4dcf571d56c6d5c0de53ac1de92cd4b8baaf44596"}
{"code": "for ( n = 0; n < num_links; ++n ) \n\t{ \n\t  tgt_cell_add = rv->tgt_cell_add[n]; \n \n          if ( IS_NOT_EQUAL(tgt_grid->cell_area[tgt_cell_add], 0) ) \n\t    norm_factor = ONE/tgt_grid->cell_area[tgt_cell_add]; \n          else \n            norm_factor = ZERO; \n \n\t  rv->wts[n*num_wts] *= norm_factor; \n\t}", "pragma": "parallel for private(  n norm_factor tgt_cell_add)", "hash": "0be762d502a6de3341a6a29d5a41f8e9b0318b4bd11efbc5e1b0668706dc1bf1"}
{"code": "for(int nl=0; nl < nn; nl++) { \n \n\t\tunsigned ng = start + nl; \n \n\t\tfloat ge = ge0[nl]; \n\t\tfloat gi = gi0[nl]; \n\t\tfloat u = u0[nl]; \n\t\tfloat v = v0[nl]; \n \n\t\t \n \n \n\t\t \n \n\t\tge = ge * tMdtOt_exc[nl]; \n\t\tgi = gi * tMdtOt_inh[nl]; \n \n\t\t \n \n        if(currentEPSP[ng] > 0.0) ge = 1.0f; \n\t\tif(currentIPSP[ng] > 0.0) gi = 1.0f; \n \n\t\tge1[nl] = ge; \n\t\tgi1[nl] = gi; \n \n\t\t \n \n\t\tfloat I = G_exc[nl]*ge*(E_exc[nl] - v) +  \n                  G_inh[nl]*gi*(E_inh[nl] - v) + currentExternal[ng]; \n \n\t\t \n \n \n\t\t \n \n\t\tcurrentExternal[ng] = 0.0f; \n \n\t\tif(sigma[nl] != 0.0f) { \n\t\t\tI += C[nl] * sigma[nl] * nrand(&rng[nl]); \n\t\t} \n \n\t\tfired[ng] = 0; \n \n\t\tfloat oneOverC = 1.0f/C[nl]; \n \n\t\tfor(unsigned t=0; t<SUBSTEPS; ++t) { \n\t\t\tif(!fired[ng]) { \n\t\t\t\t \n \n                \t\tv += SUBSTEP_MULT * oneOverC * (k[nl] * (v - Vr[nl]) * (v - Vt[nl])  - u + I); \n                \t\tu += SUBSTEP_MULT * (a[nl] * (b[nl] * (v - Vr[nl]) - u)); \n\t\t\t\tfired[ng] = v >= vpeak[nl]; \n\t\t\t} \n\t\t} \n \n\t\tfired[ng] |= fstim[ng]; \n\t\tfstim[ng] = 0; \n\t\trecentFiring[ng] = (recentFiring[ng] << 1) | (uint64_t) fired[ng]; \n \n\t\tif(fired[ng]) { \n\t\t\tv = c[nl]; \n\t\t\tu += d[nl]; \n\t\t\t \n \n\t\t} \n \n\t\tu1[nl] = u; \n\t\tv1[nl] = v; \n\t}", "pragma": "parallel for ", "hash": "1c6a57c5f671289a90f729cb283aa367d8c7e91ba2986a61438c0cdf74cdbf81"}
{"code": "for (int i = 0; i < static_cast<int>(m_quadMapper->quadCount()); i++) \n    { \n        cellScalarValue = resultAccessor->cellScalar(m_quadMapper->cellIndex(i)); \n        texCoord = mapper->mapToTextureCoord(cellScalarValue); \n        if (cellScalarValue == HUGE_VAL || cellScalarValue != cellScalarValue)  \n \n        { \n            texCoord[1] = 1.0f; \n        } \n \n        size_t j; \n        for (j = 0; j < 4; j++) \n        {    \n            rawPtr[i*4 + j] = texCoord; \n        } \n    }", "pragma": "parallel for private( cellscalarvalue texcoord)", "hash": "8031b7d8fbb73b5a57693b82e56e3c515bb84829f6855f165d6cad81673366fc"}
{"code": "for ( tgt_cell_add = 0; tgt_cell_add < tgt_grid_size; ++tgt_cell_add ) \n    { \n      int lprogress = 1; \n      if ( cdo_omp_get_thread_num() != 0 ) lprogress = 0; \n \n#include \"pragma_omp_atomic_update.h\" \n      findex++; \n      if ( lprogress ) progressStatus(0, 1, findex/tgt_grid_size); \n \n      weightlinks[tgt_cell_add].nlinks = 0;\t \n \n      if ( ! tgt_grid->mask[tgt_cell_add] ) continue; \n \n      plat = tgt_grid->cell_center_lat[tgt_cell_add]; \n      plon = tgt_grid->cell_center_lon[tgt_cell_add]; \n \n       \n \n      if ( remap_grid_type == REMAP_GRID_TYPE_REG2D ) \n\tsearch_result = grid_search_reg2d(src_grid, src_add, src_lats, src_lons,  \n\t\t\t\t\t  plat, plon, src_grid->dims, \n\t\t\t\t\t  src_grid->reg2d_center_lat, src_grid->reg2d_center_lon); \n      else \n\tsearch_result = grid_search(src_grid, src_add, src_lats, src_lons,  \n\t\t\t\t    plat, plon, src_grid->dims, \n\t\t\t\t    src_grid->cell_center_lat, src_grid->cell_center_lon, \n\t\t\t\t    src_grid->cell_bound_box, src_grid->bin_addr); \n \n       \n \n      if ( search_result > 0 ) \n\t{ \n\t  for ( int n = 0; n < 4; ++n ) \n\t    if ( ! src_grid->mask[src_add[n]] ) search_result = 0; \n\t} \n \n       \n \n      if ( search_result > 0 ) \n\t{ \n\t  double iw, jw;   \n \n \n          tgt_grid->cell_frac[tgt_cell_add] = 1.; \n \n          if ( find_ij_weights(plon, plat, src_lats, src_lons, &iw, &jw) ) \n\t    { \n\t       \n \n\t      set_bicubic_weights(iw, jw, wgts); \n \n\t      store_weightlinks4(4, src_add, wgts, tgt_cell_add, weightlinks); \n\t    } \n          else \n\t    { \n\t      bicubic_warning(); \n \n\t      search_result = -1; \n\t    } \n\t} \n\t   \n       \n \n      if ( search_result < 0 ) \n\t{ \n\t  if ( num_src_points(src_grid->mask, src_add, src_lats) > 0 ) \n\t    { \n\t      renormalize_weights(src_lats, wgts); \n \n\t      tgt_grid->cell_frac[tgt_cell_add] = 1.; \n \n\t      store_weightlinks4(4, src_add, wgts, tgt_cell_add, weightlinks); \n\t    } \n        } \n    }", "pragma": "parallel for private(       plat plon search_result src_add src_lats src_lons tgt_cell_add wgts)", "hash": "fd7aba313b814cca9f541dcea8db0dbbb6f31e9392287a7f51ebbc99de5baeb4"}
{"code": "for (int i = 7; i < 17; i += 1)", "pragma": "for ", "hash": "a8bc8cc59ae769c38d398175275eb9302f529db4ffdd7b5ee50943bdbedae7e4"}
{"code": "for (uint64_t i = 0; i < g->n_local; ++i) \n    temp_counts[i] = 0;", "pragma": "for ", "hash": "84f14a79e4fef056671c4f1f1416eaf14729db3715365f38e1ee09c007ae8e48"}
{"code": "for (uint32_t k = 0; k < n; k++) { \n            m_vectors[sizeQ + i][k].ModMulFastConstEq(currentBDivBiModBi, moduliBsk[i], currentBDivBiModBiPrecon); \n        }", "pragma": "parallel for ", "hash": "470b68df371c6a63b6119a6d1db0388e168d221d92fdfb39c089537e68f4ccad"}
{"code": "for (unsigned i = startPos.second; i < seqan::length(window2) + startPos.second - (q - 1); ++i) \n\t{ \n\t\tseqan::DnaString qGram = seqan::infix(seq1, i, i + q); \n\t\twhile (seqan::find(myFinder, qGram)) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tSSeed seed(position(myFinder) + startPos.first, i, position(myFinder) + q + startPos.first, i + q); \n\t\t\tif (!seqan::addSeed(set, seed, 2, 2, scoringScheme, seq1, seq2, seqan::Chaos())) \n\t\t\t{ \n\t\t\t\tseqan::addSeed(set, seed, seqan::Single()); \n\t\t\t} \n\t\t} \n\t\tseqan::clear(myFinder); \n\t}", "pragma": "parallel for ", "hash": "33842d79b202988a0e36e4db5e0e038d75fa4b3fe545badeae54b23b32b26963"}
{"code": "for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        const int \n          id = GetOpenMPThreadId(); \n \n        while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH) \n        { \n          MagickStatusType \n            status; \n \n          QuantumAny \n            range; \n \n          status=0; \n          range=GetQuantumRange(current_depth[id]); \n          if ((channel & RedChannel) != 0) \n            status&=image->colormap[i].red != ScaleAnyToQuantum( \n              ScaleQuantumToAny(image->colormap[i].red,range),range); \n          if ((channel & GreenChannel) != 0) \n            status&=image->colormap[i].green != ScaleAnyToQuantum( \n              ScaleQuantumToAny(image->colormap[i].green,range),range); \n          if ((channel & BlueChannel) != 0) \n            status&=image->colormap[i].blue != ScaleAnyToQuantum( \n              ScaleQuantumToAny(image->colormap[i].blue,range),range); \n          if (status == 0) \n            break; \n          current_depth[id]++; \n        } \n      }", "pragma": "parallel for ", "hash": "5e3d8182e96916973556427262ff1c81f87d89c7cb8a3f929795589ced601501"}
{"code": "for (j=0; j<N; j++) \n        zd_dev[j] = (a * xd_dev[j]) - yd_dev[j];", "pragma": "parallel for ", "hash": "b34845904991cbd18b2ac9361c2d36e00f3b3444a8bc80665f6c21c0c52774f6"}
{"code": "for (ompIndexType k = 0; k < nbElements; ++k) { \n            outZ[k].real(log(complex_abs<T>(inZ[k].real() + 1, inZ[k].imag()))); \n            outZ[k].imag(atan2(inZ[k].imag(), inZ[k].real() + 1)); \n        }", "pragma": "parallel for ", "hash": "cf2f8f09cecb37e5d9111591c6d698e77241075888e5c101e7ad82b7e9c4bd64"}
{"code": "for (int64_t i = 0; i < nv; ++i) { \n        int64_t degree = stinger_outdegree_get(graph.S, i); \n        degrees[i] = vertex_degree(i, degree); \n    }", "pragma": "parallel for ", "hash": "2be2ef09bab56ccec740e5ec8dfb6f43f0989374ce47c829adc3272cf23f23c9"}
{"code": "for(int iY = 0; iY < ny; iY++){  \n         for(int iX = 0; iX < nx; iX++){  \n             \n \n            int outVal = 1; \n             \n \n            for(int iF = 0; iF < origNf; iF++){ \n               int kextOrig = kIndex(iX, iY, iF, nx+haloOrig->lt+haloOrig->rt, ny+haloOrig->dn+haloOrig->up, origNf); \n               float origActivity = originalABatch[kextOrig]; \n                \n \n               if(origActivity != 0){ \n                  outVal = 0; \n               } \n                \n \n               for(int repIdx = 0; repIdx < repFeatureNum; repIdx++){ \n                   \n \n                  int newFeatureIdx = ((iF+1)*repFeatureNum) + repIdx; \n                  assert(newFeatureIdx < thisNf); \n                  int kext = kIndex(iX, iY, newFeatureIdx, nx+halo->lt+halo->rt, ny+halo->dn+halo->up, thisNf); \n                  ABatch[kext] = origActivity; \n               } \n            } \n             \n \n            for(int repIdx = 0; repIdx < repFeatureNum; repIdx++){ \n               int kextBackground = kIndex(iX, iY, repIdx, nx+halo->lt+halo->rt, ny+halo->dn+halo->up, thisNf); \n               ABatch[kextBackground] = outVal; \n            } \n         } \n      }", "pragma": "parallel for ", "hash": "d60674b6c8add27086a6186873a748bad680c1dc64ca6a1ffd97454de7582df9"}
{"code": "for (int a = 0; a < static_cast<int>(mol2->AtomCount()); ++a) { \n            this->atomPosFitted.Peek()[3 * a + 0] = mol2->AtomPositions()[3 * a + 0]; \n            this->atomPosFitted.Peek()[3 * a + 1] = mol2->AtomPositions()[3 * a + 1]; \n            this->atomPosFitted.Peek()[3 * a + 2] = mol2->AtomPositions()[3 * a + 2]; \n        }", "pragma": "parallel for ", "hash": "7f2ef57044daa7002de75459f29a6cdab01c76d586d6242e4831cc9cbbe1ab22"}
{"code": "for ( int i=0; i<m_dim_x; i++ ) \n    { \n      for ( int j=0; j<m_dim_y; j++ ) \n      { \n        this->Get_kx( i, i2, kx ); \n        ij = j+m_dim_y*i; \n \n        tmp1 = m_out[ij][0]; \n        m_out[ij][0] = -kx*m_out[ij][1]; \n        m_out[ij][1] = kx*tmp1; \n      } \n    }", "pragma": "parallel for private(i2 ij kx tmp1)", "hash": "690a8dfbbb1c25bf1073de463e59c1533c7b4bdeda188ab3558e0e89d649105e"}
{"code": "for(int z=0;z<K->b;++z) { \n    for(int b=0;b<N->a;++b) { \n      for(int i=0;i<E->c;++i) { \n\tint in=i*E->d; \n\tint ib=b*size; \n\tfor(int j=0;j<E->d;++j,++in) { \n\t  int im=z*(K->c*K->d); \n\t  int si=(i*stride)-kr2; \n\t  int sj=(j*stride)-kc2; \n\t  for(int i2=0;i2<K->c;++i2,++si) \n\t    for(int j2=0,sj=(j*stride)-kc2;j2<K->d;++j2,++im,++sj) \n\t      if ((si<0)||(sj<0)||(si>=inr)||(sj>=inc)) \n\t\tI->ptr2(im,in+ib)=0.0; \n\t      else \n\t\tI->ptr2(im,in+ib)=N->ptr[b]->ptr[z]->ptr2(si,sj); \n \n\t} \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "9447525920314c70df87b86911bd161173bed54faf2781a5e72a78cb7e8b7bae"}
{"code": "for(pcount = 0; pcount < chch; ++pcount){ \n \n\t\t\tx = coordinates[pcount][0]; \n\t\t\ty = coordinates[pcount][1]; \n\t\t\tz = coordinates[pcount][2]; \n\t\t\tdouble px = momentum[pcount][0]; \n\t\t\tdouble py = momentum[pcount][1]; \n\t\t\tdouble pz = momentum[pcount][2]; \n \n\t\t\tmeanSqrX[i] += x*x/chch; \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n\t\t\tdouble Ex, Ey, Ez; \n\t\t\tEx = 0; \n\t\t\tEy = 0; \n\t\t\tEz = 0; \n\t\t\t \n \n\t\t\t \n \n\t\t\tgetDipoleField(x, y, z, Bx, By, Bz, 0, 0, 1E27); \n \n\t\t\tdouble p2 = px*px + py*py + pz*pz; \n\t\t\tdouble gamma = sqrt(1.0 + p2/(massElectron*massElectron*c*c)); \n\t\t\tdouble p = sqrt(p2); \n\t\t\tdouble B = sqrt(Bx*Bx + By*By + Bz*Bz); \n \n\t\t\tdouble rg = p*c/(electron_charge*B); \n\t\t\tdouble r = sqrt(x*x + y*y + z*z); \n\t\t\tdouble relation = rg/r; \n\t\t\tdouble omega = electron_charge*B/(gamma*massElectron*c); \n\t\t\tdouble timeRelation = dt*omega; \n \n\t\t\tif(i %writePartNumber == 0){ \n\t\t\t\tfor(int k = 0; k < partWrite; ++k){ \n\t\t\t\t\tif(pcount == numbers[k]){ \n\t\t\t\t\t\tstd::string fileNumber = std::string(\"_\") + convertIntToString(k); \n\t\t\t\t\t\tFILE* file = fopen((\"./output/trajectory\" + fileNumber + \".dat\").c_str(),\"a\"); \n\t\t\t\t\t\tdouble pb = px*Bx + py*By + pz*Bz; \n\t\t\t\t\t\tdouble adiabaticInvariant = (p2 - (pb*pb/(B*B)))/B; \n\t\t\t\t\t\tfprintf(file, \"%d %g %g %g %g %g %g %g %g %g %g\\n\", i, x, y, z, px, py, pz, gamma, p2, B, adiabaticInvariant); \n\t\t\t\t\t\tfclose(file); \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t\t \n \n \n\t\t\t \n \n\t\t\tmoveSimple(x, y, z, px, py, pz, Bx, By, Bz, Ex, Ey, Ez, dt,massElectron); \n\t\t\t \n \n\t\t\t \n \n \n\t\t\tcoordinates[pcount][0] = x; \n\t\t\tcoordinates[pcount][1] = y; \n\t\t\tcoordinates[pcount][2] = z; \n\t\t\tmomentum[pcount][0] = px; \n\t\t\tmomentum[pcount][1] = py; \n\t\t\tmomentum[pcount][2] = pz; \n\t\t}", "pragma": "parallel for private(pcount)", "hash": "63c29cad62d996889fe9c7a5e532f1acc2ecc66d9cd0d77d722b487772d73177"}
{"code": "for (y=bounding_box.y; y < (ssize_t) bounding_box.height; y++) \n  { \n    PixelInfo \n      composite, \n      pixel; \n \n    double \n      alpha, \n      offset; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      i, \n      x; \n \n    ssize_t \n      j; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    pixel=zero; \n    composite=zero; \n    offset=GetStopColorOffset(gradient,0,y); \n    if (gradient->type != RadialGradient) \n      offset/=length; \n    for (x=bounding_box.x; x < (ssize_t) bounding_box.width; x++) \n    { \n      GetPixelInfoPixel(image,q,&pixel); \n      switch (gradient->spread) \n      { \n        case UndefinedSpread: \n        case PadSpread: \n        { \n          if ((x != (ssize_t) ceil(gradient_vector->x1-0.5)) || \n              (y != (ssize_t) ceil(gradient_vector->y1-0.5))) \n            { \n              offset=GetStopColorOffset(gradient,x,y); \n              if (gradient->type != RadialGradient) \n                offset/=length; \n            } \n          for (i=0; i < (ssize_t) gradient->number_stops; i++) \n            if (offset < gradient->stops[i].offset) \n              break; \n          if ((offset < 0.0) || (i == 0)) \n            composite=gradient->stops[0].color; \n          else \n            if ((offset > 1.0) || (i == (ssize_t) gradient->number_stops)) \n              composite=gradient->stops[gradient->number_stops-1].color; \n            else \n              { \n                j=i; \n                i--; \n                alpha=(offset-gradient->stops[i].offset)/ \n                  (gradient->stops[j].offset-gradient->stops[i].offset); \n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha, \n                  &gradient->stops[j].color,alpha,&composite); \n              } \n          break; \n        } \n        case ReflectSpread: \n        { \n          if ((x != (ssize_t) ceil(gradient_vector->x1-0.5)) || \n              (y != (ssize_t) ceil(gradient_vector->y1-0.5))) \n            { \n              offset=GetStopColorOffset(gradient,x,y); \n              if (gradient->type != RadialGradient) \n                offset/=length; \n            } \n          if (offset < 0.0) \n            offset=(-offset); \n          if ((ssize_t) fmod(offset,2.0) == 0) \n            offset=fmod(offset,1.0); \n          else \n            offset=1.0-fmod(offset,1.0); \n          for (i=0; i < (ssize_t) gradient->number_stops; i++) \n            if (offset < gradient->stops[i].offset) \n              break; \n          if (i == 0) \n            composite=gradient->stops[0].color; \n          else \n            if (i == (ssize_t) gradient->number_stops) \n              composite=gradient->stops[gradient->number_stops-1].color; \n            else \n              { \n                j=i; \n                i--; \n                alpha=(offset-gradient->stops[i].offset)/ \n                  (gradient->stops[j].offset-gradient->stops[i].offset); \n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha, \n                  &gradient->stops[j].color,alpha,&composite); \n              } \n          break; \n        } \n        case RepeatSpread: \n        { \n          MagickBooleanType \n            antialias; \n \n          double \n            repeat; \n \n          antialias=MagickFalse; \n          repeat=0.0; \n          if ((x != (ssize_t) ceil(gradient_vector->x1-0.5)) || \n              (y != (ssize_t) ceil(gradient_vector->y1-0.5))) \n            { \n              offset=GetStopColorOffset(gradient,x,y); \n              if (gradient->type == LinearGradient) \n                { \n                  repeat=fmod(offset,length); \n                  if (repeat < 0.0) \n                    repeat=length-fmod(-repeat,length); \n                  else \n                    repeat=fmod(offset,length); \n                  antialias=(repeat < length) && ((repeat+1.0) > length) ? \n                    MagickTrue : MagickFalse; \n                  offset=repeat/length; \n                } \n              else \n                { \n                  repeat=fmod(offset,gradient->radius); \n                  if (repeat < 0.0) \n                    repeat=gradient->radius-fmod(-repeat,gradient->radius); \n                  else \n                    repeat=fmod(offset,gradient->radius); \n                  antialias=repeat+1.0 > gradient->radius ? MagickTrue : \n                    MagickFalse; \n                  offset=repeat/gradient->radius; \n                } \n            } \n          for (i=0; i < (ssize_t) gradient->number_stops; i++) \n            if (offset < gradient->stops[i].offset) \n              break; \n          if (i == 0) \n            composite=gradient->stops[0].color; \n          else \n            if (i == (ssize_t) gradient->number_stops) \n              composite=gradient->stops[gradient->number_stops-1].color; \n            else \n              { \n                j=i; \n                i--; \n                alpha=(offset-gradient->stops[i].offset)/ \n                  (gradient->stops[j].offset-gradient->stops[i].offset); \n                if (antialias != MagickFalse) \n                  { \n                    if (gradient->type == LinearGradient) \n                      alpha=length-repeat; \n                    else \n                      alpha=gradient->radius-repeat; \n                    i=0; \n                    j=(ssize_t) gradient->number_stops-1L; \n                  } \n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha, \n                  &gradient->stops[j].color,alpha,&composite); \n              } \n          break; \n        } \n      } \n      CompositePixelInfoOver(&composite,composite.alpha,&pixel,pixel.alpha, \n        &pixel); \n      SetPixelInfoPixel(image,&pixel,q); \n      q+=GetPixelChannels(image); \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n  }", "pragma": "parallel for ", "hash": "898b8142ac77c2cca038f6c454b49072a5543443ba49f123b79ee5a9bc3e0202"}
{"code": "for(long k=0;k<m;k++)\tfor(long i=0;i<n;i++)\td->a[i+n*k] += c->a[i];", "pragma": "parallel for ", "hash": "d359083d6de4429ca0bba133f830625feaafe3f70e61caab0b9012a9ea9ca510"}
{"code": "for (k = 0; k<ths->M_total; k++) \n    { \n      INT u[ths->d], o[ths->d];  \n \n      INT t, t2;  \n \n      INT l_L;  \n \n      INT l[ths->d];  \n \n      INT lj[ths->d];  \n \n      INT ll_plain[ths->d+1];  \n \n      R phi_prod[ths->d+1];  \n \n      R y[ths->d]; \n      R fg_psi[ths->d][2*ths->m+2]; \n      INT l_fg,lj_fg; \n      R ip_w; \n      INT ip_u; \n      INT ip_s = ths->K/(ths->m+2); \n      INT j = (ths->flags & NFFT_SORT_NODES) ? ths->index_x[2*k+1] : k; \n \n      phi_prod[0] = K(1.0); \n      ll_plain[0] = 0; \n \n      MACRO_init_uo_l_lj_t; \n \n      for (t2 = 0; t2 < ths->d; t2++) \n      { \n        y[t2] = ((ths->n[t2]*ths->x[j*ths->d+t2]-(R)u[t2]) \n          * ((R)ths->K))/(ths->m+2); \n        ip_u  = LRINT(FLOOR(y[t2])); \n        ip_w  = y[t2]-ip_u; \n        for (l_fg = u[t2], lj_fg = 0; l_fg <= o[t2]; l_fg++, lj_fg++) \n        { \n          fg_psi[t2][lj_fg] = ths->psi[(ths->K+1)*t2 + ABS(ip_u-lj_fg*ip_s)] \n            * (1-ip_w) + ths->psi[(ths->K+1)*t2 + ABS(ip_u-lj_fg*ip_s+1)] \n            * (ip_w); \n        } \n      } \n \n      for (l_L = 0; l_L < lprod; l_L++) \n      { \n        C *lhs; \n        R *lhs_real; \n        C val; \n \n        MACRO_update_phi_prod_ll_plain(with_FG_PSI); \n \n        lhs = ths->g + ll_plain[ths->d]; \n        lhs_real = (R*)lhs; \n        val = phi_prod[ths->d] * ths->f[j]; \n \n        #pragma omp atomic \n        lhs_real[0] += CREAL(val); \n \n        #pragma omp atomic \n        lhs_real[1] += CIMAG(val); \n \n        MACRO_count_uo_l_lj_t; \n      }  \n \n    }", "pragma": "parallel for private(k)", "hash": "ced66e8273770bed0c3028e3cb16df0dd0ef3239a811e6e0fab6811c9f7eb54c"}
{"code": "for (int n = 0; n < nNodes; n++) { \n            MWNode<D> &out_node = *this->endNodeTable[n]; \n            MWNode<D> &inp_node = inp.getNode(out_node.getNodeIndex()); \n            double *out_coefs = out_node.getCoefs(); \n            const double *inp_coefs = inp_node.getCoefs(); \n            for (int i = 0; i < inp_node.getNCoefs(); i++) { out_coefs[i] += c * inp_coefs[i]; } \n            out_node.calcNorms(); \n        }", "pragma": "for ", "hash": "ef0e5d3c54be3a63f259167c15312e4b60461b941f2953c4c6169862f5cba8f6"}
{"code": "for (size_t l = 1, i = 0;l < lMax && i < l;l++, i++) \n\t\t{ \n\t\t\tss1 = Substring(sourceString, sourceStringSize, i, i + l - 1); \n\t\t\tss2 = Substring(sourceString, sourceStringSize, j + 1, j + l); \n\t\t\tif (Equals(ss1, ss2, l)) \n\t\t\t\treproductionPointers.push_back(i); \n\t\t\tdelete[] ss1; \n\t\t\tdelete[] ss2; \n\t\t}", "pragma": "parallel for ", "hash": "a12fcccbdbb29cb8a91a9bc7017fd5a17fa177379df59a1110f5d9a9657cb36b"}
{"code": "for(long j=0;j<2*ny;j++)\t{\thy[j] = huy[2*nx*j];\thv[j] = huv[2*nx*j];}", "pragma": "parallel for ", "hash": "91dc5e2e270383e8a711a44433f7c838f5f0570eb6057f4fec46ed0eaa4a0278"}
{"code": "for(int ie = 0; ie < f->macromesh.nbelems; ++ie) { \n    MacroCell *mcelli = f->mcell + ie; \n    if(!facealgo) DGMacroCellInterfaceSlow(mcelli, f, w, dtw); \n    DGSubCellInterface(mcelli, f, w, dtw); \n    DGVolume(mcelli, f, w, dtw); \n    DGMass(mcelli, f, dtw); \n    DGSource(mcelli, f, w, dtw); \n  }", "pragma": "parallel for ", "hash": "9ba3022d274c930707c60efc9ee9b15d8da0f1378d3a8208c3e01c7c3fc3a5e1"}
{"code": "for( i=0; i< NUM_BUCKETS; i++ ) { \n \n \n \n        k1 = i * num_bucket_keys; \n        k2 = k1 + num_bucket_keys; \n        for ( k = k1; k < k2; k++ ) \n            key_buff_ptr[k] = 0; \n \n \n \n \n \n \n        m = (i > 0)? bucket_ptrs[i-1] : 0; \n        for ( k = m; k < bucket_ptrs[i]; k++ ) \n            key_buff_ptr[key_buff_ptr2[k]]++;   \n \n                                        \n \n \n \n \n        key_buff_ptr[k1] += m; \n        for ( k = k1+1; k < k2; k++ ) \n            key_buff_ptr[k] += key_buff_ptr[k-1]; \n \n    }", "pragma": "for ", "hash": "5885e26776640d14be455dea292bc2505587932289f36c2394c426994598aab4"}
{"code": "for (int det=0;det<tod->ndet;det++) { \n    mbUncut *uncut=tod->uncuts[tod->rows[det]][tod->cols[det]]; \n    int nreg=uncut->nregions; \n    if (nreg>0) { \n      if (uncut->indexFirst[0]>0) \n\tfor (int i=0;i<uncut->indexFirst[0];i++) \n\t  tod->data[det][i]=0; \n      if (uncut->indexLast[nreg-1]<tod->ndata) \n\tfor (int i=uncut->indexLast[nreg-1];i<tod->ndata;i++) \n\t  tod->data[det][i]=0; \n      for (int reg=0;reg<nreg-1;reg++) { \n\tint i1=uncut->indexLast[reg]; \n\tint i2=uncut->indexFirst[reg+1];\t \n\tfor (int i=i1;i<i2;i++) \n\t  tod->data[det][i]=0; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "ce175a6c0967d4bfc2b8f3031982b55b63afb8789db1c3327a06c18d5735df47"}
{"code": "for(int i=0; i<nElements; i++) \n        elements[i]->getStiffnessMatrix(K, BftDBf, BctBc, L);", "pragma": "parallel for ", "hash": "d46eb92c5a25ec3857909b965a7bda86177e1aef480841283987c6e4da6a0eab"}
{"code": "for (int i = 0; i < n; ++i) \n    { \n        scene.worldPoints[i].p = x_v[i]; \n    }", "pragma": "for ", "hash": "d607869281c3f080dbb0eed96d2d6dec3c8e5e283f7b9133ac5d5fc56ae21dd9"}
{"code": "for(int i=0; i<nphases; i++) { \n\t\t\t \n \n            rvesvs[i].fillT(rvesvs[0].global.Lt, x, wx, y, wy, mp, np); \n        }", "pragma": "parallel for ", "hash": "17b427681f8ba336e89b169981f9d054079407b7f929af90f96ee4827e3e6e55"}
{"code": "for(int y = 0; y<parameters_.YSize;++y) \n    {  \n      float* previousD = &myGrid_[x][y][0]; \n      float* previousW = &myGrid_[x][y][1];       \n      for(int z = 0; z<parameters_.ZSize; ++z) \n      {            \n         \n \n        Eigen::Vector4d ray((x-parameters_.XSize/2)*parameters_.resolution, (y- parameters_.YSize/2)*parameters_.resolution , (z- parameters_.ZSize/2)*parameters_.resolution, 1);         \n        ray = worldToCam*ray; \n\t \n \n        if(ray(2) <= 0) continue; \n         \n        cv::Point2d uv; \n        uv=To2D(ray,parameters_.fx,parameters_.fy,parameters_.cx,parameters_.cy ); \n         \n        int j=floor(uv.x); \n        int i=floor(uv.y);       \n         \n         \n \n\tif(i>0 && i<depthImage_->rows-1 && j>0 && j <depthImage_->cols-1 ) { \n\t    if(validityMask_[i][j] && validityMask_[i-1][j] && validityMask_[i][j-1]) \n\t    { \n\t\tconst float* Di = depthImage_->ptr<float>(i); \n\t\tdouble Eta;  \n\t\t \n \n \n\t\tEta=(double(Di[j])-ray(2));        \n \n\t\tif(Eta >= parameters_.Dmin) \n\t\t{ \n \n\t\t    double D = std::min(Eta,parameters_.Dmax); \n \n\t\t    float W = ((D - 1e-6) < parameters_.Dmax) ? 1.0f : Wslope*D - Wslope*parameters_.Dmin; \n \n\t\t    previousD[z*2] = (previousD[z*2] * previousW[z*2] + float(D) * W) / \n\t\t\t(previousW[z*2] + W); \n \n\t\t    previousW[z*2] = std::min(previousW[z*2] + W , float(parameters_.Wmax)); \n \n\t\t} \n\t    } \n \n\t    else { \n\t\t \n \n\t\t \n \n\t    } \n\t} \n \n\telse { \n\t     \n \n\t     \n \n\t}\t     \n      } \n \n    }", "pragma": "parallel for ", "hash": "12a2fe8c71b9953a0370e68b82efd0f0ea6c585f41dd14ecf5757e127c2d5b82"}
{"code": "for (i = 1; i <= grid_points[0]-2; i++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (k = 1; k <= grid_points[2]-2; k++) { \n \n\tru1 = rho_i[i][j][k]; \n\tuu = us[i][j][k]; \n\tvv = vs[i][j][k]; \n\tww = ws[i][j][k]; \n\tac = speed[i][j][k]; \n\tac2inv = ainv[i][j][k]*ainv[i][j][k]; \n \n\tr1 = rhs[0][i][j][k]; \n\tr2 = rhs[1][i][j][k]; \n\tr3 = rhs[2][i][j][k]; \n\tr4 = rhs[3][i][j][k]; \n\tr5 = rhs[4][i][j][k]; \n \n\tt1 = c2 * ac2inv * ( qs[i][j][k]*r1 - uu*r2  -  \n\t\t\t     vv*r3 - ww*r4 + r5 ); \n\tt2 = bt * ru1 * ( uu * r1 - r2 ); \n\tt3 = ( bt * ru1 * ac ) * t1; \n \n\trhs[0][i][j][k] = r1 - t1; \n\trhs[1][i][j][k] = - ru1 * ( ww*r1 - r4 ); \n\trhs[2][i][j][k] =   ru1 * ( vv*r1 - r3 ); \n\trhs[3][i][j][k] = - t2 + t3; \n\trhs[4][i][j][k] =   t2 + t3; \n      } \n    } \n  }", "pragma": "for ", "hash": "0ece5b4d0650fa9fd8da81ec65d2d23a3797653dbb4e3859bc6777c32e2f7c86"}
{"code": "for (int t = 0; t < this->m_hp->m_num_trees; t++) \n\t\t\tthis->m_trees[t]->UpdateLeafStatistics(outbag_dataset[t]);", "pragma": "parallel for ", "hash": "ef59bd92446f0ff814d1c522b275400471c5eb4ebe7c3288ed0b0287c97b318a"}
{"code": "for( i=0; i<MAX_KEY; i++ ) \n            key_buff_ptr[i] += key_buff1_aptr[k][i];", "pragma": "for ", "hash": "3d28fcb8d254a0410b5a2ad96bb7b5dc74c1097da572d8a1851bc42dab986691"}
{"code": "for(j=0;j<top;j++){ \n                     \n \n                    idx1 = (j / incs[d])*incs[d]*ns[d] + (j % incs[d]); \n                 \n                     \n \n                    for(k=0,idx2=0 ; k<ns[d] ; k++,idx2+=incs[d]) \n                        wsi->in[k] = z[idx1+idx2] + q[idx1+idx2]; \n                         \n                    #ifdef DEBUG \n                    { \n                        int dbgi; \n                        printf(\"Slice %d: \",j); \n                        for(dbgi=0;dbgi<ns[d];dbgi++) \n                            printf(\"%lf \",slice[dbgi]); \n                        printf(\"\\n\"); \n                    } \n                    #endif \n                     \n                     \n \n                    switch((int)norms[1]){ \n                        case 1: PN_TV1(wsi->in,lambdas[1],wsi->out,NULL,ns[d],SIGMA,wsi); break; \n                        case 2: morePG_TV2(wsi->in,lambdas[1],wsi->out,NULL,ns[d],wsi); break; \n                    } \n                     \n                     \n \n                    for(k=0,idx2=0 ; k<ns[d] ; k++,idx2+=incs[d]) \n                        x[idx1+idx2] = wsi->out[k]; \n                }", "pragma": "parallel for ", "hash": "38b4cc7f7370a00323cc6c3010156dee0551b9b4c156daae017244a37e1226b5"}
{"code": "for (int i = 0; i < (int)numParticles; i++) \n\t\t{ \n\t\t\tconst Vector3r &xi = m_model->getPosition(0, i); \n\t\t\tVector3r &ai = m_model->getAcceleration(i); \n\t\t\tfor (unsigned int j = 0; j < m_model->numberOfNeighbors(i); j++) \n\t\t\t{ \n\t\t\t\tconst CompactNSearch::PointID &particleId = m_model->getNeighbor(i, j); \n\t\t\t\tconst unsigned int &neighborIndex = particleId.point_id; \n\t\t\t\tconst Vector3r &xj = m_model->getPosition(particleId.point_set_id, neighborIndex); \n\t\t\t\tconst Vector3r xixj = xi - xj; \n\t\t\t\tconst Real r2 = xixj.dot(xixj); \n \n\t\t\t\tif (particleId.point_set_id == 0) \n\t\t\t\t{ \n\t\t\t\t\tif (r2 > diameter2) \n\t\t\t\t\t\tai -= k / m_model->getMass(i) * m_model->getMass(neighborIndex) * (xi - xj) * m_model->W(xi - xj); \n\t\t\t\t\telse \n\t\t\t\t\t\tai -= k / m_model->getMass(i) * m_model->getMass(neighborIndex) * (xi - xj) * m_model->W(Vector3r(diameter, 0.0, 0.0)); \n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{ \n\t\t\t\t\tif (r2 > diameter2) \n\t\t\t\t\t\tai -= k / m_model->getMass(i) * m_model->getBoundaryPsi(particleId.point_set_id, neighborIndex) * (xi - xj) * m_model->W(xi - xj); \n\t\t\t\t\telse \n\t\t\t\t\t\tai -= k / m_model->getMass(i) * m_model->getBoundaryPsi(particleId.point_set_id, neighborIndex) * (xi - xj) * m_model->W(Vector3r(diameter, 0.0, 0.0)); \n \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "35f6fcca237a05065d5e62ca6bbe74a59704e6d03e90b53afb75296b9cf4aaeb"}
{"code": "for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n    freqs_tmp = frequencies + num_band * gp; \n     \n \n     \n \n    info = phonopy_zheev(freqs_tmp, \n                         eigenvectors + num_band * num_band * gp, \n                         num_band, \n                         uplo); \n \n     \n \n    for (j = 0; j < num_band; j++) { \n      freqs_tmp[j] = sqrt(fabs(freqs_tmp[j])) * \n        ((freqs_tmp[j] > 0) - (freqs_tmp[j] < 0)) * unit_conversion_factor; \n    } \n  }", "pragma": "parallel for private(   freqs_tmp gp info j)", "hash": "f3f50c189a1cd6f87fb477a71d4f49b4322595049b5d7b537c55f77530ff0484"}
{"code": "for (i2=off2; i2<m2; i2+=2){ \n                    for (i1=off1; i1<m1; i1+=2){ \n                        idn = i1+i2*(m1+1); \n                        comp = 0; \n                        for (r=0; r<2; r++) { \n                             \n \n                            ptr = yc + idn+comp; \n                            yA[r] = *ptr;  \n \n                            ptr = ptr+inc_x; \n                            yB[r] = *ptr;  \n \n                            ptr = ptr+inc_y; \n                            yD[r] = *ptr;  \n \n                            ptr = ptr-inc_x; \n                            yC[r] = *ptr;  \n \n                            yM[r] = 0.25*(yA[r]+yB[r]+yC[r]+yD[r]); \n                             \n                             \n \n                            rA[r] = 0.0; \n                            rB[r] = 0.0; \n                            rC[r] = 0.0; \n                            rD[r] = 0.0; \n                            comp+=nn; \n                             \n                        } \n                         \n                         \n \n                        d2SdiagTriangle(yA, yB, yM, VRef[0], rA, rB,rD,rC,alphaVolume); \n                        d2SdiagTriangle(yB, yD, yM, VRef[1], rB, rD,rC,rA,alphaVolume); \n                        d2SdiagTriangle(yD, yC, yM, VRef[2], rD, rC,rA,rB,alphaVolume); \n                        d2SdiagTriangle(yC, yA, yM, VRef[3], rC, rA,rB,rD,alphaVolume); \n                         \n                         \n \n                        comp = 0; \n                        for (r=0; r < 2; r++){ \n                            wptr = prod + idn + comp; \n                             \n \n                            *wptr += rA[r]; \n                            wptr += inc_x; \n                             \n \n                            *wptr += rB[r]; \n                            wptr +=  inc_y; \n                             \n \n                            *wptr += rD[r]; \n                            wptr -= inc_x; \n                            *wptr += rC[r]; \n                             \n \n                            comp+=nn; \n                        } \n                    } \n                }", "pragma": "for ", "hash": "894da8cda2df2e47130182a8af0def409b63dcc417397076c99e4098105e4d64"}
{"code": "for( int planeNr=0; planeNr < nrOfPlanes; planeNr++ ) \n    { \n        IPLImagePlane* plane = image->plane( planeNr ); \n        IPLImagePlane* newplane = _result->plane( planeNr ); \n \n \n        int H[256], W[256]; \n        for( int z=0; z<256; z++ ) \n            H[z] = 0; \n \n        for(int y=w2; y<height-w2; y++) \n        { \n             \n \n            notifyProgressEventHandler(100*progress++/maxProgress); \n            for(int x=w2; x<width-w2; x++) \n            { \n                 \n \n                for( int ky=-w2; ky <= w2; ky++) \n                { \n                    for( int kx=-w2; kx <= w2; kx++) \n                    { \n                        int index = (int) (plane->p(x+kx, y+ky) * FACTOR_TO_UCHAR); \n                        H[index]++; \n                    } \n                } \n \n                 \n \n                int z = 0; \n                for( int u=0; u<256; u++ ) \n                { \n                    if(H[u] > 0) \n                    { \n                        while( H[u] > 0) \n                        { \n                            W[z++] = u; \n                            H[u]--; \n                        } \n                    } \n                } \n \n                int qmin = INT_MAX; \n                int u; \n                for( int s=0; s<area; s++ ) \n                { \n                    u = std::max( 0, s-w2-1); \n                    int v = std::min( area-1, s+w2+1); \n                    int q = 0; \n                    for( int z=u; z<v; z++ ) \n                        if( s != z ) \n                            q += abs( (W[s] - W[z]) / (s - z) ); \n                    q /= (v - u); \n                    if ( q < qmin ) \n                    { \n                        u = s; \n                        qmin = q; \n \n                    } \n                } \n                newplane->p(x,y) = (float) W[u] * FACTOR_TO_FLOAT; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "f5dcef7b17a9dcae4675b7e23a691dd3019dee5bb5ae6da845dbd47322fbc13f"}
{"code": "for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j, ti; \n    for(ti = 0; ti < otime; ti++) { \n      for(i = 0; i < oheight; i++) { \n        for(j = 0; j < owidth; j++) { \n           \n \n          real *ip = input_p + k * itime * iwidth * iheight \n            + ti * iwidth * iheight * dT + i * iwidth * dH + j * dW; \n          real *op = output_p + k * otime * owidth * oheight \n            + ti * owidth * oheight + i * owidth + j; \n          real *indzp = indz_p + k * otime * owidth * oheight \n            + ti * owidth * oheight + i * owidth + j; \n \n           \n \n          real maxval = -THInf; \n          int x,y,z; \n          int mx, my, mz; \n \n          for(z = 0; z < kT; z++) { \n            for(y = 0; y < kH; y++) { \n              for(x = 0; x < kW; x++) { \n                real val = *(ip + z * iwidth * iheight + y * iwidth + x); \n                if (val > maxval) { \n                  maxval = val; \n                  mz = z; \n                  my = y; \n                  mx = x; \n                } \n              } \n            } \n          } \n \n           \n \n          ((unsigned char*)(indzp))[0] = mz; \n          ((unsigned char*)(indzp))[1] = my; \n          ((unsigned char*)(indzp))[2] = mx; \n          ((unsigned char*)(indzp))[3] = 0; \n           \n \n          *op = maxval; \n        } \n      } \n    } \n  }", "pragma": "parallel for private(k)", "hash": "cd2d0d2e1f2d2e1c4434914191b7f5026ce9ed5cee3d6f2c474993b0ad36f5ea"}
{"code": "for (i3 = 1; i3 < n3-1; i3++) { \n    for (i2 = 1; i2 < n2-1; i2++) { \n      for (i1 = 0; i1 < n1; i1++) { \n        u1[i1] = u[i3][i2-1][i1] + u[i3][i2+1][i1] \n               + u[i3-1][i2][i1] + u[i3+1][i2][i1]; \n        u2[i1] = u[i3-1][i2-1][i1] + u[i3-1][i2+1][i1] \n               + u[i3+1][i2-1][i1] + u[i3+1][i2+1][i1]; \n      } \n      for (i1 = 1; i1 < n1-1; i1++) { \n        r[i3][i2][i1] = v[i3][i2][i1] \n                      - a[0] * u[i3][i2][i1] \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n                      - a[2] * ( u2[i1] + u1[i1-1] + u1[i1+1] ) \n                      - a[3] * ( u2[i1-1] + u2[i1+1] ); \n      } \n    } \n  }", "pragma": "parallel for private(i1 i2 i3 u1 u2)", "hash": "1a555a98124c67c44be9f3ec2dd02f4c9186109254b924e98743a08298c0ae0d"}
{"code": "for (unsigned int i = 0; i < X[j].size(); ++i) \n        Fz += vbeZ<WT,C>(X[j][i], qY[j].row(i), weights_t, clusters, qZ[j][i]);", "pragma": "parallel for reduction(+ : fz) ", "hash": "06664a3a823861907437095eb0b8fdfde06acab2c13b6ebd98d12168e3972eaf"}
{"code": "for ( int ii = 0; ii < static_cast< int >( nextPyramidRows * nextPyramidColumns ); ++ii ) \n\t\t\t\t\t\taverage += nextPyramidSolution[ ii ];", "pragma": "parallel for reduction(  + : average) ", "hash": "8b09c762c0594dd8b2dae1e8556487da5907dbb27a7da33cb1f657d7c65f60cc"}
{"code": "for (int ip=0; ip<NumThreads; ++ip) \n      { \n         \n \n        MCWalkerConfiguration::iterator wit(W.begin()+wPerNode[ip]), wit_end(W.begin()+wPerNode[ip+1]); \n        Movers[ip]->startBlock(nSteps); \n        for (int step=0; step<nSteps; ++step) \n        { \n          Movers[ip]->advanceWalkers(wit,wit_end,false); \n           \n \n           \n \n        } \n        Movers[ip]->accumulate(wit,wit_end); \n        Movers[ip]->stopBlock(); \n      }", "pragma": "for ", "hash": "2008082326e4d9179bade2f85d14c7f16e624624817aae0290d8c17623966cf8"}
{"code": "for(auto i=0; i<n; ++i) { \n        if(std::fabs(6.-y[i])>1e-15) { \n            errors++; \n        } \n    }", "pragma": "parallel for reduction(+:errors) ", "hash": "ebd51e4c620fe6e234cec32075179080a2feaaabe1c4cc250cb9cc0d3615bddf"}
{"code": "for (int i = 0; i < numRows; i++) { \n            array[i] = &(data[numCols * i]); \n             \n \n             \n \n             \n \n        }", "pragma": "parallel for ", "hash": "1d664d8d234313ac7c2a9742a4fac7f69503651d02c4d166d42236e3a2ed6c6e"}
{"code": "for (int64_t j = 0; j < (end - start); j++) \n          explx0_main[j] = alpha * explx0_main[j] + (1 - alpha) * explx0_prev[j];", "pragma": "parallel for ", "hash": "fd13cacc3ee4d08efc83fee24d73cf7c31a8839882236e893c361634ef3e146d"}
{"code": "for (uint64_t i = 0; i < n_nodes; i++) \n\t{ \n\t\tStaticDigraph::Node node = graph.node(i); \n \n\t\t \n \n  #pragma omp critical \n\t\t{ \n\t\t\tprogress = progress + 1; \n\t\t} \n \n\t\tif (progress % 1000 == 0) \n\t\t{ \n\t\t\tcout << \"Node #\" << progress << \"/\" << n_nodes << \" \"; \n\t\t  \tcout << \"Time: \" << currentDateTime(); \n\t\t  \tcout.flush(); \n\t\t} \n\t\t \n \n \n\t\t \n \n\t\tif (countInArcs(graph,node) == 1) \n\t\t{ \n\t\t\tStaticDigraph::InArcIt in_arc(graph,node); \n\t\t\tfor (StaticDigraph::OutArcIt out_arc(graph,node); out_arc != INVALID; ++out_arc) \n\t\t\t{ \n\t\t\t\tif (out_arc != in_arc) \n\t\t\t\t{ \n\t\t\t\t\tcontig entry; \n\t\t\t\t\tentry.nodes.push_back(graph.id(graph.source(in_arc))); \n\t\t\t\t\tentry.nodes.push_back(graph.id(node)); \n\t\t\t\t\tentry.nodes.push_back(graph.id(graph.target(out_arc))); \n \n     #pragma omp critical \n\t\t\t\t\t{ \n\t\t\t\t\t\tret.push_back(entry); \n\t\t\t\t\t\tsafe_pairs.insert(pair_of_ints(graph.id(in_arc),graph.id(out_arc)));\t \n\t\t\t\t\t}\t \n\t\t\t\t} \n\t\t\t}\t \n\t\t} else  \n\t\t \n \n\t\tif (countOutArcs(graph,node) == 1) \n\t\t{ \n\t\t\tStaticDigraph::OutArcIt out_arc(graph,node); \n\t\t\tfor (StaticDigraph::InArcIt in_arc(graph,node); in_arc != INVALID; ++in_arc) \n\t\t\t{ \n\t\t\t\tif (in_arc != out_arc) \n\t\t\t\t{ \n\t\t\t\t\tcontig entry; \n\t\t\t\t\tentry.nodes.push_back(graph.id(graph.source(in_arc))); \n\t\t\t\t\tentry.nodes.push_back(graph.id(node)); \n\t\t\t\t\tentry.nodes.push_back(graph.id(graph.target(out_arc))); \n \n     #pragma omp critical \n\t\t\t\t\t{ \n\t\t\t\t\t\tret.push_back(entry); \n\t\t\t\t\t\tsafe_pairs.insert(pair_of_ints(graph.id(in_arc),graph.id(out_arc)));\t \n\t\t\t\t\t} \n\t\t\t\t}\t\t\t\t \n\t\t\t}\t\t\t\t \n\t\t} else \n\t\t{ \n\t\t\tfor (StaticDigraph::InArcIt in_arc(graph,node); in_arc != INVALID; ++in_arc) \n\t\t\t{ \n\t\t\t\tfor (StaticDigraph::OutArcIt out_arc(graph,node); out_arc != INVALID; ++out_arc) \n\t\t\t\t{ \n\t\t\t\t\tif (out_arc == in_arc) \n\t\t\t\t\t{ \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t} \n\t\t\t\t\t \n \n\t\t\t\t\tint tid = omp_get_thread_num(); \n\t\t\t\t\ttid++; \n\t\t\t\t\t \n \n\t\t\t\t\tStaticDigraph::NodeMap<bool> filterNodesMap(GET_GRAPH(tid), true); \n\t\t\t\t\tFilterNodes<StaticDigraph> subgraph(GET_GRAPH(tid), filterNodesMap); \n \n\t\t\t\t\t \n \n\t\t\t\t\t \n \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tsubgraph.disable((GET_NODE_MAP(tid))[node]); \n\t\t\t\t\tBfs<FilterNodes<StaticDigraph>> visit(subgraph); \n\t\t\t\t\tvisit.init(); \n \n\t\t\t\t\t \n \n\t\t\t\t\tfor (StaticDigraph::OutArcIt out_arc2(graph,node); out_arc2 != INVALID; ++out_arc2) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif (graph.target(out_arc2) != graph.target(out_arc)) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tvisit.addSource((GET_NODE_MAP(tid))[graph.target(out_arc2)]); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t\tassert(visit.queueSize() > 0); \n \n\t\t\t\t\tvector<StaticDigraph::Node> bad_guys; \n\t\t\t\t\t \n \n\t\t\t\t\tFilterNodes<StaticDigraph>::NodeMap<bool> visitTargets(subgraph,false); \n\t\t\t\t\t \n \n\t\t\t\t\tfor (StaticDigraph::InArcIt in_arc2(graph,node); in_arc2 != INVALID; ++in_arc2) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif (in_arc2 != in_arc) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tvisitTargets[(GET_NODE_MAP(tid))[graph.source(in_arc2)]] = true; \n\t\t\t\t\t\t\tbad_guys.push_back((GET_NODE_MAP(tid))[graph.source(in_arc2)]); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n\t\t\t\t\t \n \n\t\t\t\t\tif (visit.start(visitTargets) == INVALID) \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tbool no_bad_inbr_reached = true; \n\t\t\t\t\t\tfor (size_t i = 0; i < bad_guys.size(); i++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tif (visit.reached(bad_guys[i])) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tno_bad_inbr_reached = false; \n\t\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t\tif (no_bad_inbr_reached) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tcontig entry; \n\t\t\t\t\t\t\tentry.nodes.push_back(graph.id(graph.source(in_arc))); \n\t\t\t\t\t\t\tentry.nodes.push_back(graph.id(node)); \n\t\t\t\t\t\t\tentry.nodes.push_back(graph.id(graph.target(out_arc))); \n \n       #pragma omp critical \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tret.push_back(entry); \n\t\t\t\t\t\t\t\tsafe_pairs.insert(pair_of_ints(graph.id(in_arc),graph.id(out_arc))); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t\t \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "750d538171185eed319090f6b969166ba713e4f8b98a3da73e661b3dcf51e54b"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp target teams distribute simd  \n \n    for (int j = 0; j < 10; ++j) \n      ; \n  }", "pragma": "for ", "hash": "b25d34e7e3a3a5d0fa02d79a2840df0a14f72c07f36d7de0e6f09506baa3b0ee"}
{"code": "for(size_t i=0;i<laserCloud.size();i++) \n        { \n            for(int rez=0;rez<resolutions.size();rez++) \n            { \n                map_[rez][i]->addPointCloud(T.translation(), *laserCloud[i],0.06, 100, 0.03, 255); \n                map_[rez][i]->computeNDTCells(CELL_UPDATE_MODE_SAMPLE_VARIANCE,1e9,255,T.translation(),0.01); \n            } \n        }", "pragma": "for ", "hash": "5e66655993479db2de05a5e348b9a3df070090384712d8d44d76d7f9660bbf0e"}
{"code": "for (l = 0; l < Nsyn; l++) { \n\t\tixsyn = NINT((xsyn[l] - fxs)/dxs); \n \n\t\tif (ixa || ixb) {  \n\t\t\tif (reci == 0) { \n\t\t\t\tx0 = xsyn[l]-ixb*dxsrc;  \n\t\t\t\tx1 = xsyn[l]+ixa*dxsrc;  \n\t\t\t\tif ((xsrc[k] < x0) || (xsrc[k] > x1)) continue; \n\t\t\t\tix = NINT((xsrc[k]-x0)/dxsrc); \n\t\t\t\tdosrc = 1; \n\t\t\t} \n\t\t\telse if (reci == 1) { \n\t\t\t\tx0 = xsyn[l]-ixb*dxs;  \n\t\t\t\tx1 = xsyn[l]+ixa*dxs;  \n\t\t\t\tif (((xsrc[k] < x0) || (xsrc[k] > x1)) &&  \n\t\t\t\t\t(xrcv[k*nx+0] < x0) && (xrcv[k*nx+nx-1] < x0)) continue; \n\t\t\t\tif (((xsrc[k] < x0) || (xsrc[k] > x1)) &&  \n\t\t\t\t\t(xrcv[k*nx+0] > x1) && (xrcv[k*nx+nx-1] > x1)) continue; \n\t\t\t\tif ((xsrc[k] < x0) || (xsrc[k] > x1)) dosrc = 0; \n\t\t\t\telse dosrc = 1; \n\t\t\t\tix = NINT((xsrc[k]-x0)/dxs); \n\t\t\t} \n\t\t\telse if (reci == 2) { \n\t\t\t\tif (NINT(dxsrc/dx)*dx != NINT(dxsrc)) dx = dxs; \n\t\t\t\tx0 = xsyn[l]-ixb*dx;  \n\t\t\t\tx1 = xsyn[l]+ixa*dx;  \n\t\t\t\tif ((xrcv[k*nx+0] < x0) && (xrcv[k*nx+nx-1] < x0)) continue; \n\t\t\t\tif ((xrcv[k*nx+0] > x1) && (xrcv[k*nx+nx-1] > x1)) continue; \n\t\t\t} \n\t\t} \n\t\telse {  \n\t\t\tix = k;  \n\t\t\tx0 = fxs;  \n\t\t\tx1 = fxs+dxs*nxs; \n\t\t\tdosrc = 1; \n\t\t} \n\t\tif (reci == 1 && dosrc) ix = NINT((xsrc[k]-x0)/dxs); \n \n\t\tif (reci < 2 && dosrc) { \n\t\t\tfor (j = 0; j < nfreq; j++) sum[j].r = sum[j].i = 0.0; \n\t\t\tfor (j = nw_low, m = 0; j < nw_high; j++, m++) { \n\t\t\t\tfor (i = iox; i < inx; i++) { \n\t\t\t\t\tixrcv = NINT((xrcv[k*nx+i]-fxs)/dxs); \n\t\t\t\t\ttmp = syncdata[l*nw*nxs+m*nxs+ixrcv]; \n\t\t\t\t\tsum[j].r += shots[k*nw*nx+m*nx+i].r*tmp.r - \n\t\t\t\t\t\t\t\tshots[k*nw*nx+m*nx+i].i*tmp.i; \n\t\t\t\t\tsum[j].i += shots[k*nw*nx+m*nx+i].i*tmp.r + \n\t\t\t\t\t\t\t\tshots[k*nw*nx+m*nx+i].r*tmp.i; \n\t\t\t\t} \n\t\t\t} \n#pragma omp critical \n{ \n\t\t\tcr1fft(sum, rdata, optn, 1); \n} \n\t\t\t \n \n\t\t\tfor (j = 0; j < nts; j++)  \n\t\t\t\tsyndata[l*size+ix*nts+j] += rdata[j]*scl*dx; \n\t\t} \n \n\t\tif (reci == 1 || reci == 2) { \n\t\t\tfor (j = 0; j < nfreq; j++) sum[j].r = sum[j].i = 0.0; \n\t\t\tfor (i = iox; i < inx; i++) { \n\t\t\t\tif ((xrcv[k*nx+i] < x0) || (xrcv[k*nx+i] > x1)) continue; \n\t\t\t\tif (reci == 1) ix = NINT((xrcv[k*nx+i]-x0)/dxs); \n\t\t\t\telse ix = NINT((xrcv[k*nx+i]-x0)/dx); \n \n\t\t\t\tfor (j = nw_low, m = 0; j < nw_high; j++, m++) { \n\t\t\t\t\ttmp = syncdata[l*nw*nxs+m*nxs+ixsrc]; \n\t\t\t\t\tsum[j].r = shots[k*nw*nx+m*nx+i].r*tmp.r - \n\t\t\t\t\t\t\t   shots[k*nw*nx+m*nx+i].i*tmp.i; \n\t\t\t\t\tsum[j].i = shots[k*nw*nx+m*nx+i].i*tmp.r + \n\t\t\t\t\t\t\t   shots[k*nw*nx+m*nx+i].r*tmp.i; \n\t\t\t\t} \n#pragma omp critical \n{ \n\t\t\t\tcr1fft(sum, rdata, optn, 1); \n} \n\t\t\t\t \n \n\t\t\t\tfor (j = 0; j < nts; j++)  \n\t\t\t\t\tsyndata[l*size+ix*nts+j] += rdata[j]*scl*dxsrc; \n\t\t\t} \n\t\t} \n \n\t}", "pragma": "for ", "hash": "f024140743ea9b6498edd7c117929bb4f03251a935e9b18ed4cedca294def191"}
{"code": "for (int ii = 0; ii < size; ++ii) \n        { \n\t\tmyl2 += fabs(v1[ii]-v2[ii])*(v1[ii] - v2[ii]); \n        }", "pragma": "parallel for reduction(+:myl2) ", "hash": "37721668f693faa555878d9636ed703dba70c7f6df0244c0f582e6fed6405c27"}
{"code": "for (int i = 0; i < control_knn.size(); ++i) { \n                recall += nndes::recall(control_knn[i], nn[control_index[i]], K); \n            }", "pragma": "parallel for reduction(+:recall) ", "hash": "60804ecb32e2fea342c802791d266aac61bb1554c10f0614d6d103f87afa1c2a"}
{"code": "for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1,4),ceild(4*t2-Nz+5,8));t3<=min(min(floord(4*Nt+Ny-9,8),floord(2*t1+Ny-3,8)),floord(4*t2+Ny-9,8));t3++) { \n        for (t4=max(max(ceild(t1-508,512),ceild(4*t2-Nz-1011,1024)),ceild(8*t3-Ny-1011,1024));t4<=min(min(min(floord(4*Nt+Nx-9,1024),floord(2*t1+Nx-3,1024)),floord(4*t2+Nx-9,1024)),floord(8*t3+Nx-5,1024));t4++) { \n          for (t5=max(max(max(ceild(t1,2),ceild(4*t2-Nz+5,4)),ceild(8*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4));t5<=floord(t1+1,2);t5++) { \n            for (t6=max(4*t2,-4*t1+4*t2+8*t5-3);t6<=min(min(4*t2+3,-4*t1+4*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(8*t3,4*t5+4);t7<=min(8*t3+7,4*t5+Ny-5);t7++) { \n                lbv=max(1024*t4,4*t5+4); \n                ubv=min(1024*t4+1023,4*t5+Nx-5); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 1][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 1]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 1]))) + (coef2 * (((((A[ t5 % 2][ (-4*t5+t6) - 2][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 2][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 2][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 2][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 2]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 2]))) + (coef3 * (((((A[ t5 % 2][ (-4*t5+t6) - 3][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 3][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 3][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 3][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 3]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 3]))) + (coef4 * (((((A[ t5 % 2][ (-4*t5+t6) - 4][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 4][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 4][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 4][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) - 4]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8) + 4])))));; \n                } \n              } \n            } \n          } \n        } \n      } \n    }", "pragma": "parallel for private(lbv t3 t4 t5 t6 t7 t8 ubv)", "hash": "7d1c8c273510261328c9a6c7795a48fcf12932487bbd6124868768025c7d363a"}
{"code": "for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n    for (j=0; j<=i; j++) { \n      if (i == j) continue; \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n       \n      const double v = ECMcorrelation(arr1,arr2,nt,type); \n      const size_t k=j+i*(i+1)/2; \n      A[k] = v; \n    } \n  }", "pragma": "parallel for private(a j x)", "hash": "0abcd7f3d4eb71c26937fb5234dbfb0502faed801b9ddad175d9c268d3a95d54"}
{"code": "for(size_t i=0; i<obj_hypotheses_groups_.size(); i++) \n        { \n            for(size_t jj=0; jj<obj_hypotheses_groups_[i].size(); jj++) \n            { \n                HVRecognitionModel<ModelT> &rm = *obj_hypotheses_groups_[i][jj]; \n \n                if( !rm.isRejected() ) \n                    computeModelFitness(rm); \n            } \n        }", "pragma": "parallel for ", "hash": "78cf822c318f5dc0a31018ac1dfd4765c03fbcd3daab8c16d2362a134528ba21"}
{"code": "for(size_t i = 1; i < 1+options.pic_size+options.pic_size*options.pic_size; ++i) \n        options.fista_params.indices[i] = i + options.pic_size - 1;", "pragma": "parallel for simd ", "hash": "41de75498bf9be6fb059e04479dca7eed86ae0e6a777b953c76daf80365aa46f"}
{"code": "for (int ii = 1; ii < segments.count(); ii++) { \n        SegmentInfo* Sprev, *S; \n#pragma omp critical \n        { \n            Sprev = &segments[ii - 1]; \n            S = &segments[ii]; \n        } \n        DiskReadMda32 X(timeseries_path); \n        QVector<double> times1, times2; \n        QVector<int> labels1, labels2; \n        get_ending_times_labels(times1, labels1, Sprev->times, Sprev->labels, opts); \n        get_beginning_times_labels(times2, labels2, S->times, S->labels, opts); \n        Mda32 clips1 = extract_clips(X, times1, opts.clip_size); \n        Mda32 clips2 = extract_clips(X, times2, opts.clip_size); \n        int M = clips1.N1(); \n        int T = clips1.N2(); \n        Mda32 templates1 = compute_templates_from_clips_and_labels(clips1, labels1, Sprev->K); \n        Mda32 templates2 = compute_templates_from_clips_and_labels(clips2, labels2, S->K); \n        Mda neighbor_counts(Sprev->K, S->K); \n        Mda counts(S->K, 1); \n        for (int k2 = 1; k2 <= S->K; k2++) { \n            QVector<bigint> inds_k2; \n            for (bigint a = 0; a < labels2.count(); a++) { \n                if (labels2[a] == k2) \n                    inds_k2 << a; \n            } \n            Mda32 template_k2; \n            templates2.getChunk(template_k2, 0, 0, k2 - 1, M, T, 1); \n            Mda32 clips1_aligned = align_clips(clips1, labels1, templates1, template_k2, opts.offset_search_radius); \n            Mda32 clips_k2(M, T, inds_k2.count()); \n            for (bigint a = 0; a < inds_k2.count(); a++) { \n                Mda32 tmp; \n                clips2.getChunk(tmp, 0, 0, inds_k2[a], M, T, 1); \n                clips_k2.setChunk(tmp, 0, 0, a); \n            } \n            Mda32 clips1_aligned_reshaped(M * T, clips1_aligned.N3()); \n            memcpy(clips1_aligned_reshaped.dataPtr(), clips1_aligned.dataPtr(), sizeof(float) * clips1_aligned.totalSize()); \n            Mda32 clips_k2_reshaped(M * T, clips_k2.N3()); \n            memcpy(clips_k2_reshaped.dataPtr(), clips_k2.dataPtr(), sizeof(float) * clips_k2.totalSize()); \n            QTime timer; \n            timer.start(); \n            int num_features = 10; \n            QVector<bigint> neighbor_inds = find_nearest_neighbors(clips1_aligned_reshaped, clips_k2_reshaped, num_features); \n            for (bigint a = 0; a < neighbor_inds.count(); a++) { \n                int k1 = labels1[neighbor_inds[a]]; \n                if (k1 > 0) { \n                    neighbor_counts.set(neighbor_counts.get(k1 - 1, k2 - 1) + 1, k1 - 1, k2 - 1); \n                } \n            } \n            counts.set(inds_k2.count(), k2 - 1); \n        } \n        Mda match_scores(Sprev->K, S->K); \n        for (int k2 = 1; k2 <= S->K; k2++) { \n            for (int k1 = 1; k1 <= Sprev->K; k1++) { \n                double numer = neighbor_counts.get(k1 - 1, k2 - 1); \n                double denom = counts.get(k2 - 1); \n                if (denom) \n                    match_scores.set(numer / denom, k1 - 1, k2 - 1); \n            } \n        } \n \n         \n \n         \n \n         \n \n \n        int num_matches = 0; \n        while (true) { \n            int best_k1 = 0, best_k2 = 0; \n            double best_score = 0; \n            for (int k2 = 1; k2 <= S->K; k2++) { \n                for (int k1 = 1; k1 <= Sprev->K; k1++) { \n                    double score0 = match_scores.value(k1 - 1, k2 - 1); \n                    if (score0 > best_score) { \n                        best_score = score0; \n                        best_k1 = k1; \n                        best_k2 = k2; \n                    } \n                } \n            } \n            if (best_score > opts.match_score_threshold) { \n                for (int k1 = 1; k1 <= Sprev->K; k1++) { \n                    match_scores.setValue(0, k1 - 1, best_k2 - 1); \n                } \n                for (int k2 = 1; k2 <= S->K; k2++) { \n                    match_scores.setValue(0, best_k1 - 1, k2 - 1); \n                } \n                qDebug().noquote() << QString(\"Matching %1 to %2 in segment %3 (score=%4)\").arg(best_k1).arg(best_k2).arg(ii).arg(best_score); \n                num_matches++; \n                S->label_map_with_previous[best_k2] = best_k1; \n                Mda32 template1, template2; \n                templates1.getChunk(template1, 0, 0, best_k1 - 1, M, T, 1); \n                templates2.getChunk(template2, 0, 0, best_k2 - 1, M, T, 1); \n                double corr; \n                int offset2; \n                compute_sliding_correlation_between_templates(corr, offset2, template1, template2, opts.offset_search_radius); \n                S->time_offset_map_with_previous[best_k2] = offset2; \n            } \n            else \n                break; \n        } \n        qDebug().noquote() << QString(\"Matched %1 of %2 clusters in segment %3\").arg(num_matches).arg(S->K).arg(ii); \n    }", "pragma": "parallel for ", "hash": "8ebc0b69a70d2fad78902e03bca32fdaa87bff5be2c3531ab767fab3b9fb8b7b"}
{"code": "for( i = 0 ; i < size[0] ; i++ ) { \n      result[i] = trtr[i] = 0.0 ; \n    }", "pragma": "parallel for private(i)", "hash": "e7398147698eca4b75fa314e161ed3cc2e779c89778b2a1d7f887f31fc8ab7b6"}
{"code": "for (k = 0; k < ths->M_total; k++) \n    { \n      int u[ths->d], o[ths->d];  \n \n      int t, t2;  \n \n      int l_L;  \n \n      int l[ths->d];  \n \n      int lj[ths->d];  \n \n      int ll_plain[ths->d+1];  \n \n      R phi_prod[ths->d+1];  \n \n      int j = (ths->nfft_flags & NFFT_SORT_NODES) ? ths->index_x[2*k+1] : k; \n \n      phi_prod[0] = K(1.0); \n      ll_plain[0] = 0; \n \n      MACRO_init_uo_l_lj_t; \n \n      for (l_L = 0; l_L < lprod; l_L++) \n      { \n        C *lhs; \n        R *lhs_real; \n        C val; \n \n        MACRO_update_phi_prod_ll_plain(with_PRE_PSI); \n \n        lhs = ths->g + ll_plain[ths->d]; \n        lhs_real = (R*)lhs; \n        val = phi_prod[ths->d] * ths->f[j]; \n \n        #pragma omp atomic \n        lhs_real[0] += creal(val); \n \n        #pragma omp atomic \n        lhs_real[1] += cimag(val); \n \n        MACRO_count_uo_l_lj_t; \n      }  \n \n    }", "pragma": "parallel for private(k)", "hash": "ad0e54932f4aac45b10af840c7f72c650afaaa0ced2e247ffe12fe795879fcf3"}
{"code": "for (int x1 = 1; (x1 <= 8); x1 = (x1 + 1)) \n    { \n      #pragma ivdep \n      for (int x2 = 1; (x2 <= 8); x2 = (x2 + 1)) \n      { \n        int x3; \n        x3 = _out_grid_array_macro(x1, x2); \n         _my_out_grid[x3] = (_my_out_grid[x3] - _my_in_grid[_in_grid_array_macro((x1 + 0), (x2 + -1))]); \n         _my_out_grid[x3] = (_my_out_grid[x3] - _my_in_grid[_in_grid_array_macro((x1 + -1), (x2 + 0))]); \n         _my_out_grid[x3] = (_my_out_grid[x3] - _my_in_grid[_in_grid_array_macro((x1 + 1), (x2 + 0))]); \n         _my_out_grid[x3] = (_my_out_grid[x3] - _my_in_grid[_in_grid_array_macro((x1 + 0), (x2 + 1))]); \n      } \n    }", "pragma": "parallel for ", "hash": "b21c31eb0582c51ac9d452a35a92049b461c15092bfce432d0c4dc5eeca78b17"}
{"code": "for (std::size_t p = 0; p < this_size; ++p) \n    *(_data + p) = (*(_data + p)) * scalar;", "pragma": "parallel for ", "hash": "e49597da9fafa2b78149081c580aa8bc039eba9b71b7fa1ec91aa41f732c873a"}
{"code": "for(int r=0; r<fourthPoints.size(); r++) \n    { \n         res.SetIdentity(); Matrix33f rot; rot.SetIdentity(); \n \n        std::vector<Point3f> ref; std::vector<Point3f> refN; \n        std::vector<Point3f> toAl; std::vector<Point3f> toAlN; \n        corrs[3].second=fourthPoints[r].ind; \n        for (int i=0; i<4; i++) \n        { \n            vcg::Point3f r,rN; \n            r=reference.model->cm.vert[corrs[i].second].P(); \n            rN=reference.model->cm.vert[corrs[i].second].N(); \n            ref.push_back(r); \n            refN.push_back(rN); \n \n            vcg::Point3f a, aN; \n            a=toAlign.model->cm.vert[corrs[i].first].P(); \n            aN=toAlign.model->cm.vert[corrs[i].first].N(); \n            toAl.push_back(a); \n            toAlN.push_back(aN); \n \n        } \n         \n \n        ComputeSimilarityMatchMatrix(ref, toAl, res); \n        bool okNorm=true; \n         \n \n        rot[0][0]=res[0][0];rot[0][1]=res[0][1];rot[0][2]=res[0][2];rot[1][0]=res[1][0];rot[1][1]=res[1][1];rot[1][2]=res[1][2];rot[2][0]=res[2][0];rot[2][1]=res[2][1];rot[2][2]=res[2][2]; \n        for (int i=0; i<4; i++) \n        { \n            vcg::Point3f normToAlign=rot*toAlN[i]; \n            float angle=Utils::angleNorm<float>(refN[i],normToAlign); \n            if (angle>20) \n            { \n                okNorm=false; \n                break; \n            } \n \n        } \n         \n \n        if (okNorm) \n        { \n            float totError=0; float error; \n            for (int i=0; i<4; i++) \n            { \n                vcg::Point4f rotToAlign=res*vcg::Point4f(toAl[i].X(),toAl[i].Y(),toAl[i].Z(),1); \n                error=Distance(ref[i],vcg::Point3f(rotToAlign[0],rotToAlign[1],rotToAlign[2])); \n                totError+=error; \n            } \n#pragma omp critical \n            { \n                if (totError<bestError && isScaleOk(scale,getScaleFromTransf(res),toAlign.multiplier)) \n                { \n                    std::cout << \"Error after alignment \" << totError/4.0f << std::endl; \n                    bestError=totError/4.0f; \n \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "7e310739c9181c5cce3b1343220bf15e8a2750fd58db289facd9b258607b9b0f"}
{"code": "for (int y = info.offy; y < info.offy + info.height; y++)\r \n\t\t{\r \n\t\t\tint offsetBuf = (y-info.offy)*info.width*4;\r \n\t\t\tint offset = y * mipMapSize[info.level].width() + info.offx;\r \n\t\t\tfor (int x = info.offx; x < info.offx + info.width; x++)\r \n\t\t\t{\r \n\t\t\t\tfloat diff = applyModel(normalsPtr[offset], normalsLPtr[offset], info.light);\r \n\t\t\t\tbuffer[offsetBuf + 0] = tobyte(redPtr[offset].evalPoly(lVec)* diff);  \r \n\t\t\t\tbuffer[offsetBuf + 1] = tobyte(greenPtr[offset].evalPoly(lVec)* diff);\r \n\t\t\t\tbuffer[offsetBuf + 2] = tobyte(bluePtr[offset].evalPoly(lVec)* diff);\r \n\t\t\t\tbuffer[offsetBuf + 3] = 255;\r \n\t\t\t\toffsetBuf += 4;\r \n\t\t\t\toffset++;\r \n\t\t\t}\r \n\t\t}", "pragma": "parallel for ", "hash": "c1308d4ccaaa029b06a12bc902cb703b81f38727fed9e82ee5c2ae6496093750"}
{"code": "for (int i=1; i<Nint; ++i) { \n      double xx = kLin[0]+i*hh; \n      double kk = exp(xx); \n      double ap = cos(M_PI/2.*exp(xx-lkmax)); \n      double sk1,sk2; \n      switch (itype) { \n        case 0: sk1=sk2=1.0;                     break; \n        case 1: sk1=sk2=1.0-exp(-kk*kk*Rf*Rf/2); break; \n        case 2: sk1=sk2=   -exp(-kk*kk*Rf*Rf/2); break; \n        case 3: sk1=    1.0-exp(-kk*kk*Rf*Rf/2); \n                sk2=       -exp(-kk*kk*Rf*Rf/2); break; \n        default: \n          std::cerr<<\"Unknown itype=\"<<itype<<\" in calcQfuncs.\"<<std::endl; \n          myexit(1); \n      } \n      int    jj = (int)(i*hh*dkinv); \n      if (jj>=pLin.size()-2) jj=pLin.size()-2; \n      double pk = exp(pLin[jj]+(xx-kLin[jj])* \n                     (pLin[jj+1]-pLin[jj])/(kLin[jj+1]-kLin[jj])); \n      std::vector<double> jl=sphBess(kk*q); \n      int wt = 2+2*(i%2); \n      sum0 += kk*pk*sk1*sk2*(        jl[1])*wt;\t \n \n      sum1 += kk*pk*sk1*sk2*(jl[0]-2*jl[1])*wt;\t \n \n      sum2 +=-kk*pk*  1*sk2*(kk*kk*q*jl[1])*wt;\t \n \n      sum3 += kk*pk* ap*  1*(kk*kk*  jl[0])*wt;\t \n \n    }", "pragma": "parallel for reduction(+:sum0 sum1 sum2 sum3) ", "hash": "79664cb0099c5788bda5ccf32da2bb9c5536943189558899b4b45c12a507dad3"}
{"code": "for(ix=nfd; ix<nfd+2*pmlsize+nx; ix++){ \n\t\tfor(iz=nfd; iz<nfd+pmlsize; iz++){ \n\t\t\tpml_fvxz \n\t\t} \n\t}", "pragma": "parallel for private(ix iz)", "hash": "3f0cbde7a605b37402993c7ac56ba00f42eddc344adb48117bcac5134f2202d0"}
{"code": "for(index i = 0; i < mat.nbrows*bs; i++) { \n\t\t\tzz[i] = scale[i]*rr[i]; \n\t\t}", "pragma": "parallel for simd ", "hash": "b0a68d2899ad166bf71c19b43686c23deb7ab10032a4a38322ad8b8c8eb5b335"}
{"code": "for (int task=0; task<funcs_.size(); ++task) { \n        if (gather_stats_ && task==0) { \n          stats_[\"max_threads\"] = omp_get_max_threads(); \n          stats_[\"num_threads\"] = omp_get_num_threads(); \n        } \n        task_allocation[task] = omp_get_thread_num(); \n        task_starttime[task] = omp_get_wtime(); \n \n         \n \n        evaluateTask(task); \n \n        task_endtime[task] = omp_get_wtime(); \n        task_cputime[task] =  task_endtime[task] - task_starttime[task]; \n        task_order[task] = cnt++; \n      }", "pragma": "parallel for private(cnt)", "hash": "c02645c5a7b6df4bdcbabb28ca1f701768983ad81a7bf3f05abdd649c40ff243"}
{"code": "for (int i = 0; i < nReaches; ++i) \n        { \n            int reachIndex = it->second[i];  \n \n            vector<int> &vecCells = m_reachs[reachIndex]; \n            int n = vecCells.size(); \n            for (int iCell = 0; iCell < n; ++iCell) \n            { \n                ChannelFlow(reachIndex, iCell, vecCells[iCell]); \n            } \n            m_qSubbasin[reachIndex] = m_qCh[reachIndex][n - 1]; \n        }", "pragma": "parallel for ", "hash": "d931c1619d5c0e9ce801fc59dd38ff1dd4c0dd5dc254d1b32be86ceb5b5e105b"}
{"code": "for(int i = 0; i < num; i++) { \n        face[i] = (int) face_arr[i] - 1; \n        type[i] = (char*) mxMalloc(20*sizeof(char)); \n        mxArray *cell = mxGetCell(mxGetField(bc_struct, 0, \"type\"), i); \n        mxGetString(cell, type[i], 20*sizeof(char)); \n    }", "pragma": "parallel for ", "hash": "9f7c622ac440fbcf3d7a73cbe160da6f5111c7cf4a8c94a2bec33b538000f727"}
{"code": "for (int j = 0; j < rangey; j++) \n\t\t{ \n\t\t\tMat diff; \n\t\t\tMat odiff; \n\t\t\tfor (int i = 0; i < rangex; i++) \n\t\t\t{ \n\t\t\t\tint count = j*rangex + i; \n\t\t\t\tcost[count] = Mat::zeros(cim.size(), CV_32S); \n\t\t\t\tocost[count] = Mat::zeros(cim.size(), CV_32S); \n \n\t\t\t\tfor (int c = 0; c < cn; c++) \n\t\t\t\t{ \n\t\t\t\t\twarpShift(v1[c], diff, (i + minx), (j + miny), BORDER_REPLICATE); \n\t\t\t\t\tabsdiff(diff, v0[c], diff); \n\t\t\t\t\tadd(diff, cost[count], cost[count], noArray(), CV_32S); \n \n\t\t\t\t\twarpShift(v0[c], odiff, -(i + minx), -(j + miny), BORDER_REPLICATE); \n\t\t\t\t\tabsdiff(odiff, v1[c], odiff); \n\t\t\t\t\tadd(odiff, ocost[count], ocost[count], noArray(), CV_32S); \n \n\t\t\t\t\twarpShift(s1[c], diff, (i + minx), (j + miny), BORDER_REPLICATE); \n\t\t\t\t\tabsdiff(diff, s0[c], diff); \n\t\t\t\t\tadd(a*diff, cost[count], cost[count], noArray(), CV_32S); \n \n\t\t\t\t\twarpShift(s0[c], odiff, -(i + minx), -(j + miny), BORDER_REPLICATE); \n\t\t\t\t\tabsdiff(odiff, s1[c], odiff); \n\t\t\t\t\tadd(a*odiff, ocost[count], ocost[count], noArray(), CV_32S); \n\t\t\t\t} \n \n\t\t\t\tblur(cost[count], cost[count], ksize); \n\t\t\t\t \n \n\t\t\t\tblur(ocost[count], ocost[count], ksize); \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "16b1cb1f5c1dfe672b8d2255b98aa3a6f8ca96ce0b0f627f32fc8c36b5bc8301"}
{"code": "for(int ichan = 0; ichan < numChannels; ichan++){ \n     int hpDim,phDim,hpIndex,phIndex; \n     double vpqrs; \n \n     hpDim = 0; \n     for(int i = 0; i < fermiLevel; i++){ \n       for(int a = fermiLevel; a < Nspstates; a++){ \n\t if( SPbasis->checkChanSym(i,a,ichan) == 1 ){\t   \n\t   hpDim++;\t\t   \n\t }  \n \n       }  \n \n     }  \n \n \n     phDim = 0; \n     for(int a = fermiLevel; a < Nspstates; a++){ \n       for(int i = 0; i < fermiLevel; i++){ \n\t if( SPbasis->checkChanSym(a,i,ichan) == 1 ){\t   \n\t   phDim++;\t\t   \n\t }  \n \n       }  \n \n     }  \n \n \n     memoryUsed+= hpDim*phDim; \n     vnn.hpph[ichan].allocate(hpDim,phDim); \n     vnn.hpph[ichan].zeros(); \n\t     \t     \n     hpIndex = 0; \n     for(int i = 0; i < fermiLevel; i++){ \n       for(int a = fermiLevel; a < Nspstates; a++){ \n\t if( SPbasis->checkChanSym(i,a,ichan) == 1 ){ \n\t   phIndex = 0; \n\t   for(int b = fermiLevel; b < Nspstates; b++){ \n\t     for(int j = 0; j < fermiLevel; j++){\t    \t     \n\t       if( SPbasis->checkChanSym(b,j,ichan) == 1 ){ \n\t\t vpqrs = calcVpqrs(i,a,b,j,SPbasis); \n\t\t vnn.hpph[ichan].setElement(hpIndex,phIndex,vpqrs); \n\t\t vnn.hpph[ichan].rowMap[hpIndex][0] = i;\t\t \n\t\t vnn.hpph[ichan].rowMap[hpIndex][1] = a; \n\t\t vnn.hpph[ichan].colMap[phIndex][0] = b; \n\t\t vnn.hpph[ichan].colMap[phIndex][1] = j; \n\t\t phIndex++;\t\t\t \n\t       }  \n \n\t     }  \n \n\t   }  \n \n\t   hpIndex++; \n\t }  \n \n       }  \n \n     }  \n \n   \n   }", "pragma": "parallel for reduction(+:memoryused) ", "hash": "2620796712cea2bb7b0ffbd83cd3a8ccae269bcd1931f1b524bdf67c60989db3"}
{"code": "for (i = 0; i < npnts; i++) { \n                if (DEFINED_VAL(data[i]) && DEFINED_VAL(save->u_val[i])) { \n                    data_in[i] = save->u_val[i]; \n                    data_in[i+npnts] = data[i]; \n                    bitmap[i] = 1; \n\t\t} \n\t\telse { \n                    data_in[i] = data_in[i + npnts] = 0.0; \n                    bitmap[i] = 0; \n\t\t} \n\t    }", "pragma": "parallel for private(i)", "hash": "a75a2f03b18dcf4aebc60aa172167952f620b154dbbafe2c5e45920d6d1ba4dd"}
{"code": "for (int64_t j = 0; j < int64_t(m_visNorm.size()); j++) { \n        m_visWs->mutableY(j) /= m_visNorm[j]; \n      }", "pragma": "for ", "hash": "21f5c6610a9cbf51d3a2b703acef09d1a471dd32b3b54172da50e234827bb65b"}
{"code": "for (int i = 0; i < (int)numParticles; i++) \n\t\t{ \n\t\t\tm_RL[i] = m_rotations[i].transpose() * m_L[i]; \n\t\t}", "pragma": "for ", "hash": "043a0ca730a31752a45142ba8ee326f9d296e9f2451dd69ff92bf745b078aaa2"}
{"code": "for(size_t y = 0; y < oheight; y++) \n  { \n    const size_t iindex = y * iwidth + ioffset; \n    const size_t oindex = y * owidth; \n    memcpy(output + oindex, input + iindex, sizeof(float) * owidth); \n  }", "pragma": "parallel for ", "hash": "0133f0563d07ba14b90e68d6fa40d34916201de70fc5425357fd4cf4ef0f7495"}
{"code": "for (int i=0; i < m_lastMacroBlock; i++) {\r \n\t\t\t\tm_macroBlocks[i]->BitplaneEncode();\r \n\t\t\t}", "pragma": "parallel for ", "hash": "3a006d47a51b45114b7d8e8d65c04bc96b50d10930a3ccff243a2d22762a0bea"}
{"code": "for (int i = 0; i < 10; ++i) { \n    for (int j = 0; j < 10; ++j) { \n#pragma omp ordered depend  \n \n#pragma omp ordered depend(  \n \n#pragma omp ordered depend(source  \n \n#pragma omp ordered depend(sink  \n \n#pragma omp ordered depend(sink :  \n \n#pragma omp ordered depend(sink : i  \n \n#pragma omp ordered depend(sink : i)  \n \n#pragma omp ordered depend(source) \n                           if (i == j) \n#pragma omp ordered depend(source)  \n \n                             ; \n                           if (i == j) \n#pragma omp ordered depend(sink : i, j)  \n \n                             ; \n#pragma omp ordered depend(source) threads  \n \n#pragma omp ordered simd depend(source)  \n \n#pragma omp ordered depend(source) depend(source)  \n \n#pragma omp ordered depend(in : i)  \n \n#pragma omp ordered depend(sink : i, j) allocate(i)  \n \n#pragma omp ordered depend(sink : j, i)  \n \n#pragma omp ordered depend(sink : i, j, k)  \n \n#pragma omp ordered depend(sink : i+foo(), j/4)  \n \n \n \n#pragma omp ordered depend(sink : i*0, j-4) \n \n#pragma omp ordered depend(sink : i-0, j+sizeof(int)) depend(sink : i-0, j+sizeof(int)) \n#pragma omp ordered depend(sink : i-0, j+sizeof(int)) depend(source)  \n \n#pragma omp ordered depend(source) depend(sink : i-0, j+sizeof(int))  \n \n    } \n  }", "pragma": "parallel for ", "hash": "a59432fada82595658665f9fe238b7d9d657ae6cb6dab93f8e2cfed243ed5928"}
{"code": "for (i = 0; i < iScanSize; i++) { \n\t\t\tvpAllMS2Scans.at(i)->sumIntensity(); \n\t\t}", "pragma": "parallel for ", "hash": "6a73962438a4fae5028fe0a3e1bb0ed27da96d212a08898e17d070005d9a6c6f"}
{"code": "for (Nd4jLong i = 0; i < length; i++) { \n \n                for (Nd4jLong ar = 0; ar < n; ar++) { \n                    z[i] += x[ar][i] / n; \n                } \n            }", "pragma": "parallel for simd ", "hash": "efccc1d7497a2ae274f61637c0858c5147350a619b1add66919ec4a5e968ee2b"}
{"code": "for (int c = 1; c <= grid.NGM; c++) \n\t{ \n\t\tCFD::VariableChange::From_Q(CFD_variabletype, grid.cells_ghost[c].data1D(indexQ), grid.cells_ghost[c].data1D(indexV), grid.cells_ghost[c].data1D(indexW), grid.cells_ghost[c].data1D(indexMIX), grid.cells_ghost[c].data1D(indexXs), grid.cells_ghost[c].data1D(indexYs), species_set, grid.ND, CFD_NT); \n\t\t \n \n\t}", "pragma": "parallel for ", "hash": "f0f43745c3da3bbaa8a9d32ddbfdc411799236fa7af817b48c085d98036b5828"}
{"code": "for (int i = 0; i < 100000000; i++) { \n    auto v = \n        __atomic_add_fetch(&glo, 1, std::memory_order::memory_order_relaxed); \n    __atomic_add_fetch(&tot, v, std::memory_order_relaxed); \n  }", "pragma": "parallel for ", "hash": "8696efd588f3cd79e60d63ace1122d6137d52575153f7371053330a590a836c6"}
{"code": "for (i = 0; i < sz; i++) \n        out_tensor[i] = sqrt(in_tensor[i]);", "pragma": "parallel for private(i)", "hash": "387fec3dcf2f1ffa47627745f4183ba54a8f10b552cc7bc3b74ac74f1ef1ad52"}
{"code": "for (ompIndexType i = 0; i < planes; i++) { \n        for (ompIndexType j = 0; j < planesize; j++) { \n            accum = 1; \n            if (reverse) { \n                for (ompIndexType k = linesize - 1; k >= 0; --k) { \n                    accum *= sp[i * planesize * linesize + j + k * planesize] ? 1. : 0.; \n                    dp[i * planesize * linesize + j + k * planesize] = accum; \n                } \n            } else { \n                for (ompIndexType k = 0; k < linesize; k++) { \n                    accum *= sp[i * planesize * linesize + j + k * planesize] ? 1. : 0.; \n                    dp[i * planesize * linesize + j + k * planesize] = accum; \n                } \n            } \n        } \n    }", "pragma": "parallel for reduction(+ : accum) ", "hash": "21297f001063610cf9435c67e84b1abcad20f71e30bb57128c3a57b0f53fa5f5"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t(*res)[i] = ((*this)[i] == \"\")? 1 : 0;", "pragma": "for ", "hash": "16684ef9d1623ed015b9f6807ba518077b1311515d44e638f7654cb47d158d27"}
{"code": "for (y = startY; y < endY; y++) { \n                for (int x = startX; x < endX; x+=4) { \n                     \n                    random_r(&rand_state[omp_get_thread_num()], &rands[0]); \n                    random_r(&rand_state[omp_get_thread_num()], &rands[1]); \n                    random_r(&rand_state[omp_get_thread_num()], &rands[2]); \n                    random_r(&rand_state[omp_get_thread_num()], &rands[3]); \n                    random_r(&rand_state[0], &rands[0]); \n                    random_r(&rand_state[0], &rands[1]); \n                    random_r(&rand_state[0], &rands[2]); \n                    random_r(&rand_state[0], &rands[3]); \n                    cell_auto(f, x, y, f->oldGrid[y][x].status, &rands[0]); \n                    cell_auto(f, x+1, y, f->oldGrid[y][x+1].status, &rands[1]); \n                    cell_auto(f, x+2, y, f->oldGrid[y][x+2].status, &rands[2]); \n                    cell_auto(f, x+3, y, f->oldGrid[y][x+3].status, &rands[3]); \n                    } \n                }", "pragma": "parallel for private(rands)", "hash": "834fb188a165ae0356e907d6c989d32e636d4d322edc41390065d3c12c79629f"}
{"code": "for (ompIndexType k = 0; k < elementCount; k++) { \n            elements[k] = ArrayOf::emptyConstructor(); \n        }", "pragma": "parallel for ", "hash": "76bce95a621f8ffb837a9ef6a93f2b86d3d875504f0dadcf65e862104b76b895"}
{"code": "for(int j=0; j<roi_out->height; j++) \n    { \n      int i=0; \n      const uint16_t *in = ((uint16_t *)ivoid) + j*roi_out->width; \n      float *out = ((float*)ovoid) + j*roi_out->width; \n \n       \n \n      for ( ; i < ((4-(j*roi_out->width & 3)) & 3) ; i++,out++,in++) \n        *out = *in * coeffsi[FC(j+roi_out->y, i+roi_out->x, filters)]; \n \n      const __m128 coeffs = _mm_set_ps(coeffsi[FC(j+roi_out->y, roi_out->x+i+3, filters)], \n                                       coeffsi[FC(j+roi_out->y, roi_out->x+i+2, filters)], \n                                       coeffsi[FC(j+roi_out->y, roi_out->x+i+1, filters)], \n                                       coeffsi[FC(j+roi_out->y, roi_out->x+i  , filters)]); \n \n       \n \n      for( ; i < roi_out->width - 3 ; i+=4,out+=4,in+=4) \n      { \n        _mm_stream_ps(out,_mm_mul_ps(coeffs,_mm_set_ps(in[3],in[2],in[1],in[0]))); \n      } \n \n       \n \n      for( ; i<roi_out->width; i++,out++,in++) \n        *out = *in * coeffsi[FC(j+roi_out->y, i+roi_out->x, filters)]; \n    }", "pragma": "parallel for ", "hash": "6d9d2573a47f39a8e223784e2e54ea410e698252a21d634b7115fec78065438f"}
{"code": "for (integer i=0; i < loclen; i++) \n    sum += xd[i] * yd[i];", "pragma": "parallel for reduction(+: sum) ", "hash": "d0a35351bb4e0d265e4a4f4df5da6d777aece67c729deac7258df6cfe4717fec"}
{"code": "for (uint spt = 0; spt < nSpts; spt++) { \n      for (uint e = 0; e < nEles; e++) { \n        double A = gridV_spts(spt,e,1)*Jac_spts(1,spt,e,0) - gridV_spts(spt,e,0)*Jac_spts(1,spt,e,1); \n        double B = gridV_spts(spt,e,0)*Jac_spts(0,spt,e,1) - gridV_spts(spt,e,1)*Jac_spts(0,spt,e,0); \n        for (uint k = 0; k < nFields; k++) { \n          dF_spts(0,0)(spt,e,k) =  dF_spts(0,0)(spt,e,k)*Jac_spts(1,spt,e,1) - dF_spts(0,1)(spt,e,k)*Jac_spts(1,spt,e,0) + dU_spts(0,spt,e,k)*A; \n          dF_spts(1,1)(spt,e,k) = -dF_spts(1,0)(spt,e,k)*Jac_spts(0,spt,e,1) + dF_spts(1,1)(spt,e,k)*Jac_spts(0,spt,e,0) + dU_spts(1,spt,e,k)*B; \n          divF_spts[step](spt,e,k) = dF_spts(0,0)(spt,e,k) + dF_spts(1,1)(spt,e,k); \n        } \n      } \n    }", "pragma": "parallel for ", "hash": "6df8d61a57eb8efd45befd2eb573ed25e95c219507ad267321712bb2fb029759"}
{"code": "for(ic=0;ic<nc;ic++){ if(ccin[ic]) {  \n \n        if(pos){ \n          EICLOOP( img[ic][iht][ihx][ihz] += \n             opr    [pct][pcx][pcz] * \n             wfl    [mct][mcx][mcz];); \n        }else{ \n          EICLOOP( img[ic][iht][ihx][ihz] += \n             opr    [mct][mcx][mcz] * \n             wfl    [pct][pcx][pcz];); \n        } \n        } \n      }", "pragma": "parallel for private(                    ic iht ihx ihz mct mcx mcz pct pcx pcz)", "hash": "e7fc2ccd558c741248dd189c8ef19d47bdddee6b4547f715436db93219de912c"}
{"code": "for(long i=0;i<long(glyphs.size());i++)\r \n\t{\r \n\t\tmglGlyphDescr &g = glyphs[i];\r \n\t\tg.numl[1] = g.numl[2] = g.numl[3] = g.numl[0];\r \n\t\tg.numt[1] = g.numt[2] = g.numt[3] = g.numt[0];\r \n\t\tg.ln[1] = g.ln[2] = g.ln[3] = g.ln[0];\r \n\t\tg.tr[1] = g.tr[2] = g.tr[3] = g.tr[0];\r \n\t\tg.width[1] = g.width[2] = g.width[3] = g.width[0];\r \n\t}", "pragma": "parallel ", "hash": "f3ab5b5e79075e71610b71e9a01d579ac58b0ee398c9aa85116c25a8fe8332f4"}
{"code": "for (int p = 0; p < Partitions.Len(); p++) {\r \n    TNGraphMP::TEdgeI EdgeI = Partitions[p].GetVal1();\r \n    TNGraphMP::TEdgeI EndI = Partitions[p].GetVal2();\r \n     \n \n    int start = T->GetEmptyRowsStart(PartitionSizes[p]);\r \n    while (EdgeI < EndI) {\r \n      T->IntCols[0][start] = EdgeI.GetSrcNId();\r \n      T->IntCols[1][start] = EdgeI.GetDstNId();\r \n      EdgeI++;\r \n      if (EdgeI < EndI) { T->Next[start] = start+1;}\r \n      start++;\r \n    }\r \n  }", "pragma": "parallel for ", "hash": "2799a455ad3a391265f4501bfa5cb5be079b83b9968f9e464a21147732e7e01b"}
{"code": "for(unsigned i=0;i<narg;++i){ \n    double mean = 0.; \n    Value* v=getPntrToComponent(i); \n    for(unsigned j=0;j<ens_dim;++j) { \n      const unsigned index = j*narg+i; \n      setDerivative(v, index, fact); \n      mean += fact*getArgument(index); \n    } \n    v->set(mean); \n  }", "pragma": "parallel for ", "hash": "17f9c4b7f73dfe17e4aaa7596a1d31967b77795b44e21ec0f2af5df5303d7998"}
{"code": "for (int b = 0; b < m_nbands; ++b) { \n                    mp_locparams[i*ndata+b*2+0] = p_params[b*m_nparams+0] * pa; \n                    mp_locparams[i*ndata+b*2+1] = p_params[b*m_nparams+1] * pa * p_fac[i]; \n                }", "pragma": "parallel for ", "hash": "82aa1c243520cd5d8baaa461829022b7024ce37751c5733e301ea49d2ca2b94e"}
{"code": "for(i=0; i<binx; i++) \n\t{ \n\t\tfor(j=0; j<biny; j++) \n\t  \t{ \n\t\t\taux_ind = get_ind(i,j,binx); \n\t  \t\t \n \n\t  \t\t\t \n \n\t  \t\t\tfor(foo=1; foo<order_atom_num1-1; foo++) \n\t  \t\t\t{ \n\t  \t\t\t\tfill_grid_order(dirx,diry,dirz,binx,nliptop,nlipbot, \n\t  \t\t\t\t  pbc,i,j,bin_sizex,bin_sizey,aux_ind, \n\t  \t\t\t\t  lip_ind,k,l,top_ind, \n\t  \t\t\t\t  order_grid_up_sn1,order_grid_down_sn1, \n\t  \t\t\t\t  is_prot,bot_ind,frame.x, \n\t  \t\t\t\t  idlip,nprot_top_order1,ptop_ind_order1,pbot_ind_order1, \n\t  \t\t\t\t  nprot_bot_order1,idorder1, \n\t  \t\t\t\t  order_atom_num1,foo, \n\t  \t\t\t\t  order_lip1,lipidCOM,z_mid,order_val, \n\t  \t\t\t\t  grid_up_order1[foo-1],grid_down_order1[foo-1],scale, left_x, left_y, order_count_sn1_up, order_count_sn1_down); \n\t  \t\t\t } \n\t  \t\t\t  \n \n\t  \t\t\t for(foo=1; foo<order_atom_num2-1; foo++) \n\t  \t\t\t { \n\t  \t\t\t\t fill_grid_order(dirx,diry,dirz,binx,nliptop,nlipbot, \n\t  \t\t\t\t  pbc,i,j,bin_sizex,bin_sizey,aux_ind, \n\t  \t\t\t\t  lip_ind,k,l,top_ind, \n\t  \t\t\t\t  order_grid_up_sn2,order_grid_down_sn2, \n\t  \t\t\t\t  is_prot,bot_ind,frame.x, \n\t  \t\t\t\t  idlip,nprot_top_order2,ptop_ind_order2,pbot_ind_order2, \n\t  \t\t\t\t  nprot_bot_order2,idorder2, \n\t  \t\t\t\t  order_atom_num2,foo, \n\t  \t\t\t\t  order_lip2,lipidCOM,z_mid,order_val, \n\t  \t\t\t\t  grid_up_order2[foo-1],grid_down_order2[foo-1],scale, left_x, left_y, order_count_sn2_up, order_count_sn2_down); \n\t  \t\t\t } \n\t  \t} \n\t}", "pragma": "for private(aux_ind foo j)", "hash": "5be0c60c03a8273aacff40fd3e6fa6b9d8c46afa0a8d2afe181f58a5b358630e"}
{"code": "for (j = 0; j < num_values; j++) \n         data[j] += values[j];", "pragma": "parallel for private(j)", "hash": "f4c0de9f9f016c7a72839857f38452a58bc35c2016a59f814b9ab590bddcebb7"}
{"code": "for (i = 0; i < n; ++i) \n        { \n          if (cf_markers[i] > 0)  \n \n            ++p_rows_ptr[i + 1];  \n \n \n          else  \n \n            { \n              j1 = a_rows_ptr[i]; \n              j2 = a_rows_ptr[i + 1]; \n              n_cur_connections = 0; \n \n               \n \n              for (j = j1; j < j2; ++j) \n                { \n                  if (s_markers[j]) \n                    { \n                      cl = a_cols_ind[j]; \n                      if (cf_markers[cl] > 0) \n                        { \n                          for (k = 0, match = 0; k < n_cur_connections; k++) \n                            { \n                              if (cur_connections[k] == cl) \n                                { \n                                  match = 1; \n                                  break; \n                                } \n                            } \n                          if (!match) \n                            { \n                              cur_connections[n_cur_connections] = cl; \n                              ++p_rows_ptr[i + 1]; \n                              ++n_cur_connections; \n                            } \n                        } \n                      else  \n \n                        { \n                          jj1 = a_rows_ptr[cl]; \n                          jj2 = a_rows_ptr[cl + 1]; \n                          for (jj = jj1; jj < jj2; ++jj) \n                            { \n                              if (s_markers[jj]) \n                                { \n                                  cl2 = a_cols_ind[jj]; \n                                  if (cf_markers[cl2] > 0) \n                                    { \n                                      for (k = 0, match = 0; k < n_cur_connections; k++) \n                                        { \n                                          if (cur_connections[k] == cl2) \n                                            { \n                                              match = 1; \n                                              break; \n                                            } \n                                        } \n                                      if (!match) \n                                        { \n                                          cur_connections[n_cur_connections] = cl2; \n                                          ++p_rows_ptr[i + 1]; \n                                          ++n_cur_connections; \n                                        } \n                                    } \n                                } \n                            } \n                        } \n                    } \n                } \n            } \n        }", "pragma": "for ", "hash": "8f9f2748ad3845209568c6342ca4c49939d3aebce991646114dea2fe57b31edb"}
{"code": "for (int i=0; i < numMyRows; i++) { \n      int prevOffset = IndexOffset[i]; \n      int NumEntries = IndexOffset[i+1] - prevOffset; \n      int *    RowIndices = Indices+prevOffset; \n      double * RowValues  = values+prevOffset; \n      for (int k=0; k<NumVectors; k++) { \n  double sum = 0.0; \n  const double * const x = xp[k]; \n  double * const y = yp[k]; \n  for (int j=0; j < NumEntries; j++) sum += RowValues[j] * x[RowIndices[j]]; \n  y[i] = sum; \n      } \n    }", "pragma": "parallel for ", "hash": "6f29a58df900c3df0f7b1656a6206abde1c04cf25bc7bfcf3343f76c53ae5c5f"}
{"code": "for (const int (*map)[4] = maps; map < &maps[nmaps]; ++map) { \n    const int ijshift = (*map)[0] * totstates; \n    const int target_state1 = (*map)[1] - states1_b; \n    const int orig_state1 = (*map)[2]; \n    const double complex parity = (*map)[3]; \n    blasfunc->zaxpy(&states_num, \n                    &parity, \n                    &input[orig_state1 * INC2 + states2_b], \n                    &ONE, \n                    &output[ijshift +  target_state1 * INC], \n                    &SHIFT); \n  }", "pragma": "parallel for ", "hash": "6ca63811366635aaced280cd02c8ea5417771ecb7401ef7137c141f297e215f2"}
{"code": "for (x=0; x < (long) image->columns; x++) \n    { \n      if ((channel & RedChannel) != 0) \n        { \n          pixel.red=pixels[x].red-(MagickRealType) unsharp_pixels[x].red; \n          if (fabs(2.0*pixel.red) < quantum_threshold) \n            pixel.red=(MagickRealType) pixels[x].red; \n          else \n            pixel.red=(MagickRealType) pixels[x].red+(pixel.red*amount); \n          unsharp_pixels[x].red=RoundToQuantum(pixel.red); \n        } \n      if ((channel & GreenChannel) != 0) \n        { \n          pixel.green=pixels[x].green-(MagickRealType) unsharp_pixels[x].green; \n          if (fabs(2.0*pixel.green) < quantum_threshold) \n            pixel.green=(MagickRealType) pixels[x].green; \n          else \n            pixel.green=(MagickRealType) pixels[x].green+(pixel.green*amount); \n          unsharp_pixels[x].green=RoundToQuantum(pixel.green); \n        } \n      if ((channel & BlueChannel) != 0) \n        { \n          pixel.blue=pixels[x].blue-(MagickRealType) unsharp_pixels[x].blue; \n          if (fabs(2.0*pixel.blue) < quantum_threshold) \n            pixel.blue=(MagickRealType) pixels[x].blue; \n          else \n            pixel.blue=(MagickRealType) pixels[x].blue+(pixel.blue*amount); \n          unsharp_pixels[x].blue=RoundToQuantum(pixel.blue); \n        } \n      if ((channel & OpacityChannel) != 0) \n        { \n          pixel.opacity=pixels[x].opacity-(MagickRealType) \n            unsharp_pixels[x].opacity; \n          if (fabs(2.0*pixel.opacity) < quantum_threshold) \n            pixel.opacity=(MagickRealType) pixels[x].opacity; \n          else \n            pixel.opacity=pixels[x].opacity+(pixel.opacity*amount); \n          unsharp_pixels[x].opacity=RoundToQuantum(pixel.opacity); \n        } \n      if (((channel & IndexChannel) != 0) && \n          (image->colorspace == CMYKColorspace)) \n        { \n          pixel.index=unsharp_indexes[x]-(MagickRealType) indexes[x]; \n          if (fabs(2.0*pixel.index) < quantum_threshold) \n            pixel.index=(MagickRealType) unsharp_indexes[x]; \n          else \n            pixel.index=(MagickRealType) unsharp_indexes[x]+ \n              (pixel.index*amount); \n          unsharp_indexes[x]=RoundToQuantum(pixel.index); \n        } \n    }", "pragma": "parallel for private(pixel)", "hash": "d5516bb0d531c3edcd28fb17feb5272248de5e19fe19eff905d778dcc3a050d8"}
{"code": "for(size_type sequence = 0; sequence < right.sequences(); sequence++) \n  { \n     \n \n    size_type thread = omp_get_thread_num(); \n    buffers.insert(edge_type(ENDMARKER, left.sequences()), thread); \n \n     \n \n     \n \n     \n \n    edge_type right_pos = right_endmarker.LF(sequence); \n    edge_type left_pos(right_pos.first, left.record(right_pos.first).countUntil(ENDMARKER)); \n \n     \n \n    while(right_pos.first != ENDMARKER) \n    { \n      buffers.insert(left_pos, thread); \n      right_pos = right.LF(right_pos); \n      left_pos = edge_type(right_pos.first, left.fullLF(left_pos, right_pos.first)); \n    } \n  }", "pragma": "parallel for ", "hash": "a2319afba0641a6dab73634672f4d8ed0c16dce96873a7e4a5dad4b3e881ef84"}
{"code": "for (int i = 0; i < M*N*H*W; i++) \n      top[i] = bot[i];", "pragma": "parallel for ", "hash": "49adf5a18c0a21b1eb2a7c9307795b41fcb509c59edd891f599fd03f05fe50e2"}
{"code": "for(size_t i = start; i < end; ++i) \n        { \n            EHH ehh = finder.find(map, i); \n            processEHH(ehh, i); \n            ++m_counter; \n            unsigned long long tmp = m_counter; \n            if (tmp % 1000 == 0) \n            { \n                std::cout << '\\r' << tmp << \"/\" << (end-start); \n            } \n        }", "pragma": "for ", "hash": "c0851660fc7f72637a0abd9cef2ef60cfa56490b8269f7e43d4f2813a0208b87"}
{"code": "for (std::size_t i = 0; i < economic_agents.size(); ++i) {   \n \n        economic_agents[i]->iterate_investment(); \n    }", "pragma": "parallel for ", "hash": "6b8fb80d0999bc3db95071dd3c27e693f57ffdccb6e6a5025551d8acbad2c3f0"}
{"code": "for (int i = 0; i< frame_->degrees_of_freedom();i++) \n        { \n            coeff = f(*(frame_->get_quarklet(i))) / D(*(frame_->get_quarklet(i))); \n            if (fabs(coeff)>1e-15) \n            { \n#pragma omp critical \n                {fhelp.set_coefficient(*(frame_->get_quarklet(i)), coeff); \n                fhelp_int.set_coefficient(i, coeff);} \n                 \n                fnorm_sqr_help += coeff*coeff; \n            } \n        }", "pragma": "for reduction(+:fnorm_sqr_help) private(coeff)", "hash": "0355a87e2a7fd51144fd718fa623893a4eac3b85b58e56a24103efb7a551a594"}
{"code": "for(uint32_t j=0;j<seq.size();++j){ \n        calcTmpVariance(*seq[j]); \n      }", "pragma": "parallel for ", "hash": "e23a13121c8b8dc4dcf1034edf7b6f1444f916c3725f7921515decb9e1696aa0"}
{"code": "for(int y = 0; y < height; y++) \n  { \n    float L = 0; \n    int hits = 0; \n    size_t index = (size_t)y * width; \n    float *scanline = scanlines + dt_get_thread_num() * width; \n     \n \n    for (int x = 0; x < radius && x < width ; x++) \n    { \n      L += buf[index+x]; \n      hits++; \n    } \n     \n \n    int x; \n    for (x = 0; x <= radius && x < width; x++) \n    { \n      const int np = x + radius; \n      if(np < width) \n      { \n        L += buf[index + np]; \n        hits++; \n      } \n      scanline[x] = L / hits; \n    } \n     \n \n    for(; x + radius < width; x++) \n    { \n      const int op = x - radius - 1; \n      const int np = x + radius; \n      L -= buf[index + op]; \n      L += buf[index + np]; \n      scanline[x] = L / hits; \n    } \n     \n \n    for(; x < width; x++) \n    { \n      const int op = x - radius - 1; \n      L -= buf[index + op]; \n      hits--; \n      scanline[x] = L / hits; \n    } \n     \n \n    for(x = 0; x < width; x++) \n      buf[index + x] = scanline[x]; \n  }", "pragma": "parallel for ", "hash": "4d738cc74b4c905ccc2ce694dda635baaaa17955297044428eee6afdcd95e493"}
{"code": "for (int idx = 0; idx < Y.size(); idx++) \n    { \n        if ( R(idx) < clip_min ) R(idx) = clip_min; \n        if ( G(idx) < clip_min ) G(idx) = clip_min; \n        if ( B(idx) < clip_min ) B(idx) = clip_min; \n        if ( Y(idx) < clip_min ) Y(idx) = clip_min; \n \n        float currY = 1.f/Y(idx); \n \n        R(idx) *= currY; \n        G(idx) *= currY; \n        B(idx) *= currY; \n        Y(idx) = std::log10( Y(idx) ); \n    }", "pragma": "parallel for ", "hash": "75a9b74cb227c6ca26ae4bb7a864ebbac78ce8fcd39fe5dad5ff605a5b3827a1"}
{"code": "for ( int j=0; j<m_shift_y; j++ ) \n      { \n        for ( int i=0; i<m_shift_x; i++ ) \n        { \n          int ij_1 = j+i*m_dim_y; \n          int ij_2 = (j+m_shift_y)+(i+m_shift_x)*m_dim_y; \n \n          if ( (i+j)%2 == 1 ) fak2 = -fak; \n          else fak2 = fak; \n \n          tmp           = data[ij_1][0]; \n          data[ij_1][0] = data[ij_2][0] * fak2; \n          data[ij_2][0] = tmp * fak2; \n \n          tmp           = data[ij_1][1]; \n          data[ij_1][1] = data[ij_2][1] * fak2; \n          data[ij_2][1] = tmp * fak2; \n        } \n      }", "pragma": "for ", "hash": "8e029670e2a6a2e09374f68d36b2406adf27f92d512fde1de6969f337f301869"}
{"code": "for (ix=marg; ix<marg+pmlout; ix++) { \n\tfor (iz=marg+pmlout; iz<nz+pmlout+marg; iz++) { \n\t    txxn1x[ix][iz]=((1-dt*pmldx[ix]/2)*txxn0x[ix][iz]-dt*c11[ix][iz]*ldx(vxn1,ix-1,iz))/(1+dt*pmldx[ix]/2); \n\t    txxn1z[ix][iz]=((1-dt*pmldz[iz]/2)*txxn0z[ix][iz]-dt*c11[ix][iz]*ldz(vzn1,ix,iz-1))/(1+dt*pmldz[iz]/2); \n\t    txxn1[ix][iz] = txxn1x[ix][iz]+txxn1z[ix][iz]; \n\t} \n    }", "pragma": "parallel for private( ix iz)", "hash": "e69cf4b12cb8d30431c2f8b4d7475ad72198465f770e12b4012920b4f10c6b2d"}
{"code": "for (i = 0; i < HASH_BUCKETS_NB; i++) \n\t\tomp_init_lock(splayTable->tableLocks + i);", "pragma": "parallel for ", "hash": "dd55c20be75a51503b46c3acfe51577b9ef421cc4bf5d44011c8d2ffc9bd0e51"}
{"code": "for (i = 0; i < CRESN; i++) \n    for (j = 0; j < CRESN; j++) \n      solution[0][i][j] = solution[1][i][j] = 0.0;", "pragma": "parallel for private(i j)", "hash": "0f0bb9fae7eae22446463f29c873cc483ed393959828f1892aeb789730021faf"}
{"code": "for (int i = 0; i < numContenders; ++i) {\r \n\t\t\tint n;\r \n\r \n\t\t\tif (1 == compete(net, contenders[i], n)) {\r \n\t\t\t\t++score;\r \n\t\t\t}\r \n\r \n\t\t\tnumTurns += n;\r \n\t\t}", "pragma": "parallel for reduction( +:score numturns) ", "hash": "8094566436db7fd043d3117099fa2207ba0343fd941fcae9bd9da5606df40969"}
{"code": "for (i = 0; i < Data.num_loci; i++) { \n         \n        if (omp_get_thread_num() == 0 && Options.Verbosity >= 1) \n        if (Options.Verbosity >= 1)  \n                VTPROGRESSBARupdate(\"Allele Frequency Analysis\", \n                                    Data.num_loci, loci_completed); \n        calcHeterozygosity(i); \n        calcHWE(i, hwe, genotypes); \n \n         \n \n        nt[i] = NULLinit(i); \n        Data.p_null[i] = NULLcalcPn(nt[i]); \n \n#pragma omp atomic \n        loci_completed += 1; \n    }", "pragma": "parallel for ", "hash": "4405177dd642fbb1434e5272689466c6614b95ddd2ed3f69f9f7472d06946fc1"}
{"code": "for( row = 0; row < map->gdim+1; row++ ) { \n                    rpt[row] = 0; \n                }", "pragma": "parallel for ", "hash": "635af9e168a76f3d48a382e144389dbf06c24e921c71db52dc40ad2c2bab2c73"}
{"code": "for    (ix=0; ix<fdm->n2pad; ix++) { \n\t    for(iz=0; iz<fdm->n1pad; iz++) { \n\t\tupz[ix][iz] = 2*uoz[ix][iz]  \n\t\t    -           umz[ix][iz]  \n\t\t    +           ua1[ix][iz] / ro[ix][iz] * dt2;  \n \n\t\tupx[ix][iz] = 2*uox[ix][iz]  \n\t\t    -           umx[ix][iz]  \n\t\t    +           uax[ix][iz] / ro[ix][iz] * dt2;  \n\t    } \n\t}", "pragma": "parallel for private(ix iz)", "hash": "0cafbf1f01d32911a57bda54152a8889590309a471f28ee8fd3e2876de2dbd90"}
{"code": "for(i = 0; i < N; i++) \n      a[i] = a[i] + b[i];", "pragma": "for ", "hash": "d20a2cdc1652725dbf7fb071425018c9869f39b8f01b9a6547d04f78cc0863b8"}
{"code": "for(int y=0;y<theRamCanvas.getNumPixY();y++) { \n    for(int x=0;x<theRamCanvas.getNumPixX();x++) { \n      for(c=std::complex<mjr::ramCanvas3c8b::coordFltType>(theRamCanvas.int2realX(x),theRamCanvas.int2realY(y)),z=zero,count=0; (std::norm(z)<4)&&(count<=NUMITR); count++,z=z*z+c) \n        ; \n      if(count < NUMITR) \n        theRamCanvas.drawPoint(x, y, mjr::ramCanvas3c8b::colorType::csCColdeFireRamp::c(static_cast<mjr::ramCanvas3c8b::csIntType>(mjr::numberWrap(count*20, 767)))); \n    } \n  }", "pragma": "parallel for private(  c count z)", "hash": "84b64d09524c5385f98746142d46cb2de4a52e1152c420b935a15fa43e33b93d"}
{"code": "for (uint64_t vert_index = 0; vert_index < g->n_local; ++vert_index) \n    { \n      if (pulp->local_parts[vert_index] >= 0) \n        continue; \n \n      int32_t new_part = -1; \n      uint64_t out_degree = out_degree(g, vert_index); \n      uint64_t* outs = out_vertices(g, vert_index); \n      for (uint64_t j = 0; j < out_degree; ++j) \n      { \n        uint64_t out_index = outs[j]; \n        int32_t part_out = pulp->local_parts[out_index]; \n        if (part_out >= 0 &&  \n            counts[part_out] + changes[part_out] < max_part_size) \n        { \n          pulp->local_parts[vert_index] = part_out; \n          new_part = part_out; \n          break; \n        } \n      } \n \n      if (new_part >= 0) \n      { \n        add_vid_to_send(&tq, q, vert_index); \n        add_vid_to_queue(&tq, q, vert_index); \n \n    #pragma omp atomic \n        ++changes[new_part]; \n      } \n    }", "pragma": "for ", "hash": "b7712314045bcaccc0f996ce516143685d13c40474f4e7fa1b14e8990e02a10f"}
{"code": "for (int i = 0; i < (int)width; i++) \n\t\t{ \n\t\t\tfor (unsigned int j = 0; j < height; j++) \n\t\t\t{ \n\t\t\t\tfor (unsigned int k = 0; k < depth; k++) \n\t\t\t\t{ \n\t\t\t\t\tfluidParticles[i*height*depth + j*depth + k] = diam*Vector3r((Real)i, (Real)j, (Real)k) + Vector3r(startX, startY, startZ); \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "06a7d4bb9b3763e2cb8914c8ff19a2b9c6ca7625d0fef31a822af855a68b5ba0"}
{"code": "for (int i=0; i < ctr1 ;++i) { \n\t\tif (betterPointExists(&(list1[i]), list2, ctr2)) \n\t\t\tlist1[i].worth = NEG_VALUE_FOR_MARKING_NOT_OPTIMAL_POINTS; \n\t}", "pragma": "parallel for ", "hash": "64c54d3838e5bce02bf39e78ba3c9c2aa038c5f3698513c89f19ce4b07a50c6d"}
{"code": "for (int j=0; j < myLength; j++) to[j] = std::abs(from[j]);", "pragma": "parallel for ", "hash": "72de9d3ca9a014a4d78403a9da69e72dc90aefc8a9c402e56c2dc4d84003ccc1"}
{"code": "for (int i=0; i<this->get_nrow(); ++i) { \n \n      int jj = this->mat_.row_offset[i]; \n       \n      for (int j=tmp.mat_.row_offset[i]; j<tmp.mat_.row_offset[i+1]; ++j) \n       if (( paralution_abs(tmp.mat_.val[j]) > drop_off )  || \n           ( tmp.mat_.col[j] == i)) { \n         this->mat_.col[jj] = tmp.mat_.col[j]; \n         this->mat_.val[jj] = tmp.mat_.val[j];  \n         ++jj; \n       } \n              \n     }", "pragma": "parallel for ", "hash": "165883e8c3550de40ff7534ca706893611549bc520a872adde83705e394788bf"}
{"code": "for (size_t i = 0; i < frame.total (); ++i) { \n            const auto& src = frame.at< cv::Vec3b > (i); \n \n            auto& gs = g_ [i]; \n \n            for_each (begin (gs), end (gs), [=](auto& g) { \n                    g.s = g.w / sqrt (g.v); }); \n \n            sort (begin (gs), end (gs), [](const auto& g1, const auto& g2) { \n                    return g1.s > g2.s; }); \n \n            size_t n = 0; \n \n            for (double sum = 0.; \n                 n < gs.size () && sum < weight_threshold_; ++n) { \n                sum += gs [n].w; \n            } \n \n            int once = 0; \n \n            for (size_t j = 0; j < gs.size (); ++j) { \n                auto& g = gs [j]; \n \n                auto& v = g.v; \n                auto& w = g.w; \n                auto& m = g.m; \n \n                const auto distance = dot (cv::Vec3d (src) - m); \n \n                if (!once && distance < variance_threshold_ * v && ++once) { \n                    if (j < n) { \n                         \n \n                         \n \n                         \n \n                         \n \n                        mask_.at< unsigned char > (i) = 0; \n                        background_.at< cv::Vec3b > (i) = gs [0].m; \n                    } \n \n                    const double r = alpha_ * w - alpha_ * bias_; \n \n                    w = (1. - alpha_) * w + alpha_; \n \n                    m [0] += r * (src [0] - m [0]); \n                    m [1] += r * (src [1] - m [1]); \n                    m [2] += r * (src [2] - m [2]); \n \n                    v += r * (distance - v); \n                } \n                else { \n                     \n \n                     \n \n                     \n \n                    w = (1. - alpha_) * w - alpha_ * bias_; \n                } \n            } \n \n            if (!once) { \n                 \n \n                 \n \n                 \n \n                 \n \n                if (gs.size () < size_) { \n                    gs.emplace_back (gaussian_t { \n                            variance_, alpha_, alpha_ / sqrt (variance_), src }); \n                } \n                else { \n                    gs.back () = gaussian_t { \n                        variance_, alpha_, alpha_ / sqrt (variance_), src }; \n                } \n            } \n \n            { \n                 \n \n                 \n \n                 \n \n                sort (begin (gs), end (gs), [](const auto& g1, const auto& g2) { \n                        return g1.w > g2.w; }); \n \n                auto last = find_if (begin (gs), end (gs), [=](auto& g) { \n                        return g.w < 0.; }); \n \n                gs.erase (last, end (gs)); \n            } \n \n            { \n                 \n \n                 \n \n                 \n \n                const auto normal = 1. / accumulate ( \n                    begin (gs), end (gs), 0., [](auto accum, const auto& g) { \n                        return accum + g.w; }); \n \n                for_each (begin (gs), end (gs), [=](auto& g) { g.w *= normal; }); \n            } \n        }", "pragma": "parallel for ", "hash": "3389fd4b78c186184af57d04a4d51d78bd5d294516477d54d32a93a7eebaa483"}
{"code": "for ( cid = 0 ; cid < s->nr_marked ; cid++ ) { \n        c = &(s->cells[ s->cid_marked[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k] , h[k] ) - __builtin_isless( p->x[k] , 0.0 ); \n \n             \n \n            if ( ( delta[0] != 0 ) || ( delta[1] != 0 ) || ( delta[2] != 0 ) ) { \n                for ( k = 0 ; k < 3 ; k++ ) \n                    p->x[k] -= delta[k] * h[k]; \n                c_dest = &( s->cells[ space_cellid( s , \n                    (c->loc[0] + delta[0] + s->cdim[0]) % s->cdim[0] ,  \n                    (c->loc[1] + delta[1] + s->cdim[1]) % s->cdim[1] ,  \n                    (c->loc[2] + delta[2] + s->cdim[2]) % s->cdim[2] ) ] ); \n \n\t            if ( c_dest->flags & cell_flag_marked ) { \n                    pthread_mutex_lock(&c_dest->cell_mutex); \n                    space_cell_add_incomming( c_dest , p ); \n\t                pthread_mutex_unlock(&c_dest->cell_mutex); \n                    s->celllist[ p->id ] = c_dest; \n                    } \n                else { \n                    s->partlist[ p->id ] = NULL; \n                    s->celllist[ p->id ] = NULL; \n                    } \n \n                s->celllist[ p->id ] = c_dest; \n                c->count -= 1; \n                if ( pid < c->count ) { \n                    c->parts[pid] = c->parts[c->count]; \n                    s->partlist[ c->parts[pid].id ] = &( c->parts[pid] ); \n                    } \n                } \n            else \n                pid += 1; \n            } \n        }", "pragma": "parallel for private(c c_dest cid delta k p pid)", "hash": "41e2608d4e70a046bf975f929e167353a989078ab5991042f757a539cf2a9ce9"}
{"code": "for(size_t row = 0; row < o_row_max; row++) \n    { \n      float *out = (float *)ovoid + o_width * row; \n      float *tmp = tmpout + i_width * (row + shift_y) + shift_x; \n      for(size_t col = 0; col < o_col_max; col++) \n        out[col] = tmp[col]; \n    }", "pragma": "parallel for ", "hash": "a621628339fd1863be32122febab3bed85b6c946d6f1271a22c015e6c756c955"}
{"code": "for (int i = 0; i < 10; ++i) { \n    struct S { \n      void g() { throw 0; } \n    }; \n  }", "pragma": "for simd ", "hash": "eb2e0038033e7894ec1264b5f4ef1e00c6279f1100a7a9db706de789f5f36b63"}
{"code": "for (int i = 0; i < m_nCells; i++) { \n        for (int j = 0; j < CVT_INT(m_nSoilLyrs[i]); j++) { \n            float snowMelt = 0.f; \n            float snowAcc = 0.f; \n            if (m_snowMelt != nullptr) { \n                snowMelt = m_snowMelt[i]; \n            } \n            if (m_snowAccu != nullptr) { \n                snowAcc = m_snowAccu[i]; \n            } \n \n            float hWater = m_netPcp[i]; \n             \n \n            if (m_meanTmp[i] <= m_tSnow) { \n                 \n \n                hWater = 0.0f; \n            } \n            else if (m_meanTmp[i] > m_tSnow && m_meanTmp[i] <= m_t0 && snowAcc > hWater) { \n                 \n \n                hWater = 0.0f; \n            } \n            else { \n                hWater = m_netPcp[i] + m_deprSto[i] + snowMelt; \n            } \n \n            hWater += m_surfRf[i]; \n \n             \n \n            float matricPotential = (m_soilPor[i][j] - m_soilWtrSto[i][j]) * m_capillarySuction[i] / 1000.f; \n             \n \n            float ks = m_ks[i][j] / 1000.f / 3600.f;  \n \n            float dt = m_dt; \n            float infilDepth = m_accumuDepth[i] / 1000.f;  \n \n \n            float p1 = ks * dt - 2.f * infilDepth; \n            float p2 = ks * (infilDepth + matricPotential); \n             \n \n            float infilRate = (p1 + CalSqrt(CalPow(p1, 2.f) + 8.f * p2 * dt)) / (2.f * dt); \n \n            float infilCap = (m_soilPor[i][j] - m_soilWtrSto[i][j]) * m_soilDepth[i][j]; \n \n            if (hWater > 0) { \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                if (m_soilWtrSto[i][j] > m_soilPor[i][j]) { \n                    m_infil[i] = 0.0f; \n                    m_infilCapacitySurplus[i] = 0.f; \n                } \n                else { \n                    m_infil[i] = Min(infilRate * dt * 1000.f, infilCap);  \n \n \n                     \n \n                     \n \n                    if (m_infil[i] > hWater) { \n                        m_infilCapacitySurplus[i] = m_infil[i] - hWater; \n                         \n \n                        m_infil[i] = hWater; \n                    } \n                    else { \n                        m_infilCapacitySurplus[i] = 0.f; \n                    } \n \n                     \n \n                    m_accumuDepth[i] += m_infil[i]; \n                     \n \n                    m_surfRf[i] = hWater - m_infil[i]; \n \n                    if (m_soilDepth != nullptr) { \n                        m_soilWtrSto[i][j] += m_infil[i] / m_soilDepth[i][j]; \n                    } \n                } \n            } \n            else { \n                m_surfRf[i] = 0.0f; \n                m_infil[i] = 0.0f; \n                m_infilCapacitySurplus[i] = Min(infilRate * dt * 1000.f, infilCap); \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "9e46337bf605d0fade85dfe6d64ee37b5928e38ca0c78aaf5a10c00be14b35ff"}
{"code": "for (uint ev_ctr = 0; ev_ctr < number_neighbors_and_self; ++ev_ctr)     \n\t\t{  neighbors_and_self.at(ev_ctr)->second.ignore_regions_of_the_genome_from_consideration_by_this_Event(regions_near_N_nucleotides);  }", "pragma": "for ", "hash": "a265be259c102d71e409614546d3a3c1dabd6721d137055fce63ed27f45ad18b"}
{"code": "for (i = 1; i < n - 1; i++) { \n\t\t\tfor (j = 1; j < n - 1; j++) { \n\t\t\t\t \n \n\t\t\t\tU(i,j) = (1.0 - omega) * U(i,j) + omega * (U(i-1,j) + U(i+1,j) + U(i,j-1) + U(i,j+1) + h2 * F(i,j)) / 4.0; \n \n\t\t\t\t \n \n\t\t\t\tresid = U(i,j) - Uold(i,j); \n\t\t\t\terror += resid * resid; \n\t\t\t} \n\t\t}", "pragma": "parallel for reduction(+:error) private(  i j resid)", "hash": "3c6a4ac2a6ce5269fd2eda28b9dd61c54d6354c9ddb9539bebb412edc36a0146"}
{"code": "for( size_t t = 0; t < max_work_threads; ++t ) \n    { \n        compute_buffer_t&   b( buffers[ omp_get_thread_num() ] ); \n        b.resize( G ); \n    }", "pragma": "parallel for ", "hash": "92287f839eb5621389bfa7df8f2af150296056e6978cae6fa2efc8cfba07d059"}
{"code": "for(int y = 0; y < roi_out->height; y++) \n    { \n      float *i = (float *)((char *)in + (size_t)in_stride * (y + roi_out->y) + x0); \n      float *o = (float *)((char *)out + (size_t)out_stride * y); \n      memcpy(o, i, out_stride); \n    }", "pragma": "parallel for ", "hash": "4b229414a8681c9cf4363136ddc51023a9dcf5f4004d41b67d7310c86852fe2b"}
{"code": "for (int i = 0; i < 2; ++i) { \n    A::x++; \n  }", "pragma": "for private( a::x b::x f f)", "hash": "d3db88c33ed1b391db50e8fa4b546cc13f53b627776d8d320395928c70b41a19"}
{"code": "for (i=0; i<nPri; i++) { \n      indp=i*(nPri); \n      cc=cab[indp+i]; \n      nabx+=(cc*gx[i]*gx[i]); \n      naby+=(cc*gy[i]*gy[i]); \n      nabz+=(cc*gz[i]*gz[i]); \n      gxj=gyj=gzj=0.0000000e0; \n      for (j=(i+1); j<nPri; j++) { \n         cc=cab[indp+j]; \n         gxj+=(cc*gx[j]); \n         gyj+=(cc*gy[j]); \n         gzj+=(cc*gz[j]); \n      } \n      nabx+=(2.0e0*gx[i]*gxj); \n      naby+=(2.0e0*gy[i]*gyj); \n      nabz+=(2.0e0*gz[i]*gzj); \n   }", "pragma": "parallel for reduction(+: nabx naby nabz) private(cc gxj gyj gzj i indp j)", "hash": "61ab2768aa8a0bd6da450f0c50c35ebe6089827e4a7308ffcf99211b12291c1b"}
{"code": "for (long long i = 0; i < size; ++i ) \n\t\t\t\t{ \n\t\t\t\t\tgt = gtImage->GetBufferPointer()[i]; \n\t\t\t\t\tm = mask->GetBufferPointer()[i]; \n\t\t\t\t\tif (gt == 1 && m == 1) tp = tp + 1; \n\t\t\t\t\tif (gt == 1 && m == 0) fn = fn + 1; \n\t\t\t\t\tif (gt == 0 && m == 1) fp = fp + 1; \n\t\t\t\t\tif (gt == 0 && m == 0) tn = tn + 1; \n\t\t\t\t}", "pragma": "parallel for reduction(+:tp fn fp tn) ", "hash": "6f86408ec9fa3fda854ff523b51d76432fcadffac45b4a9f90741d17c6946c6f"}
{"code": "for (row = 0; row < input.height - 1; ++row) \n    interpolate_420_row<version>(row);", "pragma": "parallel for private(out row)", "hash": "335dd612938d6b42e0c6686d3084005d4317408fd79fcfd215a2aecc8de5d0ae"}
{"code": "for(j=0;j<top;j++){ \n                     \n \n                    idx1 = (j / incs[d])*incs[d]*ns[d] + (j % incs[d]); \n                 \n                     \n \n                    for(k=0,idx2=0 ; k<ns[d] ; k++,idx2+=incs[d]) \n                        wsi->in[k] = z[idx1+idx2] + q[idx1+idx2]; \n                         \n                    #ifdef DEBUG \n                    { \n                        int dbgi; \n                        fprintf(DEBUG_FILE,\"Slice %d: \",j); \n                        for(dbgi=0;dbgi<ns[d];dbgi++) \n                            fprintf(DEBUG_FILE,\"%lf \",wsi->in[dbgi]); \n                        fprintf(DEBUG_FILE,\"\\n\"); \n                    } \n                    #endif \n                     \n                     \n \n                    resetWorkspace(wsi); \n                    TV(wsi->in, lambdas[1], wsi->out, NULL, ns[d], norms[1], wsi); \n                     \n                     \n \n                    for(k=0,idx2=0 ; k<ns[d] ; k++,idx2+=incs[d]) \n                        x[idx1+idx2] = wsi->out[k]; \n                }", "pragma": "for ", "hash": "dd6b3cefd6aef397419727d8b7addc87e401ae4dde8fcf059bc330e6ff2373d7"}
{"code": "for (int i = 0; i < m_size; i++) \n\t{ \n\t\t \n \n\t\tfloat RainInten = m_Rain[i] * 3600 / m_TimeStep; \n \n\t\t \n \n\t\t \n \n\t\tfloat s = max(0.001f, m_Slope[i]); \n\t\tfloat S0 = sin(atan(s)); \n\t\tfloat Dm = 0.00124f * pow(RainInten, 0.182f); \n\t\tfloat waterdepth = (m_sr[i] + m_depression[i]) / 1000;    \n \n\t\tfloat Fw, Dr; \n\t\tif (waterdepth > Dm) \n\t\t{ \n\t\t\tFw = exp(1 - waterdepth / Dm); \n\t\t} \n\t\telse \n\t\t{ \n\t\t\tFw = 1; \n\t\t} \n\t\t \n \n\t\tDr = m_Omega * Fw * m_USLE_C[i] * m_USLE_K[i] * pow(RainInten,2.f) * (2.96f * pow(S0,0.79f) + 0.56f);\t\t \n\t\t \n \n\t\tfloat cellareas = (m_cellWith/cos(atan(s))) * m_cellWith; \n\t\tm_DETSplash[i] = Dr * (m_TimeStep/60) * cellareas; \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n \n\t}", "pragma": "parallel for ", "hash": "4e010068591b04e27cfdd746f49b5e76c3382ff5fe5cf78b0517e6593e72bfbe"}
{"code": "for (k = 0; k < r_->size[0]*r_->size[1]; k++) \n    { \n      real* ptr_output = output_data + k*nOutputCols*nOutputRows; \n      int64_t l; \n      for (l = 0; l < nOutputRows*nOutputCols; l++) \n        ptr_output[l] = 0.0; \n    }", "pragma": "parallel for private(k)", "hash": "7da650e2d1535e15e8ed3e02aca3fcbac2a165a76967dd5c8be3e4f83283b2d7"}
{"code": "for (int f = 0; f < fc-1; f++) \n\t{ \n\t\tint t = omp_get_thread_num(); \n \n\t\tfor (int d = 0; d < dc; d++) \n\t\t{ \n\t\t\tconst double cx = x[2*(pc + dc*f + d)    ]; \n\t\t\tconst double cy = x[2*(pc + dc*f + d) + 1]; \n \n\t\t\te_t[pad*t] += cx*cx + cy*cy; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "d212985dd6c30618eecda5145c10f09d37b42738e1acdc0f1a9b08fcc4525104"}
{"code": "for (v = 0; v < V*K; v++){ Ga[v] += Aux[v]; }", "pragma": "parallel for private(v)", "hash": "ff97cd67d8048efaed51a2e57e092495bfc0c9bd94fe7413e14a08ecde833d70"}
{"code": "for (int i = 0; i < j + 4; i++) \n    for (int j = 0; j < 16; j++) \n      ;", "pragma": "for ", "hash": "80edcde603d4f1ee1f0568c8b4f0fdab256e62528480c4ebae6d52286b4eb08f"}
{"code": "for (int i = 0; i < numPixels; ++i) { \n        inDirPtr = &inDirData[i * 4]; \n        renderedData = inDirPtr; \n \n        copiedInDirData[i * 4    ] = inDirPtr[0]; \n        copiedInDirData[i * 4 + 1] = inDirPtr[1]; \n        copiedInDirData[i * 4 + 2] = inDirPtr[2]; \n        copiedInDirData[i * 4 + 3] = inDirPtr[3]; \n \n         \n \n        if (inDirPtr[3] != 0.0f) continue; \n \n        inDir = lb::Vec3f(inDirPtr[0], inDirPtr[1], inDirPtr[2]); \n        outDir = lb::Vec3f(outDirData[i * 4], outDirData[i * 4 + 1], outDirData[i * 4 + 2]); \n \n        inDir = inDir.cwiseProduct(lb::Vec3f(2.0, 2.0, 2.0)) - lb::Vec3f(1.0, 1.0, 1.0); \n        outDir = outDir.cwiseProduct(lb::Vec3f(2.0, 2.0, 2.0)) - lb::Vec3f(1.0, 1.0, 1.0); \n        outDir[2] = std::max(outDir[2], 0.0f); \n        outDir.normalize(); \n \n        renderedData[0] = renderedData[1] = renderedData[2] = 0.0f; \n \n        if (reflectances_ && environmentIntensity_ > 0.0f) { \n            renderReflectance(outDir, renderedData); \n        } \n \n        if (dataType_ == lb::BTDF_DATA || \n            dataType_ == lb::SPECULAR_TRANSMITTANCE_DATA) { \n            inDir[2] = -inDir[2]; \n        } \n \n        if (inDir[2] <= 0.0f) continue; \n        inDir.normalize(); \n \n        if (brdf_ && lightIntensity_ > 0.0f) { \n            renderBrdf(inDir, outDir, renderedData); \n        } \n    }", "pragma": "parallel for private(   indir indirptr outdir rendereddata)", "hash": "11d64391eac00905bf48712ab8298c965ecf7774f01736462b45b7b35d3082c2"}
{"code": "for (int index = 0; index < (signed)data_manager->cd_data->num_rigid_contacts; index++) { \n        function_CalcContactForces( \n            index,                                                   \n \n            data_manager->cd_data->bids_rigid_rigid.data(),          \n \n            shape_pairs.data(),                                      \n \n            data_manager->settings.solver.contact_force_model,       \n \n            data_manager->settings.solver.adhesion_force_model,      \n \n            data_manager->settings.solver.tangential_displ_mode,     \n \n            data_manager->settings.solver.use_material_properties,   \n \n            data_manager->settings.solver.characteristic_vel,        \n \n            data_manager->settings.solver.min_slip_vel,              \n \n            data_manager->settings.solver.min_roll_vel,              \n \n            data_manager->settings.solver.min_spin_vel,              \n \n            data_manager->settings.step_size,                        \n \n            data_manager->host_data.mass_rigid.data(),               \n \n            data_manager->host_data.pos_rigid.data(),                \n \n            data_manager->host_data.rot_rigid.data(),                \n \n            data_manager->host_data.v.data(),                        \n \n            data_manager->host_data.fric_rigid_rigid.data(),         \n \n            data_manager->host_data.modulus_rigid_rigid.data(),      \n \n            data_manager->host_data.adhesion_rigid_rigid.data(),     \n \n            data_manager->host_data.cr_rigid_rigid.data(),           \n \n            data_manager->host_data.smc_rigid_rigid.data(),          \n \n            data_manager->cd_data->cpta_rigid_rigid.data(),          \n \n            data_manager->cd_data->cptb_rigid_rigid.data(),          \n \n            data_manager->cd_data->norm_rigid_rigid.data(),          \n \n            data_manager->cd_data->dpth_rigid_rigid.data(),          \n \n            data_manager->cd_data->erad_rigid_rigid.data(),          \n \n            data_manager->host_data.shear_neigh.data(),   \n \n            shear_touch.data(),                           \n \n            data_manager->host_data.shear_disp.data(),    \n \n            data_manager->host_data.contact_relvel_init.data(),   \n \n            data_manager->host_data.contact_duration.data(),      \n \n            ct_bid.data(),                                        \n \n            ct_force.data(),                                      \n \n            ct_torque.data()                                      \n \n        ); \n    }", "pragma": "parallel for ", "hash": "5c6074149f436dc915e78f051db155c44746bffc06aed9e348c50141b70a03e8"}
{"code": "for (int k = 0; k < n; k++) { \n    factor = (k%2 == 0) ? 1.0 : -1.0; \n \n    sum += factor/(2*k + 1); \n  }", "pragma": "parallel for reduction(+: sum) private(factor)", "hash": "d3d5aa75c0117aa6736c33e6214bfc4fda572a9056c213e0a82801ac8521d96e"}
{"code": "for (int i = 0; i < nAllAtoms; i++) \n\t{ \n\t  int l = cells->GetListAndTranslations(i, nbList[i]); \n\t  if (l > MAXLIST) \n\t    THROW( AsapError(\"Unreasonably long neighbor list for atom \") \n\t      << i << \": \" << l << \" elements.\" ); \n\t  if (fulllists) \n\t    l += cells->GetComplementaryListAndTranslations(i, complNbList[i]); \n\t  if (l > myMaxLength) \n\t    myMaxLength = l; \n          totlistsize += l; \n\t}", "pragma": "for ", "hash": "74e7bd9779e7944ee8776e18d38bab2e40d33a87f20e96bef6f6e7193c854829"}
{"code": "for (int i = 0; i < ref_keys.size(); i++){ \n            ref_min_starts[i] = 0; \n            ref_min_lens[i] = 0; \n            ref_mins[i] = new hash_t[ sketch_size ]; \n            std::sort(ref_hashes[i], ref_hashes[i] + ref_hash_lens[i]); \n            if (max_samples < 100000){ \n                for (int j = 0; j < ref_hash_lens[i], ref_min_lens[i] < sketch_size; ++j){ \n                     \n \n                     \n \n                     \n \n                    hash_t curr = *(ref_hashes[i] + j); \n                     \n \n                    if (curr != 0 && ref_hash_counter.get(curr) <= max_samples){ \n                        ref_mins[i][ref_min_lens[i]] = curr; \n                         \n \n                        ++ref_min_lens[i]; \n                        if (ref_min_lens[i] == sketch_size){ \n                            break; \n                        } \n                    } \n                    else{ \n                        continue; \n                    } \n                } \n \n            } \n            else{ \n                while (ref_hashes[i][ref_min_starts[i]] == 0 && ref_min_starts[i] < ref_hash_lens[i]){ \n                    ++ref_min_starts[i]; \n                } \n                for (int j = ref_min_starts[i]; j < ref_hash_lens[i], ref_min_lens[i] < sketch_size; ++j){ \n                    *(ref_mins[i] +ref_min_lens[i]) = *(ref_hashes[i] + j); \n                    ++ref_min_lens[i]; \n                } \n \n            } \n            ref_min_starts[i] = 0; \n \n            delete [] ref_hashes[i]; \n \n        }", "pragma": "for ", "hash": "9f7bb2be08731f7ed610cc816695cb2339b609cd699388aab749b72f779a77ea"}
{"code": "for (i = 1; i < n; i += 2) { \n            if (a[i-1] > a[i]) { \n               tmp = a[i-1]; \n               a[i-1] = a[i]; \n               a[i] = tmp; \n            } \n         }", "pragma": "for ", "hash": "b4762ad9791ab08459196ad9a1b857a519c97a579aa872f29b37032cc22e8dda"}
{"code": "for(J i = 0; i < M; ++i) \n    { \n        for(I at = csr_row_ptr_C[i] - base_C; at < csr_row_ptr_C[i + 1] - base_C; ++at) \n        { \n            J j = csr_col_ind_C[at] - base_C; \n \n            const T* x = (orderA == rocsparse_order_column) \n                             ? ((transA == rocsparse_operation_none) ? (A + i) : (A + lda * i)) \n                             : ((transA == rocsparse_operation_none) ? (A + lda * i) : (A + i)); \n            const T* y = (orderB == rocsparse_order_column) \n                             ? ((transB == rocsparse_operation_none) ? (B + ldb * j) : (B + j)) \n                             : ((transB == rocsparse_operation_none) ? (B + j) : (B + ldb * j)); \n \n            T sum = static_cast<T>(0); \n            for(J k = 0; k < K; ++k) \n            { \n                sum += x[incx * k] * y[incy * k]; \n            } \n            csr_val_C[at] = csr_val_C[at] * b + a * sum; \n        } \n    }", "pragma": "parallel for ", "hash": "ddf689e07d05d3865402dfcba0948f028e74cc226519e843e6b04c227a61860f"}
{"code": "for (size_t k1 = 0; k1 < F.n_rows; k1++) { \n    for (size_t k2 = 0; k2 <= k1; k2++) { \n       \n \n      for (size_t n = 0; n < D.n_rows; n++) { \n        delta.slice(n).row(F_pair_coord[std::make_pair(k1, k2)]) += \n            digamma_alpha.at(k1, k2) - digamma_sum_alpha; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "b932ec2cb3e97c577ec8ea66c7d5ad29eb50724058184d60bee51af820027b47"}
{"code": "for(int i = 0; i < nlocal; i++) { \n    if(x[i][0] < 0.0) x[i][0] += box.xprd; \n \n    if(x[i][0] >= box.xprd) x[i][0] -= box.xprd; \n \n    if(x[i][1] < 0.0) x[i][1] += box.yprd; \n \n    if(x[i][1] >= box.yprd) x[i][1] -= box.yprd; \n \n    if(x[i][2] < 0.0) x[i][2] += box.zprd; \n \n    if(x[i][2] >= box.zprd) x[i][2] -= box.zprd; \n  }", "pragma": "for ", "hash": "60dda238786553309ceaa04b72ae2bedd91623d8dafdaebc45a36d653b66e82a"}
{"code": "for(int i=0; i<nElements; i++) \n        elements[i]->evaluateTransformationMatrix();", "pragma": "parallel for ", "hash": "7dd519dcd3be7f5881edc54fa195fb6a751351e332f904ece4583f9c81a3c8a1"}
{"code": "for (Nd4jLong e = 0; e < x->lengthOf(); e++) { \n        T max = -MAX_FLOAT; \n        Nd4jLong idx = 0; \n             \n        for (int i = 0; i < numArgs; i++){ \n             \n            T v = (*inArrs[i])(e); \n            if (v > max) { \n                max = v; \n                idx = i; \n            } \n        } \n        output(e) = idx; \n    }", "pragma": "parallel for ", "hash": "e52b9a0fa86e87947f63157d899f5c021aaad24fd678d5b41e94b4f8db3e9de9"}
{"code": "for ( int k=0; k<i1-i0; k++ ) { \n\t\tValue::ConstValueIterator i = i0+k; \n\t\t \n \n\t\tValue::ConstMemberIterator cmi_file_name = i->FindMember(\"file_name\"); \n\t\teassert( cmi_file_name != i->MemberEnd() ); \n\t\tconst std::string file_name = cmi_file_name->value.GetString(); \n\t\tValue::ConstMemberIterator cmi_file_path = i->FindMember(\"file_path\"); \n\t\teassert( cmi_file_path != i->MemberEnd() ); \n\t\tconst std::string file_path = cmi_file_path->value.GetString(); \n\t\t \n\t\t \n \n\t\timages[i-i0] = imreadShared( coco_dir+\"/\"+file_path+\"/\"+file_name ); \n\t}", "pragma": "parallel for ", "hash": "5c6b3a3bccb7bc95c1c523a0bb0b1f54d93284e37a78e8a81d413cf188027a1c"}
{"code": "for (size_t i = 0; i < alnDbr.getSize(); i++) { \n            progress.updateProgress(); \n \n            const unsigned int queryKey = alnDbr.getDbKey(i); \n            char *querySeqData = NULL; \n            size_t querySeqLen = 0; \n            queryProfData.clear(); \n            if (needSequenceDB) { \n                size_t qId = qDbr.sequenceReader->getId(queryKey); \n                querySeqData = qDbr.sequenceReader->getData(qId, thread_idx); \n                querySeqLen = qDbr.sequenceReader->getSeqLen(qId); \n                if(sameDB && qDbr.sequenceReader->isCompressed()){ \n                    queryBuffer.assign(querySeqData, querySeqLen); \n                    querySeqData = (char*) queryBuffer.c_str(); \n                } \n                if (queryProfile) { \n                    Sequence::extractProfileConsensus(querySeqData, *subMat, queryProfData); \n                } \n            } \n \n            size_t qHeaderId = qDbrHeader.sequenceReader->getId(queryKey); \n            const char *qHeader = qDbrHeader.sequenceReader->getData(qHeaderId, thread_idx); \n            size_t qHeaderLen = qDbrHeader.sequenceReader->getSeqLen(qHeaderId); \n            std::string queryId = Util::parseFastaHeader(qHeader); \n            if (sameDB && needFullHeaders) { \n                queryHeaderBuffer.assign(qHeader, qHeaderLen); \n                qHeader = (char*) queryHeaderBuffer.c_str(); \n            } \n \n            if (format == Parameters::FORMAT_ALIGNMENT_HTML) { \n                const char* jsStart = \"{\\\"query\\\": {\\\"accession\\\": \\\"%s\\\",\\\"sequence\\\": \\\"\"; \n                int count = snprintf(buffer, sizeof(buffer), jsStart, queryId.c_str(), querySeqData); \n                if (count < 0 || static_cast<size_t>(count) >= sizeof(buffer)) { \n                    Debug(Debug::WARNING) << \"Truncated line in entry\" << i << \"!\\n\"; \n                    continue; \n                } \n                result.append(buffer, count); \n                if (queryProfile) { \n                    result.append(queryProfData); \n                } else { \n                    result.append(querySeqData, querySeqLen); \n                } \n                result.append(\"\\\"}, \\\"alignments\\\": [\\n\"); \n            } \n \n            char *data = alnDbr.getData(i, thread_idx); \n            while (*data != '\\0') { \n                Matcher::result_t res = Matcher::parseAlignmentRecord(data, true); \n                data = Util::skipLine(data); \n \n                if (res.backtrace.empty() && needBacktrace == true) { \n                    Debug(Debug::ERROR) << \"Backtrace cigar is missing in the alignment result. Please recompute the alignment with the -a flag.\\n\" \n                                           \"Command: mmseqs align \" << par.db1 << \" \" << par.db2 << \" \" << par.db3 << \" \" << \"alnNew -a\\n\"; \n                    EXIT(EXIT_FAILURE); \n                } \n \n                size_t tHeaderId = tDbrHeader->sequenceReader->getId(res.dbKey); \n                const char *tHeader = tDbrHeader->sequenceReader->getData(tHeaderId, thread_idx); \n                size_t tHeaderLen = tDbrHeader->sequenceReader->getSeqLen(tHeaderId); \n                std::string targetId = Util::parseFastaHeader(tHeader); \n \n                unsigned int gapOpenCount = 0; \n                unsigned int alnLen = res.alnLength; \n                unsigned int missMatchCount = 0; \n                unsigned int identical = 0; \n                if (res.backtrace.empty() == false) { \n                    size_t matchCount = 0; \n                    alnLen = 0; \n                    for (size_t pos = 0; pos < res.backtrace.size(); pos++) { \n                        int cnt = 0; \n                        if (isdigit(res.backtrace[pos])) { \n                            cnt += Util::fast_atoi<int>(res.backtrace.c_str() + pos); \n                            while (isdigit(res.backtrace[pos])) { \n                                pos++; \n                            } \n                        } \n                        alnLen += cnt; \n \n                        switch (res.backtrace[pos]) { \n                            case 'M': \n                                matchCount += cnt; \n                                break; \n                            case 'D': \n                            case 'I': \n                                gapOpenCount += 1; \n                                break; \n                        } \n                    } \n \n \n                    identical = static_cast<unsigned int>(res.seqId * static_cast<float>(alnLen) + 0.5); \n                     \n \n                    missMatchCount = static_cast<unsigned int>( matchCount - identical); \n                } else { \n                    const int adjustQstart = (res.qStartPos == -1) ? 0 : res.qStartPos; \n                    const int adjustDBstart = (res.dbStartPos == -1) ? 0 : res.dbStartPos; \n                    const float bestMatchEstimate = static_cast<float>(std::min(abs(res.qEndPos - adjustQstart), abs(res.dbEndPos - adjustDBstart))); \n                    missMatchCount = static_cast<unsigned int>(bestMatchEstimate * (1.0f - res.seqId) + 0.5); \n                } \n \n                switch (format) { \n                    case Parameters::FORMAT_ALIGNMENT_BLAST_TAB: { \n                        if (outcodes.empty()) { \n                            int count = snprintf(buffer, sizeof(buffer), \n                                                 \"%s\\t%s\\t%1.3f\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%.2E\\t%d\\n\", \n                                                 queryId.c_str(), targetId.c_str(), res.seqId, alnLen, \n                                                 missMatchCount, gapOpenCount, \n                                                 res.qStartPos + 1, res.qEndPos + 1, \n                                                 res.dbStartPos + 1, res.dbEndPos + 1, \n                                                 res.eval, res.score); \n                            if (count < 0 || static_cast<size_t>(count) >= sizeof(buffer)) { \n                                Debug(Debug::WARNING) << \"Truncated line in entry\" << i << \"!\\n\"; \n                                continue; \n                            } \n                            result.append(buffer, count); \n                        } else { \n                            char *targetSeqData = NULL; \n                            targetProfData.clear(); \n                            unsigned int taxon = 0; \n                            if (needTaxonomy || needTaxonomyMapping) { \n                                taxon = mapping->lookup(res.dbKey); \n                                if (taxon == 0) { \n                                    taxonNode = NULL; \n                                } else if (needTaxonomy) { \n                                    taxonNode = t->taxonNode(taxon, false); \n                                } \n                            } \n \n                            if (needSequenceDB) { \n                                size_t tId = tDbr->sequenceReader->getId(res.dbKey); \n                                targetSeqData = tDbr->sequenceReader->getData(tId, thread_idx); \n                                if (targetProfile) { \n                                    Sequence::extractProfileConsensus(targetSeqData, *subMat, targetProfData); \n                                } \n                            } \n                            for(size_t i = 0; i < outcodes.size(); i++) { \n                                switch (outcodes[i]) { \n                                    case Parameters::OUTFMT_QUERY: \n                                        result.append(queryId); \n                                        break; \n                                    case Parameters::OUTFMT_TARGET: \n                                        result.append(targetId); \n                                        break; \n                                    case Parameters::OUTFMT_EVALUE: \n                                        result.append(SSTR(res.eval)); \n                                        break; \n                                    case Parameters::OUTFMT_GAPOPEN: \n                                        result.append(SSTR(gapOpenCount)); \n                                        break; \n                                    case Parameters::OUTFMT_FIDENT: \n                                        result.append(SSTR(res.seqId)); \n                                        break; \n                                    case Parameters::OUTFMT_PIDENT: \n                                        result.append(SSTR(res.seqId*100)); \n                                        break; \n                                    case Parameters::OUTFMT_NIDENT: \n                                        result.append(SSTR(identical)); \n                                        break; \n                                    case Parameters::OUTFMT_QSTART: \n                                        result.append(SSTR(res.qStartPos + 1)); \n                                        break; \n                                    case Parameters::OUTFMT_QEND: \n                                        result.append(SSTR(res.qEndPos + 1)); \n                                        break; \n                                    case Parameters::OUTFMT_QLEN: \n                                        result.append(SSTR(res.qLen)); \n                                        break; \n                                    case Parameters::OUTFMT_TSTART: \n                                        result.append(SSTR(res.dbStartPos + 1)); \n                                        break; \n                                    case Parameters::OUTFMT_TEND: \n                                        result.append(SSTR(res.dbEndPos + 1)); \n                                        break; \n                                    case Parameters::OUTFMT_TLEN: \n                                        result.append(SSTR(res.dbLen)); \n                                        break; \n                                    case Parameters::OUTFMT_ALNLEN: \n                                        result.append(SSTR(alnLen)); \n                                        break; \n                                    case Parameters::OUTFMT_RAW: \n                                        result.append(SSTR(static_cast<int>(evaluer->computeRawScoreFromBitScore(res.score) + 0.5))); \n                                        break; \n                                    case Parameters::OUTFMT_BITS: \n                                        result.append(SSTR(res.score)); \n                                        break; \n                                    case Parameters::OUTFMT_CIGAR: \n                                        if(isTranslatedSearch == true && targetNucs == true && queryNucs == true ){ \n                                            Matcher::result_t::protein2nucl(res.backtrace, newBacktrace); \n                                            res.backtrace = newBacktrace; \n                                        } \n                                        result.append(SSTR(res.backtrace)); \n                                        newBacktrace.clear(); \n                                        break; \n                                    case Parameters::OUTFMT_QSEQ: \n                                        if (queryProfile) { \n                                            result.append(queryProfData.c_str(), res.qLen); \n                                        } else { \n                                            result.append(querySeqData, res.qLen); \n                                        } \n                                        break; \n                                    case Parameters::OUTFMT_TSEQ: \n                                        if (targetProfile) { \n                                            result.append(targetProfData.c_str(), res.dbLen); \n                                        } else { \n                                            result.append(targetSeqData, res.dbLen); \n                                        } \n                                        break; \n                                    case Parameters::OUTFMT_QHEADER: \n                                        result.append(qHeader, qHeaderLen); \n                                        break; \n                                    case Parameters::OUTFMT_THEADER: \n                                        result.append(tHeader, tHeaderLen); \n                                        break; \n                                    case Parameters::OUTFMT_QALN: \n                                        if (queryProfile) { \n                                            printSeqBasedOnAln(result, queryProfData.c_str(), res.qStartPos, \n                                                               Matcher::uncompressAlignment(res.backtrace), false, (res.qStartPos > res.qEndPos), \n                                                               (isTranslatedSearch == true && queryNucs == true), translateNucl); \n                                        } else { \n                                            printSeqBasedOnAln(result, querySeqData, res.qStartPos, \n                                                               Matcher::uncompressAlignment(res.backtrace), false, (res.qStartPos > res.qEndPos), \n                                                               (isTranslatedSearch == true && queryNucs == true), translateNucl); \n                                        } \n                                        break; \n                                    case Parameters::OUTFMT_TALN: { \n                                        if (targetProfile) { \n                                            printSeqBasedOnAln(result, targetProfData.c_str(), res.dbStartPos, \n                                                               Matcher::uncompressAlignment(res.backtrace), true, \n                                                               (res.dbStartPos > res.dbEndPos), \n                                                               (isTranslatedSearch == true && targetNucs == true), translateNucl); \n                                        } else { \n                                            printSeqBasedOnAln(result, targetSeqData, res.dbStartPos, \n                                                               Matcher::uncompressAlignment(res.backtrace), true, \n                                                               (res.dbStartPos > res.dbEndPos), \n                                                               (isTranslatedSearch == true && targetNucs == true), translateNucl); \n                                        } \n                                        break; \n                                    } \n                                    case Parameters::OUTFMT_MISMATCH: \n                                        result.append(SSTR(missMatchCount)); \n                                        break; \n                                    case Parameters::OUTFMT_QCOV: \n                                        result.append(SSTR(res.qcov)); \n                                        break; \n                                    case Parameters::OUTFMT_TCOV: \n                                        result.append(SSTR(res.dbcov)); \n                                        break; \n                                    case Parameters::OUTFMT_QSET: \n                                        result.append(SSTR(qSetToSource[qKeyToSet[queryKey]])); \n                                        break; \n                                    case Parameters::OUTFMT_QSETID: \n                                        result.append(SSTR(qKeyToSet[queryKey])); \n                                        break; \n                                    case Parameters::OUTFMT_TSET: \n                                        result.append(SSTR(tSetToSource[tKeyToSet[res.dbKey]])); \n                                        break; \n                                    case Parameters::OUTFMT_TSETID: \n                                        result.append(SSTR(tKeyToSet[res.dbKey])); \n                                        break; \n                                    case Parameters::OUTFMT_TAXID: \n                                        result.append(SSTR(taxon)); \n                                        break; \n                                    case Parameters::OUTFMT_TAXNAME: \n                                        result.append((taxonNode != NULL) ? t->getString(taxonNode->nameIdx) : \"unclassified\"); \n                                        break; \n                                    case Parameters::OUTFMT_TAXLIN: \n                                        result.append((taxonNode != NULL) ? t->taxLineage(taxonNode, true) : \"unclassified\"); \n                                        break; \n                                    case Parameters::OUTFMT_EMPTY: \n                                        result.push_back('-'); \n                                        break; \n                                    case Parameters::OUTFMT_QORFSTART: \n                                        result.append(SSTR(res.queryOrfStartPos)); \n                                        break; \n                                    case Parameters::OUTFMT_QORFEND: \n                                        result.append(SSTR(res.queryOrfEndPos)); \n                                        break; \n                                    case Parameters::OUTFMT_TORFSTART: \n                                        result.append(SSTR(res.dbOrfStartPos)); \n                                        break; \n                                    case Parameters::OUTFMT_TORFEND: \n                                        result.append(SSTR(res.dbOrfEndPos)); \n                                        break; \n                                } \n                                if (i < outcodes.size() - 1) { \n                                    result.push_back('\\t'); \n                                } \n                            } \n                            result.push_back('\\n'); \n                        } \n                        break; \n                    } \n                    case Parameters::FORMAT_ALIGNMENT_BLAST_WITH_LEN: { \n                        int count = snprintf(buffer, sizeof(buffer), \n                                             \"%s\\t%s\\t%1.3f\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%.2E\\t%d\\t%d\\t%d\\n\", \n                                             queryId.c_str(), targetId.c_str(), res.seqId, alnLen, \n                                             missMatchCount, gapOpenCount, \n                                             res.qStartPos + 1, res.qEndPos + 1, \n                                             res.dbStartPos + 1, res.dbEndPos + 1, \n                                             res.eval, res.score, \n                                             res.qLen, res.dbLen); \n \n                        if (count < 0 || static_cast<size_t>(count) >= sizeof(buffer)) { \n                            Debug(Debug::WARNING) << \"Truncated line in entry\" << i << \"!\\n\"; \n                            continue; \n                        } \n \n                        result.append(buffer, count); \n                        break; \n                    } \n                    case Parameters::FORMAT_ALIGNMENT_SAM: { \n                        bool strand = res.qEndPos > res.qStartPos; \n                        int rawScore = static_cast<int>(evaluer->computeRawScoreFromBitScore(res.score) + 0.5); \n                        uint32_t mapq = -4.343 * log(exp(static_cast<double>(-rawScore))); \n                        mapq = (uint32_t) (mapq + 4.99); \n                        mapq = mapq < 254 ? mapq : 254; \n                        int count = snprintf(buffer, sizeof(buffer), \"%s\\t%d\\t%s\\t%d\\t%d\\t\",  queryId.c_str(), (strand) ? 16: 0, targetId.c_str(), res.dbStartPos + 1, mapq); \n                        if (count < 0 || static_cast<size_t>(count) >= sizeof(buffer)) { \n                            Debug(Debug::WARNING) << \"Truncated line in entry\" << i << \"!\\n\"; \n                            continue; \n                        } \n                        result.append(buffer, count); \n                        if (isTranslatedSearch == true && targetNucs == true && queryNucs == true) { \n                            Matcher::result_t::protein2nucl(res.backtrace, newBacktrace); \n                            result.append(newBacktrace); \n                            newBacktrace.clear(); \n \n                        } else { \n                            result.append(res.backtrace); \n                        } \n                        result.append(\"\\t*\\t0\\t0\\t\"); \n                        int start = std::min(res.qStartPos, res.qEndPos); \n                        int end   = std::max(res.qStartPos, res.qEndPos); \n                        if (queryProfile) { \n                            result.append(queryProfData.c_str() + start, (end + 1) - start); \n                        } else { \n                            result.append(querySeqData + start, (end + 1) - start); \n                        } \n                        count = snprintf(buffer, sizeof(buffer), \"\\t*\\tAS:i:%d\\tNM:i:%d\\n\", rawScore, missMatchCount); \n                        if (count < 0 || static_cast<size_t>(count) >= sizeof(buffer)) { \n                            Debug(Debug::WARNING) << \"Truncated line in entry\" << i << \"!\\n\"; \n                            continue; \n                        } \n                        result.append(buffer, count); \n                        break; \n                    } \n                    case Parameters::FORMAT_ALIGNMENT_HTML: { \n                        const char* jsAln = \"{\\\"target\\\": \\\"%s\\\", \\\"seqId\\\": %1.3f, \\\"alnLen\\\": %d, \\\"mismatch\\\": %d, \\\"gapopen\\\": %d, \\\"qStartPos\\\": %d, \\\"qEndPos\\\": %d, \\\"dbStartPos\\\": %d, \\\"dbEndPos\\\": %d, \\\"eval\\\": %.2E, \\\"score\\\": %d, \\\"qLen\\\": %d, \\\"dbLen\\\": %d, \\\"qAln\\\": \\\"\"; \n                        int count = snprintf(buffer, sizeof(buffer), jsAln, \n                                             targetId.c_str(), res.seqId, alnLen, \n                                             missMatchCount, gapOpenCount, \n                                             res.qStartPos + 1, res.qEndPos + 1, \n                                             res.dbStartPos + 1, res.dbEndPos + 1, \n                                             res.eval, res.score, \n                                             res.qLen, res.dbLen); \n \n                        if (count < 0 || static_cast<size_t>(count) >= sizeof(buffer)) { \n                            Debug(Debug::WARNING) << \"Truncated line in entry\" << i << \"!\\n\"; \n                            continue; \n                        } \n                        result.append(buffer, count); \n                        if (queryProfile) { \n                            printSeqBasedOnAln(result, queryProfData.c_str(), res.qStartPos, \n                                               Matcher::uncompressAlignment(res.backtrace), false, (res.qStartPos > res.qEndPos), \n                                               (isTranslatedSearch == true && queryNucs == true), translateNucl); \n                        } else { \n                            printSeqBasedOnAln(result, querySeqData, res.qStartPos, \n                                               Matcher::uncompressAlignment(res.backtrace), false, (res.qStartPos > res.qEndPos), \n                                               (isTranslatedSearch == true && queryNucs == true), translateNucl); \n                        } \n                        result.append(\"\\\", \\\"dbAln\\\": \\\"\"); \n                        size_t tId = tDbr->sequenceReader->getId(res.dbKey); \n                        char* targetSeqData = tDbr->sequenceReader->getData(tId, thread_idx); \n                        if (targetProfile) { \n                            Sequence::extractProfileConsensus(targetSeqData, *subMat, targetProfData); \n                            printSeqBasedOnAln(result, targetProfData.c_str(), res.dbStartPos, \n                                               Matcher::uncompressAlignment(res.backtrace), true, \n                                               (res.dbStartPos > res.dbEndPos), \n                                               (isTranslatedSearch == true && targetNucs == true), translateNucl); \n                        } else { \n                            printSeqBasedOnAln(result, targetSeqData, res.dbStartPos, \n                                               Matcher::uncompressAlignment(res.backtrace), true, \n                                               (res.dbStartPos > res.dbEndPos), \n                                               (isTranslatedSearch == true && targetNucs == true), translateNucl); \n                        } \n                        result.append(\"\\\" },\\n\"); \n                        break; \n                    } \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n                    default: \n                        Debug(Debug::ERROR) << \"Not implemented yet\"; \n                        EXIT(EXIT_FAILURE); \n                } \n            } \n \n            if (format == Parameters::FORMAT_ALIGNMENT_HTML) { \n                result.append(\"]},\\n\"); \n            } \n            resultWriter.writeData(result.c_str(), result.size(), queryKey, thread_idx, isDb); \n            result.clear(); \n        }", "pragma": "for ", "hash": "1e5c5adc9403f3741f94837973c98da3c53bc84f15719cc193dbad077e5c7351"}
{"code": "for (int jx = 0; jx <= Lx; jx++) { \n                        int kx = ix - jx + Nx; \n                        if (kx < 0) continue; \n                        if (kx > Lx) continue; \n                        for (int jy = 0; jy <= Ly; jy++) { \n                            int ky = iy - jy + Ny; \n                            if (ky < 0) continue; \n                            if (ky > Ly) continue; \n                            for (int jz = 0; jz <= Lz; jz++) { \n                                int kz = iz - jz + Nz; \n                                if (kz < 0) continue; \n                                if (kz > Lz) continue; \n \n                                if (((ix - Nx) * (ix - Nx) + (iy - Ny) * (iy - Ny) + (iz - Nz) * (iz - Nz)) == 0) { \n                                    continue; \n                                } \n \n                                 \n \n                                bbxx[ix][iy][iz] += bx[jx][jy][jz] * bx[kx][ky][kz] * DVQ; \n                                bbxy[ix][iy][iz] += bx[jx][jy][jz] * by[kx][ky][kz] * DVQ; \n                                bbxz[ix][iy][iz] += bx[jx][jy][jz] * bz[kx][ky][kz] * DVQ; \n                                bbyx[ix][iy][iz] += by[jx][jy][jz] * bx[kx][ky][kz] * DVQ; \n                                bbyy[ix][iy][iz] += by[jx][jy][jz] * by[kx][ky][kz] * DVQ; \n                                bbyz[ix][iy][iz] += by[jx][jy][jz] * bz[kx][ky][kz] * DVQ; \n                                bbzx[ix][iy][iz] += bz[jx][jy][jz] * bx[kx][ky][kz] * DVQ; \n                                bbzy[ix][iy][iz] += bz[jx][jy][jz] * by[kx][ky][kz] * DVQ; \n                                bbzz[ix][iy][iz] += bz[jx][jy][jz] * bz[kx][ky][kz] * DVQ; \n                                 \n \n                                vvxx[ix][iy][iz] += vx[jx][jy][jz] * vx[kx][ky][kz] * DVQ; \n                                vvxy[ix][iy][iz] += vx[jx][jy][jz] * vy[kx][ky][kz] * DVQ; \n                                vvxz[ix][iy][iz] += vx[jx][jy][jz] * vz[kx][ky][kz] * DVQ; \n                                vvyx[ix][iy][iz] += vy[jx][jy][jz] * vx[kx][ky][kz] * DVQ; \n                                vvyy[ix][iy][iz] += vy[jx][jy][jz] * vy[kx][ky][kz] * DVQ; \n                                vvyz[ix][iy][iz] += vy[jx][jy][jz] * vz[kx][ky][kz] * DVQ; \n                                vvzx[ix][iy][iz] += vz[jx][jy][jz] * vx[kx][ky][kz] * DVQ; \n                                vvzy[ix][iy][iz] += vz[jx][jy][jz] * vy[kx][ky][kz] * DVQ; \n                                vvzz[ix][iy][iz] += vz[jx][jy][jz] * vz[kx][ky][kz] * DVQ; \n                                 \n \n                                bvxx[ix][iy][iz] += bx[jx][jy][jz] * vx[kx][ky][kz] * DVQ; \n                                bvxy[ix][iy][iz] += bx[jx][jy][jz] * vy[kx][ky][kz] * DVQ; \n                                bvxz[ix][iy][iz] += bx[jx][jy][jz] * vz[kx][ky][kz] * DVQ; \n                                bvyx[ix][iy][iz] += by[jx][jy][jz] * vx[kx][ky][kz] * DVQ; \n                                bvyy[ix][iy][iz] += by[jx][jy][jz] * vy[kx][ky][kz] * DVQ; \n                                bvyz[ix][iy][iz] += by[jx][jy][jz] * vz[kx][ky][kz] * DVQ; \n                                bvzx[ix][iy][iz] += bz[jx][jy][jz] * vx[kx][ky][kz] * DVQ; \n                                bvzy[ix][iy][iz] += bz[jx][jy][jz] * vy[kx][ky][kz] * DVQ; \n                                bvzz[ix][iy][iz] += bz[jx][jy][jz] * vz[kx][ky][kz] * DVQ; \n                                 \n \n                                vbxx[ix][iy][iz] += vx[jx][jy][jz] * bx[kx][ky][kz] * DVQ; \n                                vbxy[ix][iy][iz] += vx[jx][jy][jz] * by[kx][ky][kz] * DVQ; \n                                vbxz[ix][iy][iz] += vx[jx][jy][jz] * bz[kx][ky][kz] * DVQ; \n                                vbyx[ix][iy][iz] += vy[jx][jy][jz] * bx[kx][ky][kz] * DVQ; \n                                vbyy[ix][iy][iz] += vy[jx][jy][jz] * by[kx][ky][kz] * DVQ; \n                                vbyz[ix][iy][iz] += vy[jx][jy][jz] * bz[kx][ky][kz] * DVQ; \n                                vbzx[ix][iy][iz] += vz[jx][jy][jz] * bx[kx][ky][kz] * DVQ; \n                                vbzy[ix][iy][iz] += vz[jx][jy][jz] * by[kx][ky][kz] * DVQ; \n                                vbzz[ix][iy][iz] += vz[jx][jy][jz] * bz[kx][ky][kz] * DVQ; \n                            } \n                        } \n                    }", "pragma": "for ", "hash": "ffef1f0996dd3133de7a0d77024d4442d92fe001320a2c92557d10ec11fbe0f1"}
{"code": "for (size_t i=0; i<setSize; i++) { \n       \n    double col, lon, rad;             \n    int nodeNum = i; \n \n     \n \n    xyz2ColLonRad (x[nodeNum], y[nodeNum], z[nodeNum], col, lon, rad); \n     \n     \n \n    kdres *setTop = kd_nearest3 (topo.elvTree,   rad2Deg (col), rad2Deg (lon), R_EARTH);         \n    kdres *setCst = kd_nearest3 (topo.crustTree, rad2Deg (col), rad2Deg (lon), R_EARTH);         \n     \n    void *indTop  = kd_res_item_data (setTop); \n    void *indCst  = kd_res_item_data (setCst); \n     \n    int pointTop  = * (int *) indTop; \n    int pointCst  = * (int *) indCst; \n     \n    kd_res_free (setTop);  \n    kd_res_free (setCst);  \n     \n     \n \n    elv[i] = topo.elv[pointTop] / 1000.;     \n \n     \n     \n    double referenceHeight;     \n    double crustRho; \n    double crustVp; \n \n     \n \n    double ANI_SLOPE = 0.0011; \n    double R_ANI     = 6201.; \n \n    double isoVs            = topo.vsCrust[pointCst]; \n    double aniCorrectionVsv = (1/3.) * (ANI_SLOPE * (rad - R_ANI)); \n    double aniCorrectionVsh = (2/3.) * (ANI_SLOPE * (rad - R_ANI)); \n     \n    double crustVsh = topo.vsCrust[pointCst] + aniCorrectionVsh; \n    double crustVsv = topo.vsCrust[pointCst] - aniCorrectionVsv;     \n     \n    if (elv[i] <= 0) { \n       \n      referenceHeight = R_EARTH;       \n       \n       \n \n      crustRho = 0.2547 * isoVs + 1.979; \n      crustVp  = 1.5865 * isoVs + 0.844; \n       \n    } else { \n       \n      referenceHeight = R_EARTH + elv[i]; \n       \n       \n \n      crustRho = 0.2277 * isoVs + 2.016; \n      crustVp  = 1.5399 * isoVs + 0.840; \n       \n    }  \n        \n    double radMoho = referenceHeight - topo.dpCrust[pointCst]; \n     \n     \n \n    if (rad > radMoho) { \n \n      background_models backgroundMod; \n       \n      double vs1d, vp1d, rho1d; \n      backgroundMod.prem_no220 (rad, vs1d, vp1d, rho1d);   \n \n      double N = crustRho * crustVsh*crustVsh; \n      double L = crustRho * crustVsv*crustVsv; \n      double A = crustRho * crustVp*crustVp; \n      double C = crustRho * crustVp*crustVp; \n      double S = A - 2 * N; \n      double F = A - 2 * L; \n           \n      c11[nodeNum] = C; \n      c12[nodeNum] = F; \n      c13[nodeNum] = F; \n      c22[nodeNum] = A; \n      c23[nodeNum] = S; \n      c33[nodeNum] = A; \n      c44[nodeNum] = N; \n      c55[nodeNum] = L; \n      c66[nodeNum] = L; \n      rho[nodeNum] = crustRho; \n       \n       \n \n      du1[nodeNum] = 1; \n       \n    }     \n  }", "pragma": "parallel for ", "hash": "ccbc1ea14c882794307173eddf61c89bf179c10a12fdae1dcef0f99790438026"}
{"code": "for(s = 0; s < size; ++s) \n                    { \n                        if(recvBuffers[s] != vBuffers[s]) \n                        { \n                            throw std::runtime_error( \n                                \"Verification check failed!\"); \n                        } \n                    }", "pragma": "for ", "hash": "7ce8f61fc66087ee3e16d85cc05bd3e2aa3a5132492064250c630753d6c88285"}
{"code": "for( startingDimension=0; startingDimension<d; startingDimension++){ \n\t\t\t\t\t\tsprintf( filename, \"%s.kde%i.dat\", suffix, startingDimension); \n\t\t\t\t\t\tFILE *fp_kde_d = fopen( filename, \"w+\"); \n\t\t\t\t\t\tdouble dx = (ub[startingDimension]-lb[startingDimension]) / 10.; \n\t\t\t\t\t\tfor( startingPoint[startingDimension]=lb[startingDimension]; startingPoint[startingDimension]<=ub[startingDimension]; startingPoint[startingDimension]+=dx) \n\t\t\t\t\t\t\tfprintf( fp_kde_d, \"%e %e\\n\", startingPoint[startingDimension], rekursiveIntegration( startingPoint, 0, startingDimension, \n\t\t\t\t\t\t\t\t\tlb, ub, stepSize, d, \n\t\t\t\t\t\t\t\t\tmyfunckde, &_kdedata)); \n\t\t\t\t\t\tfclose( fp_kde_d); \n\t\t\t\t\t}", "pragma": "parallel for ", "hash": "60cddd9bfb79cfe36ea0ba5a89f5f5947952a1ee65781de6004b93db15cc525a"}
{"code": "for (local_int_t i=0; i< nrow; i++)  { \n    double sum = 0.0; \n    const double * const cur_vals = A.matrixValues[i]; \n    const local_int_t * const cur_inds = A.mtxIndL[i]; \n    const int cur_nnz = A.nonzerosInRow[i]; \n    for (int j=0; j< cur_nnz; j++) { \n      sum += cur_vals[j]*xv[cur_inds[j]]; \n\t} \n    yv[i] = sum; \n \n  }", "pragma": "parallel for ", "hash": "5b9529e4b241b792cddcdc9cbd797569b22fcb61c435d512051b781caf49bb72"}
{"code": "for (size_t _i = 0; _i<numOmegas; _i++){ \n      int idx = compactCompute ? updateList[_i] : _i; \n      const Eigen::Vector3f& referencePoint = (*_reference)[idx].point(); \n      const Eigen::Vector3f& referenceNormal = (*_reference)[idx].normal(); \n       \n      Eigen::Matrix3f& omegap = _omega_points[idx]; \n      Eigen::Matrix3f& omegan = _omega_normals[idx]; \n       \n      omegap.setZero(); \n       \n \n      if (referenceNormal.squaredNorm()>0) { \n\t \n \n\tEigen::Vector3f axis(0, -referenceNormal.z(), referenceNormal.y()); \n\tfloat s = axis.norm(); \n\tfloat c = referenceNormal.x(); \n\tfloat angle = atan2(s,c); \n\tEigen::AngleAxisf aa(angle, axis); \n\tEigen::Matrix3f Rn=aa.toRotationMatrix(); \n\tomegap+=Rn*_flat_omega*Rn.transpose(); \n\tomegan=Rn*_long_linear_omega*Rn.transpose(); \n      } else { \n\tomegan.setZero(); \n      } \n        \n      float depthScaling = 1/(1+fabs(referencePoint.z())); \n      omegap *= depthScaling; \n      omegan *= depthScaling; \n \n      if (isNan(omegap) || isNan(omegan)) { \n\tcerr << endl; \n\tcerr << \" point index: \" << idx << endl; \n\tcerr << \"p: \" << endl << referencePoint.transpose() << endl; \n\tcerr << \"Omegap\" << endl << omegap << endl; \n\tcerr << \"n: \" << endl << referenceNormal.transpose() << endl; \n\tcerr << \"Omegan\" << endl << omegan << endl; \n\tthrow std::runtime_error(\"NAN detected\"); \n      } \n \n  \n    }", "pragma": "parallel for ", "hash": "6900e195fb1793630908fa77e2f7d8be5b4f181a1dcc84b7b3f280707fcf3f19"}
{"code": "for (int hx = 0; hx < N; ++hx) { \n\t\tfor (int hy = 0; hy < M; ++hy) { \n\t\t\tfor (int hz = 0; hz < K; ++hz) { \n\t\t\t\tdouble Y = ZI _p3(hx, hy, hz)[REAL]  / ZS; \n\t\t\t\tdouble N = INI _p3(hx, hy, hz)[REAL] / ZS; \n \n\t\t\t\tif (N > 0.01) { \n\t\t\t\t\tYout.varmap _p(hx, hy, hz) = Y / (2 * N); \n\t\t\t\t} else { \n\t\t\t\t\tYout.varmap _p(hx, hy, hz) = 0; \n\t\t\t\t} \n \n\t\t\t\tYout.ni _p(hx, hy, hz) = N; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "79d2007e0349ac72f56e1c78d81391edddad02827ccfd9c739ac8fb742777e2d"}
{"code": "for(int i=0; i<i_NumOfVerticesToBeColored; i++) { \n\t\t\t\t \n \n\t\t\t\tcont = true; \n\t\t\t\tint v = vi_VerticesToBeColored[i]; \n\t\t\t\t \n \n\t\t\t\tfor (int w=m_vi_LeftVertices [v]; (w<m_vi_LeftVertices [v+1]) && (cont == true); w++ ) { \n\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t \n \n\t\t\t\t\tfor (int x=m_vi_RightVertices [m_vi_Edges [w]]; x<m_vi_RightVertices [m_vi_Edges [w]+1]; x++ ) { \n\t\t\t\t\t   \n \n\t\t\t\t\t   \n \n\t\t\t\t\t   \n \n\t\t\t\t\t   \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t  if ( m_vi_LeftVertexColors [m_vi_Edges [x]] == m_vi_LeftVertexColors[v] && f(v) > f(m_vi_Edges [x]) ) { \n\t\t\t\t\t\t\t \n \n#pragma omp critical \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tvi_verticesNeedNewColor.push_back(v); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\tcont = false; \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for private(cont)", "hash": "16719a5c4cf3ceb934d18be68dbfad15561ee4abd818fcd9590f4608b86a7850"}
{"code": "for (node u = 0; u < n; ++u) { \n\t\tif (degreeSequence[u] == 0) continue; \n \n\t\tdouble intDeg = (1.0 - mu[u]) * degreeSequence[u]; \n\t\tinternalDegreeSequence[u] = std::llround(intDeg); \n\t}", "pragma": "parallel for ", "hash": "674d4385e5afdb46ea1abe4bc308df5fdca8f3040ae8096c572d1a29c8a59e17"}
{"code": "for (int i = 0; i < (int)test_data.size(); ++i) { \n\t\tstd::vector<int> topn_labels; \n\t\tInvertedIndex::result_t results; \n\t\t \n\t\tknn.fast_knn(results, K, test_data[i], K_FIRST, data.size() / 100); \n\t\tpredict(topn_labels, results, labels); \n\t\t \n#pragma omp critical \n\t\t{ \n\t\t\tevaluation.update(topn_labels, test_labels[i]); \n\t\t\tif (i % 1000 == 0) { \n\t\t\t\tprint_evaluation(evaluation, i, t); \n\t\t\t\tt = tick(); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "c9906148cecd248b78cdbc7c0e2ead1f7bfaad54726e93dc2b2772f4e5b2eac3"}
{"code": "for (int j = 1; j < dim_n - 1; ++j ) \n\t{ \n\t\tint kstart = 1; \n\t\twhile ( ((long) &v2[j*dim_m + kstart]) & 0x000000000000001F ) \n\t\t{  \n\t\t\tkstart++; \n\t\t} \n\t\tint i = 1; \n\t\tfor (; i < kstart; ++i) \n\t\t{ \n\t\t\tkernel_sequential(v1 + j*dim_n + i, v2 + j*dim_n + i, dim_n);\t \n\t\t} \n\t\tfor (; i < dim_m - 1 - (dim_m - 1)%4; i = i + 4) \n\t\t{ \n\t\t\tkernel(v1 + j*dim_n + i, v2 + j*dim_n + i, dim_n); \n\t\t} \n\t\t \n \n\t\tfor (; i < dim_m - 1; ++i) \n\t\t{ \n\t\t\tkernel_sequential(v1 + j*dim_n + i, v2 + j*dim_n + i, dim_n);\t \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "4d40098db94821cfd12b8430639f938d78f33556718c0f75f948e5a8c2551bbc"}
{"code": "for (parallel_y = 0; parallel_y < parallel_y_max; parallel_y++)  \n \n\t\t\t{ \n\t\t\t\tint\t\tz, y; \n\t\t\t\tfloat\tcurrent_height = mapMaxs[2];  \n \n\t\t\t\tfloat\tscatter_mult_Y = 1.0; \n \n\t\t\t\tif (areas + 1 >= MAX_TEMP_AREAS) \n\t\t\t\t{ \n\t\t\t\t\tbreak; \n\t\t\t\t} \n \n\t\t\t\t \n \n\t\t\t\tif (scatter_y == scatter) scatter_y = scatter_min; \n\t\t\t\telse if (scatter_y == scatter) scatter_y = scatter_max; \n\t\t\t\telse scatter_y = scatter; \n \n\t\t\t\tif (DO_OPEN_AREA_SPREAD && ShortestWallRangeFrom( last_org ) >= 256) \n\t\t\t\t\tscatter_mult_Y = 2.0; \n \n\t\t\t\ty = (starty + offsetY) - (parallel_y * (scatter_y * scatter_mult_Y)); \n \n\t\t\t\tfor (z = startz; z >= mapMins[2]; z -= scatter_min) \n\t\t\t\t{ \n\t\t\t\t\tvec3_t\t\tnew_org, org; \n\t\t\t\t\tfloat\t\tfloor = 0; \n\t\t\t\t\tqboolean\tforce_continue = qfalse; \n\t\t\t\t\tclock_t\t\tcurrent_time = clock(); \n \n\t\t\t\t\tif (areas + 1 >= MAX_TEMP_AREAS) \n\t\t\t\t\t{ \n\t\t\t\t\t\tbreak; \n\t\t\t\t\t} \n \n\t\t\t\t\t \n \n\t\t\t\t\tfinal_tests++; \n \n\t\t\t\t\tif (final_tests > 1000) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif(omp_get_thread_num() == 0) \n\t\t\t\t\t\t{ \n \n\t\t\t\t\t\t\taw_percent_complete = (float)((float)final_tests/(float)total_tests)*100.0f; \n \n\t\t\t\t\t\t\tif ( \naw_percent_complete - awPreviousPercent > 0.1)  \n \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\tawPreviousPercent = aw_percent_complete; \n\t\t\t\t\t\t\t\ttrap->UpdateScreen(); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n\t\t\t\t\tif (z >= current_height) \n\t\t\t\t\t{ \n \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t} \n \n\t\t\t\t\t \n \n\t\t\t\t\tVectorSet(new_org, x, y, z); \n \n \n \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tfloor = FloorHeightAt(new_org); \n\t\t\t\t\t} \n \n\t\t\t\t\t \n \n\t\t\t\t\t \n \n \n\t\t\t\t\t \n \n\t\t\t\t\tVectorSet(org, new_org[0], new_org[1], floor); \n \n\t\t\t\t\tif (floor < mapMins[2] || (DO_SINGLE && floor >= MAX_MAP_SIZE)) \n\t\t\t\t\t{ \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tcurrent_height = mapMins[2]-2048;  \n \n\t\t\t\t\t\tcontinue;  \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t\telse if (floor > mapMaxs[2]) \n\t\t\t\t\t{ \n \n\t\t\t\t\t\t \n \n \n \n \n \n \n \n \n \n\t\t\t\t\t\tcurrent_height = z - scatter_min; \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t} \n\t\t\t\t\telse if (VectorDistance(org, last_org) < waypoint_scatter_distance) \n\t\t\t\t\t{ \n\t\t\t\t\t\tcurrent_height = floor; \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t} \n \n\t\t\t\t\tif (force_continue) continue;  \n \n \n \n \n\t\t\t\t\t{ \n\t\t\t\t\t\tif (!AIMod_AutoWaypoint_Check_PlayerWidth(org)) \n\t\t\t\t\t\t{ \n \n\t\t\t\t\t\t\tcurrent_height = floor; \n\t\t\t\t\t\t\tforce_continue = qtrue;  \n \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n \n\t\t\t\t\tif (force_continue) continue;  \n \n \n\t\t\t\t\tif (sjc_jkg_preview && org[2]+8 < -423 && org[2]+8 > -424.0) \n\t\t\t\t\t{ \n \n\t\t\t\t\t\tcurrent_height = floor; \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t} \n \n\t\t\t\t\tif (FOLIAGE_TreeSolidBlocking_AWP(org)) \n\t\t\t\t\t{ \n \n\t\t\t\t\t\tcurrent_height = floor; \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t} \n \n \n \n\t\t\t\t\t{ \n#pragma omp critical (__ADD_TEMP_NODE__) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tsprintf(last_node_added_string, \"^5Adding temp waypoint ^3%i ^5at ^7%f %f %f^5.\", areas, org[0], org[1], org[2]+8); \n \n\t\t\t\t\t\t\t \n \n \n\t\t\t\t\t\t\tarealist[areas][0] = org[0]; \n\t\t\t\t\t\t\tarealist[areas][1] = org[1]; \n\t\t\t\t\t\t\tarealist[areas][2] = org[2]+8; \n \n\t\t\t\t\t\t\tlast_org[0] = arealist[areas][0]; \n\t\t\t\t\t\t\tlast_org[1] = arealist[areas][1]; \n\t\t\t\t\t\t\tlast_org[2] = arealist[areas][2]; \n\t\t\t\t\t\t\tareas++; \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tcurrent_height = floor; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "a8a6a8c217776ffc9caa6a46eed67118dff015206f9c2b1d8b928250b551c802"}
{"code": "for (i = 0; i < 64; i++) \n    { \n      #pragma omp ordered doacross(source: omp_cur_iteration ) \n      #pragma omp ordered doacross(sink: i - 1) \n      #pragma omp ordered threads   \n \n      ; \n    }", "pragma": "for ", "hash": "e5da6655ba0e5a733b32ac934a4b4a3bbb1421f80e10af973149f6cad07bd40f"}
{"code": "for(node_i=0;node_i<n_nodes;node_i++) \n        { \n            s_aux=0; \n            for(node_j=0;node_j<n_nodes;node_j++) \n            { \n                s_aux+=W[node_i*n_nodes+node_j]; \n            } \n            S[node_i]=s_aux; \n        }", "pragma": "for reduction(+:s_aux) private(node_i node_j)", "hash": "a05333240df80df0b6575ef2418e0c716363a5fe3556971077e4b85b5bf32d7c"}
{"code": "for (int i = 0; i < (int) imageSizeRef[box]; i++) { \n      double sumRealNew = 0.0; \n      double sumImaginaryNew = 0.0; \n      double sumRealOld = cosMolRef[molIndex][i]; \n      double sumImaginaryOld = sinMolRef[molIndex][i]; \n      cosMolRestore[i] = cosMolRef[molIndex][i]; \n      sinMolRestore[i] = sinMolRef[molIndex][i]; \n \n      for (uint p = 0; p < length; ++p) { \n        if(particleHasNoCharge[startAtom + p]) { \n          continue; \n        } \n        double dotProductNew = Dot(p, kxRef[box][i], \n                                   kyRef[box][i], kzRef[box][i], \n                                   molCoords); \n \n        sumRealNew += (thisKind.AtomCharge(p) * cos(dotProductNew)); \n        sumImaginaryNew += (thisKind.AtomCharge(p) * sin(dotProductNew)); \n      } \n \n      sumRnew[box][i] = sumRref[box][i] + lambdaCoef * \n                        (sumRealNew - sumRealOld); \n      sumInew[box][i] = sumIref[box][i] + lambdaCoef * \n                        (sumImaginaryNew - sumImaginaryOld); \n      cosMolRef[molIndex][i] = sumRealNew; \n      sinMolRef[molIndex][i] = sumImaginaryNew; \n \n      energyRecipNew += (sumRnew[box][i] * sumRnew[box][i] + sumInew[box][i] \n                         * sumInew[box][i]) * prefactRef[box][i]; \n    }", "pragma": "parallel for reduction(+:energyrecipnew) ", "hash": "d2841fbe2830c814dcff28f8cd50f6e32868be3a0d30a1bc3b9f857a496d06b2"}
{"code": "for (int i = 0; i < (int) fx.size(); i++) \n\t\t{ \n\t\t\tconst Vector3r &xi = fx[i]; \n \n\t\t\t \n \n\t\t\tneighborhoodSearch->find_neighbors(xi.data(), neighbors); \n\t\t\tconst unsigned int numFluidNeighbors = (unsigned int) neighbors[0].size(); \n \n\t\t\tunsigned char ftype = ParticleType::Foam; \n\t\t\tif (numFluidNeighbors < 6) \n\t\t\t\tftype = ParticleType::Spray; \n\t\t\telse if (numFluidNeighbors > 20) \n\t\t\t\tftype = ParticleType::Bubbles; \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tif (ftype == ParticleType::Foam) \n\t\t\t{ \n\t\t\t\tauto correctedFluidNeighbors = numFluidNeighbors; \n\t\t\t\t \n \n\t\t\t\tauto unitSphereCapVolume = [&](const Real h) \n\t\t\t\t{ \n\t\t\t\t\treturn h * h * (M_PI / 3) * (3 - h); \n\t\t\t\t}; \n\t\t\t\tfor (auto j = 0u; j < 3; ++j) \n\t\t\t\t{ \n\t\t\t\t\tReal d; \n\t\t\t\t\td = std::abs(xi[j] - bbMin[j]); \n\t\t\t\t\tif (d < supportRadius) \n\t\t\t\t\t\tcorrectedFluidNeighbors += (decltype(correctedFluidNeighbors))(std::ceil(correctedFluidNeighbors * unitSphereCapVolume(1 - d / supportRadius))); \n\t\t\t\t\td = std::abs(xi[j] - bbMax[j]); \n\t\t\t\t\tif (d < supportRadius) \n\t\t\t\t\t\tcorrectedFluidNeighbors += (decltype(correctedFluidNeighbors))(std::ceil(correctedFluidNeighbors * unitSphereCapVolume(1 - d / supportRadius))); \n\t\t\t\t\tif (correctedFluidNeighbors > 20) \n\t\t\t\t\t{ \n\t\t\t\t\t\tftype = ParticleType::Bubbles; \n\t\t\t\t\t\tbreak; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n \n\t\t\tif (splitTypes) \n\t\t\t{ \n\t\t\t\tparticleType[i] = ftype; \n\t\t\t\tnumParticlesOfType[ftype]++; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif (((xi.array() < bbMin.array() || xi.array() > bbMax.array()).any())) \n\t\t\t{ \n\t\t\t\tif (bbType == BbType::Kill) \n\t\t\t\t{ \n\t\t\t\t\tflifetime[i] = 0; \n\t\t\t\t} \n\t\t\t\telse if (bbType == BbType::Lifesteal) \n\t\t\t\t{ \n\t\t\t\t\tflifetime[i] -= static_cast<Real>(1000.0) * timeStepSize; \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\telse if (bbType == BbType::Clamp) \n\t\t\t\t{ \n\t\t\t\t\tconst Vector3r bbNormal = ((fx[i].array() < bbMin.array()).cast<Real>() - (fx[i].array() > bbMax.array()).cast<Real>()).matrix().normalized(); \n\t\t\t\t\tconst Vector3r vReflect = fv[i] - 2 * bbNormal.dot(fv[i]) * bbNormal; \n\t\t\t\t\tfv[i] = Real(0.25) * vReflect; \n\t\t\t\t\tfx[i] = (fx[i].array() < bbMin.array()).select(bbMin, fx[i]); \n\t\t\t\t\tfx[i] = (fx[i].array() > bbMax.array()).select(bbMax, fx[i]); \n\t\t\t\t\t \n \n\t\t\t\t\t \n \n\t\t\t\t} \n\t\t\t} \n \n\t\t\t \n \n\t\t\tif (ftype == ParticleType::Spray) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\tfv[i] += timeStepSize * g; \n\t\t\t\t \n \n\t\t\t\tfx[i] += timeStepSize * fv[i]; \n \n \n \n \n \n \n \n \n \n\t\t\t} \n\t\t\telse if ((ftype == ParticleType::Foam) || (ftype == ParticleType::Bubbles)) \n\t\t\t{ \n\t\t\t\tVector3r vf = Vector3r::Zero(); \n\t\t\t\tReal sumK = 0.0; \n\t\t\t\tfor (unsigned int j = 0; j < numFluidNeighbors; j++) \n\t\t\t\t{ \n\t\t\t\t\tconst unsigned int neighborIndex = neighbors[0][j]; \n\t\t\t\t\tconst Vector3r &xj = x0[neighborIndex]; \n\t\t\t\t\tconst Real K = CubicKernel::W(xi - xj); \n\t\t\t\t\tconst Vector3r v = v0[neighborIndex];  \n\t\t\t\t\tvf += v * K; \n\t\t\t\t\tsumK += K; \n\t\t\t\t} \n\t\t\t\tvf = (1.0 / sumK) * vf; \n \n\t\t\t\tif (ftype == ParticleType::Foam) \n\t\t\t\t{ \n\t\t\t\t\t \n \n\t\t\t\t\t \n \n\t\t\t\t\tfx[i] += timeStepSize * vf; \n\t\t\t\t\tflifetime[i] -= timeStepSize; \n\t\t\t\t} \n\t\t\t\telse if (ftype == ParticleType::Bubbles) \n\t\t\t\t{ \n\t\t\t\t\t \n \n\t\t\t\t\tfv[i] += timeStepSize * (-k_buoyancy * g + k_drag * invDt * (vf - fv[i])); \n\t\t\t\t\tfx[i] += timeStepSize * fv[i]; \n \n\t\t\t\t\t \n \n\t\t\t\t} \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "66478598bdd0d9d5073bcaa89fd61edc357a4420ada092471d96acd1d2e51aed"}
{"code": "for (size_t i = 0; i < n_pop; ++i) { \n            size_t thread_num = 0; \n \n            thread_num = omp_get_thread_num(); \n \n            uint_t c_1, c_2, c_3; \n \n            do {  \n \n                c_1 = bmo::stats::rind(0, n_pop - 1, rand_engines_vec[thread_num]); \n            } while (c_1 == i); \n \n            do {  \n \n                c_2 = bmo::stats::rind(0, n_pop - 1, rand_engines_vec[thread_num]); \n            } while (c_2 == i || c_2 == c_1); \n \n            do {  \n \n                c_3 = bmo::stats::rind(0, n_pop - 1, rand_engines_vec[thread_num]); \n            } while (c_3 == i || c_3 == c_1 || c_3 == c_2); \n \n             \n \n \n            const size_t rand_ind = bmo::stats::rind(0, n_vals-1, rand_engines_vec[thread_num]); \n \n            bmo::stats::internal::runif_vec_inplace<fp_t>(n_vals, rand_engines_vec[thread_num], rand_vec); \n            RowVec_t X_prop(n_vals); \n \n            for (size_t k = 0; k < n_vals; ++k) { \n                if ( rand_vec(k) < par_CR || k == rand_ind ) { \n                    if ( mutation_method == 1 ) { \n                        X_prop(k) = X(c_3,k) + par_F*(X(c_1,k) - X(c_2,k)); \n                    } else { \n                        X_prop(k) = best_vec(k) + par_F*(X(c_1,k) - X(c_2,k)); \n                         \n \n                    } \n                } else { \n                    X_prop(k) = X(i,k); \n                } \n            } \n \n             \n \n \n            fp_t prop_objfn_val = box_objfn(BMO_MATOPS_TRANSPOSE(X_prop), nullptr, opt_data); \n \n            if (!std::isfinite(prop_objfn_val)) { \n                prop_objfn_val = inf; \n            } \n             \n            if (prop_objfn_val <= objfn_vals(i)) { \n                X_next.row(i) = X_prop; \n                objfn_vals(i) = prop_objfn_val; \n            } else { \n                X_next.row(i) = X.row(i); \n            } \n        }", "pragma": "parallel for private(rand_vec)", "hash": "ad5921ec4b8241476c2c4c40a3b522cb35469444d9c47e7ffbcd0ce265a3df0f"}
{"code": "for (int i = 0; i < N; ++i) \n    for (int j = 0; j < N; ++j) \n    { \n      T sum(0); \n      for (int k = 0; k < N; ++k) \n        sum += A(i, k) * B(k, i); \n      C(i, j) = sum; \n    }", "pragma": "parallel for ", "hash": "2b4f035a38f341c60e17cfa81e719aa1e91beff63d28cea3f96e011fcd449108"}
{"code": "for(int n = 0; n < dindex; n += 4) \n      _path_falloff_roi(buffer, dpoints + n, dpoints + n + 2, width, height);", "pragma": "parallel for ", "hash": "00ff2ef52e3315bafa5bbb7c7ed14dfb27525928fc7eba899b28ff37f12d56e9"}
{"code": "for (y=0; y < (ssize_t) image->rows; y++) \n      { \n        MagickBooleanType \n          sync; \n \n        register const Quantum \n          *magick_restrict p; \n \n        register Quantum \n          *magick_restrict q; \n \n        register ssize_t \n          x; \n \n        if (status == MagickFalse) \n          continue; \n        p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n        q=QueueCacheViewAuthenticPixels(rotate_view,0,(ssize_t) (image->rows-y- \n          1),image->columns,1,exception); \n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        q+=GetPixelChannels(rotate_image)*image->columns; \n        for (x=0; x < (ssize_t) image->columns; x++) \n        { \n          register ssize_t \n            i; \n \n          q-=GetPixelChannels(rotate_image); \n          if (GetPixelWriteMask(image,p) == 0) \n            { \n              p+=GetPixelChannels(image); \n              continue; \n            } \n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n          { \n            PixelChannel channel=GetPixelChannelChannel(image,i); \n            PixelTrait traits=GetPixelChannelTraits(image,channel); \n            PixelTrait rotate_traits=GetPixelChannelTraits(rotate_image, \n              channel); \n            if ((traits == UndefinedPixelTrait) || \n                (rotate_traits == UndefinedPixelTrait)) \n              continue; \n            SetPixelChannel(rotate_image,channel,p[i],q); \n          } \n          p+=GetPixelChannels(image); \n        } \n        sync=SyncCacheViewAuthenticPixels(rotate_view,exception); \n        if (sync == MagickFalse) \n          status=MagickFalse; \n        if (image->progress_monitor != (MagickProgressMonitor) NULL) \n          { \n            MagickBooleanType \n              proceed; \n \n            #pragma omp critical (MagickCore_IntegralRotateImage) \n            proceed=SetImageProgress(image,RotateImageTag,progress++, \n              image->rows); \n            if (proceed == MagickFalse) \n              status=MagickFalse; \n          } \n      }", "pragma": "parallel for ", "hash": "50aec6da69c9945c7c03f60d6248990992e27a4794f42cc73cfa1456204b9f99"}
{"code": "for (int64_t i = start_read_id; i < end_read_id; i += 2) { \n                if (MapToHashMapper_(mapper_, i, rec1) && \n                        MapToHashMapper_(mapper_, i + 1, rec2)) { \n                    if (rec1.contig_id == rec2.contig_id && rec1.strand != rec2.strand) { \n                        int insert_size = -1; \n \n                        if (rec1.strand == 0) { \n                            insert_size = rec2.contig_to + reads_->length(i + 1) - rec2.query_to - (rec1.contig_from - rec1.query_from); \n                        } \n                        else { \n                            insert_size = rec1.contig_to + reads_->length(i) - rec1.query_to - (rec2.contig_from - rec2.query_from); \n                        } \n \n                        if (insert_size >= (int)reads_->length(i) && \n                                insert_size >= (int)reads_->length(i + 1)) { \n                            insert_hist.insert(insert_size); \n                        } \n                    } \n                } \n            }", "pragma": "parallel for private( rec1 rec2)", "hash": "f862f2ef6e82af09512772cfefc9cef19f80530fce693162f34abef0e2ec4054"}
{"code": "for (i=0;i<nCores;i++){ \n            LinearSystem(matrix1,r1,c1,ro1,co1,matrix2,r2,c2,ro2,co2,n,m,result,rr,cr,ror,cor,nCores,i,0,memaux,blockSize); \n        }", "pragma": "for ", "hash": "b35896c58ea1a370c1ee12880f8ae90bcd235595ace552701723127854ddc5a1"}
{"code": "for (unsigned int m = 0; m < M; m++) { \n                for (unsigned int i = pntrb[m]; i < pntre[m]; i++) { \n                    unsigned int k = col[i]; \n                    complex float v = alpha * conjf(val[i]); \n \n                    #pragma unroll \n                    for (unsigned int n = 0; n < N; n++) { \n                        complex float res = v * B[m+n*ldb]; \n                        float *out = (float*) &C[k+n*ldc]; \n \n                        #pragma omp atomic \n                        out[0] += crealf(res); \n \n                        #pragma omp atomic \n                        out[1] += cimagf(res); \n                    } \n                } \n            }", "pragma": "for ", "hash": "33ce19eed508a89b4a6c125340750689394e8deac2a93bd9196a354e35c4e996"}
{"code": "for (int i = 0; i < static_cast<int>(agents_.size()); ++i) { \n\t\t\tagents_[i]->computeNeighbors(); \n\t\t\tagents_[i]->computeNewVelocity(); \n\t\t}", "pragma": "parallel for ", "hash": "cff144d92af4f6b78222a9f3d5f769b8aa422c3284ca3ef5cb8bdd86d2a777cf"}
{"code": "for ( int i = 0; i < int( normals.size() ); ++i ) \n            { \n                Core::Math::getOrthogonalVectors( normals[i], tangents[i], bitangents[i] ); \n            }", "pragma": "parallel for ", "hash": "44514de87882aff918c21761423c008cd2204e5d6f4d49c932943a3d87d4ebf0"}
{"code": "for (i = INT_MIN; i < MY_MAX; i+=INCR) { \n        #pragma omp atomic \n        a++; \n    }", "pragma": "for ", "hash": "0e375527b359e9ab253f11cbe8dbefbacb04ef923b0e6b76ea33c1134b7c198c"}
{"code": "for (int p = 0; p<arraySizeSp; p++){ \n\t\tsum += ((p %( nPoints/2+1 ) == 0) ? 0.5 : 1)* \n\t\t(pow(omegaSp[p][0]/norm, 2) + pow(omegaSp[p][1]/norm, 2)); \n\t}", "pragma": "parallel for reduction(+:sum) ", "hash": "41886a794a675ac408aac003a84143741e7acf0d4ce00f333b53d2342c0374c9"}
{"code": "for (volatile int i = 0; i < pixels_count; ++i) \n    { \n        outputFrame[i] = (float)(unpacked_frame[i] << shift_val); \n    }", "pragma": "parallel for ", "hash": "87f61dda2e42808730a25d9547ddcc8c1ab35b4c8b200b7aa60f6c10af66396b"}
{"code": "for  ( int rr2 = 1; rr2 <= num_rot1_2; rr2++ )  \n\t\t\t\t{    \n\t\t\t\t\tfloat theta2 = delta_theta2 * (rr2-1); \n\t\t\t\t\ttheta2 = theta2 * 180 / PI; \n\t\t\t\t\t \n\t\t\t\t\t \n\t        \n\t\t\t\t\t \n \n\t\t\t\t\tkeypointslist keypoints2 = keys2[tt2-1][rr2-1]; \n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\t \n \n\t\t\t\t\tmatchingslist matchings1;\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tcompute_sift_matches(keypoints1,keypoints2,matchings1,siftparameters);\t\t        \n\t\t\t\t\t \n\t\t\t\t\tif ( verb )  \n\t\t\t\t\t{ \n\t\t\t\t\t\tprintf(\"t1=%.2f, theta1=%.2f, num keys1 = %d, t2=%.2f, theta2=%.2f, num keys2 = %d, num matches=%d\\n\", t, theta, (int) keypoints1.size(), t_im2, theta2, (int) keypoints2.size(), (int) matchings1.size()); \n\t\t\t\t\t} \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\t \n \n\t\t\t\t\tif ( matchings1.size() > 0 ) \n\t\t\t\t\t{ \n\t\t\t\t\t\tmatchings_vec[tt-1][rr-1][tt2-1][rr2-1] = matchingslist(matchings1.size()); \n            Minfoall_vec[tt-1][rr-1][tt2-1][rr2-1].resize(matchings1.size()); \n\t\t\t\t\t\t \n\t\t\t\t\t\tfor ( int cc = 0; cc < (int) matchings1.size(); cc++ )\t\t    \n\t\t\t\t\t\t{\t\t      \t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tmatchings_vec[tt-1][rr-1][tt2-1][rr2-1][cc] = matchings1[cc]; \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tvector<float> Minfo_1match(6); \n\t\t\t\t\t\t\tMinfo_1match[0] = t1; \n\t\t\t\t\t\t\tMinfo_1match[1] = t2; \n\t\t\t\t\t\t\tMinfo_1match[2] = theta; \n\t\t\t\t\t\t\tMinfo_1match[3] = t_im2_1; \n\t\t\t\t\t\t\tMinfo_1match[4] = t_im2_2; \n\t\t\t\t\t\t\tMinfo_1match[5] = theta2;\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tMinfoall_vec[tt-1][rr-1][tt2-1][rr2-1][cc] = Minfo_1match; \n\t\t\t\t\t\t} \t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "parallel for private(rr2)", "hash": "1c776ce4dd1c289d00046ae9538ea8f2d074dccc647e7e694de496e8a78b9cc8"}
{"code": "for(int i = 0; i < tensor.num_elements(); ++i) \n    { \n        dst[i] = tensor[i]; \n    }", "pragma": "parallel for ", "hash": "92bb211153d3cf6f34a9237e86a20d88e5dc83b4a30cbef5c2974ec3ed9cfec3"}
{"code": "for(long u=0; u<degree1Count; u++) \n\t{ \n\t\t \n \n\t\tfindMate(degree1Vtx[u],G,flag,mate,degree);\t\t   \n\t}", "pragma": "parallel for ", "hash": "c812b931e178dd3c1555ee8ab579877cdcec42bd8857f4508e533de923d80f61"}
{"code": "for (int i = 0; i < sfm_data.views.size(); ++i) { \n\t\tViews::const_iterator iterV = sfm_data.views.begin(); \n\t\tadvance(iterV, i); \n \n\t\tsize_t viewID = iterV->second->id_view; \n \n\t\tvector<Vec2> vec2D; \n\t\tvector<Vec3> vec3D; \n\t\tfor (Landmarks::const_iterator iterL = sfm_data.structure.begin(); \n\t\t\t\titerL != sfm_data.structure.end(); iterL++) { \n\t\t\tif (iterL->second.obs.find(viewID) != iterL->second.obs.end()) { \n\t\t\t\tObservation ob = iterL->second.obs.at(viewID); \n\t\t\t\tvec2D.push_back(ob.x); \n\t\t\t\tvec3D.push_back(iterL->second.X); \n\t\t\t} \n\t\t} \n \n\t\tImage_Localizer_Match_Data resection_data; \n\t\tresection_data.pt2D.resize(2, vec2D.size()); \n\t\tresection_data.pt3D.resize(3, vec3D.size()); \n\t\tfor (int j=0; j<vec2D.size(); j++) { \n\t\t\tresection_data.pt2D.col(j) = vec2D[j]; \n\t\t\tresection_data.pt3D.col(j) = vec3D[j]; \n\t\t} \n \n\t\t \n \n\t\tif (vec2D.size() > MINIMUM_VIEW_NUM_TO_ESTIMATAE_CAMERA_POSE) { \n \n\t\t\t \n \n\t\t\tconst Intrinsics::const_iterator iterIntrinsic_I = sfm_data.GetIntrinsics().find(iterV->second->id_intrinsic); \n\t\t\tPinhole_Intrinsic *cam_I = dynamic_cast<Pinhole_Intrinsic*>(iterIntrinsic_I->second.get()); \n \n\t\t\t \n \n\t\t\topenMVG::Mat pt2D(2, vec2D.size()); \n\t\t\topenMVG::Mat pt3D(3, vec3D.size()); \n \n\t\t\tfor (size_t ptInd = 0; ptInd < vec2D.size(); ptInd++) { \n\t\t\t\tpt2D.col(ptInd) = cam_I->get_ud_pixel(vec2D[ptInd]); \n\t\t\t\tpt3D.col(ptInd) = vec3D[ptInd]; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tgeometry::Pose3 pose; \n\t\t\tconst bool bResection = sfm::SfM_Localizer::Localize( \n\t\t\t\t\tmake_pair(iterV->second->ui_width, iterV->second->ui_height), \n\t\t\t\t\tcam_I, resection_data, pose); \n\t\t\tMat3 K_, R_; \n\t\t\tVec3 t_, t_out; \n\t\t\tKRt_From_P(resection_data.projection_matrix, &K_, &R_, &t_); \n\t\t\tt_out = -R_.transpose() * t_; \n\t\t\tsfm_data.poses[iterV->second->id_pose] = Pose3(R_, t_out); \n\t\t} else { \n\t\t\twarning = true; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "16b0efefcf017c0773cbba55696637d490cf0a4bf5754defc8cab18572a9b352"}
{"code": "for(unsigned i=0;i<positions.size();++i){ \n      positions[i]=matmul(positions[i],IB); \n      forces[i]=matmul(B,forces[i]); \n    }", "pragma": "parallel for ", "hash": "bf518d47dd4f291f7131ee8749d36858489043671ecda0e7361a891a501ad311"}
{"code": "for (j = 1; j <= grid_points[1]-2; j++) { \n    for (i = 1; i <= grid_points[0]-2; i++) { \n      for (m = 0; m < 5; m++) { \n        rhs[k][j][i][m] = rhs[k][j][i][m]- dssp *  \n          ( 5.0*u[k][j][i][m] - 4.0*u[k+1][j][i][m] + \n            u[k+2][j][i][m]); \n      } \n    } \n  }", "pragma": "for ", "hash": "b908505469fafe3dff494f7ca371a41e5607a6c1a8e82ec010a547d2a2ac85b8"}
{"code": "for(i=0; i<nv; ++i)\r \n            {\r \n                m->vfaces[i].num_faces = 0;\r \n                m->vfaces[i].faces = NULL; \n            }", "pragma": "parallel for ", "hash": "e672ee374d4ba350f995e1c23607e2cb25baee1878e91678d31ef9ec262daf95"}
{"code": "for (i = 0; i < nlocal; i++) { \n      double buf[3]; \n      if (mask[i] & groupbit) { \n        temperature->remove_bias(i,&v[i].x); \n        v[i].x *= factor_eta; \n        v[i].y *= factor_eta; \n        v[i].z *= factor_eta; \n        temperature->restore_bias(i,&v[i].x); \n        angmom[i].x *= factor_eta; \n        angmom[i].y *= factor_eta; \n        angmom[i].z *= factor_eta; \n      } \n    }", "pragma": "parallel for private(i)", "hash": "e3f0a115beb49c9d3ef61136e7b1caaaf254c6a278c5bb37093d3152f32c6be9"}
{"code": "for (i = 0; i < width; ++i) { \n        flt_vector_type b1(window, 0.0); \n        b1[i] = 1.0; \n \n        const flt_vector_type c1(sg_coeff(b1, deg)); \n        for (j = 0; j < window; ++j) { \n            res[i]          += c1[j] * v[j]; \n            res[endidx - i] += c1[j] * v[endidx - j]; \n        } \n    }", "pragma": "parallel for private(i j)", "hash": "fcb5790b548e4e7204e1a19cfceae8b772d9fb861e7c5a944ab19bd4ecdca711"}
{"code": "for (intptr_t i = 0; i < static_cast<intptr_t>(size) / 32 - 1; ++i) \n    { \n        #pragma omp flush (abort) \n        if(!abort) \n        { \n            auto block = _mm256_loadu_si256( (const __m256i*)data + i ); \n            if (_mm256_testz_si256( block, block )) \n                continue; \n \n            auto offset = _mm_cmpestri( parts->needle, firstlen, _mm_loadu_si128( (const __m128i*)(data + i * 32) ), 16, _SIDD_CMP_EQUAL_ORDERED ); \n            if (offset == 16) \n            { \n                offset += _mm_cmpestri( parts->needle, firstlen, _mm_loadu_si128( (const __m128i*)(data + i * 32 + 16) ), 16, _SIDD_CMP_EQUAL_ORDERED ); \n                if (offset == 32) \n                    continue; \n            } \n \n            for (intptr_t j = 0; j < num_parts; ++j) \n            { \n                auto hay = _mm_loadu_si128( (const __m128i*)(data + (2 * i + j) * 16 + offset) ); \n                auto bitmask = _mm_movemask_epi8( _mm_cmpeq_epi8( hay, parts[j].needle ) ); \n                if ((bitmask & parts[j].mask) != parts[j].mask) \n                    goto next; \n            } \n \n            result = data + 32 * i + offset; \n            abort = true; \n            #pragma omp flush (abort) \n        } \n         \n \n \n    next:; \n    }", "pragma": "parallel for ", "hash": "5045ad04ef71ed067a0faa13fe6a420fdb1a125778d4ee49119021bd5c9f359e"}
{"code": "for (int y = 0; y < h; ++y) { \n            int row = shape.inverseYAxis ? h-y-1 : y; \n            for (int x = 0; x < w; ++x) { \n                Point2 p = Vector2(x+.5, y+.5)/scale-translate; \n \n                struct EdgePoint { \n                    SignedDistance minDistance; \n                    const EdgeHolder *nearEdge; \n                    double nearParam; \n                } sr, sg, sb; \n                sr.nearEdge = sg.nearEdge = sb.nearEdge = NULL; \n                sr.nearParam = sg.nearParam = sb.nearParam = 0; \n                double d = fabs(SignedDistance::INFINITE.distance); \n                double negDist = -SignedDistance::INFINITE.distance; \n                double posDist = SignedDistance::INFINITE.distance; \n                int winding = 0; \n \n                std::vector<Contour>::const_iterator contour = shape.contours.begin(); \n                for (int i = 0; i < contourCount; ++i, ++contour) { \n                    EdgePoint r, g, b; \n                    r.nearEdge = g.nearEdge = b.nearEdge = NULL; \n                    r.nearParam = g.nearParam = b.nearParam = 0; \n \n                    for (std::vector<EdgeHolder>::const_iterator edge = contour->edges.begin(); edge != contour->edges.end(); ++edge) { \n                        double param; \n                        SignedDistance distance = (*edge)->signedDistance(p, param); \n                        if ((*edge)->color&RED && distance < r.minDistance) { \n                            r.minDistance = distance; \n                            r.nearEdge = &*edge; \n                            r.nearParam = param; \n                        } \n                        if ((*edge)->color&GREEN && distance < g.minDistance) { \n                            g.minDistance = distance; \n                            g.nearEdge = &*edge; \n                            g.nearParam = param; \n                        } \n                        if ((*edge)->color&BLUE && distance < b.minDistance) { \n                            b.minDistance = distance; \n                            b.nearEdge = &*edge; \n                            b.nearParam = param; \n                        } \n                    } \n                    if (r.minDistance < sr.minDistance) \n                        sr = r; \n                    if (g.minDistance < sg.minDistance) \n                        sg = g; \n                    if (b.minDistance < sb.minDistance) \n                        sb = b; \n \n                    double medMinDistance = fabs(median(r.minDistance.distance, g.minDistance.distance, b.minDistance.distance)); \n                    if (medMinDistance < d) { \n                        d = medMinDistance; \n                        winding = -windings[i]; \n                    } \n                    if (r.nearEdge) \n                        (*r.nearEdge)->distanceToPseudoDistance(r.minDistance, p, r.nearParam); \n                    if (g.nearEdge) \n                        (*g.nearEdge)->distanceToPseudoDistance(g.minDistance, p, g.nearParam); \n                    if (b.nearEdge) \n                        (*b.nearEdge)->distanceToPseudoDistance(b.minDistance, p, b.nearParam); \n                    medMinDistance = median(r.minDistance.distance, g.minDistance.distance, b.minDistance.distance); \n                    contourSD[i].r = r.minDistance.distance; \n                    contourSD[i].g = g.minDistance.distance; \n                    contourSD[i].b = b.minDistance.distance; \n                    contourSD[i].med = medMinDistance; \n                    if (windings[i] > 0 && medMinDistance >= 0 && fabs(medMinDistance) < fabs(posDist)) \n                        posDist = medMinDistance; \n                    if (windings[i] < 0 && medMinDistance <= 0 && fabs(medMinDistance) < fabs(negDist)) \n                        negDist = medMinDistance; \n                } \n                if (sr.nearEdge) \n                    (*sr.nearEdge)->distanceToPseudoDistance(sr.minDistance, p, sr.nearParam); \n                if (sg.nearEdge) \n                    (*sg.nearEdge)->distanceToPseudoDistance(sg.minDistance, p, sg.nearParam); \n                if (sb.nearEdge) \n                    (*sb.nearEdge)->distanceToPseudoDistance(sb.minDistance, p, sb.nearParam); \n \n                MultiDistance msd; \n                msd.r = msd.g = msd.b = msd.med = SignedDistance::INFINITE.distance; \n                if (posDist >= 0 && fabs(posDist) <= fabs(negDist)) { \n                    msd.med = SignedDistance::INFINITE.distance; \n                    winding = 1; \n                    for (int i = 0; i < contourCount; ++i) \n                        if (windings[i] > 0 && contourSD[i].med > msd.med && fabs(contourSD[i].med) < fabs(negDist)) \n                            msd = contourSD[i]; \n                } else if (negDist <= 0 && fabs(negDist) <= fabs(posDist)) { \n                    msd.med = -SignedDistance::INFINITE.distance; \n                    winding = -1; \n                    for (int i = 0; i < contourCount; ++i) \n                        if (windings[i] < 0 && contourSD[i].med < msd.med && fabs(contourSD[i].med) < fabs(posDist)) \n                            msd = contourSD[i]; \n                } \n                for (int i = 0; i < contourCount; ++i) \n                    if (windings[i] != winding && fabs(contourSD[i].med) < fabs(msd.med)) \n                        msd = contourSD[i]; \n                if (median(sr.minDistance.distance, sg.minDistance.distance, sb.minDistance.distance) == msd.med) { \n                    msd.r = sr.minDistance.distance; \n                    msd.g = sg.minDistance.distance; \n                    msd.b = sb.minDistance.distance; \n                } \n \n                output(x, row).r = float(msd.r/range+.5); \n                output(x, row).g = float(msd.g/range+.5); \n                output(x, row).b = float(msd.b/range+.5); \n            } \n        }", "pragma": "for ", "hash": "f4fe0a1181d37c1422b0fb62c9ee79647537388fd80620e89130b2ae47aca94f"}
{"code": "for ( unsigned int i =0;i<population.size();++i)  \n \n        {\r \n            cout <<\"organisme\" << i <<\" :\"<<endl;\r \n            Reseau * reseau = population[i]->getSNC();  \n \n            for ( unsigned int i(0);i<reseau->getallSynapse().size();++i)  \n \n                {\r \n                    int idn1 = reseau->getSynapse(i)->getAmontId();  \n \n                    Neurone* a = reseau->getNeurone(idn1);           \n \n\r \n                    int idn2 = reseau->getSynapse(i)->getAvalId();   \n \n                    Neurone* b =reseau->getNeurone(idn2);            \n \n\r \n                     \n \n                    cout << \"neurone\" << reseau->getSynapse(i)->getAmontId()<<\"(\"<< \"pot = \" << a->getpotentiel()<< \") ---\" ;\r \n                    cout <<reseau->getSynapse(i)->getCoef()<<\"--> \"<< \"neurone\" <<reseau->getSynapse(i)->getAvalId() ;\r \n                    cout <<\"(\"<< \"pot = \" << b->getpotentiel()<<\")\"<<endl;\r \n                }\r \n        }", "pragma": "parallel ", "hash": "248639ff80b4b9d1ec388fe921439da9184fff7b9d9dbc34d0d066ebc69d91f2"}
{"code": "for (i = 0; i < 1; i++)", "pragma": "parallel for ", "hash": "3051bdad6ccc703f0a4396b7e26cf10b84532a9f574468868ab24951bcd05978"}
{"code": "for (int64_t b = max(c, pi_sqrty) + 1; b <= pi_x13; b++) \n  { \n    int64_t prime = primes[b]; \n    uint128_t x2 = x / prime; \n    int64_t min_trivial = min(x2 / prime, y); \n    int64_t min_clustered = (int64_t) isqrt(x2); \n    int64_t min_sparse = z / prime; \n    int64_t min_hard = max(y / prime, prime); \n \n    min_clustered = in_between(min_hard, min_clustered, y); \n    min_sparse = in_between(min_hard, min_sparse, y); \n \n    int64_t l = pi[min_trivial]; \n    int64_t pi_min_clustered = pi[min_clustered]; \n    int64_t pi_min_sparse = pi[min_sparse]; \n \n     \n \n     \n \n     \n \n     \n \n    while (l > pi_min_clustered) \n    { \n      int64_t xn = (int64_t) fast_div(x2, primes[l]); \n      int64_t phi_xn = pi[xn] - b + 2; \n      res_t phi_xn_sum = prime_sums[pi[xn]] + 1 - prime_sums[b - 1]; \n      int64_t xm = (int64_t) fast_div(x2, primes[b + phi_xn - 1]); \n      xm = max(xm, min_clustered); \n      int64_t l2 = pi[xm]; \n      s2_easy += (phi_xn_sum * prime) * (prime_sums[l] - prime_sums[l2]); \n      l = l2; \n    } \n \n     \n \n     \n \n     \n \n    for (; l > pi_min_sparse; l--) \n    { \n      int64_t xn = (int64_t) fast_div(x2, primes[l]); \n      res_t phi = prime_sums[pi[xn]] + 1 - prime_sums[b - 1]; \n      s2_easy += phi * ((PS) prime * primes[l]); \n    } \n \n    if (is_print()) \n      status.print(b, pi_x13); \n  }", "pragma": "parallel for reduction(+: s2_easy) ", "hash": "d5d0ca22753e2abff654cb37f10c3e9f6a42b36daaf355318453065540e9078e"}
{"code": "for (int i = 0; i < nf; i++) { \n\t\t\tfacesPts[i].resize(3); \n\t\t\tfor (int j = 0; j < 3; j++) { \n\t\t\t\tfacesPts[i][j]= pts[faces[i][j]]; \n\t\t\t} \n \n\t\t\ttotal_faces_index[i] = i; \n\t\t}", "pragma": "parallel for ", "hash": "869b4b969e6849447cf4bf990136cbbba01b9b7fc7d0e23f4a0deab749eba30e"}
{"code": "for (i=0; i <= (ssize_t) MaxMap; i++) \n      { \n        x_map[i].x=(MagickRealType) i; \n        y_map[i].x=0.000000; \n        z_map[i].x=(1.574800*0.50000)*(2.00000*(MagickRealType) i- \n          (MagickRealType) MaxMap); \n        x_map[i].y=(MagickRealType) i; \n        y_map[i].y=(-0.187324*0.50000)*(2.00000*(MagickRealType) i- \n          (MagickRealType) MaxMap); \n        z_map[i].y=(-0.468124*0.50000)*(2.00000*(MagickRealType) i- \n          (MagickRealType) MaxMap); \n        x_map[i].z=(MagickRealType) i; \n        y_map[i].z=(1.855600*0.50000)*(2.00000*(MagickRealType) i- \n          (MagickRealType) MaxMap); \n        z_map[i].z=0.00000f; \n      }", "pragma": "parallel for ", "hash": "aa5bfddf162319cc36459b0ed0d1607bc6e29646ff6df7509ef2565a033e6021"}
{"code": "for (i = 0; i < workingthread; i ++) { \n\t\tMapFileNode *current_mapfilenode; \n\t\tunsigned short * content; \n\t\tint k, size, current_pos, ntype, has; \n\t\tunsigned short *new_content; \n\t\tint *local_threadntypeoffsetiter = threadntypeoffsetiter[i]; \n\t\tcurrent_mapfilenode = thread_mapfile[i]->first; \n\t\twhile (current_mapfilenode) { \n\t\t\tsize = current_mapfilenode->top; \n\t\t\tcurrent_pos = 0; \n\t\t\tcontent = (unsigned short *)current_mapfilenode->TransactionContent; \n\t\t\twhile (current_pos < size) { \n\t\t\t\tntype = content[current_pos]; \n\t\t\t\tcurrent_pos ++; \n\t\t\t\thas = content[current_pos]; \n\t\t\t\tnew_content = threadtranscontent + local_threadntypeoffsetiter[ntype]; \n\t\t\t\tlocal_threadntypeoffsetiter[ntype] += has + 1; \n\t\t\t\tfor (k = 0; k < has + 1; k ++) \n\t\t\t\t\tnew_content[k] = content[current_pos ++]; \n\t\t\t} \n\t\t\tcurrent_mapfilenode->finalize(); \n\t\t\tcurrent_mapfilenode = current_mapfilenode->next; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "72e7cbef754923ae2be2497a6a06dabb4bedb4d54c14b8d3961e4d896551077c"}
{"code": "for (i = 0; i < nc; i += 4)\r \n\t\t\t{\r \n\t\t\t\ty[i] += alpha * x[i];\r \n\t\t\t\ty[i+1] += alpha * x[i+1];\r \n\t\t\t\ty[i+2] += alpha * x[i+2];\r \n\t\t\t\ty[i+3] += alpha * x[i+3];\r \n\t\t\t}", "pragma": "parallel for private(i)", "hash": "f42ef5f601afac15275dd73577792f6142fff62be26e392c861acc5c1845edca"}
{"code": "for (int k = 0; k < num_neurons_n; k++)\r \n\t{\r \n\t\t\tdprev[k] = temp_dpred_dout[k];\r \n\t}", "pragma": "parallel ", "hash": "a15659da6e812c29dd12731c9ea948b9f1746192d43c1df733e207c65018ae61"}
{"code": "for (int kk = 0; kk < NTHREADS; kk++) {  \n \n      array_coo temp_coo_v; \n      array_coo temp_coo_p; \n      double dxyz[3], vval; \n      int i_index; \n \n      for (int ii = kk*block_size_p; ii < std::min((kk + 1)*block_size_p, (int)pressure.size()); ii++) { \n \n        dxyz[0] = distance(velocity_u[ptv[idx2(ii, 0, 6)]].coords[0], velocity_u[ptv[idx2(ii, 0, 6)]].coords[1], velocity_u[ptv[idx2(ii, 0, 6)]].coords[2],            velocity_u[ptv[idx2(ii, 1, 6)]].coords[0], velocity_u[ptv[idx2(ii, 1, 6)]].coords[1], velocity_u[ptv[idx2(ii, 1, 6)]].coords[2]); \n \n        dxyz[1] = distance(velocity_v[ptv[idx2(ii, 2, 6)]].coords[0], velocity_v[ptv[idx2(ii, 2, 6)]].coords[1], velocity_v[ptv[idx2(ii, 2, 6)]].coords[2],            velocity_v[ptv[idx2(ii, 3, 6)]].coords[0], velocity_v[ptv[idx2(ii, 3, 6)]].coords[1], velocity_v[ptv[idx2(ii, 3, 6)]].coords[2]); \n \n        dxyz[2] = distance(velocity_w[ptv[idx2(ii, 4, 6)]].coords[0], velocity_w[ptv[idx2(ii, 4, 6)]].coords[1], velocity_w[ptv[idx2(ii, 4, 6)]].coords[2],            velocity_w[ptv[idx2(ii, 5, 6)]].coords[0], velocity_w[ptv[idx2(ii, 5, 6)]].coords[1], velocity_w[ptv[idx2(ii, 5, 6)]].coords[2]); \n \n         \n \n        if (interior_v_nums[ptv[idx2(ii, 2, 6)]] == -1) { \n          if (pressure[ii].coords[1] - 0.5*dxyz[1] < ymin + eps) { \n            i_index = shift_rows + ii; \n            switch (INFLOW) { \n              case HGF_INFLOW_PARABOLIC : vval = inflow_max/(pow((zmin-zmax)/2,2)*pow((xmin-xmax)/2,2))                  * (velocity_v[ptv[idx2(ii, 2, 6)]].coords[0] - xmin) * (xmax - velocity_v[ptv[idx2(ii, 2, 6)]].coords[0])                  * (velocity_v[ptv[idx2(ii, 2, 6)]].coords[2] - zmin) * (zmax - velocity_v[ptv[idx2(ii, 2, 6)]].coords[2]);  \n                break; \n              case HGF_INFLOW_CONSTANT : vval = inflow_max; break; \n              default : std::cout << INFLOW << \" is not a valid inflow BC.  See inlcude/types.hpp.\" << std::endl; \n            } \n            rhs[i_index] -= (dxyz[0] * dxyz[1] * dxyz[2] / dxyz[1]) * vval; \n          } \n        } \n         \n \n        if (interior_v_nums[ptv[idx2(ii, 3, 6)]] == -1) { \n          if (pressure[ii].coords[1] + 0.5*dxyz[1] > ymax - eps) { \n            i_index = shift_rows + ii; \n            temp_coo_v.i_index = i_index; \n            temp_coo_v.j_index = shift_v + interior_v_nums[ptv[idx2(ii, 2, 6)]]; \n            temp_coo_v.value = -dxyz[0] * dxyz[2]; \n \n             \n \n            temp_coo_p.i_index = i_index; \n            temp_coo_p.j_index = i_index; \n            temp_coo_p.value = -dxyz[0] * dxyz[1] * dxyz[2]; \n \n            temp_p_arrays[kk].push_back(temp_coo_v); \n            temp_p_arrays[kk].push_back(temp_coo_p); \n          } \n        } \n \n      } \n \n    }", "pragma": "for ", "hash": "f6760a5dfd8c1c26df65533272dc0ea6b5b86eb9f525abba8a1c21f45b22820a"}
{"code": "for (i = 0; i < system->N; ++i) { \n      type_i = system->my_atoms[i].type; \n      if (type_i < 0) continue; \n      start_i = Start_Index(i, bonds); \n      end_i = End_Index(i, bonds); \n \n      for (pj = start_i; pj < end_i; ++pj) { \n        j = bonds->select.bond_list[pj].nbr; \n        type_j = system->my_atoms[j].type; \n        if (type_j < 0) continue; \n \n        if (i < j || workspace->bond_mark[j] > 3) { \n           \n \n        } else { \n           \n \n          sym_index = bonds->select.bond_list[pj].sym_index; \n \n          bo_ij = &( bonds->select.bond_list[pj].bo_data ); \n          bo_ji = &(bonds->select.bond_list[ sym_index ].bo_data); \n          bo_ij->BO = bo_ji->BO; \n          bo_ij->BO_s = bo_ji->BO_s; \n          bo_ij->BO_pi = bo_ji->BO_pi; \n          bo_ij->BO_pi2 = bo_ji->BO_pi2; \n \n          workspace->total_bond_order[i] += bo_ij->BO; \n \n        } \n      } \n \n    }", "pragma": "for ", "hash": "c8cb14df47a1db1f5652abc6232349cc0ecf28e2c4cc8308bd4419b4a69e94d7"}
{"code": "for(int i = 0;i < blocks.size();++i) \n      ward += degen[i]*blocks[i]->trace();", "pragma": "parallel for reduction(+:ward) ", "hash": "e4e1e470c76d2d3b733c14fd649b1cf699b3faca615cf5b7b4115c9e8718202e"}
{"code": "for(i=0;i<i_maps.size();i++) \n\tupdate_queue[i]->DoDelayedMovesAndRemoves();", "pragma": "parallel for private(i)", "hash": "1db3dee670e6de5980d5e5be1390c0f56f9e11cfe04d2d564323b5c18c40a3ac"}
{"code": "for (long i=0; i<m; i++) { \n    src[i]  = permV[src[i]]; \n    dest[i] = permV[dest[i]]; \n  }", "pragma": "parallel for ", "hash": "afe4cf6a5a30a444caee6da3b741a2ac2d9a40033461e2fddb4693cba059d306"}
{"code": "for( int i=0;i<max;++i ) { \n    const basics::Field2<basics::Matrix> foo(const_cast<basics::Matrix*>(&u.X()[i]), \n        const_cast<basics::Matrix*>(&u.Y()[i])); \n    m_evals[i]->evaluate(res[i],foo); \n  }", "pragma": "parallel for ", "hash": "02df3140c9a7a863a3984594e10bf863aa38a99e1c48ac1106eb0797785926a5"}
{"code": "for( int i_neuron =0;i_neuron<static_cast<int>( _neurons.size()); i_neuron++ ) \n    { \n        NNNeuron * n =(_neurons[i_neuron]); \n        n->propagateBackSecondDerivate(); \n    }", "pragma": "parallel for ", "hash": "d27413a1ba7d8fa97cf2db6004d6a321c702fdb63ec5e96b43e0b1079b948a3a"}
{"code": "for(size_t i = 0; i < Nmesh; i++) \n        for(size_t j = 0; j < Nmesh; j++) \n          for(size_t k = 0; k < Nmesh; k++){ \n            size_t co = (i * Nmesh + j) * (2 * (Nmesh / 2 + 1)) + k; \n            twosrc[co] += digrad[0][co]*digrad[1][co]+digrad[0][co]*digrad[2][co]+digrad[1][co]*digrad[2][co]; \n          }", "pragma": "parallel for ", "hash": "af23ad9fe49d3d5e9c7f99ad19889f5daadd14cb9f5f64a73f81f7e247be3661"}
{"code": "for(ii=0;ii<npix;ii++) \n      map_result[ii]+=map_to_sum[ii];", "pragma": "for ", "hash": "93141e59d1472cd143760a3f6f3a7689964b74e196a2de36b306b09f1824e034"}
{"code": "for(i=0;i<N_BUCKETS;i++) \n                { \n                    for(j=0;j<TAMANHO_VETOR;j++) \n                    { \n                        matrix_bucketsort[i][j] = -1; \n                    } \n                }", "pragma": "for ", "hash": "a7317727a345ca88b2274d02afbbd50ad431cf6dae34d6c1409ea17f2a97ec65"}
{"code": "for (long iP = 0; iP < bytsInImg; iP += 4) \n\t{ \n\t\tbmpData[iP / 4].R = CharToFloat(imageData[iP]); \n\t\tbmpData[iP / 4].G = CharToFloat(imageData[iP + 1]); \n\t\tbmpData[iP / 4].B = CharToFloat(imageData[iP + 2]); \n\t\tbmpData[iP / 4].A = CharToFloat(imageData[iP + 3]); \n\t}", "pragma": "parallel for ", "hash": "0427b7e86ec5da92ec2a5b78ac1f8c11d9873105551d38fe5cc8a455cb597265"}
{"code": "for (unsigned int i = 1; i < e.size(); i++)   \n \n    { \n      e[i].x = (n[e[i].node[0]].x + n[e[i].node[1]].x + n[e[i].node[2]].x + n[e[i].node[3]].x) / 4.; \n      e[i].y = (n[e[i].node[0]].y + n[e[i].node[1]].y + n[e[i].node[2]].y + n[e[i].node[3]].y) / 4.; \n \n      e[i].area = 1. / 2. * ((n[e[i].node[0]].x - n[e[i].node[2]].x) * (n[e[i].node[1]].y - n[e[i].node[3]].y) + (n[e[i].node[3]].x - n[e[i].node[1]].x) * (n[e[i].node[0]].y - n[e[i].node[2]].y)); \n    }", "pragma": "parallel for ", "hash": "39bffc2eb8632b6cd00384fd4c31075c95243a9dac14f04dcd53c5b4306c8e50"}
{"code": "for (t = 0; t < stride*nframe; t++) \n  { \n    real *input_ptr = input_data + (t/stride)*dim*stride + t % stride; \n    real *output_ptr = output_data + (t/stride)*dim*stride + t % stride; \n \n    real inputMax = -THInf; \n    accreal sum; \n \n    ptrdiff_t d; \n    for (d = 0; d < dim; d++) \n    { \n      if (input_ptr[d*stride] >= inputMax) inputMax = input_ptr[d*stride]; \n    } \n \n    sum = 0; \n    for (d = 0; d < dim; d++) \n    { \n      real z = exp(input_ptr[d*stride] - inputMax); \n      output_ptr[d*stride] = z; \n      sum += z; \n    } \n \n    for (d = 0; d < dim; d++) \n    { \n      output_ptr[d*stride] *= 1/sum; \n    } \n  }", "pragma": "parallel for private(t)", "hash": "2451ff9edc68a50e972e9f5668af0c018729db13bfa91cb85a9538837e3c2d8c"}
{"code": "for (ix=1; ix<=nx; ix++) { \n\t\t\tvz[ix*n1+nz] = 0.0; \n\t\t}", "pragma": "for private(ix)", "hash": "8d0bb51b86841536639666d50ef7a52140903395aa9886568dd077c55a44ae32"}
{"code": "for(size_t j = 0; j < pixels_y + 1; j++) \n      for(size_t i = 0; i < pixels_x + 1; i++) \n      { \n         \n \n        const point_t tl = { CLAMP(2 * pixel_radius * i, 0, width - 1), \n                             CLAMP(2 * pixel_radius * j, 0, height - 1) }; \n         \n \n        const point_t cc = { CLAMP(tl.x + pixel_radius, 0, width - 1), \n                             CLAMP(tl.y + pixel_radius, 0, height - 1) }; \n         \n \n        const point_t br = { CLAMP(cc.x + pixel_radius, 0, width - 1), \n                             CLAMP(cc.y + pixel_radius, 0, height - 1) }; \n \n         \n \n        const point_t box[5] = { tl, { br.x, tl.y }, cc, { tl.x, br.y }, br }; \n \n         \n \n        dt_aligned_pixel_t RGB = { 0.f }; \n        for(size_t k = 0; k < 5; k++) \n        { \n          const float *const restrict pix_in = __builtin_assume_aligned(input + (width * box[k].y + box[k].x) * 4, 16); \n          for_four_channels(c) \n            RGB[c] += pix_in[c] / 5.f; \n        } \n \n         \n \n        for(size_t jj = tl.y; jj < br.y; jj++) \n          for(size_t ii = tl.x; ii < br.x; ii++) \n          { \n            float *const restrict pix_out = __builtin_assume_aligned(output + (jj * width + ii) * 4, 16); \n            for_four_channels(c) \n              pix_out[c] = RGB[c]; \n          } \n      }", "pragma": "parallel for ", "hash": "013b0c60366d17403f414be1dc7ac26ec2c54c01c858c0bd3e3205c06ec86d4d"}
{"code": "for(int k = 0; k < roi_out->height; k++) \n  { \n    const float *in = ((float *)i) + (size_t)4 * k * roi_out->width; \n    float *out = ((float *)o) + (size_t)4 * k * roi_out->width; \n    for(int j = 0; j < roi_out->width; j++, in += 4, out += 4) \n    { \n      const float tt = envelope(in[0]); \n      const float t = tt + (1.0f - tt) * (1.0f - d->highlights); \n      out[0] = (1.0f - t) * in[0] \n               + t * out[0] * (1.0f / 100.0f) * in[0];  \n \n    } \n  }", "pragma": "parallel for ", "hash": "4c940d1be27c7bba70a45fced7dd49bb282b976f5e4aaeef7e9daba3888001bd"}
{"code": "for (nn = n_start; nn < n_last; nn += GROUP_SIZE) \n      DeblockParallel(p_Vid, p, i, nn, n_last);", "pragma": "parallel for ", "hash": "192327f2da256ab065af152f715f6e7db068ba4fdbc6161c1c9b7d1b91439026"}
{"code": "for (int walkerNum = 0; walkerNum < nwalkers; walkerNum++) { \n \n\t\t#ifdef DEBUG_RUNMCMC_OMP \n\t\tprintf(\"numThreads: %d\\n\",numThreads); \n\t\tprintf(\"omp_num_threads(): %d\\n\",omp_get_num_threads()); \n\t\tprintf(\"omp_get_thread_num(): %d\\n\",omp_get_thread_num()); \n\t\tfflush(0); \n\t\t#endif \n \n\t\tdouble *currWalkerNewPos = nullptr; \n\t\tint threadNum = omp_get_thread_num(); \n \n\t\t#ifdef DEBUG_RUNMCMC \n\t\tprintf(\"runMCMC - Thread: %d; Walker: %d\\n\", threadNum, walkerNum); \n\t\t#endif \n \n\t\tfor (int dimNum = 0; dimNum < ndims; dimNum++) { \n\t\t\tp2Chain[dimNum + walkerNum*ndims] = initPos[dimNum + walkerNum*ndims]; \n \n\t\t\t#ifdef DEBUG_RUNMCMC_DEEP \n\t\t\tprintf(\"runMCMC - Thread: %d; Walker: %d; Dim: %d; Val: %f\\n\", threadNum, walkerNum,dimNum,p2Chain[dimNum + walkerNum*ndims]); \n\t\t\t#endif \n\t\t\t} \n \n\t\tcurrWalkerNewPos = &p2Chain[walkerNum*ndims]; \n \n\t\t#ifdef DEBUG_RUNMCMC_DEEP \n\t\tprintf(\"runMCMC - Thread: %d; walkerNum: %d\\n\",threadNum,walkerNum); \n\t\tprintf(\"runMCMC - Thread: %d; currWalkerNewPos: %f\\n\",threadNum,currWalkerNewPos[0]); \n\t\tfflush(0); \n\t\t#endif \n \n\t\tdouble LnPostVal = p2Func(currWalkerNewPos, p2FuncArgs, p2LnPrior[walkerNum], p2LnLike[walkerNum]); \n \n\t\t#ifdef DEBUG_RUNMCMC \n        printf(\"runMCMC - Thread: %d; LnPrior[%d]: %f\\n\",threadNum,walkerNum,p2LnPrior[walkerNum]); \n\t\tprintf(\"runMCMC - Thread: %d;  LnLike[%d]: %f\\n\",threadNum,walkerNum,p2LnLike[walkerNum]); \n\t\tprintf(\"\\n\"); \n\t\t#endif \n\t\t}", "pragma": "parallel for ", "hash": "37fda15c79ffa493b8832d8d356b63025d59f1362e0cfe280627d62c0cbe28d8"}
{"code": "for(index_t i = 0; i < numVertices; i++){ \n\t\tg->edges[i] = array_list_init(16, sizeof(index_t), NULL); \n\t\tif(sizeof(index_t) == sizeof(int)) { \n\t\t\tg->edges[i]->compare = int_compare; \n\t\t} else if(sizeof(index_t) == sizeof(long)) { \n\t\t\tg->edges[i]->compare = long_compare; \n\t\t} else { \n\t\t\tg->edges[i]->compare = short_compare; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "e1fe5df9bec2dc46132c330bd2c07e3cb72296b361124bdbf6f2996185be514f"}
{"code": "for( int planeNr=0; planeNr < nrOfPlanes; planeNr++ ) \n    { \n        IPLImagePlane* plane = image->plane( planeNr ); \n        IPLImagePlane* newplane = _result->plane( planeNr ); \n \n \n \n \n        double histogram[256]; \n        for(int i = 0; i < 256; i++) \n            histogram[i] = 0.0; \n        for(int y=0; y < height; y++) \n        { \n            for(int x=0; x < width; x++) \n            { \n                int index = plane->p(x,y) * 255; \n                histogram[index]++; \n            } \n        } \n        for( int i=0; i<256; i++ ) \n            histogram[i] /= width * height; \n \n         \n \n        double totalMean = 0.0; \n        for( int k=0; k<256; ++k ) \n            totalMean += k * histogram[k]; \n \n        double maxVariance = 0.0; \n        double zerothCumuMoment = 0.0; \n        double firstCumuMoment = 0.0; \n        int T = 0;   \n \n        for( int k=0; k<256; ++k ) \n        { \n            zerothCumuMoment += histogram[k]; \n            firstCumuMoment += k * histogram[k]; \n \n            double variance = (totalMean * zerothCumuMoment - firstCumuMoment);   \n \n            variance *= variance;   \n \n            double denom = zerothCumuMoment * (1 - zerothCumuMoment); \n            if( denom != 0.0 ) \n                variance /= denom;   \n \n \n            if( variance > maxVariance ) \n            { \n                maxVariance = variance; \n                T = k; \n            } \n        } \n \n        ipl_basetype threshold = T * FACTOR_TO_FLOAT; \n \n        std::stringstream s; \n        s << \"Automatic Threshold: \"; \n        s << threshold; \n        addInformation(s.str()); \n \n        for(int y=0; y<height; y++) \n        { \n             \n \n            notifyProgressEventHandler(100*progress++/maxProgress); \n            for(int x=0; x<width; x++) \n            { \n                newplane->p(x,y) = (plane->p(x,y) < threshold) ? 0.0f : 1.0f; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "79d788cf03e978149b8c00f2b791ca0301616dbb609345555685d35367275656"}
{"code": "for(ir = I1; ir <= I2; ++ir){ \n                        jr = level - ir; \n \n                        if(OpenST_FSM3D_BlockSerial(U, V, \n                                                    NI, NJ, NK, \n                                                    HI, HJ, HK, \n                                                    REVI, REVJ, REVK, \n                                                    ir * BSIZE_I, jr * BSIZE_J, \n                                                    kr * BSIZE_K, \n                                                    BSIZE_I, BSIZE_J, BSIZE_K, \n                                                    EPS)){ \n                            notconvergedt = 1; \n                        } \n                    }", "pragma": "for ", "hash": "21e02c775efbc12a4030d0838e034c06ba3d2f6af4045dace205eb4984c55c78"}
{"code": "for (iz=0; iz < nzb; iz++){ \n\t\tfor (ix=0; ix < nxb; ix++){  \n\t\t    ukr[iz][ix] = sf_crealf(uk[iz][ix]);  \n\t\t    ukr[iz][ix] /= (nkx*nkz);  \n\t\t} \n\t    }", "pragma": "parallel for private(ix iz)", "hash": "a34834b24d4867cccc77d733a3902dc99a9157901a19f7bc6e15cf9bdf7479b9"}
{"code": "for (i=0; i<scale; i++) \n            for (j=0; j<scale; j++) \n                a[i][j]= rand() / 1000;", "pragma": "for ", "hash": "11dc14f89bfb24d9b62843516df68d39fcc7413d6a876386ce9fad42cbc89420"}
{"code": "for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x2[i] = x2[i] + A[j][i] * y_2[j];", "pragma": "parallel for private(j)", "hash": "b83a36871c0c24a9583dd42f6603cadc59830492951c01d9793d035d27bc0c60"}
{"code": "for(sample1 = 0; sample1 < H-1; sample1++){ \n\t\tfor(sample2 = sample1+1; sample2 < H; sample2++){ \n\t\t\tsum = 0.0; \n\t\t\tfor(i = 0; i < W; i++){ \n\t\t\t\tsum += mm[sample1] * mm[sample2]; \n\t\t\t} \n\t\t\tr = sum / (std[sample1] * std[sample2]); \n\t\t} \n\t\t \n \n\t}", "pragma": "parallel for ", "hash": "98865707a2047652bebf227b0b48c8bf49e8ca31de0bde96a135be8b7703f7a3"}
{"code": "for (int device_id = 0; device_id < num_gpu_; ++device_id) { \n    CUDASUCCESS_OR_FATAL(cudaSetDevice(device_id)); \n \n    if (device_features_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(device_features_[device_id])); \n    } \n \n    if (device_gradients_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(device_gradients_[device_id])); \n    } \n \n    if (device_hessians_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(device_hessians_[device_id])); \n    } \n \n    if (device_feature_masks_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(device_feature_masks_[device_id])); \n    } \n \n    if (device_data_indices_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(device_data_indices_[device_id])); \n    } \n \n    if (sync_counters_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(sync_counters_[device_id])); \n    } \n \n    if (device_subhistograms_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(device_subhistograms_[device_id])); \n    } \n \n    if (device_histogram_outputs_[device_id] != NULL) { \n      CUDASUCCESS_OR_FATAL(cudaFree(device_histogram_outputs_[device_id])); \n    } \n  }", "pragma": "parallel for ", "hash": "3ecd4bb3d453c842b56edd1bea6f88b6c92321ff9add372cb3169a95c41b7137"}
{"code": "for ( int j=0 ; j<n4 ; j+=4 ) { \n                    for ( int i=0 ; i<n4 ; i+=4 ) { \n                        B[(i  )*n+j  ] = A[(j  )*n+i  ]; \n                        B[(i  )*n+j+1] = A[(j+1)*n+i  ]; \n                        B[(i  )*n+j+2] = A[(j+2)*n+i  ]; \n                        B[(i  )*n+j+3] = A[(j+3)*n+i  ]; \n                        B[(i+1)*n+j  ] = A[(j  )*n+i+1]; \n                        B[(i+1)*n+j+1] = A[(j+1)*n+i+1]; \n                        B[(i+1)*n+j+2] = A[(j+2)*n+i+1]; \n                        B[(i+1)*n+j+3] = A[(j+3)*n+i+1]; \n                        B[(i+2)*n+j  ] = A[(j  )*n+i+2]; \n                        B[(i+2)*n+j+1] = A[(j+1)*n+i+2]; \n                        B[(i+2)*n+j+2] = A[(j+2)*n+i+2]; \n                        B[(i+2)*n+j+3] = A[(j+3)*n+i+2]; \n                        B[(i+3)*n+j  ] = A[(j  )*n+i+3]; \n                        B[(i+3)*n+j+1] = A[(j+1)*n+i+3]; \n                        B[(i+3)*n+j+2] = A[(j+2)*n+i+3]; \n                        B[(i+3)*n+j+3] = A[(j+3)*n+i+3]; \n                    } \n                    for ( int i=n4 ; i<n ; i++ ) \n                        B[i*n+j] = A[j*n+i]; \n                }", "pragma": "for private(i j n4)", "hash": "e79b7e089e8db2b725b983308e6f5d443f852d1e147e9703fa96ba77aa682b47"}
{"code": "for(ip=0;ip<npix;ip++) { \n      long iring; \n      nest2ring(nside,ip,&iring); \n \n      map_out[iring]=map_in[ip]; \n    }", "pragma": "for ", "hash": "747a44f5eb6c054a0d1789ca47988d589b9d52020ff0360883eacfbf495a1588"}
{"code": "for (j = 0; j < lastcol - firstcol + 1; j++) \n\t\t\td = d + p[j] * q[j];", "pragma": "for reduction(+:d) ", "hash": "86b8426747e6aa2f1f1abf72e97ebedfcc5a64f3cac725ddb965f620558fc438"}
{"code": "for (blockID = 0; blockID < nBlocks; blockID++) { \n         int offset = blockID*blockSize*width; \n         int offset3 = offset*3; \n         for (float yi = blockID*blockSize; yi < (blockID+1)*blockSize; yi++) { \n             for (float xi = 0; xi < width; xi++,offset++,offset3+=3) { \n                 get3DPoint(xi,yi,zPtr[offset],iK,&pts3[offset3+0],&pts3[offset3+1],&pts3[offset3+2]); \n             } \n         } \n     }", "pragma": "parallel for private(blockid)", "hash": "0bdede3192e2cd485ab6273cb53f261e48981db15d886ba0d57d8267383645f6"}
{"code": "for(t = 0; t < N*C; t++){ \n             \n        int i, j, x;  \n        float tmp[16] __attribute__((aligned(64)));  \n        float s[16] __attribute__((aligned(64)));  \n \n        const float* data = image+t*sizeI;  \n        int tile_count = t*ntiles;  \n         \n         \n \n        for(i = 0; i < irows-2; i += 2){ \n            #pragma unroll(4)             \n            for(j = 0; j < (irows-2); j += 2){ \n                tmp[0 :4] =data[(i+0)*ldi+j:4];  \n                tmp[4 :4] =data[(i+1)*ldi+j:4];  \n                tmp[8 :4] =data[(i+2)*ldi+j:4];  \n                tmp[12:4] =data[(i+3)*ldi+j:4];  \n \n                 \n \n                s[0 ] =(tmp[0] - tmp[8 ]) - (tmp[2 ]- tmp[10]);    \n                s[1 ] =(tmp[1] - tmp[9 ]) + (tmp[2 ]- tmp[10]);  \n                s[2 ] =(tmp[2] - tmp[10]) - (tmp[1 ]- tmp[9 ]);  \n                s[3 ] =(tmp[1] - tmp[9 ]) - (tmp[3 ]- tmp[11]);  \n                s[4 ] =(tmp[4] + tmp[8 ]) - (tmp[6 ]+ tmp[10]);  \n                s[5 ] =(tmp[5] + tmp[9 ]) + (tmp[6 ]+ tmp[10]);  \n                s[6 ] =(tmp[6] + tmp[10]) - (tmp[5 ]+ tmp[9 ]);  \n                s[7 ] =(tmp[5] + tmp[9 ]) - (tmp[7 ]+ tmp[11]);  \n                s[8 ] =(tmp[8] - tmp[4 ]) - (tmp[10]- tmp[6 ]);  \n                s[9 ] =(tmp[9] - tmp[5 ]) + (tmp[10]- tmp[6 ]);  \n                s[10] =(tmp[10]- tmp[6 ]) - (tmp[9 ]- tmp[5 ]);  \n                s[11] =(tmp[9] - tmp[5 ]) - (tmp[11]- tmp[7 ]);  \n                s[12] =(tmp[4] - tmp[12]) - (tmp[6 ]- tmp[14]);  \n                s[13] =(tmp[5] - tmp[13]) + (tmp[6 ]- tmp[14]);  \n                s[14] =(tmp[6] - tmp[14]) - (tmp[5 ]- tmp[13]);  \n                s[15] =(tmp[5] - tmp[13]) - (tmp[7 ]- tmp[15]);  \n \n                 \n \n                otile[tile_count+0*STRIDE ] = s[0 ];  \n                otile[tile_count+1*STRIDE ] = s[1 ];  \n                otile[tile_count+2*STRIDE ] = s[2 ];  \n                otile[tile_count+3*STRIDE ] = s[3 ];  \n                otile[tile_count+4*STRIDE ] = s[4 ];  \n                otile[tile_count+5*STRIDE ] = s[5 ];  \n                otile[tile_count+6*STRIDE ] = s[6 ];  \n                otile[tile_count+7*STRIDE ] = s[7 ];  \n                otile[tile_count+8*STRIDE ] = s[8 ];  \n                otile[tile_count+9*STRIDE ] = s[9 ];  \n                otile[tile_count+10*STRIDE] = s[10];  \n                otile[tile_count+11*STRIDE] = s[11];  \n                otile[tile_count+12*STRIDE] = s[12];  \n                otile[tile_count+13*STRIDE] = s[13];  \n                otile[tile_count+14*STRIDE] = s[14];  \n                otile[tile_count+15*STRIDE] = s[15];  \n \n \n                tile_count++;  \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "1058a6c856f8ee81234a7e6283ecda8c06826dcfda205e8efa583fa3fe532748"}
{"code": "for (R_xlen_t t = 0; t < tlen; t++) { \n            memcpy(&p_vec[t * Nnodes], p_nodes, Nnodes * sizeof(int)); \n        }", "pragma": "parallel for ", "hash": "e09f4379f1fc2571c52c6a3bf7a65bb9f590b481c7d4d7922d3af16a72ee8bfb"}
{"code": "for (int i=0; i<N; i++) { \n    if (not star[i]->flags.check(active)) continue; \n \n     \n \n     \n \n    for (int j=0; j<N; j++) { \n      if (i == j) continue; \n \n      for (int k=0; k<ndim; k++) dr[k] = star[j]->r[k] - star[i]->r[k]; \n      for (int k=0; k<ndim; k++) dv[k] = star[j]->v[k] - star[i]->v[k]; \n      NearestPeriodicVector(simbox, dr, dr_corr); \n      drsqd    = DotProduct(dr, dr, ndim); \n      invdrmag = (FLOAT) 1.0/sqrt(drsqd); \n      drdt     = DotProduct(dv,dr,ndim)*invdrmag; \n      star[i]->gpot += star[j]->m*invdrmag; \n      for (int k=0; k<ndim; k++) star[i]->a[k] += star[j]->m*dr[k]*pow(invdrmag,3); \n      for (int k=0; k<ndim; k++) star[i]->adot[k] += \n        star[j]->m*pow(invdrmag,3)*(dv[k] - 3.0*drdt*invdrmag*dr[k]); \n \n       \n \n      if (simbox.PeriodicGravity) { \n        ewald->CalculatePeriodicCorrection(star[j]->m, dr, aperiodic, potperiodic); \n        for (int k=0; k<ndim; k++) star[i]->a[k] += aperiodic[k]; \n        star[i]->gpot += potperiodic; \n      } \n \n    } \n     \n \n \n  }", "pragma": "parallel for private(       aperiodic dr dr_corr drdt drsqd dv invdrmag potperiodic)", "hash": "cf3e9a61cd9a6ca7469397aefb66e66d276d11441f82a4e3b98898222a35455c"}
{"code": "for ( k=0; k<dimk; k++ ) { \n\t\tfor ( j=0; j<dimj; j++ ) { \n\t\t\talpha = -b[k+j*stride]; \n\t\t\tdaxpy ( &c[j*stride], &a[k*stride], dimi, alpha ); \n\t\t} \n\t}", "pragma": "for reduction( - : alpha) ", "hash": "0e3c277eae63f2631b737842621950fc78a62552c781e1c99daa90396349641e"}
{"code": "for (i = 1; i < n+1; i++) { \n\t\tfor (j = 1; j < n+1; j++) { \n\t\t\tfor (k = 1; k < n+1; k++) { \n\t\t\t\ta0[i*size*size+j*size+k] = (float) rand()/ (float)(1.0 + RAND_MAX); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(j k)", "hash": "18663241f90f1120b9483456747c0f7696eec6b760e9ab475710e5c411363625"}
{"code": "for (int i = 0; i < recv_total; ++i) { \n      uint64_t d = incoming_data[i]; \n      uint32_t v0 = uint32_t(d >> lg_nvertices_per_subpart_2d(lg_nvertices, lg_nvertices_local_1d_per_subowner)) & subpart_2d_mask; \n      uint32_t v1 = uint32_t(d) & subpart_2d_mask; \n      incoming_data[i] = make_edge_local(v0, v1); \n    }", "pragma": "parallel for ", "hash": "e1036092493f23f028d106de72181a8120c0eb7ef3a092e543afb28708616fb8"}
{"code": "for (i = 1; i <= LOOPCOUNT; i++) \n\t{ \n\t    sum0 = sum0 + i; \n\t    sum1 = sum0; \n\t}", "pragma": "for private(sum0 sum0)", "hash": "90b8268a5a00d0ca4620eb900d915a38d35764083fa8fbcce2ee13f16730f79f"}
{"code": "for (int ind = 0; ind < (*part)->getNumberOfParticles(); ind++) \n\t\t\t{ \n\t\t\t\titerateParticle(&data.at(0).at(ind), &data.at(1).at(ind), &data.at(2).at(ind), &data.at(3).at(ind), &data.at(4).at(ind), \n\t\t\t\t\tBFieldModel_m.get(), EFieldModel_m.get(), simTime_m, dt_m, (*part)->mass(), (*part)->charge(), simMin_m, simMax_m); \n\t\t\t\tif ((cudaloopind % checkDoneEvery == 0) && done && (data.at(4).at(ind) < 0.0)) \n\t\t\t\t{ \n\t\t\t\t\t \n \n\t\t\t\t\tdone = false;  \n \n\t\t\t\t\t \n \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "0aeee3344aaca402c418dc5fcc811549caccaa8ebae145c1b6422d0328fd7256"}
{"code": "for (j = 0; j < (*pTropt).cellcooqty[i]; j++) \n    { \n      int k; \n      double dist, *coo = ut_alloc_1d (3); \n \n      ut_array_1d_add ((*pTropt).cellcoos[i][j], (double *) x, 3, coo); \n \n      dist = DBL_MAX; \n      for (k = 0; k < (*pTropt).refcellcooqty[i]; k++) \n        dist = ut_num_min (dist, ut_space_dist (coo, (*pTropt).refcellcoos[i][k])); \n \n#pragma omp critical \n      val += dist; \n \n      ut_free_1d (&coo); \n    }", "pragma": "parallel for private(j)", "hash": "50a9d42e4a0b52241774ecccfe7de2cf5012e7f965e92cc57a5af34843b0f76d"}
{"code": "for( i=0; i<(N-1); i++ ) \n\t\t{ \n\t\t\tif ( wa[i+1] < wa[i] ) \n\t\t\t{ \n\t\t\t\tisSort[j][0] = false; \n\t\t\t\ti = N; \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "1e3699dedc5da3107fb0be941c2ad87092d164bece4bb93a9a368e4e8b19cd2c"}
{"code": "for( size_t c = 0; c < tendencies.size(); ++c ) { \n            switch( settings.tendency ) { \n                case BalanceSettings::WeightTendency::kNone: { \n                     \n \n                    assert( false ); \n                    break; \n                } \n                case BalanceSettings::WeightTendency::kMedian: { \n                    tendencies[c] = utils::median( \n                        result.edge_masses.col(c).begin(), result.edge_masses.col(c).end() \n                    ); \n                    break; \n                } \n                case BalanceSettings::WeightTendency::kArithmeticMean: { \n                    tendencies[c] = utils::arithmetic_mean( \n                        result.edge_masses.col(c).begin(), result.edge_masses.col(c).end() \n                    ); \n                    break; \n                } \n                case BalanceSettings::WeightTendency::kGeometricMean: { \n                     \n \n                     \n \n                    auto raw = result.edge_masses.col(c).to_vector(); \n                    for( auto& e : raw ) { \n                        e += 1.0; \n                    } \n                    tendencies[c] = utils::geometric_mean( raw ); \n                    break; \n                } \n                default: { \n                    assert( false ); \n                } \n            } \n            assert( std::isfinite( tendencies[c] )); \n            assert( tendencies[c] >= 0.0 ); \n        }", "pragma": "parallel for ", "hash": "20b4cede30779ee629a6149e4280f18cac3b5d6880f25a5ae70ca56acf0b4c90"}
{"code": "for (int ia = 0; ia < ctx_.unit_cell().num_atoms(); ia++) { \n         \n \n        for (int dir = 0; dir < 3; dir++) { \n            double d{0}; \n            for (int ia1 = 0; ia1 < ctx_.unit_cell().num_atoms(); ia1++) { \n                auto const& atom = ctx_.unit_cell().atom(ia1); \n                if (atom.type().hubbard_correction()) { \n                    int const lmax_at = 2 * atom.type().hubbard_orbital(0).l + 1; \n                    for (int ispn = 0; ispn < ctx_.num_spins(); ispn++) { \n                        for (int m1 = 0; m1 < lmax_at; m1++) { \n                            for (int m2 = 0; m2 < lmax_at; m2++) { \n                                d += std::real(potential_.U().U(m2, m1, ispn, ia1) * dn(m1, m2, ispn, ia1, dir, ia)); \n                            } \n                        } \n                    } \n                } \n            } \n            forceh_(dir, ia) -= d; \n        } \n    }", "pragma": "parallel for ", "hash": "9cbae312acbdeb41b0e144c0e0fd2fb0f7f4b1d930b73f94f8164f2a82ab97cd"}
{"code": "for ( i = 0; i < num_links; i++ ) \n    tmp[i] = add1[idx[i]];", "pragma": "parallel for private(i)", "hash": "0b745cfca8244d2e94cb255befabc0071f7205f691218ad421886f7092b7b5fb"}
{"code": "for (uint64_t i = 0; i < buffer.size(); i++) \n  { \n    FASTX::Record r = buffer[i]; \n    FASTX::Record r_rc = !r; \n    auto seqptr = r.get_seq_ptr(); \n    auto mapptr = kmap.map.find((*seqptr)); \n    auto seqptr_rc = r_rc.get_seq_ptr(); \n    auto mapptr_rc = kmap.map.find((*seqptr_rc)); \n \n    std::vector<aln_t> hits; \n \n    bool have_exact = false; \n \n    if (mapptr != kmap.map.end()) \n    { \n       \n \n      for (offset_t const & hit : mapptr->second) \n      { \n        aln_t x; \n        x.off = hit; \n        x.penalty = 0; \n        x.snp = \"-\"; \n        x.snp_pos = 0; \n        hits.push_back(x); \n      } \n      have_exact = true; \n    } \n    if (mapptr_rc != kmap.map.end()) \n    { \n      for (offset_t const & hit : mapptr_rc->second) \n      { \n        aln_t x; \n        x.off = hit; \n        x.penalty = 0; \n        x.snp = \"-\"; \n        x.snp_pos = 0; \n        hits.push_back(x); \n      } \n      have_exact = true; \n    } \n \n    if (! have_exact) \n    { \n       \n \n      for (uint64_t n = 0; n < seqptr->size(); n++) \n      { \n        for (uint64_t m = 0; m < 4; m++) \n        { \n          if (nucs[m] == (*seqptr)[n]) \n          { \n            continue; \n          } \n          std::string scopy = (*seqptr); \n          scopy[n] = nucs[m]; \n          mapptr = kmap.map.find(scopy); \n          if (mapptr != kmap.map.end()) \n          { \n            for (offset_t const & hit : mapptr->second) \n            { \n              aln_t x; \n              x.off = hit; \n              x.penalty = 1; \n              x.snp_pos = n; \n              x.snp += (*seqptr)[n]; \n              x.snp += \"/\"; \n              x.snp += nucs[m]; \n              hits.push_back(x); \n            } \n          } \n        } \n      } \n       \n \n      for (uint64_t n = 0; n < seqptr_rc->size(); n++) \n      { \n        for (uint64_t m = 0; m < 4; m++) \n        { \n          if (nucs[m] == (*seqptr_rc)[n]) \n          { \n            continue; \n          } \n          std::string scopy = (*seqptr_rc); \n          scopy[n] = nucs[m]; \n          mapptr = kmap.map.find(scopy); \n          if (mapptr != kmap.map.end()) \n          { \n            for (offset_t const & hit : mapptr->second) \n            { \n              aln_t x; \n              x.off = hit; \n              x.penalty = 1; \n              x.snp_pos = n; \n              x.snp += (*seqptr)[n]; \n              x.snp += \"/\"; \n              x.snp += nucs[m]; \n              hits.push_back(x); \n            } \n          } \n        } \n      } \n    } \n \n \n    #pragma omp critical \n    { \n      if (hits.size() == 0) \n      { \n        std::cout << \n                  *seqptr << '\\t' << \n                  \"NA\\t\" << \n                  \"NA\\t\" << \n                  \"NA\\t\" << \n                  \"NA\\t\" << \n                  \"NA\\n\"; \n      } \n      else \n      { \n        for (aln_t const & hit : hits) \n        { \n          std::cout << \n                    *seqptr << '\\t' << \n                    kmap.ids[hit.off.chr] << '\\t' << \n                    hit.off.pos << '\\t' << \n                    hit.penalty << '\\t' << \n                    hit.snp_pos << '\\t' << \n                    hit.snp << '\\n'; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "0546cd549ecf89529e5a8f1f3cbc0e7dc3226230d200e9504780b7731ce181e4"}
{"code": "for (k = 0; k < dz; k++) { \n\tfor(j = 0; j < dy; j++) { \n\t  for(i = 0; i < dx; i++) { \n\t    index = i+j*dx+k*dx*dy; \n\t    indexShifted = ((i+r0 + (j+r1)*dx + (k+r2)*dx*dy)%(dx*dy*dz)+(dx*dy*dz))%(dx*dy*dz); \n\t    data[indexShifted] = dataCopy[index]; \n\t  } \n\t} \n      }", "pragma": "parallel for private(   i index indexshifted j k)", "hash": "93e11d73ea153c56145b055ed5e1063245fee7a1853d8fea8553d85f4f25840b"}
{"code": "for (int y = 0; y < height; y += 4) \n\t\t\t\t\tfor (int x = 0, yStep = (y / 4) * Wsteps8; x < width; x += 8, yStep++) \n\t\t\t\t\t\tfor (int iy = 0, xStep = 4 * yStep; iy < 4; iy++, xStep++) \n\t\t\t\t\t\t\tdecodebytesC8_To_Raw16_SSSE3((u16*)dst + (y + iy) * width + x, src + 8 * xStep, tlutaddr);", "pragma": "parallel for ", "hash": "8cdffe1a5252c278452fefa30168509f3278a08894267af0f4e724541015d085"}
{"code": "for(size_t i = 0; i < non_zero_elements_amount-starting_index; ++i) \n        remove_neg_indices[i] = i + starting_index;", "pragma": "parallel for simd ", "hash": "4a1cbcf4b72e0863e592039f0c1142f57b184569636eef950d2d2898b82eb42a"}
{"code": "for(long i = 0; i < img_size; ++i) \n\t\t(*(dest + i)) = (uint8_t)((*(image + i)) + (*(residue + i)));", "pragma": "parallel ", "hash": "64eaddf5148b5c8f40972998f53fc7c4300f69e3d8791214fd67e2a535fcf161"}
{"code": "for( OMPInt i=0; i<nEl; ++i) \n\t  { \n\t    (*res)[ i] = abs( (*res)[ i]);  \n\t  }", "pragma": "for ", "hash": "b6ddc17cff2c1ae63490427650b997f5a6541cbf4cabb355d85336382cce0730"}
{"code": "for (k = 0; k < n; k++) { \n                  residual += pow(level[field_res]->data[k], 2.0); \n                  delta_u += pow(level[field_old]->data[k] - level[field_u]->data[k], 2.0); \n                  level[field_old]->data[k] = level[field_u]->data[k]; \n               }", "pragma": "for reduction(+:delta_u residual) ", "hash": "1c9eb411f8f1ba950b0d42f9aa3ba879654eee6ae66a30448a1e49d14c0b624f"}
{"code": "for (int64_t i = 0; i < n; i++) { \n        const int32_t* codes1 = codes + i * ld_codes; \n        BitstringWriter bsw(packed_codes + i * code_size, code_size); \n        for (int m = 0; m < M; m++) { \n            bsw.write(codes1[m], nbits[m]); \n        } \n        if (norm_bits != 0) { \n            bsw.write(encode_norm(norms[i]), norm_bits); \n        } \n    }", "pragma": "parallel for ", "hash": "83b66e510b2725839580549494e539e98b67d6609258910aaa1eab4fb1f48778"}
{"code": "for( OMPInt i=0; i < nEl; ++i) \n\t(*res)[i] = (*right)[i] + (*this)[i];", "pragma": "for ", "hash": "d773bad4ebfb34334686091cc862e2e2f0f765657cca21a46f33530e9a94239a"}
{"code": "for(int j=0;j<size;j++) \n\t{ \n\t\t \n \n\t\tmod=j;  \n \n \n\t\tfor(int l=0;l<sizeArrayParameters;l++) \n\t\t{ \n\t\t\tif(l==(sizeArrayParameters-1)){ \n\t\t\t\titerators[l]=mod; \n\t\t\t}else{ \n\t\t\t\titerators[l]=mod/iterators_max[l+1]; \n\t\t\t\tmod=(int)mod%iterators_max[l+1]; \n\t\t\t} \n\t\t} \n\t\t \n \n\t\tif(isDebugInfo){ \n\t\t\tcout<<\"array\"; \n\t\t\tfor(int debugIter=0;debugIter<sizeArrayParameters;debugIter++) \n\t\t\t{cout<<\"[\"<<iterators[debugIter]<<\"]\";}; \n\t\t\tcout <<\"=\" \n\t\t\t<<frames[j] \n\t\t\t<<endl; \n\t\t} \n\t \n\t\t \n \n\t\tif(iterators[find_key]!=0){ \n\t \n\t\t\tint pos_delta=j-iterators_max[find_key+1]; \n\t\t\tif(abs(frames[j]-frames[pos_delta])<=noise) \n\t\t\t{ \n\t\t\t\tchangesMask[j]=false;\t \n\t\t\t\t \n \n\t\t\t\tif(isDebugInfo){ \n\t\t\t\t\tcout<<\" Not changed \"<<endl; \n\t\t\t\t} \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tchangesMask[j]=true; \n\t\t\t\tif(isDebugInfo){\t \n\t\t\t\t\tcout<<\" Changed \"<<endl; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t\telse \n\t\t{ \n\t\t\t \n \n\t\t\tif(isDebugInfo){\t \n\t\t\t\tcout<<\"Exception: iterators[find_key]=0\"<<endl; \n\t\t\t} \n\t\t} \n\t \n\t}", "pragma": "parallel for private(j)", "hash": "e285d771fdf91dbe00272a588cfd7bce2689202517db5842c7c9f7dfa6e401e8"}
{"code": "for (int mi = 0; mi < mltNum; mi++) { \n            auto idx = OMPUtil::getThreadIdx(); \n \n            auto& image = acuumImage[idx]; \n            if (image.empty()) { \n                image.resize(width * height); \n                memset(&image[0], 0, sizeof(vec3) * width * height); \n            } \n \n             \n \n             \n \n             \n \n            CMJ rnd; \n            rnd.init(time.milliSeconds, mi, 4 * mltNum + mi + 1); \n            MLTSampler mlt(&rnd); \n \n             \n \n             \n \n \n             \n \n            int seedPathMax = width * height; \n            if (seedPathMax <= 0) { \n                seedPathMax = 1; \n            } \n \n            std::vector<Path> seedPaths(seedPathMax); \n \n            real sumI = 0.0; \n            mlt.largeStep = 1; \n \n            for (int i = 0; i < seedPathMax; i++) { \n                mlt.init(); \n \n                 \n \n                seedPaths[i] = genPath(ctxt, scene, &mlt, -1, -1, width, height, camera); \n                const auto& sample = seedPaths[i]; \n \n                 \n \n                mlt.globalTime++; \n \n                 \n \n                mlt.clearStack(); \n \n                 \n \n                sumI += color::luminance(sample.contrib); \n            } \n \n             \n \n             \n \n            int selecetdPath = 0; \n            { \n                auto cost = rnd.nextSample() * sumI; \n                real accumlatedImportance = 0; \n \n                for (int i = 0; i < seedPathMax; i++) { \n                    const auto& path = seedPaths[i]; \n                    accumlatedImportance += color::luminance(path.contrib); \n \n                    if (accumlatedImportance >= cost) { \n                        selecetdPath = i; \n                        break; \n                    } \n                } \n            } \n \n            const real b = sumI / seedPathMax; \n            const real p_large = 0.5; \n            const int M = mutation; \n            int accept = 0; \n            int reject = 0; \n \n            Path oldPath = seedPaths[selecetdPath]; \n \n            for (int i = 0; i < M; i++) { \n                mlt.largeStep = rnd.nextSample() < p_large ? 1 : 0; \n \n                mlt.init(); \n \n                 \n \n                Path newPath = genPath(ctxt, scene, &mlt, -1, -1, width, height, camera); \n \n                real I = color::luminance(newPath.contrib); \n                real oldI = color::luminance(oldPath.contrib); \n \n                real a = std::min(real(1.0), I / oldI); \n \n                const real newPath_W = (a + mlt.largeStep) / (I / b + p_large) / M; \n                const real oldPath_W = (real(1.0) - a) / (oldI / b + p_large) / M; \n \n                int newPos = newPath.y * width + newPath.x; \n                vec3 newV = newPath_W * newPath.contrib * newPath.weight; \n                image[newPos] += newV; \n \n                int oldPos = oldPath.y * width + oldPath.x; \n                vec3 oldV = oldPath_W * oldPath.contrib * oldPath.weight; \n                image[oldPos] += oldV; \n \n                auto r = rnd.nextSample(); \n \n                if (r < a) { \n                     \n \n                    accept++; \n \n                     \n \n                    oldPath = newPath; \n \n                    if (mlt.largeStep) { \n                        mlt.largeStepTime = mlt.globalTime; \n                    } \n                    mlt.globalTime++; \n \n                     \n \n                    mlt.clearStack(); \n                } \n                else { \n                     \n \n                    reject++; \n \n                     \n \n                    int idx = mlt.usedRandCoords - 1; \n                    while (!mlt.stack.empty()) { \n                        mlt.u[idx--] = mlt.stack.top(); \n                        mlt.stack.pop(); \n                    } \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "288391b28d5d3b36523a37d0b710c1711883e61c872dbbb1566a9f6a6b9e731b"}
{"code": "for (int index = 0; index < _input_gpath_num; ++index) \n    { \n        float **results = &results_array[index]; \n        string input_gpath = input_gpath_array[index]; \n \n         \n \n        Mat image = imread(input_gpath); \n        ValStructVec<float, Vec4i> boxesTests; \n        boxesTests.reserve(10000); \n        detector->getObjBndBoxes(image, boxesTests, numPerSz); \n \n        int length = boxesTests.size(); \n        *results = new float[ length * RESULT_LENGTH ]; \n        for (int i = 0; i < length; ++i) \n        { \n            for (int j = 0; j < RESULT_LENGTH; ++j) \n            { \n                (*results)[i * RESULT_LENGTH + j] = boxesTests[i][j]; \n            } \n        } \n        length_array[index] = length; \n    }", "pragma": "parallel for ", "hash": "08892dfbe40815096f4662826e4af168da4725300a441dcfd5ae6aa3414e1eab"}
{"code": "for (ompIndexType idx = 0; idx < (ompIndexType)nbElements; ++idx) { \n            maxValue = std::max(val[idx], maxValue); \n            minValue = std::max(val[idx], minValue); \n        }", "pragma": "for ", "hash": "5d802f94e76c0d05d6046750f1da0358a871703bf89544d69fa3587bb1cb8204"}
{"code": "for(t = 0; t < stride*nframe; t++) \n  { \n    real *input_ptr = input_data + (t/stride)*dim*stride + t % stride; \n    real *output_ptr = output_data + (t/stride)*dim*stride + t % stride; \n \n    real inputMax = -THInf; \n    accreal sum; \n \n    long d; \n    for(d = 0; d < dim; d++) { \n      if (input_ptr[d*stride] >= inputMax) inputMax = input_ptr[d*stride]; \n    } \n \n    sum = 0; \n    for(d = 0; d < dim; d++) { \n      real z = THExpMinusApprox(inputMax - input_ptr[d*stride]); \n      output_ptr[d*stride] = z; \n      sum += z; \n    } \n \n    for(d = 0; d < dim; d++) { \n      output_ptr[d*stride] *= 1/sum; \n    } \n  }", "pragma": "parallel for private(t)", "hash": "57fe8d85032f12560a5d7fa6bd588312c06af52c5444c5607e9d0762e1abb038"}
{"code": "for(i=0; i<N; i++) { \n    zp[i] = zp[i] + dt*vz[i]; \n    yp[i] = yp[i] + dt*vy[i]; \n    xp[i] = xp[i] + dt*vx[i]; \n  }", "pragma": "parallel for ", "hash": "0ee119818b7aba5862f90fe76d85ea47546ce7a9ff3389d8e3ce02cb70e8553f"}
{"code": "for(i=0; i<N; i++) { \n    double dtqmi = dt*qm[i]; \n    vz[i] = vz[i] + dtqmi*Ez[i]; \n    vy[i] = vy[i] + dtqmi*Ey[i]; \n    vx[i] = vx[i] + dtqmi*Ex[i]; \n\t \n  }", "pragma": "parallel for ", "hash": "bc462d871d3ed5c4b494d68373652c3d6b6da5ffc6f147497f89dce1167e38f3"}
{"code": "for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      gamma; \n \n    MagickBooleanType \n      sync; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict l, \n      *restrict p; \n \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) (width-1)/2L),y-(ssize_t) \n      ((width-1)/2L),image->columns+width,width,exception); \n    l=GetCacheViewVirtualPixels(luminance_view,-((ssize_t) (width-1)/2L),y- \n      (ssize_t) ((width-1)/2L),luminance_image->columns+width,width,exception); \n    q=GetCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if ((p == (const PixelPacket *) NULL) || \n        (l == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(image_view); \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      double \n        contrast; \n \n      DoublePixelPacket \n        pixel; \n \n      MagickRealType \n        intensity; \n \n      register const double \n        *restrict k; \n \n      register ssize_t \n        u; \n \n      ssize_t \n        j, \n        v; \n \n      pixel.red=bias.red; \n      pixel.green=bias.green; \n      pixel.blue=bias.blue; \n      pixel.opacity=bias.opacity; \n      pixel.index=bias.index; \n      k=kernel; \n      intensity=GetPixelIntensity(image,p+center); \n      gamma=0.0; \n      j=0; \n      if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse)) \n        { \n          for (v=0; v < (ssize_t) width; v++) \n          { \n            for (u=0; u < (ssize_t) width; u++) \n            { \n              contrast=GetPixelIntensity(luminance_image,l+u+j)-intensity; \n              if (fabs(contrast) < threshold) \n                { \n                  pixel.red+=(*k)*GetPixelRed(p+u+j); \n                  pixel.green+=(*k)*GetPixelGreen(p+u+j); \n                  pixel.blue+=(*k)*GetPixelBlue(p+u+j); \n                  gamma+=(*k); \n                } \n              k++; \n            } \n            j+=(ssize_t) (image->columns+width); \n          } \n          if (gamma != 0.0) \n            { \n              gamma=PerceptibleReciprocal(gamma); \n              if ((channel & RedChannel) != 0) \n                SetPixelRed(q,ClampToQuantum(gamma*pixel.red)); \n              if ((channel & GreenChannel) != 0) \n                SetPixelGreen(q,ClampToQuantum(gamma*pixel.green)); \n              if ((channel & BlueChannel) != 0) \n                SetPixelBlue(q,ClampToQuantum(gamma*pixel.blue)); \n            } \n          if ((channel & OpacityChannel) != 0) \n            { \n              gamma=0.0; \n              j=0; \n              for (v=0; v < (ssize_t) width; v++) \n              { \n                for (u=0; u < (ssize_t) width; u++) \n                { \n                  contrast=GetPixelIntensity(luminance_image,l+u+j)-intensity; \n                  if (fabs(contrast) < threshold) \n                    { \n                      pixel.opacity+=(*k)*(p+u+j)->opacity; \n                      gamma+=(*k); \n                    } \n                  k++; \n                } \n                j+=(ssize_t) (image->columns+width); \n              } \n              gamma=PerceptibleReciprocal(gamma); \n              SetPixelOpacity(q,ClampToQuantum(gamma*pixel.opacity)); \n            } \n          if (((channel & IndexChannel) != 0) && \n              (image->colorspace == CMYKColorspace)) \n            { \n              gamma=0.0; \n              j=0; \n              for (v=0; v < (ssize_t) width; v++) \n              { \n                for (u=0; u < (ssize_t) width; u++) \n                { \n                  contrast=GetPixelIntensity(luminance_image,l+u+j)-intensity; \n                  if (fabs(contrast) < threshold) \n                    { \n                      pixel.index+=(*k)*GetPixelIndex(indexes+x+u+j); \n                      gamma+=(*k); \n                    } \n                  k++; \n                } \n                j+=(ssize_t) (image->columns+width); \n              } \n              gamma=PerceptibleReciprocal(gamma); \n              SetPixelIndex(blur_indexes+x,ClampToQuantum(gamma*pixel.index)); \n            } \n        } \n      else \n        { \n          MagickRealType \n            alpha; \n \n          for (v=0; v < (ssize_t) width; v++) \n          { \n            for (u=0; u < (ssize_t) width; u++) \n            { \n              contrast=GetPixelIntensity(luminance_image,l+u+j)-intensity; \n              if (fabs(contrast) < threshold) \n                { \n                  alpha=(MagickRealType) (QuantumScale*GetPixelAlpha(p+u+j)); \n                  pixel.red+=(*k)*alpha*GetPixelRed(p+u+j); \n                  pixel.green+=(*k)*alpha*GetPixelGreen(p+u+j); \n                  pixel.blue+=(*k)*alpha*GetPixelBlue(p+u+j); \n                  pixel.opacity+=(*k)*GetPixelOpacity(p+u+j); \n                  gamma+=(*k)*alpha; \n                } \n              k++; \n            } \n            j+=(ssize_t) (image->columns+width); \n          } \n          if (gamma != 0.0) \n            { \n              gamma=PerceptibleReciprocal(gamma); \n              if ((channel & RedChannel) != 0) \n                SetPixelRed(q,ClampToQuantum(gamma*pixel.red)); \n              if ((channel & GreenChannel) != 0) \n                SetPixelGreen(q,ClampToQuantum(gamma*pixel.green)); \n              if ((channel & BlueChannel) != 0) \n                SetPixelBlue(q,ClampToQuantum(gamma*pixel.blue)); \n            } \n          if ((channel & OpacityChannel) != 0) \n            { \n              gamma=0.0; \n              j=0; \n              for (v=0; v < (ssize_t) width; v++) \n              { \n                for (u=0; u < (ssize_t) width; u++) \n                { \n                  contrast=GetPixelIntensity(luminance_image,l+u+j)-intensity; \n                  if (fabs(contrast) < threshold) \n                    { \n                      pixel.opacity+=(*k)*GetPixelOpacity(p+u+j); \n                      gamma+=(*k); \n                    } \n                  k++; \n                } \n                j+=(ssize_t) (image->columns+width); \n              } \n              gamma=PerceptibleReciprocal(gamma); \n              SetPixelOpacity(q,ClampToQuantum(pixel.opacity)); \n            } \n          if (((channel & IndexChannel) != 0) && \n              (image->colorspace == CMYKColorspace)) \n            { \n              gamma=0.0; \n              j=0; \n              for (v=0; v < (ssize_t) width; v++) \n              { \n                for (u=0; u < (ssize_t) width; u++) \n                { \n                  contrast=GetPixelIntensity(luminance_image,l+u+j)-intensity; \n                  if (fabs(contrast) < threshold) \n                    { \n                      alpha=(MagickRealType) (QuantumScale* \n                        GetPixelAlpha(p+u+j)); \n                      pixel.index+=(*k)*alpha*GetPixelIndex(indexes+x+u+j); \n                      gamma+=(*k); \n                    } \n                  k++; \n                } \n                j+=(ssize_t) (image->columns+width); \n              } \n              gamma=PerceptibleReciprocal(gamma); \n              SetPixelIndex(blur_indexes+x,ClampToQuantum(gamma*pixel.index)); \n            } \n        } \n      p++; \n      l++; \n      q++; \n    } \n    sync=SyncCacheViewAuthenticPixels(blur_view,exception); \n    if (sync == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor != (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_SelectiveBlurImageChannel) \n        proceed=SetImageProgress(image,SelectiveBlurImageTag,progress++, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  }", "pragma": "parallel for ", "hash": "9d1a5715c7da946c18849785983c69799a7b6c0c4be419b9dc0b46dfc4988cfe"}
{"code": "for(size_t i=0; i<size; i++) result &= data[i] == rhs.data[i];", "pragma": "parallel for reduction(&:result) ", "hash": "ad46ff01a530482cae50b733290de36775bc5f8ce401bc241f536b1df4c06b18"}
{"code": "for(int i=0; i<i_NumOfVerticesToBeColored; i++) { \n\t\t\t\t \n \n\t\t\t\tcont = true; \n\t\t\t\tint v = vi_VerticesToBeColored[i]; \n\t\t\t\t \n \n\t\t\t\tfor (int w=m_vi_LeftVertices [v]; (w<m_vi_LeftVertices [v+1]) && (cont == true); w++ ) { \n\t\t\t\t\t \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t \n \n\t\t\t\t\tfor (int x=m_vi_RightVertices [m_vi_Edges [w]]; x<m_vi_RightVertices [m_vi_Edges [w]+1]; x++ ) { \n\t\t\t\t\t   \n \n\t\t\t\t\t   \n \n\t\t\t\t\t   \n \n\t\t\t\t\t   \n \n\t\t\t\t\t\t \n \n\t\t\t\t\t  if ( m_vi_LeftVertexColors [m_vi_Edges [x]] == m_vi_LeftVertexColors[v] && f(v) > f(m_vi_Edges [x]) ) { \n\t\t\t\t\t\t\t \n \n#pragma omp critical \n                                              { \n\t\t\t\t\t\t\t\tvi_verticesNeedNewColor.push_back(v); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\tcont = false; \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for private(cont)", "hash": "0172e3dec303c7f6eec098920f565fcc8830e4b2510f4e33363d94ab5efc9311"}
{"code": "for (i = 0; i < nelem; i++) \n        { \n            int             k; \n            int             ind; \n \n            ind = elem[i].attrib.prcp_conc - 1; \n \n            for (k = 0; k < rttbl->num_spc; k++) \n            { \n                elem[i].prcpchm.tot_conc[k] = forc->prcpc[ind].value[k]; \n            } \n        }", "pragma": "parallel for ", "hash": "b1506a31d13f3897e0977eccf93bdf1a38b8647d2ec22c43c8f9149612e78291"}
{"code": "for (loop_index = 0; loop_index < loop_num; loop_index++) { \n \n\t\tbitmask = one; \n\t\tstart_index = loop_interval * loop_index; \n\t\tp_index = CHAR_NUM * CPU_V_NUM * loop_index * word_num; \n\t\tint bit_index = 0; \n\t\tint char_index = 0; \n\t\tfor (i = 0; i < read_seq->len; i++) { \n\t\t\tif (bit_index == word_size) { \n\t\t\t\tbitmask = one; \n\t\t\t\tbit_index = 0; \n\t\t\t\tchar_index++; \n\t\t\t} \n \n\t\t\tfor (j = 0; j < CPU_V_NUM; j++) { \n\t\t\t\tchar_value = mapping_table[(int) itr[start_index + (read_seq->len + 1) * j]]; \n\t\t\t\tresult_reads[p_index + char_value * word_num * CPU_V_NUM + char_index * CPU_V_NUM + j] |= bitmask; \n\t\t\t} \n \n\t\t\tbitmask <<= 1; \n\t\t\tstart_index++; \n\t\t\tbit_index++; \n\t\t} \n\t}", "pragma": "parallel for private(      bitmask char_value i j loop_index p_index start_index)", "hash": "fefe93c8d1ccc0ab0c03705cdb94e7fd38c25de329d5fa8b9af5dfd736275890"}
{"code": "for (Index j = 0 ; j < n ; j++) \n                { \n                    int64_t s = Sp [j] ; \n                    for (int64_t p = Ap [j] ; p < Ap [j+1] ; p++) \n                    { \n                        Index i = Ai [p] ; \n                        if (perm [i] > perm [j]) \n                        { \n                            Si [s++] = i ; \n                        } \n                    } \n                }", "pragma": "parallel for ", "hash": "5a8ade9e00965ef3ebb195af39ba3297f5d0aed661f1c5c1ab41eda569feaa5d"}
{"code": "for (i = 0; i < nx; i++) { \n \n          o = i;     \n \n          r = o+1;   \n \n          l = o-1;   \n \n \n          if (i>0 && i<nx-1) \n            un[o] = u[o] + kx*(u[r]-2*u[o]+u[l]); \n          else \n            un[o] = u[o]; \n\t\t\t\t}", "pragma": "for ", "hash": "e5e7d9eeb0334a07cbbf4950a4fb04c58af9281df212eb1a419a7a46f12a3f0c"}
{"code": "for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const PixelPacket \n      *restrict p; \n \n    register ssize_t \n      i, \n      x; \n \n    size_t \n      bit, \n      byte; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    bit=0; \n    byte=0; \n    i=(ssize_t) (image->columns+7)/8; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      byte<<=1; \n      if (((MagickRealType) GetPixelRed(p) < threshold) || \n          ((MagickRealType) GetPixelGreen(p) < threshold) || \n          ((MagickRealType) GetPixelBlue(p) < threshold)) \n        byte|=0x01; \n      bit++; \n      if (bit == 8) \n        { \n          (void) SetRadonCell(source_cells,--i,y,bits[byte]); \n          bit=0; \n          byte=0; \n        } \n      p++; \n    } \n    if (bit != 0) \n      { \n        byte<<=(8-bit); \n        (void) SetRadonCell(source_cells,--i,y,bits[byte]); \n      } \n  }", "pragma": "parallel for ", "hash": "1440a10b492c78a7877d7b71f9b2ed374dbd723fa64c8f9c26358aaa6a4af43c"}
{"code": "for(i = 0;i<ndata;i++){ \n     tmp=0.0; \n     for(j = ptr[i];j<ptr[i+1];j++) \n     { \n       tmp+=val[j]*xvec[col[j]]; \n       axvec[i]=tmp; \n     } \n   }", "pragma": "parallel for reduction(+:tmp) private(  axvec axvec j val xvec)", "hash": "3ff3e6fe389d46b8c04c693dc1768f9d073de846c723a3ac6894c806d7f8e1e2"}
{"code": "for (int i = 0; i < N; i++) { \n\t\t\toffset = N * i; \n\t\t\tfor (j = 0; j < N; j++) { \n\t\t\t\tu[i] += matrix[offset + j] * result[j]; \n\t\t\t} \n\t\t}", "pragma": "parallel for private( j offset)", "hash": "c66213cb32e680d2dd62fd16a8be1eb068eef3ab4867ef301fd961eb00f605d7"}
{"code": "for(int j = 0; j < roi_out->height; j++) \n  { \n    float *out = (float *)ovoid + (size_t)roi_out->width * j; \n    float *in = (float *)ivoid + (size_t)roi_out->width * j; \n \n    for(int i = 0; i < roi_out->width; i++, in++, out++) \n    { \n      if(i == roi_out->width - 1 || j == roi_out->height - 1) \n      { \n         \n \n        out[0] = MIN(clip, in[0]); \n      } \n      else \n      { \n        int clipped = 0; \n \n         \n \n        float R = 0.0f, Gmin = FLT_MAX, Gmax = -FLT_MAX, B = 0.0f; \n        for(int jj = 0; jj <= 1; jj++) \n        { \n          for(int ii = 0; ii <= 1; ii++) \n          { \n            const float val = in[(size_t)jj * roi_out->width + ii]; \n \n            clipped = (clipped || (val > clip)); \n \n            const int c = FC(j + jj + roi_out->y, i + ii + roi_out->x, filters); \n            switch(c) \n            { \n              case 0: \n                R = val; \n                break; \n              case 1: \n                Gmin = MIN(Gmin, val); \n                Gmax = MAX(Gmax, val); \n                break; \n              case 2: \n                B = val; \n                break; \n            } \n          } \n        } \n \n        if(clipped) \n        { \n          const float Ro = MIN(R, clip); \n          const float Go = MIN(Gmin, clip); \n          const float Bo = MIN(B, clip); \n \n          const float L = (R + Gmax + B) / 3.0f; \n \n          float C = SQRT3 * (R - Gmax); \n          float H = 2.0f * B - Gmax - R; \n \n          const float Co = SQRT3 * (Ro - Go); \n          const float Ho = 2.0f * Bo - Go - Ro; \n \n          if(R != Gmax && Gmax != B) \n          { \n            const float ratio = sqrtf((Co * Co + Ho * Ho) / (C * C + H * H)); \n            C *= ratio; \n            H *= ratio; \n          } \n \n          float RGB[3] = { 0.0f, 0.0f, 0.0f }; \n \n           \n \n          RGB[0] = L - H / 6.0f + C / SQRT12; \n          RGB[1] = L - H / 6.0f - C / SQRT12; \n          RGB[2] = L + H / 3.0f; \n \n          out[0] = RGB[FC(j + roi_out->y, i + roi_out->x, filters)]; \n        } \n        else \n        { \n          out[0] = in[0]; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "91de2efe04ec93d0ab2a85f6e9bfa1d563df640ee5a3c2eaf9f78c49ae29ec7a"}
{"code": "for (ii = 0; ii < nn; ++ii) { \n      i = ilist[ii]; \n      if (atom->mask[i] & groupbit) { \n        indxI = 2 * i; \n        b[indxI  ] = eta[ atom->type[i] ] * x[indxI  ]; \n        b[indxI+1] = eta[ atom->type[i] ] * x[indxI+1]; \n      } \n    }", "pragma": "for ", "hash": "fa6eb3b1e102742ec5f0ff389aa2a5ceeaf73907f24429eae07aa07d943ee0e4"}
{"code": "for(int j=1;j<thNum-1;j++){ \n\t\tA[1][j]=0; \n\t\t#ifdef SC \n\t\t\t#ifndef PUREOHM \n\t\t\t\tA[0][j]=-A[2][j]*(sc_factors[j]*thtd/dr+(B[1][j+1]-B[1][j-1])/(pow(rmin,2)*sines[j]*4*dth))/(sc_factors[j]*thtd/dr-(B[1][j+1]-B[1][j-1])/(pow(rmin,2)*sines[j]*4*dth)); \n\t\t\t#endif \n        #else \n            A[0][j]=-A[2][j]; \n\t\t#endif \n\t\tA[rNum+1][j]=A[rNum-1][j]; \n\t\tfor(int n=0;n<l;n++){ \n\t\t\tA[rNum+1][j]+=boundary_factors2[n]*a[n]*legendre_comb[n][j]; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "c3490c66168f11a8da77e5e034e2c0abcfacaac0c7e28c9adacf6fe3ba5a4b48"}
{"code": "for (int i=1; i<imax; i++)  \n  { \n    for (int j=1; j<jmax; j++) \n    { \n      for (int rf=1; rf<rf_num; rf++) \n      { \n        if (hydroindex[i][j]==rf)  \n        { \n          rainfallgrid2D[i][j] = rain_data[current_rainfall_timestep][rf-1];  \n \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "2bf7d3292d993aa4fd168352d010b9e897d12140242783f420c55b93fd56ee92"}
{"code": "for (UINT y = 0; y < nHeight; y++) \n\t{ \n\t\tfor (UINT x = 0; x < nWidth; x++) \n\t\t{ \n\t\t\tUINT id = y*nWidth+x; \n\t\t\tVector3f value = buffer[id]; \n\t\t\tif(_IsNan(value)) \n\t\t\t{ \n\t\t\t\ttexBuffer[id].rgbRed = 0; \n\t\t\t\ttexBuffer[id].rgbGreen = 0; \n\t\t\t\ttexBuffer[id].rgbBlue = 0; \n\t\t\t\ttexBuffer[id].rgbReserved = 0; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\ttexBuffer[id].rgbRed = (BYTE)(value[0] * 255); \n\t\t\t\ttexBuffer[id].rgbGreen = (BYTE)(value[1] * 255); \n\t\t\t\ttexBuffer[id].rgbBlue = (BYTE)(value[2] * 255); \n\t\t\t\ttexBuffer[id].rgbReserved = 255; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "1e1887cdf680aa0b8ba2d2f371c1b476c72cc802b53c0073665912fb7fb9c99a"}
{"code": "for (int i = 0; i < numReads; ++i) {\r \n\t\treadArray[i].formTuples(K);\r \n\t\treadArray[i].sortTuples();\r \n\t}", "pragma": "parallel for ", "hash": "89efe68879a1fd83e1297cb575dc95b567d78e3289361e0d2517c011330b614a"}
{"code": "for (i = 0; i < 10; i++) \n    { \n        if (a != (3 + i)) \n            abort(); \n        if (b != (4 + i)) \n            abort(); \n \n        a++; \n        b++; \n    }", "pragma": "for private( a b)", "hash": "1708fe6d2b1af57bb47fd55f34783e6a60e1d6cc8ebec54b0c84847433dab46d"}
{"code": "for(int row = 2; row < roi_out->height - 2; row++) \n  { \n    const float *in = (float *)ivoid + (size_t)width * row + 2; \n    float *out = (float *)ovoid + (size_t)width * row + 2; \n    for(int col = 2; col < width - 2; col++, in++, out++) \n    { \n      float mid = *in * multiplier; \n      if(*in > threshold) \n      { \n        int count = 0; \n        float maxin = 0.0; \n        float other; \n#define TESTONE(OFFSET)                                                                                         other = in[OFFSET];                                                                                           if(mid > other)                                                                                               {                                                                                                               count++;                                                                                                      if(other > maxin) maxin = other;                                                                            } \n        TESTONE(-2); \n        TESTONE(-widthx2); \n        TESTONE(+2); \n        TESTONE(+widthx2); \n#undef TESTONE \n        if(count >= min_neighbours) \n        { \n          *out = maxin; \n          fixed++; \n          if(markfixed) \n          { \n            for(int i = -2; i >= -10 && i >= -col; i -= 2) out[i] = *in; \n            for(int i = 2; i <= 10 && i < width - col; i += 2) out[i] = *in; \n          } \n        } \n      } \n    } \n  }", "pragma": "parallel for reduction(+ : fixed) ", "hash": "5307ff95f6c28b8ce190de22b921aa710fec7657c9886ee978a45e0e17041859"}
{"code": "for (int i=0; i<cast_prolong->get_nrow(); ++i) \n    for (int j=cast_prolong->mat_.row_offset[i]; j<cast_prolong->mat_.row_offset[i+1]; ++j) \n      for (int jj=cast_prolong->mat_.row_offset[i]; jj<cast_prolong->mat_.row_offset[i+1]-1; ++jj) \n        if (cast_prolong->mat_.col[jj] > cast_prolong->mat_.col[jj+1]) { \n           \n \n \n          int ind = cast_prolong->mat_.col[jj]; \n          ValueType val = cast_prolong->mat_.val[jj]; \n \n          cast_prolong->mat_.col[jj] = cast_prolong->mat_.col[jj+1]; \n          cast_prolong->mat_.val[jj] = cast_prolong->mat_.val[jj+1];           \n \n          cast_prolong->mat_.col[jj+1] = ind; \n          cast_prolong->mat_.val[jj+1] = val; \n        }", "pragma": "parallel for ", "hash": "0ffe0cec8379fcd3a6c1057fd7f1a744bbccf28ef366f68b9c80f6dbebd0cbdf"}
{"code": "for(long i=0;i<nx*ny*nz;i++) \n\t{ \n\t\tregister mreal aa=a->vthr(i), pp=p->vthr(i); \n\t\td->a[i] = dual(aa*cos(pp), aa*sin(pp)); \n\t}", "pragma": "parallel for ", "hash": "6461870403c4123a2b03c28d5766474b8b8df653bc53f46f1822a546e54e71d4"}
{"code": "for(int midx=0; midx < modelFit.rows(); midx++) \n    { \n        float fit = modelFit(midx); \n        fit < -1.f ? fit = 0.f : fit = exp(-fit); \n        modelFit(midx) = fit; \n    }", "pragma": "parallel for ", "hash": "eeb73d98d086f4ce11af9aa25d7962aa75f2066bf9c9d3d68b17c43e5387d710"}
{"code": "for(k=0; k<n; k++) { \n        C[i*n+j] += A[i*n+k]*B[k*n+j]; \n      }", "pragma": "parallel for ", "hash": "fe6d04a2dcfd18b454207786e686bebb76f6a0dabf5eb544f89798aa5c4494eb"}
{"code": "for ( int i=0 ; i<n ; i++ ) \n                    for ( int j=0 ; j<n ; j++ ) \n                        B[i*n+j] = A[j*n+i];", "pragma": "parallel for ", "hash": "f136797e2461e0c6d2d0b64ae9e9014c612df7637663d1c5b8d448898ce8cfd5"}
{"code": "for (i=0; i<mrows*ncols; i++)\r \n\t{\r \n\t\tint r=i%mrows;\r \n\t\tint c=i/mrows;\r \n\t\tif (r>=win_half_r && r<=(mrows-win_half_r) && c>=win_half_c && c<=(ncols-win_half_c)\r \n\t\t\t&& r%2==0 && c%2==0)\r \n\t\t{\r \n\t\t\tdouble *temp=new double[total_win];\r \n\t\t\tdouble *atmp=new double[pca_len];\r \n\t\t\tdouble win_counter=0, cent_r=0, cent_c=0;\r \n\t\t\tfor (int j=0; j<win_c; j++)\r \n\t\t\t{\r \n\t\t\t\tfor (int k=0; k<win_r; k++)\r \n\t\t\t\t{\r \n\t\t\t\t\ttemp[k+j*win_r]=*(ImgPtr+(r-win_half_r+k)+(c-win_half_c+j)*mrows)-*(pca_meanPtr+k+j*win_r);\r \n\t\t\t\t\twin_counter=win_counter+*(ImgPtr+(r-win_half_r+k)+(c-win_half_c+j)*mrows);\r \n\t\t\t\t\tcent_r=cent_r+k*(*(ImgPtr+(r-win_half_r+k)+(c-win_half_c+j)*mrows));\r \n\t\t\t\t\tcent_c=cent_c+j*(*(ImgPtr+(r-win_half_r+k)+(c-win_half_c+j)*mrows));\r \n\t\t\t\t}\r \n\t\t\t}\r \n\t\t\tcent_r=cent_r/win_counter;\r \n\t\t\tcent_c=cent_c/win_counter;\r \n\t\t\tdouble pixel_num=250;\r \n\t\t\tif ((r-1/3.0*win_r)+win_half_r<win_r)\r \n\t\t\t\tpixel_num=pixel_num*((r-1/3.0*win_r)+win_half_r)/double(win_r);\r \n\t\t\telse if ((r+win_half_r)>(mrows-1.0/3*win_r))\r \n\t\t\t\tpixel_num=pixel_num*(win_r-((r+win_half_r)-(mrows-1.0/3*win_r)))/double(win_r);\r \n\t\t\t\r \n\t\t\tif (win_counter>pixel_num) {\r \n\t\t\t\tif (abs(34-cent_r)<=10 || abs(41-cent_c)<=10)\r \n\t\t\t\t{\r \n\t\t\t\t\tdotproduct(temp, eigPtr, total_win, pca_len, atmp);\r \n\t\t\t\t\tdouble diff_sq[31];\r \n\t\t\t\t\tdouble min_diff=total_win,min_diff_ind;\r \n\t\t\t\t\tfor (int j=0; j<31; j++)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tdiff_sq[j]=0;\r \n\t\t\t\t\t\tfor (int k=0; k<pca_len; k++)\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\tdiff_sq[j] = diff_sq[j]+pow((atmp[k]-*(coePtr+k+pca_len*j)),2);\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t\tif (diff_sq[j]<=min_diff) {\r \n\t\t\t\t\t\t\tmin_diff=diff_sq[j];\r \n\t\t\t\t\t\t\tmin_diff_ind=j;\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t}\r \n\t\t\t\t\t*(outPtr+i)=min_diff;\r \n\t\t\t\t\t*(outPtr2+i)=min_diff_ind;\r \n\t\t\t\t}\r \n\t\t\t\telse *(outPtr+i)=290.0;\r \n\t\t\t}\r \n\t\t\telse *(outPtr+i)=280.0;\r \n\t\t\tdelete [] temp;\r \n\t\t\tdelete [] atmp;\r \n\t\t}\r \n\t\telse *(outPtr+i)=206.0;\r \n\t}", "pragma": "parallel for ", "hash": "1d62c28021639aee1196adf916bf573eeee1c7f8aa190514506a673d16132aaf"}
{"code": "for (i = 0; i < nrows; ++i) { \n        t = 0.0; \n        #pragma ivdep \n        for (j = 0; j < max_entries_per_row; ++j) { \n            t += A[i][j] * x[indices[i][j]]; \n        } \n        r[i] = t; \n    }", "pragma": "parallel for private(  i j t)", "hash": "125940b75d3beaa9de54065f288cd6e738824fd03f6b8e7e199128ed8c5a4634"}
{"code": "for (i = 0; i < imageSizeRef[box]; i++) { \n    factor = prefactRef[box][i] * (sumRref[box][i] * sumRref[box][i] + \n                                   sumIref[box][i] * sumIref[box][i]); \n \n    wT11 += factor * (1.0 - 2.0 * (constVal + 1.0 / hsqrRef[box][i]) * \n                      kxRef[box][i] * kxRef[box][i]); \n \n    wT22 += factor * (1.0 - 2.0 * (constVal + 1.0 / hsqrRef[box][i]) * \n                      kyRef[box][i] * kyRef[box][i]); \n \n    wT33 += factor * (1.0 - 2.0 * (constVal + 1.0 / hsqrRef[box][i]) * \n                      kzRef[box][i] * kzRef[box][i]); \n  }", "pragma": "parallel for reduction(  +:wt11 wt22 wt33) private( factor i)", "hash": "f40252efbbf93e1648877646b132baf1b289cd152ee9c915226c5051327c00af"}
{"code": "for(int selK = 0; selK < reference.selection.size(); selK++){ \n     \n \n        unsigned int k = reference.selection[selK]; \n \n        CVertexO vj=reference.model->cm.vert[k]; \n \n             \n \n            float maxScaleRef = vj.Q(); \n            int xMin, yMin, xMax, yMax; \n            computeScaleBounds(reference, toAlign, maxScaleRef, maxscaleToAl, xMin, xMax, yMin, yMax); \n \n            std::vector<DerivableSphereFit> *descr = descriptorsReference[k]; \n            std::vector<DerivableSphereFit>* result = descriptorsToAlign[ind]; \n \n            DynamicSolver ds; \n            ds.solve(*descr,  descr->size(), \n\t\t\t\t\t *result, result->size(), \n                     toAlign.multiplier, xMin, xMax, yMin, yMax); \n \n#pragma omp critical \n            { \n                std::vector<Cand>::iterator it; \n                it = firstPoints.begin(); \n                 \n \n                if (firstPoints.back().confidence < ds.confidence) \n                { \n                    DynamicProg::ConvolutionStretchEstimation<Scalar> vse; \n                    cpoint.confidence=ds.confidence; \n                    cpoint.ind = k; \n                     \n \n                    cpoint.scale=vse.estimate(ds.stepMatrix(), toAlign.multiplier); \n                     \n \n                    if (firstPoints.back().ind==-1) \n                    { \n                         \n \n                        firstPoints[0].confidence=cpoint.confidence; \n                        firstPoints[0].ind=cpoint.ind; \n                        firstPoints[0].scale=cpoint.scale; \n                         \n \n                    } \n                    else for(unsigned int r=0; r<firstPoints.size(); r++) \n                    { \n                         \n \n                        if(firstPoints[r].confidence<cpoint.confidence) \n                        { \n                            firstPoints.insert(it+r, cpoint); \n                            if(firstPoints.size()>FIRST_POINTS) \n                                firstPoints.pop_back(); \n                            break; \n                        } \n                    } \n                } \n            } \n         \n \n         \n \n\t}", "pragma": "parallel for ", "hash": "78bb9849824377c381d5bf1c37c44e47190710a09b538bf7f0f5f7ef64e081ec"}
{"code": "for (uint32_t i=0; i<(uint32_t) m_Height*m_Width; i++) {\r \n    for (short Ch=1; Ch<NrChannels; Ch++) {\r \n      MicrocontrastLayer->m_Image[i][Ch] = CLIP((int32_t) ((WPH-(int32_t)MicrocontrastLayer->m_Image[i][Ch])+m_Image[i][Ch]));\r \n    }\r \n  }", "pragma": "parallel for ", "hash": "4a9f7da66b3f02b9a70d4be028beeba3186f25f14d9d4de489fae54e5e796d6c"}
{"code": "for(unsigned long n=0; n<ncell; n++)\t\t\t\t\t\t \n \n\t\t{ \n\t\t \n \n\t\tcell_volume += volumeOld[n]; \n\t\t \n\t\t \n \n\t\tif( CellVector[n].Get_isonAS() ) \n\t\t\t{ \n\t\t\tlong double g_env = CellVector[n].Get_g_env(); \n\t\t\ts0_env += g_env; \n\t\t\tsG_env += g_env*(mGextOld[n]/volume_extraOld[n]); \n\t\t\t \n \n\t\t\tsA_env += g_env*(mAextOld[n]/volume_extraOld[n]); \n\t\t\tsAcL_env += g_env*(mAcLextOld[n]/volume_extraOld[n]); \n\t\t\t} \n\t\t\t \n\t\t}", "pragma": "parallel for ", "hash": "86bd25369f448ec41350348ee53f9a97e961b05c682c3f274ba678ef35cd80d9"}
{"code": "for (int i=0; i<im->h; i++) { \n            j=(positionj[k]-(i*sin(theta*positioni[k])))/cos(theta*positioni[k]); \n            if (j<im->w && j>0) { \n                im->img[j*im->h+i]=255; \n            } \n        }", "pragma": "for ", "hash": "6a8190f925e727541eaccae15e4e4b61922bc6eb0aaec166a8fa51b264e1703f"}
{"code": "for(long long n_tmp = 0LL; n_tmp < static_cast<long long>(N); ++n_tmp) { \n            std::size_t n = static_cast<std::size_t>(n_tmp); \n            std::pair<std::size_t, float> min_k_dist = FindNearetCenterLinear(NthCode(pydata, n), centers_old); \n            assignments_[n] = (int) min_k_dist.first; \n            errors[n] = min_k_dist.second; \n        }", "pragma": "parallel for ", "hash": "fc91af9cb6b2c69976881716cc616a9d3bc04e95509829869d89b3da610f820b"}
{"code": "for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i) \n  { \n    make_hv_dline(i); \n  }", "pragma": "parallel for ", "hash": "9642da06ae3fc8443fd38cc526fc317b83fde0919bd1685554a63d8303df5fe4"}
{"code": "for (int i = 0; i < my_vector.size(); i++) { \n    my_vector[i] = exp(-sin(i * i + pi * log(i + 1))); \n  }", "pragma": "parallel for ", "hash": "d42886a251db907fb4a89c0f89ff82b75596133b6c52ae3ffd426e100305f6f4"}
{"code": "for(size_t i=0;i<n;i++) \n\t{ \n\t\tEigen::VectorXd l(p); \n\t\tfinal_result_out_per_pixel opp; \n\t\tif(mask.data[i]) \n\t\t{ \n\t\t\tfor(int c=0;c<3;c++) \n\t\t\t{ \n\t\t\t\tfor(int j=0;j<p;j++) \n\t\t\t\t{ \n\t\t\t\t\tconst float* data=(const float*)inputs[j].data; \n\t\t\t\t\tl[j]=data[3*i+c]/newlightsources[j].intensity[c]; \n\t\t\t\t} \n\t\t\t\t \n\t\t\t\tcv::Vec4f xyzd_c=perpixelsolver.solve_xyzd_normal(l); \n\t\t\t\topp.normal+=cv::Vec3f(xyzd_c[0],xyzd_c[1],xyzd_c[2]); \n\t\t\t\topp.normal/=3.0f; \n\t\t\t\topp.diffuse[c]=xyzd_c[3]; \n\t\t\t} \n\t\t} \n\t\tfor(int c=0;c<3;c++) \n\t\t{ \n\t\t\tnormalsout[3*i+c]=opp.normal[c]; \n\t\t\tdiffuseout[3*i+c]=opp.diffuse[c]; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "b36c06f2bf3879eae84b4e25877ff068aae9dbee4c581d4313e14fc87eacfc6b"}
{"code": "for(pairI = 0; pairI < pairMax; pairI++)\r \n\t\t\t{\r \n\t\t\t\tint tI = omp_get_thread_num();\r \n\t\t\t\tassert(omp_get_num_threads() == outerThreads);\r \n\t\t\t\tassert((tI >= 0) && (tI < outerThreads));\r \n\t\t\t\t\r \n\t\t\t\tassert((pairI >= 0) && (pairI < readPairs.size()));\r \n\t\t\t\toneReadPair rP = readPairs.at(pairI);\t\t\t\t\r \n\t\t\t\t    \r \n\t\t\t\tassert((tI >= 0) && (tI < graphAligners.size()));\r \n\r \n\t\t\t\tstd::map<int, double> _IS_ignore;\r \n\t\t\t\t\r \n\r \n\t\t\t\t\r \n\t\t\t\tstd::pair<seedAndExtend_return_local, seedAndExtend_return_local> alignment_pair;\r \n\r \n\t\t\t\tif(useAllAlignments_short)\r \n\t\t\t\t{\t\t\t\t\r \n\t\t\t\t\r \n\t\t\t\t\tstd::vector<std::pair<seedAndExtend_return_local, seedAndExtend_return_local>> alignment_pairs = graphAligners.at(tI)->seedAndExtend_short_allAlignments(rP, insertSize_mean, insertSize_sd, greedyLocalExtension);\r \n\t\t\t\t\t\t\t\r \n\t\t\t\t\talignment_pair = alignment_pairs.at(0);\r \n\t\t\t\t}\r \n\t\t\t\telse\r \n\t\t\t\t{\r \n\t\t\t\t\tassert(! greedyLocalExtension);\r \n\t\t\t\t\talignment_pair = graphAligners.at(tI)->seedAndExtend_local_paired_or_short(rP, usePairing, useShort, insertSize_mean, insertSize_sd, false, _IS_ignore);\r \n\t\t\t\t}\r \n\t\t\t\t\r \n\t\t\t\talignments_perThread.at(tI).push_back(alignment_pair);\r \n\t\t\t\talignments_readPairI_perThread.at(tI).push_back(pairI);\r \n\t\t\t\t\r \n\t\t\t\tif(tI == 0)\r \n\t\t\t\t{\r \n\t\t\t\t\tstd::cout  << Utilities::timestamp() << \"\\t\\t\" << \"Thread \" << tI << \": align pair \" << pairI << \"\\n\" << std::flush;\r \n\t\t\t\t\tthread1_pairs++;\r \n\t\t\t\t\tif((thread1_pairs % 10) == 0)\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\ttime_t N = std::time(0);\r \n\t\t\t\t\t\tif(thread1_lastPairs != -1)\r \n\t\t\t\t\t\t{\r \n\t\t\t\t\t\t\tint d_pairs = thread1_pairs - thread1_lastPairs;\r \n\t\t\t\t\t\t\tdouble d_time = N - thread1_lastTime;\r \n\t\t\t\t\t\t\tdouble rate = (double)d_pairs / d_time;\r \n\t\t\t\t\t\t\tstd::cout << \"\\t Rate: \" << rate << \"\\n\" << std::flush;\r \n\t\t\t\t\t\t}\r \n\t\t\t\t\t\tthread1_lastPairs = thread1_pairs;\r \n\t\t\t\t\t\tthread1_lastTime = N;\r \n\t\t\t\t\t}\r \n\t\t\t\t}\r \n\t\t\t}", "pragma": "parallel for ", "hash": "f19a4b597e673e1b2a566bdd9d94d3df9970de4c81892ed95ff37a39166e139e"}
{"code": "for (int iv = 0; iv < (int)vvariables.size(); iv++) { \n        if (vvariables[iv]->IsActive()) \n            vvariables[iv]->Get_qb().FillElem(0); \n    }", "pragma": "parallel for ", "hash": "d755f7817cd499006c325a413e95a51d501ead7d2ca268e39d560c5f49fba404"}
{"code": "for (i = 0; i < max; i++) \n    { \n        array[i]->load(); \n    }", "pragma": "parallel for private(i)", "hash": "27e9ab22e7e69e2cfb655d5730589196f093f1a9866ac48a3dd5551e50da064b"}
{"code": "for(int i1 = 0; i1 < img1.height; i1++) \n        box_min_1d(img1.width, img1.data + (size_t)i1 * img1.width, img2.data + (size_t)i1 * img2.width, 1, w);", "pragma": "for ", "hash": "18815d6317b1fa09da3bc64c8fba75f01d42de06cf87b88c78ccec11a3701e91"}
{"code": "for (int i=0; i < N; ++i) \n    andl = andl && rcl[i];", "pragma": "parallel reduction(&&: andl) ", "hash": "dce77bf0132fc9ca97fba3091173db30adf3e0256df267e41019b9ed7dcf5d25"}
{"code": "for (std::size_t i = 0; i < numOfTasks; ++i) { \n                    const Task4& task = tmpTaskList[i]; \n                    unpackTaskList[i * 4] = task.shellIndex1; \n                    unpackTaskList[i * 4 + 1] = task.shellIndex2; \n                    unpackTaskList[i * 4 + 2] = task.shellIndex3; \n                    unpackTaskList[i * 4 + 3] = task.shellIndex4; \n                }", "pragma": "parallel for ", "hash": "4ed810599978aefad8461d54ce7fb9504932f5349193a0fafc4dc4eefc2ceda6"}
{"code": "for (size_t i = 0; i < dbr.getSize(); i++) { \n            progress.updateProgress(); \n \n             \n \n            if (mergedClustering[i].empty()) \n                continue; \n \n             \n \n            unsigned int dbKey = dbr.getDbKey(i); \n            for (std::list<unsigned int>::iterator it = mergedClustering[i].begin(); it != mergedClustering[i].end(); ++it) { \n                char *tmpBuff = Itoa::u32toa_sse2(dbr.getDbKey(*it), buffer); \n                size_t length = tmpBuff - buffer - 1; \n                res.append(buffer, length); \n                res.push_back('\\n'); \n            } \n \n            dbw.writeData(res.c_str(), res.length(), dbKey, thread_idx); \n            res.clear(); \n        }", "pragma": "for ", "hash": "b8e25f14a765bb0d1406e25055f419dccda57eaafca768b94180bcbc988b39af"}
{"code": "for(ir=0;ir<par->smap->nr;ir++) { \n      for(ib=0;ib<par->smap->nbeams;ib++) { \n        for(ipp=0;ipp<5*par->smap->num_pix_per_beam[ir];ipp++) \n          par->smap->data[ib][ir][ipp]=0; \n      } \n    }", "pragma": "for ", "hash": "b35cb746b276dcfd8e7c555529a04c3e82012747c7df3b7fecf5babeb3957d4d"}
{"code": "for ( long nodeIdx = 0; nodeIdx < static_cast<long>( nodeCount ); nodeIdx++ ) \n        { \n            const std::vector<int> elements = femPart->elementsUsingNode( nodeIdx ); \n \n             \n \n            cvf::Vec3d result         = cvf::Vec3d::ZERO; \n            int        nValidElements = 0; \n            for ( int elmIdx : elements ) \n            { \n                RigElementType elmType = femPart->elementType( elmIdx ); \n                if ( elmType == HEX8P ) \n                { \n                     \n \n                    std::array<cvf::Vec3d, 8> hexCorners; \n                    std::array<double, 8>     cornerValues; \n \n                    int elmNodeCount = RigFemTypes::elementNodeCount( elmType ); \n                    for ( int elmNodIdx = 0; elmNodIdx < elmNodeCount; ++elmNodIdx ) \n                    { \n                        size_t elmNodResIdx   = femPart->elementNodeResultIdx( elmIdx, elmNodIdx ); \n                        size_t resultValueIdx = femPart->resultValueIdxFromResultPosType( RIG_NODAL, elmIdx, elmNodIdx ); \n \n                        cornerValues[elmNodIdx] = srcFrameData[resultValueIdx]; \n                        hexCorners[elmNodIdx]   = cvf::Vec3d( nodeCoords[resultValueIdx] ); \n                    } \n \n                    std::array<cvf::Vec3d, 8> gradients = RigHexGradientTools::gradients( hexCorners, cornerValues ); \n \n                    for ( int elmNodIdx = 0; elmNodIdx < elmNodeCount; ++elmNodIdx ) \n                    { \n                        size_t elmNodResIdx   = femPart->elementNodeResultIdx( elmIdx, elmNodIdx ); \n                        size_t resultValueIdx = femPart->resultValueIdxFromResultPosType( RIG_NODAL, elmIdx, elmNodIdx ); \n                         \n \n                        if ( static_cast<size_t>( nodeIdx ) == resultValueIdx ) \n                        { \n                            result.add( gradients[elmNodIdx] ); \n                        } \n                    } \n \n                    nValidElements++; \n                } \n            } \n \n            if ( nValidElements > 0 ) \n            { \n                 \n \n                 \n \n                double epsilon = 1.0e-6; \n                result /= static_cast<double>( nValidElements ); \n                dstFrameDataX[nodeIdx] = std::abs( result.x() ) > epsilon ? result.x() : 0.0; \n                dstFrameDataY[nodeIdx] = std::abs( result.y() ) > epsilon ? result.y() : 0.0; \n                dstFrameDataZ[nodeIdx] = std::abs( result.z() ) > epsilon ? result.z() : 0.0; \n            } \n        }", "pragma": "parallel for ", "hash": "12ea6ab6cffcd0566b19987e1fe74e425480576faa500a57796b27ce461d7f6a"}
{"code": "for (t2=lb2; t2<=ub2; t2++) { \n      for (t3=0;t3<=floord(K-1,32);t3++) { \n        for (t4=max(0,32*t1);t4<=min(M-1,32*t1+31);t4++) { \n          for (t5=max(0,32*t3);t5<=min(K-1,32*t3+31);t5++) { \n{ \n lbv=max(0,32*t2); ubv=min(N-1,32*t2+31); \n#pragma ivdep \n#pragma vector always \n for (t6=lbv; t6<=ubv; t6++) { \n              C[t4][t6]=C[t4][t6]+A[t4][t5]*B[t5][t6]; ; \n            } \n} \n          } \n        } \n      } \n    }", "pragma": "parallel for private(t2 t3 t4 t5 t6)", "hash": "d8a79c4f198166d6bd998061e4b1505c12a1919fa8add2893a3367aa49cd1543"}
{"code": "for (int device_id = 0; device_id < num_gpu_; ++device_id) { \n     \n \n    CUDASUCCESS_OR_FATAL(cudaEventSynchronize(histograms_wait_obj_[device_id])); \n  }", "pragma": "parallel for ", "hash": "c380ae992c8bc910e04c47ecc76b564cbf111c2f79e2ec832cb016cb0c786a51"}
{"code": "for (int rw = 0; rw < m_nRows; rw++) \n            { \n                if (!FloatEqual(data[rw][2], NoDataValue)) \n                { \n                     \n \n                    if (FloatEqual(m_1DDataWithRowCol[rw][2], NoDataValue)) m_1DDataWithRowCol[rw][2] = 0.0f; \n                    m_1DDataWithRowCol[rw][0] = data[rw][0];  \n \n                    m_1DDataWithRowCol[rw][1] = data[rw][1];  \n \n                    if (m_Counter == 0) \n                    { \n                         \n \n                        m_1DDataWithRowCol[rw][2] = data[rw][2];     \n \n                    } \n                    else \n                    { \n                         \n \n                        m_1DDataWithRowCol[rw][2] = ((m_1DDataWithRowCol[rw][2] * m_Counter) + data[rw][2]) / (m_Counter + 1); \n                    } \n                } \n            }", "pragma": "parallel for ", "hash": "02bfef302b3db1e1dbf8f9c975f2d11cf719668b20b5f3828a26e1b0eae5ffa5"}
{"code": "for(MMD_int i = 0; i < nlocal; i++) { \n    v[i * 3 + 0] += dtforce * f[i * 3 + 0]; \n    v[i * 3 + 1] += dtforce * f[i * 3 + 1]; \n    v[i * 3 + 2] += dtforce * f[i * 3 + 2]; \n    x[i * 3 + 0] += dt * v[i * 3 + 0]; \n    x[i * 3 + 1] += dt * v[i * 3 + 1]; \n    x[i * 3 + 2] += dt * v[i * 3 + 2]; \n  }", "pragma": "for ", "hash": "afc17f03cd904ec91a90f2c1cc12513f2d1ef1fcdb3fa6a10cc44abaf491e50d"}
{"code": "for (libxsmm_blasint i = 0; i < s; ++i) { \n          a_array[i] = a + static_cast<size_t>(asize) * helper.shuffle(i); \n          b_array[i] = b + static_cast<size_t>(bsize) * helper.shuffle(i); \n \n          if (0 == check) { \n            c_array[i] = d + static_cast<size_t>(csize) * chunksize * omp_get_thread_num(); \n          } \n          else \n          c_array[i] = d; \n        }", "pragma": "parallel for ", "hash": "1c0e9abc2d1bbd1ea1c335c1fd72140160d37683cc9e2a775f59bc991aecfca0"}
{"code": "for( i = 0 ; i < LCU ; i++ ) {     \n      const size_t idx = i + t*LCU ; \n      struct halfspinor res ; \n      colormatrixdag_halfspinor( (void*)res.D , lat[idx].O[ND-1] , \n\t\t\t\t F -> S[i] ) ; \n      F -> S[i] = res ; \n    }", "pragma": "for private(i)", "hash": "c1b59985d7cdcf961bedc98f752e257f1785732d93208d855c5f60599bc6a31e"}
{"code": "for( int i=0; i<l_ids.size(); i++ ) { \n\t\tconst int N = l_ids[i].size(); \n\t\tif( N>0 ) { \n\t\t\tRMatrixXf d_lbl( N, lbl.cols() ); \n\t\t\tVectorXf d_weight( N ); \n\t\t\tfor( int j=0; j<N; j++ ) { \n\t\t\t\tint k = l_ids[i][j]; \n\t\t\t\td_lbl.row(j) = lbl.row( k ); \n\t\t\t\td_weight[j]  = weight[ k ]; \n\t\t\t} \n\t\t\tif( settings.use_single_leaf_label ) { \n\t\t\t\tstd::shared_ptr<SplitCriterion> csplit = split->create( d_lbl, d_weight ); \n\t\t\t\tleaf_ids[i] = VectorXi::Constant(1,l_ids[i][csplit->repLabel()]); \n\t\t\t\tleaf_weight[i] = VectorXf::Constant(1,1.0f); \n\t\t\t} \n\t\t\telse { \n\t\t\t\tleaf_ids[i] = VectorXi::Map( l_ids[i].data(), l_ids[i].size() ); \n\t\t\t\tleaf_weight[i] = d_weight; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "3650e21cc830b3e9427ab8b33649a8aa856842e639a2b539bd45b3f1198db53b"}
{"code": "for (int y = 0; y < height; y++) { \n                for (int x = 0; x < width; x++) { \n                    int pos = y * width + x; \n \n                    const vec3& s = src[pos]; \n \n                    vec3 col = vec3( \n                        aten::sqrt(s.r), \n                        aten::sqrt(s.g), \n                        aten::sqrt(s.b)); \n \n                    real lum = color::RGBtoY(col); \n \n                    if (lum > real(0)) { \n                        sumY[idx] += aten::log(lum); \n \n                        if (lum > maxLum[idx]) { \n                            maxLum[idx] = lum; \n                        } \n \n                        cnt++; \n                    } \n                } \n            }", "pragma": "for ", "hash": "73ef99ac4b9e8407350761b88d2f670126b534da05e1c24ef5decabc748c48f7"}
{"code": "for(int i=0;i<diff_count;i++) \n                                sum_var_med += (MED_z -save_Z[i])*(MED_z -save_Z[i]);", "pragma": "parallel for reduction(+:sum_var_med) ", "hash": "6770090676cb4d20db211b489ff4291d193a65d4d745ea5b5aa3a17ba84d1523"}
{"code": "for (i = 14; i < nx - 14; i+=1) \n            { \n                float tmp = coeffs[0] * (A0[i + 1] + A0[i - 1]) ; \n                tmp += coeffs[1] * (A0[i + 2] + A0[i - 2]) ; \n                tmp += coeffs[2] * (A0[i + 3] + A0[i - 3]) ; \n                tmp += coeffs[3] * (A0[i + 4] + A0[i - 4]) ; \n                tmp += coeffs[4] * (A0[i + 5] + A0[i - 5]) ; \n                tmp += coeffs[5] * (A0[i + 6] + A0[i - 6]) ; \n                tmp += coeffs[6] * (A0[i + 7] + A0[i - 7]) ; \n                tmp += coeffs[7] * (A0[i + 8] + A0[i - 8]) ; \n                tmp += coeffs[8] * (A0[i + 9] + A0[i - 9]) ; \n                tmp += coeffs[9] * (A0[i + 10] + A0[i - 10]) ; \n                tmp += coeffs[10] * (A0[i + 11] + A0[i - 11]) ; \n                tmp += coeffs[11] * (A0[i + 12] + A0[i - 12]) ; \n                tmp += coeffs[12] * (A0[i + 13] + A0[i - 13]) ; \n                tmp += coeffs[13] * (A0[i + 14] + A0[i - 14]) ; \n                tmp += coeffs[14] * A0[i]; \n \n                Anext[i] = tmp; \n            }", "pragma": "for ", "hash": "1250067e097ac1ebcc1bb68f0ea541b8b9ac10e012c497fe213b40f9030a7a1a"}
{"code": "for (Index i = 0; i < activeUniforms; ++i) { \n\t\t\t\t\t\tindices[i] = static_cast<GLuint>(tempIndices[i]); \n\t\t\t\t\t}", "pragma": "parallel for ", "hash": "58d01f341f1d00a615382a53646e980996328e7d2a520e1651c734ce882e4231"}
{"code": "for (i = 0; i < ns; i++) { \n        p = a0[i]; \n        for (j = 0; j < nf; j++) { \n            p += a1[i * nf + j]; \n            out[p] = data[i * nf + j]; \n        } \n    }", "pragma": "parallel for private( j p)", "hash": "61e53c1b04cbf0ac2f9bc1891593b0f919d316aa4d3f8f9b09c99258e4d00e0c"}
{"code": "for(long i=0;i<ny;i++)\ta[xx+nx*i] = b?b[i]:v->v(i);", "pragma": "parallel for ", "hash": "8326ed4b5f9b65d9f94b6b53be67508424186784d149538cd8d4fcba93fa7674"}
{"code": "for(std::size_t i=0; i<10000; ++i) \n        { \n             \n \n             \n \n            const auto real01_1 = rng_1.uniform_real01(); \n            const auto real01_2 = rng_2.uniform_real01(); \n             \n \n \n#pragma omp critical \n            { \n                BOOST_TEST(0.0 <= real01_1); \n                BOOST_TEST(real01_1 < 1.0); \n                BOOST_TEST(0.0 <= real01_2); \n                BOOST_TEST(real01_2 < 1.0); \n                BOOST_TEST(real01_1 == real01_2); \n            } \n        }", "pragma": "parallel for ", "hash": "4868b0d1adc026695048a399cceda2e2f299cb8295aaa1c3288f6b7153487d1b"}
{"code": "for(ix=0; ix<nx; ix++){ \n    for(iz=0; iz<nz; iz++){ \n      vtmp[ix][iz]=vv[ix][iz]+epsil*cg[ix][iz]; \n    } \n  }", "pragma": "parallel for private( ix iz)", "hash": "c3cce1091455ca4538d306557a5841bd907f759c5d29a9ac4084d3bf990a5088"}
{"code": "for (int i = 0; i < M1->row_count; ++i) {\r \n        for (int k = 0; k < vector_size; ++k) {\r \n            for (int j = 0; j < M2->col_count; ++j) {\r \n                M3->values[i][j] += M1->values[i][k] * M2->values[k][j];\r \n            }\r \n        }\r \n    }", "pragma": "parallel ", "hash": "b90f3432af321cbdbde5f81640625f70610fc6c66b4bb9793c5b824c94ed17f4"}
{"code": "for (int j=0;j<SEG_NUM;j++){ \n\t\t\t\tint *addr1,*addr2; \n\t\t\t\tint id = j % nump; \n\t\t\t\tint part_id = j / nump; \n\t\t\t\t \n \n\t\t\t\taddr1 = data + part_id*n2; \n\t\t\t\taddr2 = addr1 + len; \n\t\t\t\tint pos,pos2; \n\t\t\t\tint bsearch_len = (id+1)*seg_len; \n\t\t\t\tif ( id+1 != nump ){ \n\t\t\t\t\tif (id < nump/2){ \n\t\t\t\t\t\taddr2 += len - bsearch_len; \n\t\t\t\t\t\tpos = bsearch(addr1 , addr2 , bsearch_len); \n\t\t\t\t\t\tpos2 = bsearch_len - pos; \n\t\t\t\t\t\tpos2 = len - pos2; \n\t\t\t\t\t} \n\t\t\t\t\telse { \n\t\t\t\t\t\tpos = bsearch(addr1 , addr2 , bsearch_len); \n\t\t\t\t\t\tbsearch_len = n2-(id+1)*seg_len; \n\t\t\t\t\t\taddr1 += len - bsearch_len; \n\t\t\t\t\t\tpos = bsearch(addr1 , addr2 , bsearch_len); \n\t\t\t\t\t\tpos2 = bsearch_len - pos; \n\t\t\t\t\t\tpos += len - bsearch_len; \n\t\t\t\t\t\tpos2 = bsearch_len - pos2; \n\t\t\t\t\t} \n\t\t\t\tcut[j] = pos; \n\t\t\t\tcut2[j] = pos2; \n\t\t\t\t} \n \n\t\t\t}", "pragma": "parallel for ", "hash": "42c976fa932ee780e6ddaf6a6befd2536d2f8c694e405dc00bf9ee0eb02e408b"}
{"code": "for (i = 0; i < num; ++i) \n        { \n            double arg = 0.0, phase_re = 0.0, phase_im = 0.0, re = 0.0, im = 0.0; \n            arg = twopi * (u[i] * delta_l + v[i] * delta_m + w[i] * delta_n); \n            phase_re = cos(arg); \n            phase_im = sin(arg); \n            re = a[i].x * phase_re - a[i].y * phase_im; \n            im = a[i].x * phase_im + a[i].y * phase_re; \n            a[i].x = re; \n            a[i].y = im; \n        }", "pragma": "parallel for private(i)", "hash": "25a34450f677890cb81031a80a7cb5c2e7a3e80e4647afbfa40e1820103672d5"}
{"code": "for (int cell = 0; cell < nCells; cell++) { \n       \n \n      int ii = x_index[cell]; \n      int jj = y_index[cell]; \n      int kk = z_index[cell]; \n \n      els[cell].dx = dx; \n      els[cell].dy = dy; \n      els[cell].dz = dz; \n \n       \n \n       \n \n      els[cell].vtx[0].coords[0] = ii*dx; \n      els[cell].vtx[0].coords[1] = jj*dy; \n      els[cell].vtx[0].coords[2] = kk*dz; \n \n       \n \n      els[cell].vtx[1].coords[0] = (ii + 1)*dx; \n      els[cell].vtx[1].coords[1] = jj*dy; \n      els[cell].vtx[1].coords[2] = kk*dz; \n \n       \n \n      els[cell].vtx[2].coords[0] = (ii + 1)*dx; \n      els[cell].vtx[2].coords[1] = (jj + 1)*dy; \n      els[cell].vtx[2].coords[2] = kk*dz; \n \n       \n \n      els[cell].vtx[3].coords[0] = ii*dx; \n      els[cell].vtx[3].coords[1] = (jj + 1)*dy; \n      els[cell].vtx[3].coords[2] = kk*dz; \n \n       \n \n      els[cell].vtx[4].coords[0] = ii*dx; \n      els[cell].vtx[4].coords[1] = (jj + 1)*dy; \n      els[cell].vtx[4].coords[2] = (kk + 1)*dz; \n \n       \n \n      els[cell].vtx[5].coords[0] = (ii + 1)*dx; \n      els[cell].vtx[5].coords[1] = (jj + 1)*dy; \n      els[cell].vtx[5].coords[2] = (kk + 1)*dz; \n \n       \n \n      els[cell].vtx[6].coords[0] = (ii + 1)*dx; \n      els[cell].vtx[6].coords[1] = jj*dy; \n      els[cell].vtx[6].coords[2] = (kk + 1)*dz; \n \n       \n \n      els[cell].vtx[7].coords[0] = ii*dx; \n      els[cell].vtx[7].coords[1] = jj*dy; \n      els[cell].vtx[7].coords[2] = (kk + 1)*dz; \n \n       \n \n       \n \n      if (jj == 0 || par.voxel_geometry[idx3(kk, (jj - 1), ii, par.ny, par.nx)] == 1) { \n        els[cell].fac[0].bctype = 1; \n        els[cell].fac[0].neighbor = -1; \n      } \n      else { \n        els[cell].fac[0].bctype = 0; \n        els[cell].fac[0].neighbor = cell_numbers[idx3(kk, (jj - 1), ii, par.ny, par.nx)]; \n      } \n       \n \n      if (ii == par.nx - 1 || par.voxel_geometry[idx3(kk, jj, (ii + 1), par.ny, par.nx)] == 1) { \n        els[cell].fac[1].bctype = 1; \n        els[cell].fac[1].neighbor = -1; \n      } \n      else { \n        els[cell].fac[1].bctype = 0; \n        els[cell].fac[1].neighbor = cell_numbers[idx3(kk, jj, (ii + 1), par.ny, par.nx)]; \n      } \n       \n \n      if (jj == par.ny - 1 || par.voxel_geometry[idx3(kk, (jj + 1), ii, par.ny, par.nx)] == 1) { \n        els[cell].fac[2].bctype = 1; \n        els[cell].fac[2].neighbor = -1; \n      } \n      else { \n        els[cell].fac[2].bctype = 0; \n        els[cell].fac[2].neighbor = cell_numbers[idx3(kk, (jj + 1), ii, par.ny, par.nx)]; \n      } \n       \n \n      if (ii == 0 || par.voxel_geometry[idx3(kk, jj, (ii - 1), par.ny, par.nx)] == 1) { \n        els[cell].fac[3].bctype = 1; \n        els[cell].fac[3].neighbor = -1; \n      } \n      else { \n        els[cell].fac[3].bctype = 0; \n        els[cell].fac[3].neighbor = cell_numbers[idx3(kk, jj, (ii - 1), par.ny, par.nx)]; \n      } \n       \n \n      if (kk == 0 || par.voxel_geometry[idx3((kk - 1), jj, ii, par.ny, par.nx)] == 1) { \n        els[cell].fac[4].bctype = 1; \n        els[cell].fac[4].neighbor = -1; \n      } \n      else { \n        els[cell].fac[4].bctype = 0; \n        els[cell].fac[4].neighbor = cell_numbers[idx3((kk - 1), jj, ii, par.ny, par.nx)]; \n      } \n       \n \n      if (kk == par.nz - 1 || par.voxel_geometry[idx3((kk + 1), jj, ii, par.ny, par.nx)] == 1) { \n        els[cell].fac[5].bctype = 1; \n        els[cell].fac[5].neighbor = -1; \n      } \n      else { \n        els[cell].fac[5].bctype = 0; \n        els[cell].fac[5].neighbor = cell_numbers[idx3((kk + 1), jj, ii, par.ny, par.nx)]; \n      } \n    }", "pragma": "for ", "hash": "da6b1724f50591a481c27d01050aa76cbd91cb7926821854a41d54032106bf2a"}
{"code": "for (size_t k = 0; k < n; k++) { \n        a[k] = 0.0; \n        b[k] = 0.5; \n        c[k] = 0.5; \n    }", "pragma": "parallel for ", "hash": "0f8a487f3d7388523e070d826ea19a989b1a95d44e764f6f82159cf98bf66fe0"}
{"code": "for (int tid = 0; tid < num_threads; ++tid) { \n          iters[tid].emplace_back( \n              feature_groups_[gid]->SubFeatureIterator(fid)); \n        }", "pragma": "parallel for ", "hash": "26d93fb2a835217c2979a01996dda33e37d6e5f432d911c01f6c6815fff49f67"}
{"code": "for (int y = info.offy; y < info.offy + info.height; y++)\r \n\t{\r \n\t\tint offsetBuf = (y-info.offy)*info.width<<2;\r \n\t\tint offset = y * mipMapSize[info.level].width() + info.offx;\r \n\t\tfor (int x = info.offx; x < info.offx + info.width; x++)\r \n\t\t{\r \n\t\t\tvcg::Point3f h(0, 0, 1);\r \n\t\t\th += info.light;\r \n\t\t\th /= 2;\r \n\t\t\th.Normalize();\r \n            float nDotH = h * normalsPtr[offset];\r \n\t\t\tif (nDotH < 0) \r \n\t\t\t\tnDotH = 0.0;\r \n\t\t\telse if (nDotH > 1)\r \n\t\t\t\tnDotH = 1.0;\r \n\t\t\tnDotH = pow(nDotH, exp);\r \n\t\t\tfloat r = redPtr[offset].evalPoly(lVec);\r \n\t\t\tfloat g = greenPtr[offset].evalPoly(lVec);\r \n            float b = bluePtr[offset].evalPoly(lVec);\r \n\t\t\tfloat temp = (r + g + b)/3;\r \n            float lum =  temp * ks * 2 * nDotH;\r \n\t\t\tbuffer[offsetBuf + 0] = tobyte( r * kd + lum);\r \n\t\t\tbuffer[offsetBuf + 1] = tobyte( g * kd + lum );\r \n\t\t\tbuffer[offsetBuf + 2] = tobyte( b * kd + lum );\r \n\t\t\tbuffer[offsetBuf + 3] = 255;\r \n\t\t\toffsetBuf += 4;\r \n\t\t\toffset++;\r \n\t\t}\r \n\t}", "pragma": "parallel for ", "hash": "936526651a8f55b45dc815e1c900e423b67d8903f7db31cbedcf22382f0610cb"}
{"code": "for (p = 0; p < nbatch; p++) \n    { \n      THNN_(SpatialMaxUnpooling_updateGradInput_frame)(gradInput_data+p*nslices*iwidth*iheight, gradOutput_data+p*nslices*owidth*oheight, \n                                                   indices_data+p*nslices*iwidth*iheight, \n                                                   nslices, \n                                                   iwidth, iheight, \n                                                   owidth, oheight); \n    }", "pragma": "parallel for private(p)", "hash": "7eef8f2a06bd9a2ccd71fff081a2946ab98611ce2f2047797438fe4ed4252b8e"}
{"code": "for (dim_t i = 0; i < src_seq_length_max; i++) \n        for (dim_t j = 0; j < batch; j++) \n            alignments[i * batch + j] /= exp_sums[j];", "pragma": "parallel for ", "hash": "f9d56516a1079150a71a0e6a0c542650730b83d7b65ab713c3a0a992cedde258"}
{"code": "for (k = 0; k < vol->nz; k++) { \n\tvol->data[i][j][k] = (ndat[i][j][k] - dmin) / (dmax - dmin); \n      }", "pragma": "parallel for private(k)", "hash": "e6010d28a87abca8b83aa1ad9400cd52b7221c478a90f19b661cb5dd4bb0a575"}
{"code": "for(int i = 0;i<np;i++) \n  { \n    MatL Pi = P.row(i); \n     \n \n    MatL SmPi = S-Pi; \n    t(i) = -(DmS.array()*SmPi.array()).sum() / v_sqrlen; \n     \n \n    MatL projP = (1-t(i))*S + t(i)*D; \n    sqrD(i) = (Pi-projP).squaredNorm(); \n  }", "pragma": "parallel for ", "hash": "fd498dfc77e8470dd29687622fee0b16a29ac8bcfe1254dc237c5833ebe90a62"}
{"code": "for (int i = 0; i < image->count; i++) \n  { \n    if (img_data[i]) \n    { \n      int index = img_data[i] - 1; \n#pragma omp atomic \n      data_area[index]++; \n    } \n  }", "pragma": "parallel for ", "hash": "af7604d5a3c55bd8a03021974e4b5ef104bf556a298a250a9411c055f1226cd6"}
{"code": "for (i1=0; i1 < nk; i1++) { \n    ith = omp_get_thread_num(); \n    kiss_fft_stride(icfg2[ith],(kiss_fft_cpx *) (inp+i1),ctrace2[ith],nk); \n    for (i2=0; i2<n2; i2++) { \n      tmp[i2][i1] = ctrace2[ith][i2]; \n    } \n  }", "pragma": "parallel for private(i1 i2 ith)", "hash": "800ca63e33d41a9442fb58a8819958fa8334f6812ba9f0dcaf8fe38755495d86"}
{"code": "for(size_t i=0; i<lines.size(); i++) \n\t{ \n\t\tint dx = lines[i][0] - lines[i][2]; \n\t\tint dy = lines[i][1] - lines[i][3]; \n\t\tdouble angle = atan2(dy, dx) * 180/CV_PI; \n \n\t\t \n \n\t\tif(fabs(angle) > 75 && fabs(angle) < 105) \n\t\t{ \n\t\t\tline( img, Point(lines[i][0], lines[i][1]), \n        \tPoint(lines[i][2], lines[i][3]), Scalar(0,0,255), 3, 8 ); \n \n        \t \n \n\t\t} \n\t\t \n\t}", "pragma": "parallel for ", "hash": "222aa3cb0b8673ecd1592c68d85a19be32ccc11364051b3ce4925a777d8a72e4"}
{"code": "for (int i=0;i<nchan;i++) { \n    float myamp=0; \n    for (int j=0;j<ndata;j++)  \n      myamp+=dat[i][j]*tot[j]; \n    myamp/=totsqr; \n    amps[i]=myamp; \n    for (int j=0;j<ndata;j++) \n      dat[i][j]-=tot[j]*myamp; \n  }", "pragma": "parallel for ", "hash": "e5ca01f25a2bd30b0a6cd8adb342dfc7d6e46b4e31f953d40ef7f08f621f4193"}
{"code": "for (fuint u = 0; u < N; u++) { \n      for (int v : G[u]) { \n        for (auto d : M[i - 1][v]) { \n          if (getBit(d.first, color[u])) continue; \n          M[i][u][setBit(d.first, color[u])] += d.second; \n        } \n      } \n    }", "pragma": "parallel for ", "hash": "7f899f9acfb29d90198e437d10fd0bc8967070037c5644f83b93795b21904e66"}
{"code": "for(y = 0; y < height; y++) \n\t\t\tfor (k = 0; k < 3 * width; k += 3) \n\t\t\t{ \n\t\t\t\tgray_filter((pFrame->data[0] + y*pFrame->linesize[0] + k)); \n\t\t\t}", "pragma": "for ", "hash": "d92d8598e1e741129279e78839e6ac1213a1bfc0836ee889281a91076368deb9"}
{"code": "for(int i = 0; i < reads->size(); i++) { \n        \tp_dSplatResults.clear(); \n \n   #pragma omp critical \n        \t{ \n        \tl_sShortRead = l_hiReadsIterator->first; \n        \tl_vReadHeads = l_hiReadsIterator->second.ReadHeadersVector; \n        \tl_hiReadsIterator++; \n        \t} \n \n        \tl_dCurrentReference->splatRead(&l_sShortRead, p_dSplatResults, *m_iMinIntronSize, *m_iMaxIntronSize); \n \n\t\t\tl_sReverseComplement = __utility::findReverseComplement(&l_sShortRead); \n\t\t\tl_dCurrentReference->splatRead(&l_sReverseComplement, p_dSplatResults, *m_iMinIntronSize, *m_iMaxIntronSize); \n \n   #pragma omp critical \n\t\t\t{ \n\t\t\t\tl_iTotalReadsProcessed++; \n\t\t\t\tl_iTotalReadsPercent++; \n\t\t\t\tif(l_iTotalReadsPercent == l_iTenPercentOfTotalReads) { \n\t\t\t\t\tint l_iTotalPercentProcessed = l_iTotalReadsProcessed / l_iTenPercentOfTotalReads * 10; \n\t\t\t\t\tstd::string l_sTotalPercentProcessed, l_sTotalReadsProcessed; \n\t\t\t\t\tss << l_iTotalPercentProcessed; l_sTotalPercentProcessed = ss.str(); ss.str(\"\"); \n\t\t\t\t\tss << l_iTotalReadsProcessed; l_sTotalReadsProcessed = ss.str(); ss.str(\"\"); \n\t\t\t\t\tl_sStatus = \"\\t\" + l_sTotalPercentProcessed + \"% of reads = \" + l_sTotalReadsProcessed + \" reads processed ...\\n\"; \n\t\t\t\t\t__utility::outputStatus(l_sStatus); \n\t\t\t\t\tl_iTotalReadsPercent = 0; \n\t\t\t\t} \n \n\t\t\t\tScheduler::printData(p_dSplatResults, l_vReadHeads); \n\t\t\t} \n        }", "pragma": "for ", "hash": "5eae087545e802897b2970f90f95ea4393e2725939eb0bf5d30268faebab6e58"}
{"code": "for( OMPInt i=0; i < rEl; ++i) \n        (*res)[i] = ((*right)[i] == s);", "pragma": "for ", "hash": "f8265652c06761805be38cf0369ebb177c050286d30a71da31e61c1ced22960b"}
{"code": "for( size_t node_idx = 0; node_idx < data.tree.node_count(); ++node_idx ) { \n        auto const& node = data.tree.node_at( node_idx ); \n        assert( node.index() == node_idx ); \n \n         \n \n        auto const deg = degree( node ); \n        if( deg == 1 ) { \n            continue; \n        } \n \n         \n \n         \n \n         \n \n        std::unordered_set<size_t> lhs_indices; \n        std::unordered_set<size_t> rhs_indices; \n        if( deg == 2 ) { \n            assert( is_root( node )); \n \n             \n \n             \n \n            lhs_indices = get_subtree_indices_( Subtree{ node.link().outer() }); \n            rhs_indices = get_subtree_indices_( Subtree{ node.link().next().outer() }); \n \n             \n \n            assert( lhs_indices.size() + rhs_indices.size() == data.tree.edge_count() ); \n        } else { \n            assert( deg == 3 ); \n \n             \n \n            lhs_indices = get_subtree_indices_( Subtree{ node.link().next().outer() }); \n            rhs_indices = get_subtree_indices_( Subtree{ node.link().next().next().outer() }); \n \n             \n \n            assert( lhs_indices.size() + rhs_indices.size() < data.tree.edge_count() ); \n        } \n \n         \n \n        if( reverse_signs ) { \n            std::swap( lhs_indices, rhs_indices ); \n        } \n \n         \n \n        result.col( node_idx ) = mass_balance( data, lhs_indices, rhs_indices ); \n    }", "pragma": "parallel for ", "hash": "1deb8ff59ed05c0e5a378504b2359be626059c70622afd8b7d7e298196c7244a"}
{"code": "for(int iit=0; iit<objects.size(); iit++) { \n\t  objects[iit]->intProperty[ckey]=(*f)(); \n\t}", "pragma": "parallel for ", "hash": "9c0a5c45e429205d8bb3a2111fb8f44785b4a7523a9a2a533cfd09af68c69cd4"}
{"code": "for(int i = 1; i < coarseSize+1; i++) { \n    int m = i << 1; \n    for(int j = 1; j < coarseSize+1; j++) { \n      int n = j << 1; \n      fine[m][n] = coarse[i][j]; \n    } \n  }", "pragma": "for ", "hash": "ece38a691163fb1c683092f17e57487b496f0e6bd5309262e605100e2440bee5"}
{"code": "for(index=0;index<targetVoxelNumber; index++){ \n \n            intensity=0.0; \n \n            if((maskPtr[index])>-1){ \n \n                world[0]=(FieldTYPE) deformationFieldPtrX[index]; \n                world[1]=(FieldTYPE) deformationFieldPtrY[index]; \n                 \n \n                position[0] = world[0]*sourceIJKMatrix.m[0][0] + world[1]*sourceIJKMatrix.m[0][1] + \n                        sourceIJKMatrix.m[0][3]; \n                position[1] = world[0]*sourceIJKMatrix.m[1][0] + world[1]*sourceIJKMatrix.m[1][1] + \n                        sourceIJKMatrix.m[1][3]; \n \n                previous[0] = (int)floor(position[0]); \n                previous[1] = (int)floor(position[1]); \n \n                 \n \n                relative=position[0]-(FieldTYPE)previous[0]; \n                interpolantCubicSpline<FieldTYPE>(relative, xBasis); \n                 \n \n                relative=position[1]-(FieldTYPE)previous[1]; \n                interpolantCubicSpline<FieldTYPE>(relative, yBasis); \n \n                previous[0]--;previous[1]--; \n \n                for(b=0; b<4; b++){ \n                    Y= previous[1]+b; \n                    yPointer = &sourceIntensity[Y*sourceImage->nx]; \n                    if(-1<Y && Y<sourceImage->ny){ \n                        xyPointer = &yPointer[previous[0]]; \n                        xTempNewValue=0.0; \n                        for(a=0; a<4; a++){ \n                            if(-1<(previous[0]+a) && (previous[0]+a)<sourceImage->nx){ \n                                xTempNewValue +=  (FieldTYPE)*xyPointer * xBasis[a]; \n                            } \n                            xyPointer++; \n                        } \n                        intensity += (xTempNewValue * yBasis[b]); \n                    } \n                } \n            } \n \n            switch(sourceImage->datatype){ \n            case NIFTI_TYPE_FLOAT32: \n                resultIntensity[index]=(SourceTYPE)intensity; \n                break; \n            case NIFTI_TYPE_FLOAT64: \n                resultIntensity[index]=(SourceTYPE)intensity; \n                break; \n            case NIFTI_TYPE_UINT8: \n                resultIntensity[index]=(SourceTYPE)(intensity>0?round(intensity):0); \n                break; \n            case NIFTI_TYPE_UINT16: \n                resultIntensity[index]=(SourceTYPE)(intensity>0?round(intensity):0); \n                break; \n            case NIFTI_TYPE_UINT32: \n                resultIntensity[index]=(SourceTYPE)(intensity>0?round(intensity):0); \n                break; \n            default: \n                resultIntensity[index]=(SourceTYPE)round(intensity); \n                break; \n            } \n        }", "pragma": "parallel for private(                  a b index intensity position previous relative world xbasis xtempnewvalue xypointer y ybasis ypointer)", "hash": "1f1a86157b3a46938f72bf83cc5502c9ccfa862d352fe502ef3c51575f3f7290"}
{"code": "for(loop_index = 0; loop_index < loop_num; loop_index++) { \n \n        bitmask = one << (threshold + 1); \n        start_index = loop_interval * loop_index; \n        p_index = CHAR_NUM * SSE_V_NUM * loop_index * word_num; \n        int bit_index = 0; \n        int char_index = 0; \n \n        for(int i = 0; i < threshold; i++) { \n \n            for(j = 0; j < SSE_V_NUM; j++) { \n                char_value = mapping_table[(int)itr[start_index + (read_seq->len + 1) * j]]; \n                result_reads[p_index + char_value * word_num * SSE_V_NUM + char_index * SSE_V_NUM + j] |= bitmask; \n            } \n \n            bitmask <<= 1; \n            start_index++; \n            bit_index++; \n        }  \n \n        bitmask = one; \n        bit_index = 0; \n        char_index++; \n        for(i = threshold; i < read_seq->len; i++) { \n            if(bit_index == word_size) { \n                bitmask = one; \n                bit_index = 0; \n                char_index++; \n            } \n \n            for(j = 0; j < SSE_V_NUM; j++) { \n                char_value = mapping_table[(int)itr[start_index + (read_seq->len + 1) * j]]; \n                result_reads[p_index + char_value * word_num * SSE_V_NUM + char_index * SSE_V_NUM + j] |= bitmask; \n            } \n \n            bitmask <<= 1; \n            start_index++; \n            bit_index++; \n        } \n    }", "pragma": "parallel for private(      bitmask char_value i j loop_index p_index start_index)", "hash": "65bdc32454b7022654e3cbd86248599e3bec88a8335efd27729d84ca6b9e3f13"}
{"code": "for (int b = 0; b < nBeers; b++) \n  { \n    double tZ; \n    topicZ(b, tZ); \n \n    for (int k = 0; k < K; k++) \n    { \n      double q = -lambda * (beerTopicCounts[b][k] - beerWords[b] * exp(*kappa * gamma_beer[b][k]) / tZ); \n      dgamma_beer[b][k] += *kappa * q; \n      dk += gamma_beer[b][k] * q; \n    } \n  }", "pragma": "parallel for reduction(+:dk) ", "hash": "72bde006c541c6980fc51a2ffff6fba073bdd1ba68428354f40ecdfbb9330a63"}
{"code": "for(size_t y = 0; y < oheight; y++) \n        { \n          const size_t a_start = ((y + yoffs) * iwidth + xoffs) * DT_BLENDIF_RGB_CH; \n          const size_t b_start = y * owidth * DT_BLENDIF_RGB_CH; \n          const size_t m_start = y * owidth; \n          blend(tmp_buffer + b_start, a + a_start, p, b + b_start, mask + m_start, owidth); \n        }", "pragma": "parallel for ", "hash": "ebfb7f41e7fa81df48d13cbef057497cf04b8e0c9e7bba0ea46a0ec566e32a4a"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp target parallel for \n    for (int i = 0; i < 10; ++i) \n      ; \n  }", "pragma": "for ", "hash": "3f465006f84414c9085ddc381e511b2b336f3942fd50011552b520b7569723dc"}
{"code": "for (int i=0; i<semidense_mapper-> initial_inv_depth_sd.rows; i++) \n    { \n \n        if (semidense_mapper-> initial_inv_depth_inEveryCamera_largeParallax[i].rows >= minim_images ) \n        { \n \n             \n \n \n \n            semidense_mapper-> initial_inv_depth_sd.at<float>(i,0) = semidense_mapper-> initial_inv_depth_inEveryCamera_largeParallax[i].at<float>(semidense_mapper-> initial_inv_depth_inEveryCamera_largeParallax[i].rows-1,0); \n \n \n            cv::Mat sorted_inv_depths; \n            cv::sort(semidense_mapper-> initial_inv_depth_inEveryCamera_largeParallax[i],sorted_inv_depths,CV_SORT_EVERY_COLUMN + CV_SORT_ASCENDING); \n \n            cv::Mat sorted_index ; \n            cv::sortIdx(semidense_mapper-> initial_inv_depth_inEveryCamera_largeParallax[i],sorted_index,CV_SORT_EVERY_COLUMN +CV_SORT_ASCENDING); \n \n            cv::Mat sorted_variances = semidense_mapper -> initial_inv_depth_inEveryCamera_uncertainty[i].clone(); \n \n            for (int l = 0; l < sorted_variances.rows; l++) \n            { \n                sorted_variances.at<float>(l,0) = semidense_mapper ->  initial_inv_depth_inEveryCamera_uncertainty[i].at<float>(sorted_index.at<int>(l,0),0); \n            } \n \n \n            deviation_inv_depth.at<float>(i,0) = (semidense_mapper->X_gy_ey.ph_error[0].at<float>(i,0)  +                     semidense_mapper->X_gx_ex.ph_error[0].at<float>(i,0)); \n \n            int outliers_to_eliminate = round(0.1*sorted_inv_depths.rows); \n            sorted_inv_depths= sorted_inv_depths.rowRange(outliers_to_eliminate,sorted_inv_depths.rows-outliers_to_eliminate); \n \n            semidense_mapper-> initial_inv_depth_sd.at<float>(i,0) = sorted_inv_depths.at<float>(sorted_inv_depths.rows/2,0); \n \n            final_variances.at<float>(i,0) = cv::mean(sorted_variances.rowRange(outliers_to_eliminate,sorted_variances.rows-outliers_to_eliminate) )[0]; \n \n \n            be_outlier.at<float>(i,0) = 1; \n            be_outlier_print.at<float>(i,0) = 1; \n \n \n            if ( fabs(sorted_inv_depths.at<float>(0,0) - sorted_inv_depths.at<float>(sorted_inv_depths.rows-1,0))  / final_variances.at<float>(i,0) < inv_depth_disparity_th) \n            { \n                be_outlier.at<float>(i,0) = 0; \n \n                if ( fabs(sorted_inv_depths.at<float>(0,0) - sorted_inv_depths.at<float>(sorted_inv_depths.rows-1,0))  / final_variances.at<float>(i,0) < inv_depth_disparity_print_th ) \n                { \n                    be_outlier_print.at<float>(i,0) = 0; \n                } \n            } \n        } \n        else \n        { \n            if (semidense_mapper-> initial_inv_depth_inEveryCamera_largeParallax[i].rows > 1 ) \n            { \n                cv::Mat sorted_inv_depths; \n                cv::sort(semidense_mapper-> initial_inv_depth_inEveryCamera_largeParallax[i],sorted_inv_depths,CV_SORT_EVERY_COLUMN + CV_SORT_ASCENDING); \n                semidense_mapper-> initial_inv_depth_sd.at<float>(i,0) = sorted_inv_depths.at<float>(round(sorted_inv_depths.rows/2),0); \n            } \n \n            be_outlier.at<float>(i,0) = 1; \n            be_outlier_print.at<float>(i,0) = 1; \n        } \n        if (be_outlier_print.at<float>(i,0) == 0) \n            counter_converged_points++; \n    }", "pragma": "parallel for ", "hash": "7b79cdd91b96ffbb4619d56b6b742ca23f475f618d4da9ae441233035761d745"}
{"code": "for (size_t i = 0; i < s->n; i++) { \n            mpz_random_(slots[i], s->rngs[i], s->rho); \n            mpz_mul(slots[i], slots[i], s->gs[i]); \n            if (i < n) \n                mpz_add(slots[i], slots[i], xs[i]); \n             \n \n        }", "pragma": "parallel for ", "hash": "c3f0dcdcd3d3e23ced28667ee349fba1d959981ae5541bae72651dede74aa67c"}
{"code": "for(int c = 1; c < n_subs_classes; ++c) \n\t\t\t\t{ \n\t\t\t\t\tdouble min_val, max_val; \n\t\t\t\t\tPoint min_point, max_point; \n\t\t\t\t\tRect window_rect; \n\t\t\t\t\tMat colour_channels[3]; \n \n\t\t\t\t\t \n \n\t\t\t\t\tminMaxLoc(subs_post[c-1],&min_val,&max_val,&min_point,&max_point); \n\t\t\t\t\twindow_rect = Rect(max_point,mean_shift_size); \n\t\t\t\t\tmeanShift(subs_post[c-1],window_rect,mean_shift_term_crit); \n\t\t\t\t\tconst int max_subs_x_resize = (window_rect.x+window_rect.width/2.0); \n\t\t\t\t\tconst int max_subs_y_resize = (window_rect.y+window_rect.height/2.0); \n\t\t\t\t\tsubs_locations[c-1] = Point(max_subs_x_resize/scale_factor,max_subs_y_resize/scale_factor); \n \n\t\t\t\t\t \n \n\t\t\t\t\tif(display_mode == C_DISPLAY_MODE_ALL || display_mode == C_DISPLAY_MODE_NO_IMPOSE) \n\t\t\t\t\t{ \n\t\t\t\t\t\tcolour_channels[0] = Mat::zeros(subs_post[c-1].rows,subs_post[c-1].cols,CV_8U); \n\t\t\t\t\t\tcolour_channels[1] = Mat::zeros(subs_post[c-1].rows,subs_post[c-1].cols,CV_8U); \n\t\t\t\t\t\tcolour_channels[2] = 255*subs_post[c-1]; \n\t\t\t\t\t\tcolour_channels[2].convertTo(colour_channels[2],CV_8U); \n\t\t\t\t\t\tmerge(colour_channels,3,post_superimposed[c-1]); \n\t\t\t\t\t\tresize(post_superimposed[c-1],post_superimposed[c-1],Size(xsize,ysize)); \n\t\t\t\t\t\tif(display_mode == C_DISPLAY_MODE_ALL) \n\t\t\t\t\t\t\tpost_superimposed[c-1] = post_superimposed[c-1] + disp; \n\t\t\t\t\t} \n\t\t\t\t}", "pragma": "parallel for ", "hash": "70c85fb806fd32cc9e420b364e7a22b0feee42f22ad9e697243f7951c6c3d9d9"}
{"code": "for (int i = 0; i < n_total_coef; ++i) \n    { \n        x(i) = penalty_weight*x_update_tmp(i)/(2.0*D(i)*D(i) + penalty_weight); \n \n        if (nonnegative_constraint()) \n        { \n            x(i) = std::max(x(i), 0.0); \n            x(i) = std::min(x(i), 1.0); \n        } \n    }", "pragma": "for ", "hash": "9cf3d1809db2d39a3384900ec639704c2f96b3e3a18e3e5c86b72e0bff55c538"}
{"code": "for (int i = 0; i < n; i++) \n  { \n    data_in[i]  = i; \n    data_out[i] = data_in[i]; \n  }", "pragma": "parallel for ", "hash": "f2de757a682ff80f5a53da7a590c3ee7fff29f7fc443b07be9555f9fee1d3b4a"}
{"code": "for (is = 1; is < ndr/2; is++) { \n        cc1 = s1[is][0] * s2[is][0] + s1[is][1] * s2[is][1] + s1[is][2] * s2[is][2]; \n        cc2 = s2[is][0] * s3[is][0] + s2[is][1] * s3[is][1] + s2[is][2] * s3[is][2]; \n        cc3 = s3[is][0] * s1[is][0] + s3[is][1] * s1[is][1] + s3[is][2] * s1[is][2]; \n        cc  = 1.0 + cc1 + cc2 + cc3; \n        ss1 = s2[is][1] * s3[is][2] - s2[is][2] * s3[is][1]; \n        ss2 = s2[is][2] * s3[is][0] - s2[is][0] * s3[is][2]; \n        ss3 = s2[is][0] * s3[is][1] - s2[is][1] * s3[is][0]; \n        ss  = s1[is][0] * ss1 + s1[is][1] * ss2 + s1[is][2] * ss3; \n        siga += atan2(ss,cc); \n      }", "pragma": "parallel for reduction(+:siga) private(cc cc1 cc2 cc3 ss ss1 ss2 ss3)", "hash": "ea09d75e5224d69f72e60655ca9323824b974fcd19d393d9be7b57fc317c22d7"}
{"code": "for (i = 1; i < grid_points[0]-1; i++) { \n    for (k = 1; k < grid_points[2]-1; k++) { \n      for (m = 0; m < 5; m++) { \n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp *  \n\t  (-4.0*u[i][j-1][k][m] + 6.0*u[i][j][k][m] - \n\t   4.0*u[i][j+1][k][m] + u[i][j+2][k][m]); \n      } \n    } \n  }", "pragma": "for private(k m)", "hash": "f7fe2dfe61c3a1707bb744c55567cf8e5495c56aad57c6237b4b0a5d6db21785"}
{"code": "for (int ii = 0; ii < nx*ny; ii++)\r \n\t\t{\r \n\t\t\ttempLight[ii] /= static_cast<float>(nKernel[ii]);\r \n\t\t\ttempLight[ii].Normalize();\r \n\t\t}", "pragma": "parallel ", "hash": "f47be5191abb8a1e8644decc2407d0fc4cff67d28b1f4ef38a81929d9ccffee3"}
{"code": "for (MKL_INT i = 0; i < row; i++) { \n        const MKL_INT startRow = ia[i]; \n        const MKL_INT endRow = ia[i + 1]; \n        MKL_INT sorted = 0; \n        MKL_INT elem; \n        while (!sorted) { \n            sorted = 1; \n            for (elem = startRow; elem < endRow - 1; elem++) { \n                 \n \n                const MKL_INT col1 = ja[elem]; \n                const MKL_INT col2 = ja[elem + 1]; \n                 \n \n                 \n \n                if (col1 > col2) { \n                     \n \n                    sorted = 0;  \n \n                    ja[elem] = col2; \n                    ja[elem + 1] = col1; \n                } else if (col1 == col2) { \n                    sorted = 0; \n                    ja[elem + 1] = (col1 != row - 1) ? col1 + 1 : 0; \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "91a24458c8200cb499707ff655fd9237d2a89f4bb283e08f8e1106cb9f3033a7"}
{"code": "for (i = 0; i < h; i++)  \n\tm_data.buffer [i].Create (parentObjP, objP, 3.0f);", "pragma": "parallel for ", "hash": "d27bb10602047db89db9ce7137e5f0a362ce452dccc59fd03f5b0d4b51218dbc"}
{"code": "for (i = 0; i < som->dimension*som->dimension; i++) { \n            som->state[i] = 1.0f - ((som->state[i] - min)/(max - min)); \n        }", "pragma": "parallel for ", "hash": "80bcf2d1bdccb1591a15b0eef224d0a809d25078961f9320c795f46ad3505e45"}
{"code": "for (j = 0; j < size; j++) \n\t\t\t\t\tsum += buffer[j];", "pragma": "for ", "hash": "636ac8d5129c52240793d7f4005f8f0491d1eda57afe1bc28433136f1377bc7b"}
{"code": "for(int k = 0; k < mNumComponents; ++k) \n\t\tlogPartf[k] = mCholeskyFactors[k].diagonal().array().abs().log().sum() \n\t\t\t- mDimOut / 2. * log(2. * PI);", "pragma": "parallel for ", "hash": "c241b2e8ceaa9394a57f66c1c9859f3dd34e3d874fdf67452c127afd6d7a1531"}
{"code": "for (int i = 0; i < SIZE; ++i) \n        in[i] = reindex[in[i]];", "pragma": "parallel for ", "hash": "4c60f2d9ad6b98fb984e347c93bb6d58d74b3de3e76506dd680469711a39b67f"}
{"code": "for(br=0;br<bm;br++){ \n        int p,v,vmin; \n        vmin=32767; \n        for(p=0;p<np;p++){ \n          v=vold[pre[p][0]+mul0*br]+pre[p][1]; \n          if(v<vmin)vmin=v; \n          if(pre[p][2]){ \n            if(c>0)vnew[pre[p][3]+mul1*br]=vmin; else v0[pre[p][3]+mul1*br]+=vmin; \n            vmin=32767; \n          } \n        } \n      }", "pragma": "parallel for ", "hash": "ac5ff1673923d486fc8874ff256db0e8a645fcef1df26a74c94a96d3463bdad9"}
{"code": "for (size_t i = 0; i < dataset.set_size; i++) \n    l += log_likelihood_from_scale(compute_forward_scale(dataset.sequences[i]));", "pragma": "parallel for reduction(+ : l) ", "hash": "cb30d348a6b40234c05cff1d4372d0cfb3e40df9f486dd5a4aa6eaf46361bb67"}
{"code": "for(unsigned long n=0; n<ncells; n++)\t\t\t\t\t\t \n \n\t\t{ \n\t\t \n\t\t \n\t\t \n\t\t \n \n\t\tdouble vmax2 = type[n]->Get_VMAX_2(); \n\t\tdouble vmax22 = type[n]->Get_VMAX_22(); \n\t\tdouble vmaxP = type[n]->Get_VMAX_P(); \n\t\tdouble vmaxP_A = type[n]->Get_VMAX_P_A(); \n\t\tdouble vmaxP_ATP = type[n]->Get_VMAX_P_ATP(); \n\t\tdouble vmaxDNA = type[n]->Get_VMAX_DNA(); \n\t\tdouble v_WORK = type[n]->Get_v_WORK(); \n\t\tdouble C1 = type[n]->Get_C1();\t\t \n\t\tdouble C2 = type[n]->Get_C2();\t\t \n\t\tdouble Vmin = type[n]->Get_Vmin();\t\t \n\t\tdouble vmaxDNA_A = type[n]->Get_VMAX_DNA_A(); \n\t\tdouble vmaxDNA_ATP = type[n]->Get_VMAX_DNA_ATP(); \n\t\tdouble vmaxM = type[n]->Get_VMAX_M(); \n\t\tdouble vmaxM_A = type[n]->Get_VMAX_M_A(); \n\t\tdouble vmaxM_ATP = type[n]->Get_VMAX_M_ATP(); \n\t\tdouble Km1 = type[n]->Get_Km1(); \n\t\tdouble Km2 = type[n]->Get_Km2(); \n\t\tdouble Km22 = type[n]->Get_Km22(); \n\t\tdouble Kmc = type[n]->Get_Kmc(); \n\t\tdouble Kmd = type[n]->Get_Kmd(); \n\t\tdouble Ka = type[n]->Get_Ka(); \n\t\tdouble KmA = type[n]->Get_KmA(); \n\t\tdouble KmAL = type[n]->Get_KmAL(); \n\t\tdouble Kmp = type[n]->Get_Kmp(); \n\t\tdouble KmDNA = type[n]->Get_KmDNA(); \n\t\tdouble KmM = type[n]->Get_KmM(); \n\t\tdouble ATPSt = type[n]->Get_ATPSt(); \n \n\t\tdouble coeffg1 = type[n]->Get_coeffg1(); \n\t\tdouble coeffg2 = type[n]->Get_coeffg2(); \n\t\tdouble coeffg3 = type[n]->Get_coeffg3(); \n\t\tdouble coeffr1 = type[n]->Get_coeffr1(); \n\t\t \n\t\t \n\t\t \n \n\t\tdouble tpH = 0.5 * ( 1. + tanh( type[n]->Get_tph_slope()*(pHiOld[n] - type[n]->Get_tph_thr()) ) ); \n\t\tdouble tp11 = 0.5 * ( 1. + tanh( type[n]->Get_tp11_slope()*(pHiOld[n] - type[n]->Get_tp11_thr()) ) ); \n\t\tdouble a2c = 0.5 * ( 1. + tanh( type[n]->Get_a2c_slope()*(pHOld[n] - type[n]->Get_a2c_thr()) ) ); \n\t\tdouble c2a = 0.5 * ( 1. + tanh( type[n]->Get_c2a_slope()*(pHiOld[n] - type[n]->Get_c2a_thr()) ) ); \n\t\tdouble a2cA = 0.5 * ( 1. + tanh( type[n]->Get_a2cA_slope()*(pHOld[n] - type[n]->Get_a2cA_thr()) ) ); \n\t\tdouble c2aA = 0.5 * ( 1. + tanh( type[n]->Get_c2aA_slope()*(pHiOld[n] - type[n]->Get_c2aA_thr()) ) ); \n\t\tdouble a2cAcL = 2. - tanh( type[n]->Get_a2cAcL_slope()*( pHOld[n]-type[n]->Get_a2cAcL_thr() ) ); \n\t\tdouble c2aAcL = 2. - tanh( type[n]->Get_c2aAcL_slope()*( pHiOld[n]-type[n]->Get_c2aAcL_thr() ) ); \n\t\t \n\t\t \n \n\t\t \n \n\t\tdouble da2cAcL = (1./(volume_extraOld[n]*BufCapEnv))/pow(cosh( type[n]->Get_a2cAcL_slope()*( pHOld[n]-type[n]->Get_a2cAcL_thr() ) ),2); \n\t\t \n\t\t \n\t\tif( phase[n] != dead ) \n\t\t\tpHiNew[n] = pHi_STANDARD;\t \n \n\t\t\t\t\t\t\t\t\t\t \n \n\t\telse \n\t\t\tpHiNew[n] = pHOld[n];\t\t \n \n\t\t \n\t\tpHNew[n] = 7.5443-( mAcLextOld[n]/volume_extraOld[n])/BufCapEnv; \n\t\t \n\t\t \n\t\t \n \n\t\tr[n] = pow(3.*volumeOld[n]/(4.*PI), (double)1./3.); \n\t\tsurface[n] = 4.*PI*r[n]*r[n]; \n \n\t\t \n\t\tif( phase[n] != dead ) \n\t\t\t{ \n\t\t\t \n \n\t\t\tvolumeNew[n] = Vmin * (1+DNANew[n]) + C2*MitOld[n] + C1*ATPpOld[n];\t\t \n\t\t\tvolume_extraNew[n] = surface[n]*type[n]->Get_extvolume_thickness()*type[n]->Get_extvolume_fraction(); \n\t\t\t} \n\t\telse \n\t\t\t{ \n\t\t\t \n \n\t\t\tvolumeNew[n] = volumeOld[n]; \n\t\t\tvolume_extraNew[n] = volume_extraOld[n]; \n\t\t\t} \n\t\t \n\t\tATP_St[n] = ATPSt; \n\t\tdouble dSensO2_O2 = 0.;\t \n \n\t\tdouble SensATP = 0.; \n\t\t \n\t\tif( phase[n] != dead ) \n\t\t\t{ \n\t\t\tSensO2[n] = mO2Old[n]/(volumeOld[n]*type[n]->Get_KmO2() + mO2Old[n]); \n\t\t\tdSensO2_O2 = volumeOld[n]*type[n]->Get_KmO2()/pow(volumeOld[n]*type[n]->Get_KmO2() + mO2Old[n],2); \n\t\t\tATP_Ox[n] = 30.*(PM_ATP/PM_G)*SensO2[n] * ( coeffg2 + coeffg3*StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]) ) * mG6POld[n]; \n\t\t\tSensATP = 0.5*( 1 - tanh( 100.*(ATP_Ox[n]/ATP_St[n]-1.) ) ); \n\t\t\tATP_NOx[n] = 2.*(PM_ATP/PM_G)*tpH*( coeffg1*mG6POld[n] + coeffr1*StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]) ); \n\t\t\tATP2[n] = SensO2[n]*SensATP*(ATP_St[n] - ATP_Ox[n])*StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]) ; \n\t\t\tATP3[n] = (14./5.)*SensO2[n]*SensATP*(ATP_St[n] - ATP_Ox[n]) * mAinOld[n]/(volumeOld[n]*Kmd+mAinOld[n]); \n\t\t\tConsATP[n] = 2.*(PM_ATP/PM_G) * tp11*tpH * coeffr1 * (1.-SensATP) * mAinOld[n]/(volumeOld[n]*Kmd+mAinOld[n]); \n\t\t\t} \n\t\telse \n\t\t\tATP_Ox[n] = ATP_NOx[n] = ATP2[n] = ConsATP[n] = 0.; \n\t\t \n\t\tdouble vp, dvp_A, dvp_ATPp;\t\t\t\t\t \n \n\t\t \n \n\t\tif(phase[n] != G0_phase && phase[n] != dead)\t \n\t\t\t{ \n\t\t\tvp = ATPpOld[n]*mAinOld[n]/(pow(volumeOld[n],2)*Kmp+ATPpOld[n]*mAinOld[n]); \n\t\t\tdvp_A = ATPpOld[n]*pow(volumeOld[n],2)*Kmp/pow(pow(volumeOld[n],2)*Kmp+ATPpOld[n]*mAinOld[n],2); \n\t\t\tdvp_ATPp = pow(volumeOld[n],2)*Kmp*mAinOld[n]/pow(pow(volumeOld[n],2)*Kmp+ATPpOld[n]*mAinOld[n],2); \n\t\t\t} \n\t\telse \n\t\t\tvp= dvp_A = dvp_ATPp = 0.; \n\t\t \n\t\tdouble vDNA, dvDNA_A, dvDNA_ATPp;\t\t\t \n \n\t\tif(phase[n] == S_phase)\t \n \n\t\t\t{ \n\t\t\tvDNA = ATPpOld[n]*mAinOld[n]/(pow(volumeOld[n],2)*KmDNA+ATPpOld[n]*mAinOld[n]); \n\t\t\tdvDNA_A = ATPpOld[n]*pow(volumeOld[n],2)*KmDNA/pow(pow(volumeOld[n],2)*KmDNA+ATPpOld[n]*mAinOld[n],2); \n\t\t\tdvDNA_ATPp = pow(volumeOld[n],2)*KmDNA*mAinOld[n]/pow(pow(volumeOld[n],2)*KmDNA+ATPpOld[n]*mAinOld[n],2); \n\t\t\t} \n\t\telse \n\t\t\tvDNA = dvDNA_A = dvDNA_ATPp = 0.; \n\t\tDNA_rate[n] = vmaxDNA*vDNA; \n\t\t \n\t\t \n \n\t\tdouble vM, dvM_A, dvM_ATPp; \n\t\tif(phase[n] != dead) \n\t\t\t{ \n\t\t\tvM = ATPpOld[n]*mAinOld[n]/(pow(volumeOld[n],2)*KmM+ATPpOld[n]*mAinOld[n]); \n\t\t\tdvM_A = ATPpOld[n]*pow(volumeOld[n],2)*KmM/pow(pow(volumeOld[n],2)*KmM+ATPpOld[n]*mAinOld[n],2); \n\t\t\tdvM_ATPp = pow(volumeOld[n],2)*KmM*mAinOld[n]/pow(pow(volumeOld[n],2)*KmM+ATPpOld[n]*mAinOld[n],2); \n\t\t\t} \n\t\telse \n\t\t\tvM = dvM_A = dvM_ATPp = 0.; \n \n \n         \n \n         \n \n        if( phase[n] != dead ) \n            { \n            h[n] = 0.5*(1.3*(1.-mO2Old[n]/(volumeOld[n]*O2st))+1.)*(1.+tanh(100.*(1-mO2Old[n]/(volumeOld[n]*O2st)))) + 0.5*(1-tanh(100.*(1.-mO2Old[n]/(volumeOld[n]*O2st)))); \n            } \n\t\t \n\t\tdouble v1max = type[n]->Get_VMAX_1()*surface[n]*h[n]; \n\t\tdouble vmaxA = type[n]->Get_VMAX_A()*surface[n]; \n\t\tdouble vmaxAcL = type[n]->Get_VmaxAL0() * surface[n]; \n\t\t \n \n \n \n\t\t \n \n\t\t \n \n\t\t \n \n \n\t\tdouble rhoG_bv = 0.; \n\t\tdouble rhoO2_bv = 0.; \n\t\tdouble rhoA_bv = 0.; \n\t\tdouble rhoAcL_bv = 0.; \n \n\t\tif(isonBV[n]) \n\t\t\t{ \n\t\t\tBloodVessel BV = BloodVesselVector[isonBV[n]-1];\t \n \n\t\t \n\t\t\trhoG_bv = BV.GetBloodVesselG();\t\t\t \n \n\t\t\trhoO2_bv = 0.5*(BV.GetBloodVesselO2start()+BV.GetBloodVesselO2end());\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\t \n \n\t\t\trhoA_bv = BV.GetBloodVesselA();\t\t\t \n \n\t\t\trhoAcL_bv = BV.GetBloodVesselAcL();\t\t \n \n\t\t\t \n\t\t\t \n \n \n\t\t\t} \n \n \n \n\t\t \n\t\t \n\t\t \n \n\t\tdouble s0 = 0.; \n\t\tdouble sG = 0.; \n\t\tdouble sO2 = 0.; \n\t\tdouble sA = 0.; \n\t\tdouble sAcL = 0.; \n\t\t \n\t\t \n \n\t\tfor(int nv=0; nv<neigh[n]; nv++)\t\t \n\t\t\t{ \n\t\t\tint name = vneigh[n][nv]; \n\t\t\ts0 += gnk[n][nv]; \n\t\t\tsG += gnk[n][nv]*mGextOld[name]/volume_extraOld[name];\t\t\t \n\t\t\tsO2 += gnk[n][nv]*mO2Old[name]/volumeOld[name];\t\t\t \n\t\t\tsA += gnk[n][nv]*mAextOld[name]/volume_extraOld[name];\t\t \n\t\t\tsAcL += gnk[n][nv]*mAcLextOld[name]/volume_extraOld[name];\t\t\t \n\t\t\t} \n\t\t \n \n \n\t\t \n \n \n\t\tdouble M_Gnow, DM_Gnow, T_Gnow, DT_Gnow_in, DT_Gnow_ext;\t \n \n\t\tdouble M_Gnow_0, T_Gnow_0in, T_Gnow_0ext;\t\t\t\t\t \n \n\t \n         \n \n        M_Gnow = ((int)(phase[n] != dead))*                  ( -vmax2*mGinOld[n]*mGinOld[n]/((volumeOld[n]*Km2+mGinOld[n])*(volumeOld[n]*Ka+mGinOld[n]))                  - vmax22*mGinOld[n]*mGinOld[n]/((volumeOld[n]*Km22+mGinOld[n])*(volumeOld[n]*Ka+mGinOld[n])) ); \n         \n \n        DM_Gnow = ((int)(phase[n] != dead))*                   ( -2*vmax2*mGinOld[n]/((volumeOld[n]*Km2+mGinOld[n])*(volumeOld[n]*Ka+mGinOld[n]))                  + vmax2*mGinOld[n]*mGinOld[n]/(pow(volumeOld[n]*Km2+mGinOld[n],2)*(volumeOld[n]*Ka+mGinOld[n]))                  + vmax2*mGinOld[n]*mGinOld[n]/((volumeOld[n]*Km2+mGinOld[n])*pow(volumeOld[n]*Ka+mGinOld[n],2))                  - 2*vmax22*mGinOld[n]/((volumeOld[n]*Km22+mGinOld[n])*(volumeOld[n]*Ka+mGinOld[n]))                  + vmax22*mGinOld[n]*mGinOld[n]/(pow(volumeOld[n]*Km22+mGinOld[n],2)*(volumeOld[n]*Ka+mGinOld[n]))                  + vmax22*mGinOld[n]*mGinOld[n]/((volumeOld[n]*Km22+mGinOld[n])*pow(volumeOld[n]*Ka+mGinOld[n],2)) ); \n         \n        M_Gnow_0 = 0.;\t \n \n                 \n         \n \n        T_Gnow = a2c*v1max*mGextOld[n]/(volume_extraOld[n]*Km1+mGextOld[n]) - c2a*v1max*mGinOld[n]/(volumeOld[n]*Km1+mGinOld[n]); \n         \n \n        DT_Gnow_in = -c2a*v1max*volumeOld[n]*Km1/pow(volumeOld[n]*Km1+mGinOld[n],2); \n         \n \n        DT_Gnow_ext = a2c*v1max*volume_extraOld[n]*Km1/pow(volume_extraOld[n]*Km1+mGextOld[n],2); \n         \n         \n \n        T_Gnow_0in = a2c*v1max*mGextOld[n]/(volume_extraOld[n]*Km1+mGextOld[n]);\t \n \n        T_Gnow_0ext = - c2a*v1max*mGinOld[n]/(volumeOld[n]*Km1+mGinOld[n]);\t\t\t \n \n\t\t\t \n                    \t\t \n\t\t \n \n        mGinNew[n] = mGinOld[n] - ( mGinOld[n] - ( G[n] + dt*( M_Gnow + T_Gnow ) ) )/( 1. - dt*( DM_Gnow + DT_Gnow_in ) ); \n \n\t\tif( mGinNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\tdouble fhi = mGinOld[n] - ( G[n] + dt*( M_Gnow + T_Gnow ) );\t \n \n\t\t\tdouble flo = - ( G[n] + dt*( M_Gnow_0 + T_Gnow_0in ) );\t\t \n \n\t\t\tdouble xsol = mGinOld[n]*flo/(flo-fhi); \n\t\t\tmGinNew[n] = xsol; \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\terrorlog_file << scientific << \"mGinOld[\"<< n << \"] = \" << mGinOld[n] << \"; mGinNew[\"<< n << \"] = \" << mGinNew[n] << \"\\n\" <<endl; \n\t\t\t} \n\t\tif( mGinNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" mGinNew[\"<< n << \"] = \" << scientific << mGinNew[n] << \" < 0\" << endl; \n\t\t\terrorlog_file << \"in questa iterazione si mantiene mGinNew[n] = mGinOld[n] = \" << mGinOld[n] << \"\\n\" << endl; \n\t\t\tmGinNew[n] = mGinOld[n];\t \n \n\t\t\t} \n \n \n \n\t\t \n \n\t\tdouble cG = G_extra[n] + dt*Diff_ES_G*sG + dt*Diff_Env_G*(mG_envOld/volume_envOld)*g_env[n] + dt*Diff_BV_G*rhoG_bv*g_bv[n];\t \n \n\t\t \n\t\tmGextNew[n] = mGextOld[n] - ( mGextOld[n]*(1+Diff_ES_G*dt*s0/volume_extraOld[n]+Diff_Env_G*dt*g_env[n]/volume_extraOld[n]+Diff_BV_G*dt*g_bv[n]/volume_extraOld[n]) + dt*T_Gnow - cG ) \t\t\t\t/( 1. + Diff_ES_G*dt*s0/volume_extraOld[n] + Diff_Env_G*dt*g_env[n]/volume_extraOld[n] + Diff_BV_G*dt*g_bv[n]/volume_extraOld[n] + dt*DT_Gnow_ext ); \n\t\tif(mGextNew[n] < 0)\t \n \n\t\t\t{ \n\t\t\tdouble fhi = ( mGextOld[n]*(1+Diff_ES_G*dt*s0/volume_extraOld[n]+Diff_Env_G*dt*g_env[n]/volume_extraOld[n]+Diff_BV_G*dt*g_bv[n]/volume_extraOld[n]) + dt*T_Gnow - cG ); \n\t\t\tdouble flo = ( dt*T_Gnow_0ext - cG ); \n\t\t\tdouble xsol = mGextOld[n]*flo/(flo-fhi); \n\t\t\tmGextNew[n] = xsol; \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\terrorlog_file << scientific << \"mGextOld[\"<< n << \"] = \" << mGextOld[n] << \"; mGextNew[\"<< n << \"] = \" << mGextNew[n] << \"\\n\" <<endl; \n\t\t\t} \n\t\tif( mGextNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" mGextNew[\"<< n << \"] = \" << scientific << mGextNew[n] << \" < 0\" << endl; \n\t\t\terrorlog_file << \"in questa iterazione si mantiene mGextNew[n] = mGextOld[n] = \" << mGextOld[n] << \"\\n\" << endl; \n\t\t\tmGextNew[n] = mGextOld[n];\t \n \n\t\t\t} \n\t\t \n\t\t \n \n\t\tGConsRate[n] = (double)M_Gnow; \n\t\tGAbsRate[n] = (double)T_Gnow; \n\t\t \n\t\t \n \n \n \n \n\t\t \n\t\t \n \n\t\tif( phase[n] != dead ) \n\t\t\tmG6PNew[n] = (mG6POld[n] - dt*M_Gnow)/( 1. + dt*( tpH*coeffg1 + coeffg2*SensO2[n] + coeffg3) ); \n\t\telse \n\t\t\tmG6PNew[n] = mG6POld[n]; \n \n \n \n\t\t \n \n\t\t\t\t \n\t\tdouble M_O2now, DM_O2now;\t\t\t\t\t\t\t\t \n \n\t\tdouble M_O2now_0;\t\t\t\t\t\t\t\t\t\t \n \n\t\t \n\t\tif( phase[n] != dead ) \n\t\t\t{ \n\t\t\tM_O2now = -6.*(PM_O2/PM_G) * SensO2[n] * ( coeffg2*mG6POld[n]  \t\t\t\t+ coeffg3*mG6POld[n]*(StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]))  \t\t\t\t+ SensATP*0.033333*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) * (StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]))  \t\t\t\t+ 0.1*SensATP*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) * (mAinOld[n]/(volumeOld[n]*Kmd+mAinOld[n]))  ); \n\t\t\tDM_O2now = -6.*(PM_O2/PM_G) * dSensO2_O2 * ( coeffg2*mG6POld[n]  \t\t\t\t+ coeffg3*mG6POld[n]*(StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]))  \t\t\t\t+ SensATP*0.033333*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) * (StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]))  \t\t\t\t+ 0.1*SensATP*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) * (mAinOld[n]/(volumeOld[n]*Kmd+mAinOld[n]))  ); \n\t\t\t\t \n\t\t\tM_O2now_0 = 0.;\t \n \n\t\t\t \n\t\t\t} \n\t\telse \n\t\t\t{ \n\t\t\tM_O2now = DM_O2now = 0.;\t \n \n\t\t\tM_O2now_0 = 0.; \n\t\t\t} \n\t\t\t \n\t\tO2Flow += M_O2now; \n\t\t\t \n\t\t \n \n\t\tdouble cO2 = O2[n] + dt*Diff_ES_O2*sO2 + dt*Diff_Env_O2*(mO2_envOld/volume_envOld)*g_env[n] + dt*Diff_BV_O2*rhoO2_bv*g_bv[n];\t \n \n\t\t \n\t\tmO2New[n] = mO2Old[n] - ( mO2Old[n] * ( 1+Diff_ES_O2*dt*s0/volumeOld[n]+Diff_Env_O2*dt*g_env[n]/volumeOld[n]+Diff_BV_O2*dt*g_bv[n]/volumeOld[n]) - dt*M_O2now - cO2 ) \t\t\t\t/( 1 + Diff_ES_O2*dt*s0/volumeOld[n] + Diff_Env_O2*dt*g_env[n]/volumeOld[n] + Diff_BV_O2*dt*g_bv[n]/volumeOld[n] - dt*DM_O2now); \n\t\t\t\t \n\t\tif( mO2New[n] < 0 )\t \n \n\t\t\t{ \n\t\t\tdouble fhi = mO2Old[n] * ( 1+Diff_ES_O2*dt*s0/volumeOld[n]+Diff_Env_O2*dt*g_env[n]/volumeOld[n]+Diff_BV_O2*dt*g_bv[n]/volumeOld[n]) - dt*M_O2now - cO2; \n\t\t\tdouble flo = - dt*M_O2now_0 - cO2; \n\t\t\tdouble xsol = mO2Old[n]*flo/(flo-fhi); \n\t\t\tmO2New[n] = xsol; \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\terrorlog_file << scientific << \"mO2Old[\"<< n << \"] = \" << mO2Old[n] << \"; mO2New[\"<< n << \"] = \" << mO2New[n] << \"\\n\" <<endl; \n\t\t\t} \n\t\tif( mO2New[n] < 0 )\t \n \n\t\t\t{ \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" mO2New[\"<< n << \"] = \" << scientific << mO2New[n] << \" < 0\" << endl; \n\t\t\terrorlog_file << \"in questa iterazione si mantiene mO2New[n] = mO2Old[n] = \" << mO2Old[n] << \"\\n\" << endl; \n\t\t\tmO2New[n] = mO2Old[n];\t \n \n\t\t\t} \n\t\t \n\t\t \n \n \n \n\t\t \n \n\t\t \n\t\tdouble M_Anow, DM_Anow, T_Anow, DT_Anow_in, DT_Anow_ext;\t \n \n\t\tdouble M_Anow_0, T_Anow_0in, T_Anow_0ext;\t\t\t\t\t \n \n\t\t \n         \n \n        M_Anow = ((int)(phase[n] != dead))*              ( -( tp11*tpH*coeffr1*(1-SensATP) + 0.1*SensO2[n]*SensATP*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) ) * (mAinOld[n]/(volumeOld[n]*Kmd+mAinOld[n]))              - vmaxP_A*vp - vmaxDNA_A*vDNA - vmaxM_A*vM ); \n         \n \n        DM_Anow = ((int)(phase[n] != dead))*              ( -( tp11*tpH*coeffr1*(1-SensATP) + 0.1*SensO2[n]*SensATP*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) ) * (volumeOld[n]*Kmd/pow(volumeOld[n]*Kmd+mAinOld[n],2))              - vmaxP_A*dvp_A - vmaxDNA_A*dvDNA_A - vmaxM_A*dvM_A ) ; \n             \n        M_Anow_0 = 0;\t \n \n         \n         \n \n        T_Anow = a2cA*vmaxA * mAextOld[n]/(volume_extraOld[n]*KmA+mAextOld[n]) - c2aA*vmaxA * mAinOld[n]/(volumeOld[n]*KmA+mAinOld[n]); \n         \n \n        DT_Anow_in = - c2aA*vmaxA * volumeOld[n]*KmA/pow(volumeOld[n]*KmA+mAinOld[n],2); \n         \n \n        DT_Anow_ext = a2cA*vmaxA * volume_extraOld[n]*KmA/pow(volume_extraOld[n]*KmA+mAextOld[n],2); \n \n         \n \n        T_Anow_0in = a2cA*vmaxA * mAextOld[n]/(volume_extraOld[n]*KmA+mAextOld[n]);\t \n \n        T_Anow_0ext = - c2aA*vmaxA * mAinOld[n]/(volumeOld[n]*KmA+mAinOld[n]);\t\t \n \n\t\t \n\t\t \n \n        mAinNew[n] = mAinOld[n] - ( mAinOld[n] - ( A[n] + dt*( M_Anow + T_Anow ) ) )/( 1. - dt*( DM_Anow + DT_Anow_in ) ); \n\t\t\t \n\t\tif( mAinNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\tdouble fhi = mAinOld[n] - ( A[n] + dt*( M_Anow + T_Anow ) ); \n\t\t\tdouble flo = - ( A[n] + dt*( M_Anow_0 + T_Anow_0in ) ); \n\t\t\tdouble xsol = mAinOld[n]*flo/(flo-fhi); \n\t\t\tmAinNew[n] = xsol; \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\terrorlog_file << scientific << \"mAinOld[\"<< n << \"] = \" << mAinOld[n] << \"; mAinNew[\"<< n << \"] = \" << mAinNew[n] << \"\\n\" <<endl; \n\t\t\t} \n\t\tif( mAinNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" mAinNew[\"<< n << \"] = \" << scientific << mAinNew[n] << \" < 0\" << endl; \n\t\t\terrorlog_file << \"in questa iterazione si mantiene mAinNew[n] = mAinOld[n] = \" << mAinOld[n] << \"\\n\" << endl; \n\t\t\tmAinNew[n] = mAinOld[n];\t \n \n\t\t\t} \n\t\t \n\t\t \n\t\t \n\t\t \n \n\t\tdouble cA = A_extra[n] + dt*Diff_ES_A*sA + dt*Diff_Env_A*(mA_envOld/volume_envOld)*g_env[n] + dt*Diff_BV_A*rhoA_bv*g_bv[n];\t \n \n\t\t \n\t\tmAextNew[n] = mAextOld[n] - ( mAextOld[n]*(1+Diff_ES_A*dt*s0/volume_extraOld[n]+Diff_Env_A*dt*g_env[n]/volume_extraOld[n]+Diff_BV_A*dt*g_bv[n]/volume_extraOld[n]) + dt*T_Anow - cA ) \t\t\t\t/( 1. + Diff_ES_A*dt*s0/volume_extraOld[n] + Diff_Env_A*dt*g_env[n]/volume_extraOld[n] + Diff_BV_A*dt*g_bv[n]/volume_extraOld[n] + dt*DT_Anow_ext ); \n\t\tif( mAextNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\tdouble fhi = ( mAextOld[n]*(1+Diff_ES_A*dt*s0/volume_extraOld[n]+Diff_Env_A*dt*g_env[n]/volume_extraOld[n]+Diff_BV_A*dt*g_bv[n]/volume_extraOld[n]) + dt*T_Anow - cA ); \n\t\t\tdouble flo = ( dt*T_Anow_0ext - cA ); \n\t\t\tdouble xsol = mAextOld[n]*flo/(flo-fhi); \n\t\t\tmAextNew[n] = xsol; \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\terrorlog_file << scientific << \"mAextOld[\"<< n << \"] = \" << mAextOld[n] << \"; mAextNew[\"<< n << \"] = \" << mAextNew[n] << \"\\n\" <<endl; \n\t\t\t} \n\t\tif( mAextNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" mAextNew[\"<< n << \"] = \" << scientific << mAextNew[n] << \" < 0\" << endl; \n\t\t\terrorlog_file << \"in questa iterazione si mantiene mAextNew[n] = mAextOld[n] = \" << mAextOld[n] << \"\\n\" << endl; \n\t\t\tmAextNew[n] = mAextOld[n];\t \n \n\t\t\t} \n \n\t\t \n \n\t\tAConsRate[n] = (double)M_Anow; \n\t\tAAbsRate[n] = (double)T_Anow; \n\t\t \n\t\t \n \n \n \n\t\t \n\t\t \n\t\t \n \n \n\t\tif( phase[n] != dead ) \n\t\t\t{ \n\t\t\tdouble Ast = store[n] + dt * ( coeffg3*mG6POld[n] + tp11*tpH*coeffr1*(mAinOld[n]/(volumeOld[n]*Kmd+mAinOld[n]))*(1-SensATP) ); \n\t\t\tdouble Bst = -dt * ( tpH*coeffr1 + coeffg3*mG6POld[n]*SensO2[n] + SensO2[n]*SensATP*0.033333*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) ); \n\t\t\tdouble Kst = volumeOld[n]*Kmc; \n \n\t\t\tStoreNew[n] = 0.5*( (Ast+Bst-Kst) + sqrt( pow(Ast+Bst-Kst,2) + 4*Ast*Kst ) ); \n\t\t\t \n\t\t\t \n \n\t\t\tStoreFillRate[n] = (double)( coeffg3*mG6POld[n] + tp11*tpH*coeffr1*(mAinOld[n]/(volumeOld[n]*Kmd+mAinOld[n]))*(1-SensATP) ); \n\t\t\tStoreConsRate[n] = (double)(-( tpH*coeffr1 + coeffg3*mG6POld[n]*SensO2[n] + SensO2[n]*SensATP*0.033333*(PM_G/PM_ATP)*( ATP_St[n] - ATP_Ox[n] ) ) * (StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n]))); \n\t\t\t} \n\t\telse \n\t\t\t{ \n\t\t\tStoreNew[n] = StoreOld[n]; \n\t\t\tStoreFillRate[n] = StoreConsRate[n] = 0.; \n\t\t\t} \n \n\t\t \n \n\t\t \n\t\tdouble M_AcLnow, DM_AcLnow, T_AcLnow, DT_AcLnow_in, DT_AcLnow_ext; \n\t\tdouble M_AcLnow_0, T_AcLnow_0in, T_AcLnow_0ext; \n\t\t \n         \n \n        M_AcLnow = ((int)(phase[n] != dead))*              ( 2.*tpH*( coeffg1*mG6POld[n] + coeffr1*(StoreOld[n]/(volumeOld[n]*Kmc+StoreOld[n])) ) ); \n         \n         \n \n         \n \n         \n         \n \n        DM_AcLnow = 0.; \n         \n        M_AcLnow_0 = M_AcLnow;\t \n \n         \n         \n \n        T_AcLnow = a2cAcL*vmaxAcL * mAcLextOld[n]/(volume_extraOld[n]*KmAL+mAcLextOld[n]) - c2aAcL*vmaxAcL * mAcLinOld[n]/(volumeOld[n]*KmAL+mAcLinOld[n]); \n         \n \n        DT_AcLnow_in = - c2aAcL*vmaxAcL * volumeOld[n]*KmAL/pow(volumeOld[n]*KmAL+mAcLinOld[n],2); \n         \n \n        DT_AcLnow_ext = da2cAcL*vmaxAcL * mAcLextOld[n]/(volume_extraOld[n]*KmAL+mAcLextOld[n]) +                          a2cAcL*vmaxAcL * volume_extraOld[n]*KmAL/pow(volume_extraOld[n]*KmAL+mAcLextOld[n],2); \n         \n         \n \n        T_AcLnow_0in = a2cAcL*vmaxAcL * mAcLextOld[n]/(volume_extraOld[n]*KmAL+mAcLextOld[n]);\t \n \n        T_AcLnow_0ext = - c2aAcL*vmaxAcL * mAcLinOld[n]/(volumeOld[n]*KmAL+mAcLinOld[n]);\t\t \n \n\t\t\t \n \n\t\t \n \n        mAcLinNew[n] = mAcLinOld[n] - ( mAcLinOld[n] - ( AcL[n] + dt*( M_AcLnow + T_AcLnow ) ) )/( 1 - dt*( DM_AcLnow + DT_AcLnow_in ) ); \n\t\t\t \n\t\tif( mAcLinNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\tdouble fhi = mAcLinOld[n] - ( AcL[n] + dt*( M_AcLnow + T_AcLnow ) );\t \n \n\t\t\tdouble flo = - ( AcL[n] + dt*( M_AcLnow_0 + T_AcLnow_0in ) );\t\t\t \n \n\t\t\tdouble xsol = mAcLinOld[n]*flo/(flo-fhi); \n\t\t\tmAcLinNew[n] = xsol; \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\terrorlog_file << scientific << \"mAcLinOld[\"<< n << \"] = \" << mAcLinOld[n] << \"; mAcLinNew[\"<< n << \"] = \" << mAcLinNew[n] << \"\\n\" <<endl; \n\t\t\t} \n\t\tif( mAcLinNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" mAcLinNew[\"<< n << \"] = \" << scientific << mAcLinNew[n] << \" < 0\" << endl; \n\t\t\terrorlog_file << \"in questa iterazione si mantiene mAcLinNew[n] = mAcLinOld[n] = \" << mAcLinOld[n] << \"\\n\" << endl; \n\t\t\tmAcLinNew[n] = mAcLinOld[n];\t \n \n\t\t\t} \n\t\t \n\t\t \n \n\t\tdouble cAcL = AcL_extra[n] + dt*Diff_ES_AcL*sAcL + dt*Diff_Env_AcL*(mAcL_envOld/volume_envOld)*g_env[n] + dt*Diff_BV_AcL*rhoAcL_bv*g_bv[n];\t \n \n\t\t \n\t\tmAcLextNew[n] = mAcLextOld[n] - ( mAcLextOld[n]*(1+Diff_ES_AcL*dt*s0/volume_extraOld[n]+Diff_Env_AcL*dt*g_env[n]/volume_extraOld[n]+Diff_BV_AcL*dt*g_bv[n]/volume_extraOld[n]) + dt*T_AcLnow - cAcL ) \t\t\t\t/( 1. + Diff_ES_AcL*dt*s0/volume_extraOld[n] + Diff_Env_AcL*dt*g_env[n]/volume_extraOld[n] + Diff_BV_AcL*dt*g_bv[n]/volume_extraOld[n] + dt*DT_AcLnow_ext ); \n\t\tif( mAcLextNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\tdouble fhi = mAcLextOld[n]*(1+Diff_ES_AcL*dt*s0/volume_extraOld[n]+Diff_Env_AcL*dt*g_env[n]/volume_extraOld[n]+Diff_BV_AcL*dt*g_bv[n]/volume_extraOld[n]) + dt*T_AcLnow - cAcL; \n\t\t\tdouble flo = dt*T_AcLnow_0ext - cAcL; \n\t\t\tdouble xsol = mAcLextOld[n]*flo/(flo-fhi); \n\t\t\tmAcLextNew[n] = xsol; \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\terrorlog_file << scientific << \"mAcLextOld[\"<< n << \"] = \" << mAcLextOld[n] << \"; mAcLextNew[\"<< n << \"] = \" << mAcLextNew[n] << \"\\n\" <<endl; \n\t\t\t} \n\t\tif( mAcLextNew[n] < 0 )\t \n \n\t\t\t{ \n\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" mAcLextNew[\"<< n << \"] = \" << scientific << mAcLextNew[n] << \" < 0\" << endl; \n\t\t\terrorlog_file << \"in questa iterazione si mantiene mAcLextNew[n] = mAcLextOld[n] = \" << mAcLextOld[n] << \"\\n\" << endl; \n\t\t\tmAcLextNew[n] = mAcLextOld[n];\t \n \n\t\t\t} \n \n\t\t \n \n\t\tAcLRate[n] = (double)M_AcLnow; \n\t\tAcLOutRate[n] = (double)T_AcLnow; \n\t\t \n\t\t \n \n \n \n \n \n\t\t \n \n\t\t \n\t\tif( phase[n] != dead ) \n\t\t\t{ \n\t\t\t \n\t\t\tdouble M_ATPnow, DM_ATPnow;\t\t\t\t\t\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\tConsATP_1[n] = v_WORK*C1*ATPpOld[n]; \n\t\t\tConsATP_2[n] = vmaxP_ATP*vp; \n\t\t\tConsATP_3[n] = vmaxDNA_ATP*vDNA; \n\t\t\tConsATP_5[n] = vmaxM_ATP*vM; \n\t\t\t \n\t\t\trATPprod = ATP_Ox[n] + ATP_NOx[n] + ATP2[n] + ATP3[n]; \n\t\t\trATPcons = ConsATP[n] + ConsATP_1[n] + ConsATP_2[n] + ConsATP_3[n] + ConsATP_5[n]; \n \n\t\t\t \n \n\t\t\tM_ATPnow = rATPprod - rATPcons; \n\t\t\t \n \n\t\t\tDM_ATPnow = - v_WORK*C1 - vmaxP_ATP*dvp_ATPp - vmaxDNA_ATP*dvDNA_ATPp - vmaxM_ATP*dvM_ATPp;  \n \n\t\t\t \n \n\t\t\tATPpNew[n] = ATPpOld[n] - ( ATPpOld[n] - ATPp[n] - dt*M_ATPnow )/(1.-dt*DM_ATPnow); \n\t\t\tif( ATPpNew[n] < 0 )\t \n \n\t\t\t\t{ \n\t\t\t\tdouble fhi = ATPpOld[n] - ATPp[n] - dt*M_ATPnow; \n\t\t\t\tdouble flo = - ( ATPp[n] + dt*(ATP_NOx[n]) ); \n\t\t\t\tdouble xsol = ATPpOld[n]*flo/(flo-fhi); \n\t\t\t\tATPpNew[n] = xsol; \n\t\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \", iterazione \" << nrepeats << \", cellula \" << n; \n\t\t\t\terrorlog_file << \" e' necessario passare al metodo della secante\" << endl; \n\t\t\t\terrorlog_file << scientific << \"ATPpOld[\"<< n << \"] = \" << ATPpOld[n] << \"; ATPpNew[\"<< n << \"] = \" << ATPpNew[n] << \"\\n\" <<endl; \n\t\t\t\t} \n\t\t\tif( ATPpNew[n] < 0 )\t \n \n\t\t\t\t{ \n\t\t\t\terrorlog_file << \"ATTENZIONE: al passo \" << nstep << \" ATPpNew[\"<< n << \"] = \" << scientific << ATPpNew[n] << \" < 0\" << endl; \n\t\t\t\terrorlog_file << \"in questa iterazione si mantiene ATPpNew[n] = ATPpOld[n] = \" << ATPpOld[n] << \"\\n\" << endl; \n\t\t\t\terrorlog_file << \"Altre informazioni sullo stato cellulare attuale: \" << endl; \n\t\t\t\terrorlog_file << \"eta' cellulare \" << age[n] << endl; \n\t\t\t\terrorlog_file << \"eta' di fase cellulare \" << phase_age[n] << endl; \n\t\t\t\terrorlog_file << \"ATP_St \" << ATP_St[n] << endl; \n\t\t\t\terrorlog_file << \"ATP_Ox \" << ATP_Ox[n] << endl; \n\t\t\t\terrorlog_file << \"ATP_NOx \" << ATP_NOx[n] << endl; \n\t\t\t\terrorlog_file << \"ATP2 \" << ATP2[n] << endl; \n\t\t\t\terrorlog_file << \"ATP3 \" << ATP3[n] << endl; \n\t\t\t\terrorlog_file << \"ConsATP \" << ConsATP[n] << endl; \n\t\t\t\terrorlog_file << \"ConsATP_1 \" << ConsATP_1[n] << endl; \n\t\t\t\terrorlog_file << \"ConsATP_2 \" << ConsATP_2[n] << endl; \n\t\t\t\terrorlog_file << \"ConsATP_3 \" << ConsATP_3[n] << endl; \n\t\t\t\terrorlog_file << \"ConsATP_4 \" << ConsATP_4[n] << endl; \n\t\t\t\terrorlog_file << \"ConsATP_5 \" << ConsATP_5[n] << endl; \n\t\t\t\terrorlog_file << \"ATPtot \" << ATPtot[n] << endl; \n\t\t\t\terrorlog_file << \"ATPp \" << ATPp[n] << endl; \n\t\t\t\terrorlog_file << \"ATPmin \" << ATPmin[n] << endl; \n\t\t\t\terrorlog_file << endl; \n\t\t\t\tATPpNew[n] = ATPpOld[n];\t \n \n\t\t\t\t} \n\t\t\t \n\t\t\t \n \n\t\t\tif(phase[n] != G0_phase) \n\t\t\t\tMitNew[n] = M[n] + vmaxM*vM*dt;  \n\t\t\telse \n\t\t\t\tMitNew[n] = M[n]; \n\t\t\t} \n\t\telse \n\t\t\t{ \n\t\t\tConsATP_1[n] = 0.; \n\t\t\tConsATP_2[n] = 0.; \n\t\t\tConsATP_3[n] = 0.; \n\t\t\tConsATP_5[n] = 0.; \n\t\t\tATPpNew[n] = ATPpOld[n]; \n\t\t\tMitNew[n] = M[n]; \n\t\t\t} \n\t\t\t \n\t\t \n\t\t \n \n\t\t \n\t\tif( phase[n] != dead ) \n\t\t\t{ \n\t\t\tdelta_protein[n] = vmaxP*vp*dt; \n\t\t\tproteinNew[n] = protein[n] + delta_protein[n]; \n\t\t\t \n\t\t\tif( phase[n] == G2_phase || phase[n] == M_phase) \n\t\t\t\tpRbNew[n] = pRb[n] + type[n]->Get_pRb_fraction()*delta_protein[n]; \n\t\t\telse \n\t\t\t\tpRbNew[n] = pRb[n]; \n\t\t\t\t \n\t\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n \n\t\t\tdouble ConcpRb = 1000.*pRbNew[n]/(PM_pRb * volume[n]);\t\t\t\t \n \n\t\t\tdouble ConcCyclinD = 1000.*cyclinD[n]/(PM_cyclinD * volume[n] );\t \n \n\t\t\tdouble ConcCyclinE = 1000.*cyclinE[n]/(PM_cyclinE * volume[n] );\t \n \n             \n \n             \n \n                 \n\t\t\tint N_pRb = type[n]->Get_N_pRb();\t\t \n \n\t\t\tint k_pRb = type[n]->Get_k_pRb();\t\t \n \n\t\t\tdouble pRb_ONOFFratio = type[n]->Get_pRb_ONOFFratio(); \n \n\t\t\tdouble p_pRb = ( (N_pRb * ConcpRb + (ConcCyclinD+ConcCyclinE) + pRb_ONOFFratio) -  \t\t\t\t\tsqrt( pow(N_pRb * ConcpRb + (ConcCyclinD+ConcCyclinE) + pRb_ONOFFratio,2) - 4.*N_pRb*ConcpRb*(ConcCyclinD+ConcCyclinE) ) )/(2. * N_pRb * ConcpRb); \n\t\t\t \n\t\t\tdouble Pk_pRb = 0.; \n\t\t\tfor(int l=k_pRb; l<=N_pRb; l++) \n\t\t\t\t{ \n\t\t\t\tPk_pRb += bico(N_pRb,k_pRb) * pow(p_pRb,l)*pow(1.-p_pRb,N_pRb-l); \n\t\t\t\t} \n\t\t\t \n\t\t\tdouble ConcE = ConcpRb*Pk_pRb;\t \n \n \n\t\t\t \n \n\t\t\tConcSNew[n] = 0.5*( (ConcS[n] - dt*ConcE*type[n]->Get_k3MM() - type[n]->Get_KmMM())  \t\t\t\t+ sqrt( pow(ConcS[n] - dt*ConcE*type[n]->Get_k3MM() - type[n]->Get_KmMM(),2)  \t\t\t\t\t\t+ 4.*ConcS[n]*type[n]->Get_KmMM() ) ); \n\t\t\t} \n\t\telse \n\t\t\t{ \n\t\t\tdelta_protein[n] = 0.; \n\t\t\tproteinNew[n] = protein[n]; \n\t\t\tpRbNew[n] = pRb[n]; \n\t\t\tConcSNew[n] = ConcS[n]; \n\t\t\t} \n\t\t \n\t\t \n\t\t \n \n\t\t \n\t\tif(phase[n] == S_phase) \n\t\t\tDNANew[n] = DNA[n] + DNA_rate[n]*dt; \n\t\telse \n\t\t\tDNANew[n] = DNA[n]; \n \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n \n\t\t}", "pragma": "parallel for ", "hash": "07f3068cfb6867e79628916c4897aff05163007afa3f531670c9763aa75d6e36"}
{"code": "for(long i=0;i<nx*ny*nz;i++)\tr->a[i] = real(dd->a[i]);", "pragma": "parallel for ", "hash": "7c0204dbfd2c4f73c24d6789fb6433ec59daaa98af55e73b607172fee2c394ee"}
{"code": "for( i = 0 ; i < LVOLUME ; i++ ) { \n    double p = 0. , res ; \n    size_t mu ; \n    for( mu = 0 ; mu < ND-1 ; mu++ ) { \n      speed_trace_Re( &res , lat[i].O[mu] ) ;  \n      p = p + (double)res ;  \n    } \n    splink = splink + (double)p ; \n     \n \n    speed_trace_Re( &res , lat[i].O[ND-1] ) ;  \n    tlink = tlink + (double)res ;  \n  }", "pragma": "parallel for reduction(+:splink) reduction(+:tlink) private(i)", "hash": "60bd8b93aeabc4dac905e86f6f3c4925260d9370b2ea838735f774af1dfaa31a"}
{"code": "for (j = leftterminal; j <= rightterminal; j++) { \n         \n \n        node = &coordination->access(j, 1); \n        hxi = node->hxi; \n        heta = node->heta; \n        vxi = \n            (coordination->access(j, 2).psi - \n             cylinderBoundary->access(j, \n                                      1).psi) / \n            (2 * heta * deltaeta); \n        veta = \n            -(coordination->access(j + 1, 1).psi - \n              coordination->access(j - 1, \n                                   1).psi) / (2 * hxi * deltaxi); \n        uxi = vxi / hxi; \n        ueta = veta / heta; \n \n        if (Re < 1000) { \n            lambdaxi = 1 - 1 / exp(abs(uxi)); \n            lambdaeta = 1 - 1 / exp(abs(ueta)); \n        } else { \n            lambdaxi = 1; \n            lambdaeta = 1; \n        } \n \n        node->c1 = \n            -2 / deltat - lambdaxi * abs(uxi) / (2 * deltaxi) - \n            (-ueta) / (2 * deltaeta) - \n            4 / (hxi * hxi * deltaxi * deltaxi * Re) - \n            4 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c2 = \n            -2 / deltat + lambdaxi * abs(uxi) / (2 * deltaxi) + \n            (-ueta) / (2 * deltaeta) + \n            4 / (hxi * hxi * deltaxi * deltaxi * Re) + \n            4 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c3 = -(ueta - (-ueta)) / (12 * deltaeta); \n        node->c4 = \n            (2 * ueta - (-ueta)) / (3 * deltaeta) - \n            2 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c5 = \n            -(2 * ueta + (-ueta)) / (3 * deltaeta) - \n            2 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c6 = (ueta + (-ueta)) / (12 * deltaeta); \n        node->c7 = -(uxi - lambdaxi * abs(uxi)) / (12 * deltaxi); \n        node->c8 = \n            (2 * uxi - lambdaxi * abs(uxi)) / (3 * deltaxi) - \n            2 / (hxi * hxi * deltaxi * deltaxi * Re); \n        node->c9 = \n            -(2 * uxi + lambdaxi * abs(uxi)) / (3 * deltaxi) - \n            2 / (hxi * hxi * deltaxi * deltaxi * Re); \n        node->c10 = (uxi + lambdaxi * abs(uxi)) / (12 * deltaxi); \n \n         \n \n        node = &coordination->access(j, -1); \n        hxi = node->hxi; \n        heta = node->heta; \n        vxi = \n            (cylinderBoundary->access(j, 0).psi - \n             coordination->access(j, \n                                  -2).psi) / (2 * heta * deltaeta); \n        veta = \n            -(coordination->access(j + 1, -1).psi - \n              coordination->access(j - 1, \n                                   -1).psi) / (2 * hxi * deltaxi); \n        uxi = vxi / hxi; \n        ueta = veta / heta; \n \n        if (Re < 1000) { \n            lambdaxi = 1 - 1 / exp(abs(uxi)); \n            lambdaeta = 1 - 1 / exp(abs(ueta)); \n        } else { \n            lambdaxi = 1; \n            lambdaeta = 1; \n        } \n \n        node->c1 = \n            -2 / deltat - lambdaxi * abs(uxi) / (2 * deltaxi) - \n            ueta / (2 * deltaeta) - \n            4 / (hxi * hxi * deltaxi * deltaxi * Re) - \n            4 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c2 = \n            -2 / deltat + lambdaxi * abs(uxi) / (2 * deltaxi) + \n            ueta / (2 * deltaeta) + \n            4 / (hxi * hxi * deltaxi * deltaxi * Re) + \n            4 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c3 = -(ueta - ueta) / (12 * deltaeta); \n        node->c4 = \n            (2 * ueta - ueta) / (3 * deltaeta) - \n            2 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c5 = \n            -(2 * ueta + ueta) / (3 * deltaeta) - \n            2 / (heta * heta * deltaeta * deltaeta * Re); \n        node->c6 = (ueta + ueta) / (12 * deltaeta); \n        node->c7 = -(uxi - lambdaxi * abs(uxi)) / (12 * deltaxi); \n        node->c8 = \n            (2 * uxi - lambdaxi * abs(uxi)) / (3 * deltaxi) - \n            2 / (hxi * hxi * deltaxi * deltaxi * Re); \n        node->c9 = \n            -(2 * uxi + lambdaxi * abs(uxi)) / (3 * deltaxi) - \n            2 / (hxi * hxi * deltaxi * deltaxi * Re); \n        node->c10 = (uxi + lambdaxi * abs(uxi)) / (12 * deltaxi); \n    }", "pragma": "parallel for private(         heta hxi j lambdaeta lambdaxi node ueta uxi veta vxi)", "hash": "48661831952664d5f297cce18211206565662857a17e47546fb6629e009a4c18"}
{"code": "for (Nd4jLong i = 0; i < length; i++) { \n \n                for (Nd4jLong ar = 1; ar < n; ar++) { \n                    z[i] += x[ar][i] / n; \n                } \n            }", "pragma": "parallel for simd ", "hash": "a4457b4a5bc0208103c3d269a6b9db8493f4bd9434a1828c36aa145a1aa1effd"}
{"code": "for (i = 0; i < bsize; i++)  \n    p->sb[bsize * p->id + i] = p->rb[bsize * p->id + i];", "pragma": "parallel for ", "hash": "9f439b56e7ca970b22ba4fa3221c4d27d4c77be9b07f29f4145d78af4f20fcc0"}
{"code": "for (int igloc = 0; igloc < gvec().count(); igloc++) { \n                    int ig = gvec().offset() + igloc; \n                    auto G = gvec().gvec(ig); \n                    for (int x : {0, 1, 2}) { \n                        gvec_coord_(igloc, x) = G[x]; \n                    } \n                }", "pragma": "parallel for ", "hash": "d80edb955ff0dd8d1b038b31132e593854ca24150cfa9a6658ef1f84aa656cb4"}
{"code": "for (i = 0; i < length; i++) \n\t    { \n\t    bodyarray[i]->setSnap(zeroVector); \n\t    bodyarray[i]->setCrackle(zeroVector); \n\t    bodyarray[i]->calcSnapCrackle(G, bodyarray, softeningLength); \n\t    }", "pragma": "for ", "hash": "b9da54bea1b4ad0033e3c2fc4c27a2d16e9ba23522c7f42cceb7f3a6258a01dd"}
{"code": "for(size_t j = 0; j < N; ++j) { \n                    contract(tmp, _delta, rightStack[1][j], 1); \n\t\t\t\t\tconst double normPart = misc::sqr(frob_norm(tmp)); \n\t\t\t\t\tnorm += normPart; \n                }", "pragma": "parallel for reduction(+:norm) private(tmp)", "hash": "f2fff4b3355131f4695320b162bf5ceb2e7c6e2f1bb51a5f12d8070533babfd9"}
{"code": "for (i=0; i<nnz; i++) { \n    hp0 = indices[i]; \n    hp1 = (i+1 == nnz) ?  dim : indices[i+1]; \n    if (hp0 != hp1) for (h = hp0; h < hp1; h++) { \n      THTensor_fastSet1d(csr, h+1, i+1); \n    } \n  }", "pragma": "parallel for private(   h hp0 hp1 i)", "hash": "f065ac0f675ddaf71463f31d3234d32b7032f3b2acbec851d40d42a1d473ad78"}
{"code": "for (int i = 0; i < 64; i++) \n    r11[1]++;", "pragma": "parallel simd reduction(+:r11[1:13]) ", "hash": "6c7a6a712d4059bf9c44c427d03c7bb18496c3a0c77f8beb31570dcee5a5a1ef"}
{"code": "for(index i = 0; i < mat->nbrows; i++) { \n\t\t\tza[i] = ytemp[i]; \n\t\t}", "pragma": "parallel for simd ", "hash": "0cefa4cf8aef062285dafbbaca70328d818793f4df55561221855c9469632413"}
{"code": "for (int index = 0; index < num_rigid_shapes; index++) { \n    shape_type type = obj_data_T[index]; \n    uint id = obj_data_ID[index]; \n    real3 A = obj_data_A[index]; \n    real3 B = obj_data_B[index]; \n    real3 C = obj_data_C[index]; \n    real3 position = body_pos[id]; \n    real4 rotation = (mult(body_rot[id], obj_data_R[index])); \n    real3 temp_min; \n    real3 temp_max; \n \n    if (type == SPHERE) { \n      A = quatRotate(A, body_rot[id]); \n      ComputeAABBSphere(B.x + collision_envelope, A + position, temp_min, temp_max); \n    } else if (type == TRIANGLEMESH) { \n      A = quatRotate(A, body_rot[id]) + position; \n      B = quatRotate(B, body_rot[id]) + position; \n      C = quatRotate(C, body_rot[id]) + position; \n      ComputeAABBTriangle(A, B, C, temp_min, temp_max); \n    } else if (type == ELLIPSOID || type == BOX || type == CYLINDER || type == CONE) { \n      ComputeAABBBox(B + collision_envelope, A, position, obj_data_R[index], body_rot[id], temp_min, temp_max); \n    } else if (type == ROUNDEDBOX || type == ROUNDEDCYL || type == ROUNDEDCONE) { \n      ComputeAABBBox(B + C.x + collision_envelope, A, position, obj_data_R[index], body_rot[id], temp_min, temp_max); \n    } else if (type == CAPSULE) { \n      real3 B_ = R3(B.x, B.x + B.y, B.z) + collision_envelope; \n      ComputeAABBBox(B_, A, position, obj_data_R[index], body_rot[id], temp_min, temp_max); \n    } else if (type == CONVEX) { \n      ComputeAABBConvex(convex_data.data(), B, A, position, rotation, temp_min, temp_max); \n      temp_min -= collision_envelope; \n      temp_max += collision_envelope; \n    } else { \n      continue; \n    } \n \n    aabb_min_rigid[index] = temp_min; \n    aabb_max_rigid[index] = temp_max; \n  }", "pragma": "parallel for ", "hash": "5a32ba02266d794151999b571228095e9eb9c4af614978a1d0443bee0cbabe87"}
{"code": "for(ix=0; ix<nx; ix++){ \n    for(iz=0; iz<nz; iz++){ \n\ta += g1[ix][iz]*(g1[ix][iz]-g0[ix][iz]); \n \n\tb += cg[ix][iz]*(g1[ix][iz]-g0[ix][iz]); \n \n\tc += g1[ix][iz]*g1[ix][iz];\t\t \n \n    } \n  }", "pragma": "parallel for private( ix iz)", "hash": "dba39ff73b2e198f811d62dd6d0b04c0dfcc34b515137b392094aa6d0143ca6f"}
{"code": "for (i = 0; i < N; i++) { \n        producto = 0; \n        printf(\"\\nHebra %d calcula componente %d: \", omp_get_thread_num(), i); \n \n        for (k = 0; k < N; k++) { \n            producto += M[i][k] * V[k]; \n            printf(\"->[%d]\", producto); \n        } \n \n        VR[i] = producto; \n    }", "pragma": "parallel for reduction(+:producto) ", "hash": "9214527a449d66e7e3af70b957b0b70b86f687fd139f71aeaf5716b92120346f"}
{"code": "for (j = 1; j < nrows + 1; j++) \n\t\trowstr[j] = rowstr[j] - nzloc[j-1];", "pragma": "parallel for ", "hash": "1792207c93887f144edcd5d815f1124d247712ca8879c186039c8203951ba517"}
{"code": "for( int p=0; p<Population; p++ ) \n                f[p] = Eval( solver.GetStateArr()[p] );", "pragma": "for ", "hash": "d90f145152d9627207c343debff12f45fbaa54554d04e9b41f8000f6d9d2c5a0"}
{"code": "for(pIdx = 0; pIdx < pCnt; ++pIdx) \n    { \n      int\tpln; \n      WlzIVertex3 pos2 = {0}; \n      WlzPixelV   val2 = {0}; \n      WlzObject *obj2 = NULL; \n      WlzErrorNum errNum2 = WLZ_ERR_NONE; \n \n      pln = gObj->domain.p->plane1 + pIdx; \n      if(tiled) \n      { \n\tobj2 = WlzMakeMain(WLZ_2D_DOMAINOBJ, domains[pIdx], \n\t\t\t    gObj->values, NULL, NULL, &errNum2); \n      } \n      else \n      { \n        obj2 = WlzMakeMain(WLZ_2D_DOMAINOBJ, domains[pIdx], values[pIdx], \n\t                    NULL, NULL, &errNum2); \n      } \n      if(errNum2 == WLZ_ERR_NONE) \n      { \n        pos2 = WlzGreyExtremumPos2(obj2, pln, isMax, &val2, &errNum2); \n      } \n      WlzFreeObj(obj2); \n#pragma omp critical (WlzGreyExtremum) \n      { \n        if(errNum2 == WLZ_ERR_NONE) \n\t{ \n\t  if(first) \n\t  { \n\t    first = 0; \n\t    pos = pos2; \n\t    val = val2; \n\t  } \n\t  else \n\t  { \n\t    switch(val2.type) \n\t    { \n\t      case WLZ_GREY_INT: \n\t\tif((isMax  && (val2.v.inv > val.v.inv)) || \n\t\t   (!isMax && (val2.v.inv < val.v.inv))) \n\t\t{ \n\t\t  pos = pos2; \n\t\t  val = val2; \n\t\t} \n\t\tbreak; \n\t      case WLZ_GREY_SHORT: \n\t\tif((isMax  && (val2.v.shv > val.v.shv)) || \n\t\t   (!isMax && (val2.v.shv < val.v.shv))) \n\t\t{ \n\t\t  pos = pos2; \n\t\t  val = val2; \n\t\t} \n\t\tbreak; \n\t      case WLZ_GREY_UBYTE: \n\t\tif((isMax  && (val2.v.ubv > val.v.ubv)) || \n\t\t   (!isMax && (val2.v.ubv < val.v.ubv))) \n\t\t{ \n\t\t  pos = pos2; \n\t\t  val = val2; \n\t\t} \n\t\tbreak; \n\t      case WLZ_GREY_FLOAT: \n\t\tif((isMax  && (val2.v.flv > val.v.flv)) || \n\t\t   (!isMax && (val2.v.flv < val.v.flv))) \n\t\t{ \n\t\t  pos = pos2; \n\t\t  val = val2; \n\t\t} \n\t\tbreak; \n\t      case WLZ_GREY_DOUBLE: \n\t\tif((isMax  && (val2.v.dbv > val.v.dbv)) || \n\t\t   (!isMax && (val2.v.dbv < val.v.dbv))) \n\t\t{ \n\t\t  pos = pos2; \n\t\t  val = val2; \n\t\t} \n\t\tbreak; \n\t      default: \n\t\terrNum = WLZ_ERR_GREY_TYPE; \n\t    } \n\t  } \n\t} \n\tif(errNum2 != WLZ_ERR_NONE) \n\t{ \n\t  if(errNum == WLZ_ERR_NONE) \n\t  { \n\t    errNum = errNum2; \n\t  } \n\t} \n      } \n \n    }", "pragma": "parallel for ", "hash": "ebae62e27215ead9cee99f1cdefd5c5845ed354d179ee9308000a15c2755020a"}
{"code": "for (long j = 1; j < ny; ++j) {\r \n\t\t\tfor (long i = 1; i < nx - 1; ++i) {\r \n\t\t\t\tconst double d2vdx2 = (1 / (dx*dx))*(v(i + 1, j) - 2 * v(i, j) + v(i - 1, j));\r \n\t\t\t\tconst double d2vdy2 = (1 / (dy*dy))*(v(i, j + 1) - 2 * v(i, j) + v(i, j - 1));\r \n\r \n\t\t\t\tconst double duvdx = (0.25 / dx)*(((u(i + 1, j) + u(i + 1, j - 1))*(v(i, j) + v(i + 1, j))) - ((u(i, j - 1) + u(i, j))*(v(i - 1, j) + v(i, j))))\r \n\t\t\t\t\t+ (0.25*gamma / dx)*(fabs(u(i + 1, j) + u(i + 1, j - 1))*(v(i, j) - v(i + 1, j)) - fabs(u(i, j - 1) + u(i, j))*(v(i - 1, j) - v(i, j)));\r \n\r \n\t\t\t\tconst double dv2dy = (0.25 / dy)*((v(i, j) + v(i, j + 1))*(v(i, j) + v(i, j + 1)) - (v(i, j - 1) + v(i, j))*(v(i, j - 1) + v(i, j)))\r \n\t\t\t\t\t+ (0.25*gamma / dy)*(fabs(v(i, j) + v(i, j + 1))*(v(i, j) - v(i, j + 1)) - fabs(v(i, j - 1) + v(i, j))*(v(i, j - 1) - v(i, j)));\r \n\r \n\t\t\t\tg(i, j) = v(i, j) + dt*(Rei*(d2vdx2 + d2vdy2) - duvdx - dv2dy);\r \n\t\t\t}\r \n\t\t}", "pragma": "parallel ", "hash": "8662557c49adc6b7e0552b8b9934e6ca11989091f60a1e55110151261b445f37"}
{"code": "for(lI=0;lI<np*nt;lI++){ \n    i=lI%np; \n    j=lI/np; \n    mesh[j+nt*(i+np*VARRHO)]+=dtdx*(flx[i  +(np+1)*(j+nt*VARRHO)]- \n\t\t\t\t    flx[i+1+(np+1)*(j+nt*VARRHO)]); \n    mesh[j+nt*(i+np*VARVX )]+=dtdx*(flx[i  +(np+1)*(j+nt*VARVY )]- \n\t\t\t\t    flx[i+1+(np+1)*(j+nt*VARVY )]); \n    mesh[j+nt*(i+np*VARVY )]+=dtdx*(flx[i  +(np+1)*(j+nt*VARVX )]- \n\t\t\t\t    flx[i+1+(np+1)*(j+nt*VARVX )]); \n    mesh[j+nt*(i+np*VARPR )]+=dtdx*(flx[i  +(np+1)*(j+nt*VARPR )]- \n\t\t\t\t    flx[i+1+(np+1)*(j+nt*VARPR )]); \n  }", "pragma": "parallel for private(i j li)", "hash": "b73cc24b536487c902ab62b959b83801de1312e9d8108786a23de488ade1c120"}
{"code": "for (idx_t iik = 0; iik < nx * (idx_t)nprobe; iik++) { \n                idx_t i = iik / (idx_t)nprobe; \n                idx_t ik = iik % (idx_t)nprobe; \n                if (qres == nullptr || qres->qno != i) { \n                    qres = &pres.new_result(i); \n                    scanner->set_query(x + i * d); \n                } \n                scan_list_func(i, ik, *qres); \n            }", "pragma": "for ", "hash": "5239d9044f9f18fdbe8985091dc367fce1ec5f574f9e0d32d4896fe2b31f4d5f"}
{"code": "for (size_t setId = 0; setId < dbSize; setId++) { \n            const size_t elementSize = LEN(offsetTable, setId); \n            for (size_t elementId = 0; elementId < elementSize; elementId++) { \n                const unsigned int currElm = elementLookupTable[setId][elementId]; \n                const unsigned int currElementSize = LEN(offsetTable, currElm); \n                const bool elementFound = std::binary_search(elementLookupTable[currElm], \n                                                             elementLookupTable[currElm] + currElementSize, setId); \n                 \n \n                if (elementFound == false) { \n                    tmpSize[static_cast<size_t>(currElm) * static_cast<size_t>(threads) + \n                            static_cast<size_t>(thread_idx)] += 1; \n                } \n            } \n        }", "pragma": "for ", "hash": "9e1ac36b513b47b2af1302b8353eab6b07dad35be4479fc7cb8d4bf0c53ff787"}
{"code": "for (unsigned char i = '0' ; i <= '9'; ++i) \n    for (x = -10; x < 10; ++x) { \n \n \n \n \n \n \n \n \n \n \n \n    #pragma omp ordered threads \n    a[i] = b[i] * c[i] * d[i]; \n \n \n \n  }", "pragma": "for ", "hash": "65b6fe535d423f8650e8ac8c7cad229e12bc8eb09d93fb25077137b95f1d1a97"}
{"code": "for (size_t en_i=0; en_i<ensemble_size; en_i++) { \n\t\t\t \n \n\t\t\t \n \n\t\t\tset_rng_seed(w, rng_seed+en_i); \n\t\t\tfor (size_t j=0; j<N; j++) { \n\t\t\t\tnoises[N*en_i+j] = gsl_ran_gaussian(w->r, 1.0); \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "1bc9927daa8248ab5d945a5420999c371a771a8848a0046e255bfc40e7e4141b"}
{"code": "for(int i=0; i<n; i++){ \n        sum += v[i]*v[i]; \n    }", "pragma": "parallel for reduction(+:sum) ", "hash": "c4effd8441f9abe7a57311ea0d8403da24560bb5e7a03273318a4f204e659ae3"}
{"code": "for (uint64_t i = 0; i < d->numParticles; i++) { \n                for(int k = 0; k<3; k++) { \n                        d->pos[i*3 + k] *= 1000; \n                } \n        }", "pragma": "parallel for ", "hash": "48e4b0ff14356d4be60ad088de84cfbc4162dcf514e75a78df5c46a6b7dd172f"}
{"code": "for (index = 0; index < count; index++) \n\t{ \n\t\tHash(256, (BitSequence *)saved_key[index], saved_key_length[index] * 8, (BitSequence *)crypt_out[index]); \n\t}", "pragma": "parallel for ", "hash": "a6c36e9be821df78be6cb3e34662be4ac50a7cc278897e518cb30901e9bd79e8"}
{"code": "for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    float DT_ALIGNED_PIXEL pi[3] = { points[i] + cx, points[i + 1] + cy, 1.0f }; \n    float DT_ALIGNED_PIXEL po[3]; \n    mat3mulv(po, (float *)ihomograph, pi); \n    points[i] = po[0] / po[2]; \n    points[i + 1] = po[1] / po[2]; \n  }", "pragma": "parallel for simd ", "hash": "2092e69953464c5c5bac2a5b1b54e2f004269200dbd98762450fd7bd88ea453b"}
{"code": "for(int i=0; i<bsize0; i++) \n        ptr[i] = 0;", "pragma": "parallel for ", "hash": "c29a5477f0f53daa85226679375f9dc62b8a3bca1ebdcbcd98ac576766f0f250"}
{"code": "for (i = 0; i < count; i++) \n      new_map[i] = less_op((T2)map[i]);", "pragma": "parallel for ", "hash": "8f05f7655a7cb7bb2b8c91060dfac9cbfe840f51059f315f4df11b75b348f29c"}
{"code": "for(long i=0;i<v->GetNx();i++) \n\t{ \n\t\tregister mreal v0 = v->v(i); \n\t\tmgl_cont_gen(gr,v0,&s.a,&s.x,&s.y,&s.z,gr->GetC(ss,v0),text,0); \n\t}", "pragma": "parallel for ", "hash": "3642abd15beb44b9f3dde217cad5443d11d47d6eb5b173715d8b049e90a4a3f8"}
{"code": "for (int i=0;i<actualCameraGridWidth*actualCameraGridHeight;i++) \n\t\t{\t \n\t\t\tif (blackCapturingMode[i]) \n\t\t\t\tmemset(cameraFrames[i],0,cameraFramesWidth[i]*cameraFramesHeight[i]*sizeof(unsigned char)); \n\t\t\telse \n\t\t\t\tcameras[i]->getCameraFrame(cameraFrames[i]); \n\t\t}", "pragma": "for ", "hash": "516799c01dad146d12d9fad3d66259d28fde4f25d9d21cfec30fe5da1fffec7f"}
{"code": "for(int y=0; y<height; y++) \n\t\t\t{ \n\t\t\t\tHistogram h(truncate,mode); \n\t\t\t\tfor(int x=0; x<width; x++) \n\t\t\t\t{ \n\t\t\t\t\th.clear(); \n\t\t\t\t\tconst uchar gg = guide.at<uchar>(y,x); \n\t\t\t\t\tfor(int j=0,idx=0; j<2*r+1; j++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tuchar* sp = src2.ptr<uchar>(y+j); sp+=x; \n\t\t\t\t\t\tuchar* gp = G.ptr<uchar>(y+j); gp+=x; \n\t\t\t\t\t\tfor(int i=0; i<2*r+1; i++,idx++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tfloat addval = luts[idx]; \n\t\t\t\t\t\t\tint diff = abs(gg-*gp); \n\t\t\t\t\t\t\taddval*= lutc[diff];\t \n\t\t\t\t\t\t\th.add(addval, *sp, metric); \n\t\t\t\t\t\t\tsp++; \n\t\t\t\t\t\t\tgp++; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t\tdst.at<uchar>(y,x) = h.returnVal(); \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "a9b76103dbc6483e9c0bdd253d59b80581508267fa70cfd8e497922c75252305"}
{"code": "for (size_t i = 0; i < gEstimators.size(); ++i) { \n        err_average += gEstimators.at(i)->err * gEstimators.at(i)->err; \n    }", "pragma": "parallel for reduction(+:err_average) ", "hash": "e434549329114b078d959800384b6f43a5b841385260b2ee2ce1257920fa974d"}
{"code": "for (size_t i = 1; i < size; ++i) { \n        minVal = std::min(minVal, data[i]); \n        maxVal = std::max(maxVal, data[i]); \n    }", "pragma": "parallel for reduction(min:minval) reduction(max:maxval) ", "hash": "da43a235c0b4bf022b9ea085801d9d35af91e89f09d4fecd79d9affa7bafb60a"}
{"code": "for (size_t i = 0; i < bic_scores.size(); i++) { \n        auto score = bic_scores[i]; \n        if (score.pscore > score.cscore) { \n            printf(\"\\nPart: %u will NOT split! pscore: %.4f > cscore: %.4f\\n\", \n                    score.pid, score.pscore, score.cscore); \n             \n \n            auto const& lmembers = memb_cltrs[score.lid]; \n            for (size_t i = 0; i < memb_cltrs[score.lid].size(); i++) \n               cluster_assignments[lmembers[i]] = score.pid; \n \n            auto const& rmembers = memb_cltrs[score.rid]; \n            for (size_t i = 0; i < memb_cltrs[score.rid].size(); i++) \n               cluster_assignments[rmembers[i]] = score.pid; \n \n             \n \n            cluster_assignment_counts[score.pid] = \n                cluster_assignment_counts[score.lid] + \n                        cluster_assignment_counts[score.rid]; \n \n             cluster_assignment_counts[score.lid] = \n                        cluster_assignment_counts[score.rid] = 0; \n \n             \n \n            deactivate(score.lid); deactivate(score.rid); \n             \n \n            deactivate(score.pid); \n            remove_cache->set(i, true); \n#pragma omp critical \n            { \n                ider->reclaim_id(score.lid); \n                ider->reclaim_id(score.rid); \n                final_centroids[score.pid] = std::vector<double>( \n                        cltrs->get_mean_rawptr(score.pid), \n                        cltrs->get_mean_rawptr(score.pid) + ncol); \n            } \n        } else { \n            printf(\"\\nPart: %u will split! pscore: %.4f <= cscore: %.4f\\n\", \n                    score.pid, score.pscore, score.cscore); \n        } \n    }", "pragma": "parallel for ", "hash": "a4c5d7a068f339dba4358ea8c187b808abc7b4aefd10888528d2169c8e20c935"}
{"code": "for (j=0; j<N; j++) \n        zd[j] = xd[j] - yd[j];", "pragma": "for ", "hash": "0c62d3dd8c999f762b1716bd11c7fb1630aa27dc89d96feca04f778b1db16bf6"}
{"code": "for(long i=0;i<nx;i++)\tu.a[i] = mgl_index_1(x1+(x2-x1)*i/(nx-1.),xxd,acx);", "pragma": "parallel for ", "hash": "39c6494ec5594e3707e3c8d8022915a5335c709e6c47b3b8a2a7e27fb47bbd71"}
{"code": "for (int ir = 0; ir < NR; ++ir) { \n      #pragma omp simd \n      for (int ic = 0; ic < NC; ++ic) { \n         double tmp = -2.5 * cos(3. * k_th.get(ir, ic)) * \n         boost::math::cyl_bessel_j(3, a0 * k_r.get(ir, ic)); \n         if (fabs(tmp) < pow(10, -14)) { \n            tmp = 0.0; \n         } \n         (*cs1).set(ir, ic, tmp); \n      } \n   }", "pragma": "parallel for ", "hash": "30b71e7ee47720f8b4519df55c9c97ba65a0d8af31741be8c8017febf6eee270"}
{"code": "for(size_t k = 0; k < height * width; k++) buffer[k] = 0.f;", "pragma": "parallel for simd ", "hash": "0fd28c32eb15ef9e15222dc65b12dc7d9b3c46fac57243537faff8eebdbc24c5"}
{"code": "for( int i = 0; i < kpts.size(); i++ ) \n                { \n                    Compute_Main_Orientation_SURF(kpts[i]); \n                    Get_MSURF_Descriptor_64(kpts[i]); \n                }", "pragma": "parallel for ", "hash": "7de16de2601f233133019dc2380535d599908a68ed043db3cef2d63a1ca2161e"}
{"code": "for(int j=1;j<argc;j++) \n    {\tprintf(\"%s %d\\n\",argv[j],omp_get_thread_num()); \n        readMesoData(argv[j]); \n    }", "pragma": "parallel for ", "hash": "b02ad2ad4384a45a2cf2a0974b88a262af2d28c526d9befe62e9b62f0d45c1ad"}
{"code": "for(index i = 0; i < mat->nbrows; i++) \n\t\t{ \n\t\t\tfor(index j = mat->browptr[i]; j < mat->browptr[i+1]; j++) \n\t\t\t\tiluvals[j] = scale[i]*mat->vals[j]*scale[mat->bcolind[j]]; \n\t\t}", "pragma": "parallel for ", "hash": "93c400eab587277c252f2172e40db74f353643e45354dcb1f9b2f67e212011f6"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp target simd  \n \n    for (int j = 0; j < 10; ++j) \n      ; \n  }", "pragma": "for ", "hash": "4a680f53a0b91b4492e08de674d3659764bb6f0ab3e944c6981b57f57214dbd7"}
{"code": "for(int iit=0; iit<objects.size(); iit++) { \n     Object **it= &(objects[iit]); \n     (*it)->doubleProperty[ckey]=(*f)((*it)->doubleProperty[ckey],(*it)->doubleProperty[a1],(*it)->doubleProperty[a2]); \n    }", "pragma": "parallel for ", "hash": "575370c85220d77a3a5f3c696e647fb0b0fe03b9025e999cfdb51e8a85c1bab4"}
{"code": "for(i = 0; i < k; ++i) { \n      for(j = 1, p = i + k, sum = C[i]; j < maxthreads; ++j, p += k) { \n        sum += C[p]; \n      } \n      C[i] = sum; \n    }", "pragma": "parallel for private(   i j p sum)", "hash": "a7e23510164f2726f769541a53a4b8f1f93f0a95900d9ffbc5da9ebed1235e58"}
{"code": "for (i = 1; i < n+1; i++) { \n\t\t\t\tfor (j = 1; j < n+1; j++) { \n\t\t\t\t\tfor (k = 1; k < n+1; k++) { \n\t\t\t\t\t\ta1[i*size*size+j*size+k] = ( \n\t\t\t\t\t\t\t\ta0[i*size*size+(j-1)*size+k] + a0[i*size*size+(j+1)*size+k] + \n\t\t\t\t\t\t\t\ta0[(i-1)*size*size+j*size+k] + a0[(i+1)*size*size+j*size+k] + \n\t\t\t\t\t\t\t\ta0[(i-1)*size*size+(j-1)*size+k] + a0[(i-1)*size*size+(j+1)*size+k] + \n\t\t\t\t\t\t\t\ta0[(i+1)*size*size+(j-1)*size+k] + a0[(i+1)*size*size+(j+1)*size+k] + \n \n\t\t\t\t\t\t\t\ta0[i*size*size+(j-1)*size+(k-1)] + a0[i*size*size+(j+1)*size+(k-1)] + \n\t\t\t\t\t\t\t\ta0[(i-1)*size*size+j*size+(k-1)] + a0[(i+1)*size*size+j*size+(k-1)] + \n \n\t\t\t\t\t\t\t\ta0[i*size*size+(j-1)*size+(k+1)] + a0[i*size*size+(j+1)*size+(k+1)] + \n\t\t\t\t\t\t\t\ta0[(i-1)*size*size+j*size+(k+1)] + a0[(i+1)*size*size+j*size+(k+1)] + \n \n\t\t\t\t\t\t\t\ta0[i*size*size+j*size+(k-1)] + a0[i*size*size+j*size+(k+1)] \n\t\t\t\t\t\t) * fac; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "for private(j k)", "hash": "a08aef622648693c8fa73b2a033aa7714a396c364b800f7d394e15ff0878eb2c"}
{"code": "for (i = -3; i < 119; i += 2) \n    { \n      ++s; \n      #pragma omp taskgroup \n      { \n #pragma omp task in_reduction (+: t) \n\t  ++t; \n\tif ((a[i + 4] % 11) == 9) \n\t  v = i; \n\telse \n\t  ++r; \n      } \n    }", "pragma": "for reduction( +:r s) reduction( +: t task) private(conditional: v)", "hash": "ad1ee3db2ed3fbeccae19cd2068b7d109b5d202044b3d10529ec0f9d6a185648"}
{"code": "for(int sy = 0; sy < syMax; ++sy) \n            { \n                for(int sx = 0; sx < sxMax; ++sx) \n                { \n                    int index = startIndex[c] + sy * sxMax + sx; \n                    float bestDepth = std::numeric_limits<float>::max(); \n                    float bestScore = 0; \n                    float bestSimScore = 0; \n                    int bestX = 0; \n                    int bestY = 0; \n                    for(int y = sy * step, ymax = std::min((sy+1) * step, height); \n                        y < ymax; ++y) \n                    { \n                        for(int x = sx * step, xmax = std::min((sx+1) * step, width); \n                            x < xmax; ++x) \n                        { \n                            const std::size_t index = y * width + x; \n                            const float depth = depthMap[index]; \n                            if(depth <= 0.0f) \n                                continue; \n \n                            int numOfModals = 0; \n                            const int scoreKernelSize = 1; \n                            for(int ly = std::max(y-scoreKernelSize, 0), lyMax = std::min(y+scoreKernelSize, height-1); ly < lyMax; ++ly) \n                            { \n                                for(int lx = std::max(x-scoreKernelSize, 0), lxMax = std::min(x+scoreKernelSize, width-1); lx < lxMax; ++lx) \n                                { \n                                    if(depthMap[ly * width + lx] > 0.0f) \n                                    { \n                                        numOfModals += 10 + int(numOfModalsMap[ly * width + lx]); \n                                    } \n                                } \n                            } \n                            float sim = simMap[index]; \n                            sim = sim < 0.0f ?  0.0f : sim;  \n \n                             \n \n                             \n \n                            const float simScore = 1.0f + sim * params.simFactor; \n \n                            const float score = numOfModals + (1.0f / simScore); \n                            if(score > bestScore) \n                            { \n                                bestDepth = depth; \n                                bestScore = score; \n                                bestSimScore = simScore; \n                                bestX = x; \n                                bestY = y; \n                            } \n                        } \n                    } \n                    if(bestScore < 3*13) \n                    { \n                         \n \n                        pixSizePrepare[index] = -1.0; \n                    } \n                    else \n                    { \n                        Point3d p = mp->CArr[c] + (mp->iCamArr[c] * Point2d((float)bestX, (float)bestY)).normalize() * bestDepth; \n                         \n                         \n \n                        if(voxel == nullptr || mvsUtils::isPointInHexahedron(p, voxel))  \n                        { \n                            verticesCoordsPrepare[index] = p; \n                            simScorePrepare[index] = bestSimScore; \n                            pixSizePrepare[index] = mp->getCamPixelSize(p, c); \n                        } \n                        else \n                        { \n                             \n \n                             \n \n                            pixSizePrepare[index] = -1.0; \n                        } \n                    } \n                } \n            }", "pragma": "parallel for ", "hash": "489be7aaf7b5e18fd30832d28d69a4c83678b436364db82ca890a6ad76ac089d"}
{"code": "for (i = 0; i < nlocal; i++) { \n       const int ibody = body[i]; \n       if (ibody < 0) continue; \n \n       double unwrap[3]; \n       domain->unmap(x[i],xcmimage[i],unwrap); \n       const double dx = unwrap[0] - xcm[0][0]; \n       const double dy = unwrap[1] - xcm[0][1]; \n       const double dz = unwrap[2] - xcm[0][2]; \n \n       s0 += f[i].x; \n       s1 += f[i].y; \n       s2 += f[i].z; \n \n       s3 += dy*f[i].z - dz*f[i].y; \n       s4 += dz*f[i].x - dx*f[i].z; \n       s5 += dx*f[i].y - dy*f[i].x; \n \n       if (extended && (eflags[i] & TORQUE)) { \n\t s3 += torque_one[i][0]; \n\t s4 += torque_one[i][1]; \n\t s5 += torque_one[i][2]; \n       } \n     }", "pragma": "parallel for reduction(+:s0 s1 s2 s3 s4 s5) private(i)", "hash": "044039708e7b4bdc2bd4a6fff08b71761e89b4108c41194369a2ec900674e519"}
{"code": "for(index irow = 0; irow < mat.nbrows; irow++) \n\t\tdblks[irow] = vals[mat.diagind[irow]].inverse();", "pragma": "parallel for ", "hash": "a82ff4350c963e4bb04775a89d51c6de49d5b1c8d9d6922ae889735867a0664f"}
{"code": "for (i = a_nlocalverts + 1; i <= b_nlocalverts; ++i) { \n    b->rowstarts[i] += a_nlocaledges; \n  }", "pragma": "parallel for ", "hash": "363de5b65458acae69e6c0465fde55685c757dc7384bf3a26896ab446fa26e44"}
{"code": "for (int rotateY = 0; rotateY < rotateH; ++rotateY) { \n\t\t\trotateToLine(rotateY); \n\t\t}", "pragma": "parallel for ", "hash": "f4195a23d83c070dc804a238457d539f1e7c13f2355aa14f30ad6e2e6ce3153c"}
{"code": "for (unsigned int i=0; i < n; i++) { \n\t\t\tif (addends[i] != 0){ \n\t\t\t\tunsigned long int new_tails = flipCoinsUntilHeads(r); \n \n\t\t\t\t \n \n\t\t\t\t#ifdef __GNUC__ \n\t\t\t\t{ \n\t\t\t\t\t \n \n\t\t\t\t\twhile (1) { \n\t\t\t\t\t\tunsigned long int curr_tails = max_tails; \n\t\t\t\t\t\tif (new_tails > curr_tails) { \n\t\t\t\t\t\t\tif (__sync_bool_compare_and_swap(&max_tails, curr_tails, new_tails)) { \n\t\t\t\t\t\t\t\tbreak;     \n \n\t\t\t\t\t\t\t}; \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\t#else \n\t\t\t\t{ \n     #pragma omp critical (max_tails) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif (new_tails > max_tails) { \n\t\t\t\t\t\t\tmax_tails = new_tails; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\t#endif \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "82e265a2cb6cd9634dddae91fd3947a2c4b2639bdf69f1f570e85105826a377d"}
{"code": "for( int j = 0 ; j < train_num ; j++ ) \n    { \n        pcl::PointCloud<PointT>::Ptr full_cloud(new pcl::PointCloud<PointT>()); \n        pcl::io::loadPCDFile(file_names[j], *full_cloud); \n         \n \n        if( full_cloud->size() > 30 ) \n        { \n             \n \n            std::cerr << \"Processing (\" << j + 1 << \"/\" << train_num <<\")\\n\"; \n             \n            spPooler triple_pooler; \n            if (use_sift_) triple_pooler.init(full_cloud, *hie_producer, radius_, down_ss_); \n            else triple_pooler.lightInit(full_cloud, *hie_producer, radius_, down_ss_); \n             \n            if (use_shot_) triple_pooler.build_SP_LAB(lab_pooler_set, false); \n            if (use_fpfh_) triple_pooler.build_SP_FPFH(fpfh_pooler_set, radius_, false); \n            if (use_sift_) triple_pooler.build_SP_SIFT(sift_pooler_set, *hie_producer, sift_det_vec, false); \n             \n            for( int ll = 0 ; ll <= order_ ; ll++ ) \n            { \n                std::vector<cv::Mat> sp_fea = triple_pooler.sampleSPFea(ll, box_num, false, true); \n                for( std::vector<cv::Mat>::iterator it = sp_fea.begin(); it < sp_fea.end() ; it++ ) \n                { \n                    if( train_dim > 0 && it->cols != train_dim ) \n                    { \n                        std::cerr << \"Error: fea_dim > 0 && cur_final.cols != fea_dim   \" << train_dim << \" \" << it->cols << std::endl; \n                        exit(0); \n                    } \n                    else if( train_dim < 0 ) \n                    { \n                        #pragma omp critical \n                        { \n                            train_dim = it->cols; \n                            std::cerr << \"Fea Dim: \" << train_dim << std::endl; \n                        } \n                    }     \n                    std::vector< sparseVec> this_sparse; \n                    sparseCvMat(*it, this_sparse); \n                    #pragma omp critical \n                    { \n                        final_fea[ll].push_back(this_sparse[0]); \n                    } \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "c2a3b17b623a7174a25894b8e8d57c28692e5379b3cbb6986e2e4aa7dfe4d855"}
{"code": "for(uint32_t j = 0; j < ht; j++) \n  { \n    uint8_t *out2 = out + bpp * wd * j; \n    const uint8_t *in2 = in + bpp * (iw * jj + ii + sj * (int32_t)(scale * j)); \n    float stepi = 0.0f; \n    for(uint32_t i = 0; i < wd; i++) \n    { \n      const uint8_t *in3 = in2 + ((int32_t)stepi) * si * bpp; \n       \n \n       \n \n       \n \n       \n \n      if(in3 + offm >= in && in3 + offM < in + bpp * iw * ih) \n      { \n        for(int k = 0; k < 3; k++) \n          out2[k] =  \n \n              CLAMP(((int32_t)in3[bpp * half_pixel * sj + k] + (int32_t)in3[bpp * half_pixel * (si + sj) + k] \n                     + (int32_t)in3[bpp * half_pixel * si + k] + (int32_t)in3[k]) \n                        / 4, \n                    0, 255); \n      } \n      out2 += bpp; \n      stepi += scale; \n    } \n  }", "pragma": "parallel for ", "hash": "fda7634cd8f9e9986178491056c13088b188c4d9448a7b38932bac56fe0e00f4"}
{"code": "for (index_type i = 0; i < size; ++i) { \n        const index_type orb = startMO + i; \n        const double QAii2 = this->calcQA_ii(C, orb); \n        G += QAii2; \n    }", "pragma": "parallel for reduction(+: g) ", "hash": "e5866f6ef8c7ef55ca8ada40bf9edffd614254dd2a5e09c25078e112d995922e"}
{"code": "for(size_t k = 0; k < nfloats; k++) \n      buf[k] *= mul_value;", "pragma": "parallel for simd ", "hash": "c8112b5e554eef89f9de3d8a17e7a6f534e76772c3ce3ea29d30c750e750bba0"}
{"code": "for (int k = 0; k <= variable_setup.ND-1; k++)\tV[variable_setup.NS+k]\t= u[k];", "pragma": "parallel for ", "hash": "2a8bdb16222f481f369f9d96d75a385830c4e3486dca29effb08ff90db91eae8"}
{"code": "for (ix=0; ix < nxb; ix++) { \n\t\tfor (iz=0; iz < nzb; iz++) { \n\t\t\tvp_1[ix][iz] = 0.; \n\t\t\tvp_2[ix][iz] = 0.; \n\t\t\tvx_1[ix][iz] = 0.; \n\t\t\tvx_2[ix][iz] = 0.; \n\t\t\tvz_1[ix][iz] = 0.; \n\t\t\tvz_2[ix][iz] = 0.; \n \n\t\t\ttpxx_1[ix][iz] = 0.; \n\t\t\ttpxx_2[ix][iz] = 0.; \n\t\t\ttpzz_1[ix][iz] = 0.; \n\t\t\ttpzz_2[ix][iz] = 0.; \n\t\t\ttxx[ix][iz] = 0.; \n\t\t\ttzz[ix][iz] = 0.; \n\t\t\ttxz_1[ix][iz] = 0.; \n\t\t\ttxz_2[ix][iz] = 0.; \n \n\t\t\tdatx[ix][iz] = 0.; \n\t\t\tdatz[ix][iz] = 0.; \n\t\t\tdatpx[ix][iz] = 0.; \n\t\t\tdatpz[ix][iz] = 0.; \n\t\t\tdatsx[ix][iz] = 0.; \n\t\t\tdatsz[ix][iz] = 0.; \n\t\t} \n\t}", "pragma": "parallel for private(ix iz)", "hash": "bd75d398fd94db6e3ea00fc87568f6c12d63fadcabe32ce49e6bd337bb47fcf2"}
{"code": "for (long iter = 0; iter < iters; iter++) { \n\t\t\tgbg[iter]++; \n\t\t}", "pragma": "parallel for ", "hash": "2b98dc48dc7d97a035603deee1a6e6466ff7285a588477bf010acbe07711294d"}
{"code": "for(chunk = 0; chunk < SPM_NCHUNKS(mat); chunk++) { \n            localMat->chunkLen[chunk] = 0; \n            remoteMat->chunkLen[chunk] = 0; \n            localMat->chunkLenPadded[chunk] = 0; \n            remoteMat->chunkLenPadded[chunk] = 0; \n            localMat->chunkMin[chunk] = 0; \n            remoteMat->chunkMin[chunk] = 0; \n        }", "pragma": "parallel for ", "hash": "faae3e582700ce39e924f306c2e4cccaa970db65bdff87d0c4cda66bc6ca5b56"}
{"code": "for ( int cellIndex = 0; cellIndex < static_cast<int>( source->size() ); cellIndex++ ) \n    { \n        ( *destination )[cellIndex] = ( *source )[cellIndex]; \n    }", "pragma": "parallel for ", "hash": "85e21da2697c877ea4736987ca5958e230ac71164be7ab51c3efac9c5dfcd652"}
{"code": "for(fint ied = m->gDomFaceStart(); ied < m->gDomFaceEnd(); ied++) \n\t{ \n\t\tconst fint ielem = m->gintfac(ied,0); \n\t\tconst fint jelem = m->gintfac(ied,1); \n \n\t\tfor(int i = 0; i < nvars; i++) \n\t\t{ \n\t\t\tconst scalar deltam = computeBiasedDifference(ri+ielem*NDIM, ri+jelem*NDIM, \n\t\t\t                                              u(ielem,i), u(jelem,i), &grads[ielem](0,i)); \n\t\t\tconst scalar deltap = computeBiasedDifference(ri+ielem*NDIM, ri+jelem*NDIM, \n\t\t\t                                              u(ielem,i), u(jelem,i), &grads[jelem](0,i)); \n\t\t\t \n\t\t\tscalar phi_l = (2.0*deltam * (u(jelem,i) - u(ielem,i)) + eps)  \n\t\t\t\t/ (deltam*deltam + (u(jelem,i) - u(ielem,i))*(u(jelem,i) - u(ielem,i)) + eps); \n \n\t\t\tif( phi_l < 0.0) phi_l = 0.0; \n \n\t\t\tscalar phi_r = (2*deltap * (u(jelem,i) - u(ielem,i)) + eps)  \n\t\t\t\t/ (deltap*deltap + (u(jelem,i) - u(ielem,i))*(u(jelem,i) - u(ielem,i)) + eps); \n \n\t\t\tif( phi_r < 0.0) phi_r = 0.0; \n \n\t\t\tufl(ied,i) = musclReconstructLeft(u(ielem,i), u(jelem,i), deltam, phi_l); \n\t\t\tufr(ied,i) = musclReconstructRight(u(ielem,i), u(jelem,i), deltap, phi_r); \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "062fd87b5f4444dd35911281b93e66cdbb1dd5f62f876c31d8079498fc52730d"}
{"code": "for(i=0; i<n; i++){ \n            for(j=0; j<m; j++){ \n                k=i*m+j; \n                if(_geno_mkl[k]<1e5) _geno_mkl[k]*=sd_SNP[j]; \n                else _geno_mkl[k]=0.0; \n            } \n        }", "pragma": "parallel for private( j k)", "hash": "8436a931da0975a06fdf56cdb55ed237ba5aeee8b515315d3fb06e4927f60330"}
{"code": "for (int row = 0; row < out->rows(); row++) { \n    temp_row.head(half_size) = \n          out->row(row).segment(1, half_size).reverse(); \n      temp_row.segment(half_size, image.cols()) = out->row(row); \n      temp_row.tail(half_size) = \n          out->row(row) \n          .segment(image.cols() - 1 - half_size, half_size) \n          .reverse(); \n \n       \n \n       \n \n      out->row(row) = kernel_x(0) * temp_row.head(image.cols()); \n      for (int i = 1; i < full_size; i++) { \n        out->row(row) += kernel_x(i) * temp_row.segment(i, image.cols()); \n      } \n    }", "pragma": "parallel for private(temp_row)", "hash": "f3cff6433873384702695e921272ef603fa6d45b6e289b10a88eee22366f7122"}
{"code": "for(j=0; j<J; j++) { \n\t    thread_id = omp_get_thread_num(); \n\t    thread_id = 0; \n \n             \n \n            for(i=0; i<p_it_mif->length; i++) { \n                for(k=0; k< routers[p_it_mif->ind[i]]->n_gp; k++) { \n                    offset = p_it_mif->offset[i]+k; \n \n                    if(p_best->is_estimated[offset]) { \n                        gsl_vector_set(J_theta[j], offset, gsl_vector_get(J_theta_tmp[j], offset) + gsl_ran_gaussian(calc[thread_id]->randgsl, sd_fac*sqrt(gsl_matrix_get(p_best->var, offset, offset))));  \n \n                    } else { \n                        gsl_vector_set(J_theta[j], offset, gsl_vector_get(J_theta_tmp[j], offset));  \n \n                    } \n                } \n            } \n \n             \n \n            for(i=0; i<p_it_fls->length; i++) { \n                for(k=0; k< routers[p_it_fls->ind[i]]->n_gp; k++) { \n                    offset = p_it_fls->offset[i]+k; \n                    gsl_vector_set(J_theta[j], offset, gsl_vector_get(J_theta_tmp[j], offset));  \n \n                } \n            } \n        }", "pragma": "parallel for private(   i k offset thread_id)", "hash": "05971d6e1969c95b7d4f5175e7dbf6f4e667fefe5b002c1c3b5569fc6864ecae"}
{"code": "for (long i=0; i<size; i++){ \n\t\tconst shared_ptr<Body> b=(*bodies)[i]; \n\t\tif (b->shape->getClassIndex()!=Sphere::getClassIndexStatic() || !b) continue;\t \n\t\tauto* thState = b->state.get(); \n       \t\tif (!thState->Tcondition) { \n\t\t\tthState->temp += delT; \n        \t} \n\t}", "pragma": "parallel for ", "hash": "c48addc35a459766d1635a2cedf405eecc872287a820e9858079e0a80cba50cd"}
{"code": "for (int i = 0; i < 20; ++i) \n    { \n         \n \n        report(i); \n    }", "pragma": "parallel for ", "hash": "80dd978aa8503d707982a33045e5a10924c69d3b45dc668a63ecc97d1d7650a4"}
{"code": "for(size_t i=0;i<compute_shells.size();i++) { \n    size_t ish=compute_shells[i]; \n \n     \n \n    arma::vec shf=shells[ish].eval_func(x,y,z); \n     \n \n    size_t f0=shells[ish].get_first_ind(); \n \n     \n \n    for(size_t fi=0;fi<shells[ish].get_Nbf();fi++) { \n      ret(f0+fi)=shf(fi); \n    } \n  }", "pragma": "parallel for ", "hash": "3d4032b8f036df26a3f759580f19df77fa4ef5db392eb7c6b2c41b3e902f40d4"}
{"code": "for (int j = 0; j < edges[i].colorDisplacement.size(); ++j) \n\t\t\t\tcolors[eData[i].cPtr + j] = convertToRGB(edges[i].colorDisplacement[j]);", "pragma": "parallel for ", "hash": "b0b8710a3b47719b17c7db033345355e0e0ea316e79d3846fe1560b938d58304"}
{"code": "for (i = 0; i < tmp->nblocks ; i++) {  \n\t\t\ttbp = &(tmp->tri_block[i]); \n\t\t\tTbp = tbp; \n\t\t\tif (tbp->npnt == 0)  \n\t\t\t\tcontinue; \n \n\t\t\tsubret = _NhlCtcica(tbp->rpnt,tbp->iedg,tbp->itri, \n\t\t\t\t\t    cnp->fws,cnp->iws,cnp->cws, \n\t\t\t\t\t    msize,msize,nsize, \n\t\t\t\t\t    bbox.l,bbox.b,bbox.r,bbox.t, \n\t\t\t\t\t    min_cell_size, \n\t\t\t\t\t    cnp->raster_smoothing_on, \n\t\t\t\t\t    fill_op, \n\t\t\t\t\t    (void *) tbp, \n\t\t\t\t\t    entry_name); \n\t\t}", "pragma": "for ", "hash": "5a17842fa64828c3f86131937f6ef1908314e2a2de1e390a05ff0d57619ea7a4"}
{"code": "for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        for (m = 0; m < 5; m++) { \n          forcing[k][j][i][m] = 0.0; \n        } \n      } \n    } \n  }", "pragma": "for ", "hash": "25e99b400daa374725365b06b7986dd9da75b4b44c6ca437fb97df18152a846d"}
{"code": "for (i = 0; i < d->wake->n_nodes(); i++) \n                        local_wake_velocities[i] = velocity(d->wake->nodes[i]);", "pragma": "for ", "hash": "0983cb73d1fb951a5fdc6151ac4436bf67502ec149c5cff540f6092338a3a477"}
{"code": "for(fint i = m->gnelem(); i < m->gnelem()+m->gnConnFace(); i++) { \n\t\t\tygr[i] = 0; \n\t\t}", "pragma": "parallel for simd ", "hash": "8b65c12ea237a35d665ef013abdafb589becfc24742cfb46a2345bc158e3d77b"}
{"code": "for (int index = 0; index < data_manager->num_rigid_contacts; index++) { \n    real3 U = norm[index], V, W; \n    real3 T3, T4, T5, T6, T7, T8; \n    real3 TA, TB, TC; \n    real3 TD, TE, TF; \n    Orthogonalize(U, V, W); \n    int2 body_id = ids[index]; \n \n    int row = index; \n     \n \n    Compute_Jacobian(rot[body_id.x], U, V, W, ptA[index] - pos_data[body_id.x], T3, T4, T5); \n    Compute_Jacobian(rot[body_id.y], U, V, W, ptB[index] - pos_data[body_id.y], T6, T7, T8); \n \n     \n \n    SetRow6(D_n_T, row * 1 + 0, body_id.x * 6, -U, T3); \n    SetRow6(D_n_T, row * 1 + 0, body_id.y * 6, U, -T6); \n \n    if (solver_mode == SLIDING || solver_mode == SPINNING) { \n      SetRow6(D_t_T, row * 2 + 0, body_id.x * 6, -V, T4); \n      SetRow6(D_t_T, row * 2 + 1, body_id.x * 6, -W, T5); \n \n      SetRow6(D_t_T, row * 2 + 0, body_id.y * 6, V, -T7); \n      SetRow6(D_t_T, row * 2 + 1, body_id.y * 6, W, -T8); \n    } \n \n    if (solver_mode == SPINNING) { \n      Compute_Jacobian_Rolling(rot[body_id.x], U, V, W, TA, TB, TC); \n      Compute_Jacobian_Rolling(rot[body_id.y], U, V, W, TD, TE, TF); \n \n      SetRow3(D_s_T, row * 3 + 0, body_id.x * 6 + 3, -TA); \n      SetRow3(D_s_T, row * 3 + 1, body_id.x * 6 + 3, -TB); \n      SetRow3(D_s_T, row * 3 + 2, body_id.x * 6 + 3, -TC); \n \n      SetRow3(D_s_T, row * 3 + 0, body_id.y * 6 + 3, TD); \n      SetRow3(D_s_T, row * 3 + 1, body_id.y * 6 + 3, TE); \n      SetRow3(D_s_T, row * 3 + 2, body_id.y * 6 + 3, TF); \n    } \n  }", "pragma": "parallel for ", "hash": "a49e1b357ccad49304e816a2a2e67400f2e46e68abcb7856f22869cf510b3848"}
{"code": "for (i = 0; i < N; i++) \n    xd[i] *= a;", "pragma": "parallel for private(i)", "hash": "65a6e8de334824a753e74737422a947b2023e13cdd08061508563daaa8c84eb2"}
{"code": "for (size_t i = 0; i < s; ++i){ \n\t\t\tstd::deque<std::tuple<L,U, size_t>>r = flatMapFunc(d[i], this->localData->getLineSizes()[i]); \n \n\t\t\tresultList.insert(resultList.end(), partResultList.begin(), partResultList.end() ); \n\t\t}", "pragma": "for ", "hash": "c0572f4d6cc3adde3e888b9140e219eb2cc6f07901ba717093f4a90d8991a103"}
{"code": "for(int col = 0; col < num_columns; col += 1 ) \n        { \n            const float t_cost = ground_cost(last_disparity, col); \n             \n \n            ground_cost.col(col).segment(last_disparity, segment_size).setConstant(t_cost); \n        }", "pragma": "parallel for ", "hash": "d6c5760ac9d9153c54a332ad2dbddadd807a8622f668f8b5bea8d6bd2ac90d78"}
{"code": "for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        float alpha = (mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) ? in[3] : 0.0f; \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = in[1] * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = d->table[(uint16_t)CLAMP((int)(0x10000ul * value), 0, 0xffff)]; \n        } \n      } \n    }", "pragma": "parallel for ", "hash": "d0ee91ad68729acc4bd5325947cda1252ade495fcd47a1f51097b7d231b21de9"}
{"code": "for(i = 0; i < n; i++) { \n      if(I[i] > ThreadMax) ThreadMax = I[i]; \n      if(I[i] < ThreadMin) ThreadMin = I[i]; \n    }", "pragma": "for private(i)", "hash": "e28d37f43e184286b8492dbaa9885133e2451663d4d95c95706d09c7891ac95b"}
{"code": "for (ii = 0; ii < ffdot->numzs; ii++) { \n            int jj; \n            float *fkern = (float *) shi->kern[ii].data; \n            float *fpdata = (float *) pdata; \n            float *fdata = (float *) tmpdat; \n            float *outpows = ffdot->powers[ii]; \n             \n \n             \n \n#pragma GCC ivdep \n            for (jj = 0; jj < fftlen * 2; jj += 2) { \n                const float dr = fpdata[jj], di = fpdata[jj + 1]; \n                const float kr = fkern[jj], ki = fkern[jj + 1]; \n                fdata[jj] = dr * kr + di * ki; \n                fdata[jj + 1] = di * kr - dr * ki; \n            } \n             \n \n            fftwf_execute_dft(invplan, (fftwf_complex *) tmpdat, \n                              (fftwf_complex *) tmpout); \n             \n \n             \n \n            fdata = (float *) tmpout; \n#pragma GCC ivdep \n            for (jj = 0; jj < ffdot->numrs; jj++) { \n                const int ind = 2 * (jj + offset); \n                outpows[jj] = (fdata[ind] * fdata[ind] + \n                               fdata[ind + 1] * fdata[ind + 1]) * norm; \n            } \n        }", "pragma": "for ", "hash": "302318948893e64a2b123b8f3d30a779666450767cbb910527fb07cc4bb9b3d9"}
{"code": "for (i=0;i<n;i++) { \n        acc.clear();  \n        for (j=0;j<n;j++) {  \n \n            if (j != i) {  \n \n                r = celas[j].p1 - celas[i].p1; \n                d = max(r.mag(), celas[j].r + celas[i].r); \n                acc += G * celas[j].m * r / (r.mag() * d * d); \n            } \n        } \n        celas[i].a *= (1 - omega); \n        celas[i].a += omega * acc; \n    }", "pragma": "parallel for private(acc d j r)", "hash": "deab91e8fa547511a8112b30917ac73dc8ae038356d0b2472d499bd2820f85e0"}
{"code": "for (int ip = 0; ip < otherphysicslist.size(); ++ip)   \n \n    { \n        ChPhysicsItem* PHpointer = otherphysicslist[ip]; \n        PHpointer->VariablesFbReset(); \n        PHpointer->ConstraintsBiReset(); \n    }", "pragma": "parallel for ", "hash": "f6f81f52ca3539e8137c2de1eef29ba120976c6dc6bb43352e8574ba8f3fab0c"}
{"code": "for(int i = 0; i < n; i++) \n        out[i] = Q3_Zel(k[i]);", "pragma": "parallel for ", "hash": "db17b0120d0f80a3932efc2c38d4bba74e2cf758ddb1e9b96a139917104bec6f"}
{"code": "for (i = 0; i < system->N; ++i) { \n      type_i = system->my_atoms[i].type; \n      if(type_i < 0) continue; \n      sbp_i = &(system->reax_param.sbp[type_i]); \n      val_i = sbp_i->valency; \n      Deltap_i = workspace->Deltap[i]; \n      Deltap_boc_i = workspace->Deltap_boc[i]; \n      start_i = Start_Index(i, bonds); \n      end_i = End_Index(i, bonds); \n \n      for (pj = start_i; pj < end_i; ++pj) { \n\tj = bonds->select.bond_list[pj].nbr; \n\ttype_j = system->my_atoms[j].type; \n\tif(type_j < 0) continue; \n\tbo_ij = &( bonds->select.bond_list[pj].bo_data ); \n \n\tif( i < j || workspace->bond_mark[j] > 3) { \n\t  twbp = &( system->reax_param.tbp[type_i][type_j] ); \n \n\t  if( twbp->ovc < 0.001 && twbp->v13cor < 0.001 ) { \n\t    bo_ij->C1dbo = 1.000000; \n\t    bo_ij->C2dbo = 0.000000; \n\t    bo_ij->C3dbo = 0.000000; \n\t \n\t    bo_ij->C1dbopi = bo_ij->BO_pi; \n\t    bo_ij->C2dbopi = 0.000000; \n\t    bo_ij->C3dbopi = 0.000000; \n\t    bo_ij->C4dbopi = 0.000000; \n\t \n\t    bo_ij->C1dbopi2 = bo_ij->BO_pi2; \n\t    bo_ij->C2dbopi2 = 0.000000; \n\t    bo_ij->C3dbopi2 = 0.000000; \n\t    bo_ij->C4dbopi2 = 0.000000; \n\t \n\t  } \n\t  else { \n\t    val_j = system->reax_param.sbp[type_j].valency; \n\t    Deltap_j = workspace->Deltap[j]; \n\t    Deltap_boc_j = workspace->Deltap_boc[j]; \n\t \n\t     \n \n\t    if( twbp->ovc >= 0.001 ) { \n\t       \n \n\t      exp_p1i = exp( -p_boc1 * Deltap_i ); \n\t      exp_p2i = exp( -p_boc2 * Deltap_i ); \n\t      exp_p1j = exp( -p_boc1 * Deltap_j ); \n\t      exp_p2j = exp( -p_boc2 * Deltap_j ); \n\t \n\t      f2 = exp_p1i + exp_p1j; \n\t      f3 = -1.0 / p_boc2 * log( 0.5 * ( exp_p2i  + exp_p2j ) ); \n\t      f1 = 0.5 * ( ( val_i + f2 )/( val_i + f2 + f3 ) + \n\t\t\t   ( val_j + f2 )/( val_j + f2 + f3 ) ); \n\t \n\t       \n \n\t       \n \n\t      temp = f2 + f3; \n\t      u1_ij = val_i + temp; \n\t      u1_ji = val_j + temp; \n\t      Cf1A_ij = 0.5 * f3 * (1.0 / SQR( u1_ij ) + \n\t\t\t\t    1.0 / SQR( u1_ji )); \n\t      Cf1B_ij = -0.5 * (( u1_ij - f3 ) / SQR( u1_ij ) + \n\t\t\t\t( u1_ji - f3 ) / SQR( u1_ji )); \n\t \n\t      Cf1_ij = 0.50 * ( -p_boc1 * exp_p1i / u1_ij - \n\t\t\t\t((val_i+f2) / SQR(u1_ij)) * \n\t\t\t\t( -p_boc1 * exp_p1i + \n\t\t\t\t  exp_p2i / ( exp_p2i + exp_p2j ) ) + \n\t\t\t\t-p_boc1 * exp_p1i / u1_ji - \n\t\t\t\t((val_j+f2) / SQR(u1_ji)) * \n\t\t\t\t( -p_boc1 * exp_p1i + \n\t\t\t\t  exp_p2i / ( exp_p2i + exp_p2j ) )); \n\t \n\t \n\t      Cf1_ji = -Cf1A_ij * p_boc1 * exp_p1j + \n\t\tCf1B_ij * exp_p2j / ( exp_p2i + exp_p2j ); \n\t    } \n\t    else { \n\t       \n \n\t      f1 = 1.0; \n\t      Cf1_ij = Cf1_ji = 0.0; \n\t    } \n \n\t    if( twbp->v13cor >= 0.001 ) { \n\t       \n \n\t      exp_f4 =exp(-(twbp->p_boc4 * SQR( bo_ij->BO ) - \n\t\t\t    Deltap_boc_i) * twbp->p_boc3 + twbp->p_boc5); \n\t      exp_f5 =exp(-(twbp->p_boc4 * SQR( bo_ij->BO ) - \n\t\t\t    Deltap_boc_j) * twbp->p_boc3 + twbp->p_boc5); \n\t \n\t      f4 = 1. / (1. + exp_f4); \n\t      f5 = 1. / (1. + exp_f5); \n\t      f4f5 = f4 * f5; \n\t \n\t       \n \n\t      Cf45_ij = -f4 * exp_f4; \n\t      Cf45_ji = -f5 * exp_f5; \n\t    } \n\t    else { \n\t      f4 = f5 = f4f5 = 1.0; \n\t      Cf45_ij = Cf45_ji = 0.0; \n\t    } \n\t \n\t     \n \n\t    A0_ij = f1 * f4f5; \n\t    A1_ij = -2 * twbp->p_boc3 * twbp->p_boc4 * bo_ij->BO * \n\t      (Cf45_ij + Cf45_ji); \n\t    A2_ij = Cf1_ij / f1 + twbp->p_boc3 * Cf45_ij; \n\t    A2_ji = Cf1_ji / f1 + twbp->p_boc3 * Cf45_ji; \n\t    A3_ij = A2_ij + Cf1_ij / f1; \n\t    A3_ji = A2_ji + Cf1_ji / f1; \n\t \n\t     \n \n\t    bo_ij->BO    = bo_ij->BO    * A0_ij; \n\t    bo_ij->BO_pi = bo_ij->BO_pi * A0_ij *f1; \n\t    bo_ij->BO_pi2= bo_ij->BO_pi2* A0_ij *f1; \n\t    bo_ij->BO_s  = bo_ij->BO - ( bo_ij->BO_pi + bo_ij->BO_pi2 ); \n\t \n\t    bo_ij->C1dbo = A0_ij + bo_ij->BO * A1_ij; \n\t    bo_ij->C2dbo = bo_ij->BO * A2_ij; \n\t    bo_ij->C3dbo = bo_ij->BO * A2_ji; \n\t \n\t    bo_ij->C1dbopi = f1*f1*f4*f5; \n\t    bo_ij->C2dbopi = bo_ij->BO_pi * A1_ij; \n\t    bo_ij->C3dbopi = bo_ij->BO_pi * A3_ij; \n\t    bo_ij->C4dbopi = bo_ij->BO_pi * A3_ji; \n\t \n\t    bo_ij->C1dbopi2 = f1*f1*f4*f5; \n\t    bo_ij->C2dbopi2 = bo_ij->BO_pi2 * A1_ij; \n\t    bo_ij->C3dbopi2 = bo_ij->BO_pi2 * A3_ij; \n\t    bo_ij->C4dbopi2 = bo_ij->BO_pi2 * A3_ji; \n\t  } \n\t \n\t   \n \n\t  if( bo_ij->BO < 1e-10 ) \n\t    bo_ij->BO = 0.0; \n\t  if( bo_ij->BO_s < 1e-10 ) \n\t    bo_ij->BO_s = 0.0; \n\t  if( bo_ij->BO_pi < 1e-10 ) \n\t    bo_ij->BO_pi = 0.0; \n\t  if( bo_ij->BO_pi2 < 1e-10 ) \n\t    bo_ij->BO_pi2 = 0.0; \n\t \n\t  workspace->total_bond_order[i] += bo_ij->BO;  \n \n\t} \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n\t \n \n\t \n \n      } \n \n    }", "pragma": "for ", "hash": "7018a0997a36b622fd337afcd21adb5afb53a979b834863429bca346e6379096"}
{"code": "for(int kw = 0; kw < WW_t; kw++){                    \n \n        libxsmm_meltw_unary_param trans_param_permute_1; \n        trans_param_permute_1.in.primary  = &flip_d_weight_a[kw*C_t*F_t]; \n        trans_param_permute_1.out.primary = &flip_weight_a[kw*C_t*F_t]; \n        trans_permute_1( &trans_param_permute_1 ); \n    }", "pragma": "parallel for ", "hash": "2eaf8b010c447f6eaa4e084de69f7efdad8cef8a388ac7f11a4d0a74e2d7b3fa"}
{"code": "for (j = 0; j < nColumns; ++j) \n           { \n                \n \n                \n \n               {unsigned i; \n               for (i = 0; i < nRows; ++i) \n                   model[i] = PixColumnMajor(input->sci.data,i,j); \n               } \n \n               traps = &(PixColumnMajor(trapPixelMap->sci.data, 0, j)); \n \n               if ((localStatus = simulateColumnReadout(model, traps, ctePars, cteRprof, cteCprof, nRows, ctePars->n_par))) \n               { \n                   setAtomicFlag(&runtimeFail); \n                   setAtomicInt(&status, localStatus); \n               } \n                \n \n                \n \n               {unsigned i; \n               for (i = 0; i < nRows; ++i) \n                   PixColumnMajor(output->sci.data, i, j) = model[i]; \n               } \n           }", "pragma": "for ", "hash": "ae7fb76374d913cfabc0bfdc0defe748f5a37f6e1221c5edc34804ceaf939a3b"}
{"code": "for( i = 0; i < nodes; ++i ) { \n        dxi = 0.; \n        dyi = 0.; \n         \n        px = xpos[i]; \n        py = ypos[i]; \n        for( j = i+1; j < nodes; ++j ) { \n          dx = px - xpos[j]; \n          dy = py - ypos[j]; \n          len = dx*dx + dy*dy; \n           \n           \n \n          if( len == 0. ) { \n            dx = rand() * 1e-9; \n            dy = rand() * 1e-9; \n            len = dx*dx + dy*dy; \n          } \n           \n          dxi += dx/len; \n          dyi += dy/len; \n          dx_local[j] -= dx/len; \n          dy_local[j] -= dy/len; \n        } \n        dx_local[i] += dxi; \n        dy_local[i] += dyi; \n      }", "pragma": "for ", "hash": "3e388915ab2090d5752ec797b3af575bec4cc52e32079f8a8bee4f25a54161de"}
{"code": "for (int i = 0; i < m_NumTrees; ++i) \n  { \n    std::shared_ptr< vigra::RandomForest<int> > lrf = std::make_shared< vigra::RandomForest<int> >(); \n    lrf->set_options().use_stratification(vigra::RF_NONE);  \n \n    lrf->set_options().sample_with_replacement(true);  \n \n    lrf->set_options().samples_per_tree(m_SampleFraction);  \n \n    lrf->set_options().tree_count(1);  \n \n    lrf->set_options().min_split_node_size(5);  \n \n    lrf->ext_param_.max_tree_depth = m_MaxTreeDepth; \n \n    lrf->learn(m_FeatureData, m_LabelData,vigra::rf::visitors::VisitorBase(),splitter); \n#pragma omp critical \n    { \n      count++; \n      MITK_INFO << \"Tree \" << count << \" finished training.\"; \n      trees.push_back(lrf); \n    } \n  }", "pragma": "parallel for ", "hash": "87707527b24478aa9ef54d719209942df24f2c6d40f40d4d3ee3a7e734334744"}
{"code": "for (int n = 1; n < s->Ns; n++)  \n\t\tfor (int i = 0; i < 2*s->Nd+1; i++) \n\t\t\trhs[i+n*(2*s->Nd+1)] = s->mesh->a[n] * rhs[i];", "pragma": "parallel for ", "hash": "13067940baacb80f3d0860899756b4133eb1e863396774e3ff6e01e35dd02feb"}
{"code": "for(UINT64 i = 1; i <= dataSet->size() ; i++)  \n \n\t{ \n\t\tif(dataSet->at(i)->isUsedRead()) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tUINT32 containedReads=dataSet->getRecursiveContainedReadCount(i); \n\t\t\tusedReads+=(containedReads + 1); \n\t\t} \n\t}", "pragma": "parallel for reduction(+:usedreads) ", "hash": "883f837d405be96df6959a61e2b8839ae328695b0e5123a075ec330d773af082"}
{"code": "for (int i = 0; i < boxes.size(); i++) \n\t{ \n\t\tboxes[i].setMortonCentroid(morton3D(boxes[i].centroid(), sceneSize, sceneCenter)); \n\t\tm_leafNodes[i].isLeaf = true; \n\t\tm_leafNodes[i].box = new AABBox(boxes[i]); \n\t}", "pragma": "parallel for ", "hash": "433e78c098c17be5a6a0d66a762b15f69c19a9b15796108500a21e8eabf7911d"}
{"code": "for (int p = 0; p < (signed)num_fea_nodes; p++) { \n            int start = contact_counts[p]; \n            int end = contact_counts[p + 1]; \n            for (int index = start; index < end; index++) { \n                int i = index - start;                                         \n \n                int rigid = neighbor_rigid_tet[p * max_rigid_neighbors + i];   \n \n                real rigid_coh = data_manager->host_data.cohesion_data[rigid]; \n                real rigid_mu = data_manager->host_data.fric_data[rigid].x; \n                real cohesion = data_manager->composition_strategy->CombineCohesion(rigid_coh, coh); \n                real friction = data_manager->composition_strategy->CombineFriction(rigid_mu, mu); \n \n                real3 gam; \n                gam.x = gamma[start_boundary_node + index]; \n                gam.y = gamma[start_boundary_node + num_rigid_tet_node_contacts + index * 2 + 0]; \n                gam.z = gamma[start_boundary_node + num_rigid_tet_node_contacts + index * 2 + 1]; \n \n                gam.x += cohesion; \n \n                real mu = friction; \n                if (mu == 0) { \n                    gam.x = gam.x < 0 ? 0 : gam.x - cohesion; \n                    gam.y = gam.z = 0; \n \n                    gamma[start_boundary_node + index] = gam.x; \n                    gamma[start_boundary_node + num_rigid_tet_node_contacts + index * 2 + 0] = gam.y; \n                    gamma[start_boundary_node + num_rigid_tet_node_contacts + index * 2 + 1] = gam.z; \n                    continue; \n                } \n \n                if (Cone_generalized_rnode(gam.x, gam.y, gam.z, mu)) { \n                } \n \n                gamma[start_boundary_node + index] = gam.x - cohesion; \n                gamma[start_boundary_node + num_rigid_tet_node_contacts + index * 2 + 0] = gam.y; \n                gamma[start_boundary_node + num_rigid_tet_node_contacts + index * 2 + 1] = gam.z; \n            } \n        }", "pragma": "parallel for ", "hash": "309a3046a731e6f9813e3a956da3fdbb5ca4e89e877e5c644e39a85d959f737d"}
{"code": "for (int g = 0; g < Ng; g++) { \n      #pragma omp simd \n      for (int v = 0; v < VLEN; v++) { \n        a[IDX2(v,g,VLEN)] = A_START; \n        b[IDX2(v,g,VLEN)] = B_START; \n        c[IDX2(v,g,VLEN)] = C_START; \n      } \n    }", "pragma": "for ", "hash": "4522baccfacc53bc7079064984b0ce1bded0ff9177cb1abfa0b2810101ef649c"}
{"code": "for (int ikappa=0; ikappa<nKappa; ikappa++){ \n      int dimL = denBK->gCurrentDim(index,sectorNL[ikappa],sectorTwoSL[ikappa],sectorIL[ikappa]); \n      int dimR = denBK->gCurrentDim(index+1,sectorNR[ikappa],sectorTwoSR[ikappa],sectorIR[ikappa]); \n      double * MxBlock = Mx->gStorage(sectorNR[ikappa],sectorTwoSR[ikappa],sectorIR[ikappa],sectorNR[ikappa],sectorTwoSR[ikappa],sectorIR[ikappa]); \n      char notrans = 'N'; \n      double one = 1.0; \n      double zero = 0.0; \n      int dim = dimL*dimR; \n      double * mem = new double[dim]; \n      dgemm_(&notrans,&notrans,&dimL,&dimR,&dimR,&one,storage+kappa2index[ikappa],&dimL,MxBlock,&dimR,&zero,mem,&dimL); \n      int inc = 1; \n      dcopy_(&dim,mem,&inc,storage+kappa2index[ikappa],&inc); \n      delete [] mem; \n   }", "pragma": "parallel for ", "hash": "dc377b9429c5c03a78ff826a67b348bfe9b8b99f1d3622f1c42fa20b7c5984c8"}
{"code": "for (i=0; i<ny; i++){ \n      unew[(nx-1)*npadded + i] = f[(nx-1)*npadded + i]; \n    }", "pragma": "for simd ", "hash": "f1def5b12ab14ac65530350547c7ae0001c9819f73142825c9b5261efede9b4f"}
{"code": "for (int i=0;i<nvecs;i++) { \n    for (int j=0;j<ndet;j++) \n      ninv_vecs[i][j]=vecs[i][j]*ninv[j]; \n  }", "pragma": "parallel for ", "hash": "97a2d8a419aa18cfa33b5327c3269c05aa7b5145b922415f64f8102e71800783"}
{"code": "for (i = 0; i < pyramid.nScales; i++)\r \n\tfor (int32_t i = 0; i < pyramid.nScales; i++)\r \n\t{\r \n\t\tif (epipolarLine > 0){\r \n\t\t\tshiftY = (detector.modelPadHt - detector.modelHt) / 2 - opt.pad.height;\r \n\t\t\tepipolarLine = pyramid.scalesHt[scaleindex] * epipolarLine - shiftY;\r \n\t\t}\r \n\r \n\t\tvector<DetectResult> r0;\r \n\t\tdetector.Detect(pyramid.data[i], opt.chnsOpt.shrink, r0, epipolarLine);\r \n\t\tshiftX = (detector.modelPadWd - detector.modelWd) / 2 - opt.pad.width;\r \n\t\tshiftY = (detector.modelPadHt - detector.modelHt) / 2 - opt.pad.height;\r \n\t\tfor (uint32_t j = 0; j < r0.size(); j++)\r \n\t\t{\r \n\t\t\tDetectResult r = r0[j];\r \n\t\t\tr.cs = (r.cs + shiftX) / pyramid.scalesWd[scaleindex];\r \n\t\t\tr.rs = (r.rs + shiftY) / pyramid.scalesHt[scaleindex];\r \n\t\t\tr.modelWd = detector.modelWd / pyramid.scales[scaleindex];\r \n\t\t\tr.modelHt = detector.modelHt / pyramid.scales[scaleindex];\r \n\t\t\tr.scaleindex = scaleindex;\r \n#pragma omp critical (result)\r \n\t\t\t{\r \n\t\t\t\tres.push_back(r);\r \n\t\t\t}\r \n\t\t}\r \n\t}", "pragma": "parallel for private(i)", "hash": "b8d744da7c43115aa01c28191c5be1b0ebd43bace148c5c4dc60eb0bd2f01f70"}
{"code": "for(j=0; j < hist_size; j++) { \n        float diff; \n        unsigned int match = nearest_search(n, &achv[j].acolor, achv[j].tmp.likely_colormap_index, &diff); \n        achv[j].tmp.likely_colormap_index = match; \n        total_diff += diff * achv[j].perceptual_weight; \n \n        viter_update_color(achv[j].acolor, achv[j].perceptual_weight, map, match, omp_get_thread_num(), average_color); \n \n        if (callback) callback(&achv[j], diff); \n    }", "pragma": "parallel for reduction(+:total_diff) ", "hash": "dcf0c8e772f2da7a383aeef1770ed61d8baeeb8e6158b0405cb08bc9c937151e"}
{"code": "for (ompIndexType i = 0; i < (ompIndexType)count; i++) { \n        dstPtr[i] = (TOUT)ptr[i]; \n    }", "pragma": "parallel for ", "hash": "e986749d4333e5bc4bfc872c03a4dcdc9ab5847d55919dcf513ad1e186e5e349"}
{"code": "for (int i=0; i<nr; i++) \n  { \n    for (int j=0; j<nc; j++) \n    { \n      float x = gau[0] * im_data[i*im->width + j];  \n      float y = gau[0] * im_data[i*im->width + j]; \n \n      for (int k=1; k<width; k++) \n      { \n        int I1 = (i+k)%nr;  \n        int I2 = (i-k+nr)%nr; \n        y += gau[k]*im_data[I1*im->width + j] + gau[k]*im_data[I2*im->width + j]; \n \n        I1 = (j+k)%nc;  \n        I2 = (j-k+nc)%nc; \n        x += gau[k]*im_data[i*im->width + I1] + gau[k]*im_data[i*im->width + I2]; \n      } \n \n      smx[i][j] = x;  \n      smy[i][j] = y; \n    } \n  }", "pragma": "parallel for ", "hash": "154be8f89bbdfd48503a044299015eace247a7328ed38dc60f8984820e46f683"}
{"code": "for(int i = 0; i < n_control_points; ++i ){ \n\t\tprev_w.col(i) = w.col(i); \n\t\tw.col(i) = initialvalue_solver.solve( L * (v.col(i) + d1.col(i) - a.col(i)) + y.col(i) + d3.col(i) + z.col(i) + d4.col(i) ); \n\t\tw_diff.col(i) = w.col(i) - prev_w.col(i); \n\t\tdual_residual_v.col(i) = L * w_diff.col(i); \n\t}", "pragma": "for ", "hash": "42a143c2d09947b1919eff86a972b875694062a1d945ef58c94108b06b39f413"}
{"code": "for(int i=0;i<A->a;++i) \n\t  for(int j=0;j<A->b;++j) \n\t    for(int k=0;k<A->c;++k) \n\t      for(int l=0;l<A->d;++l) \n\t\tif (inc) C->ptr[i]->ptr[j]->ptr2(k,l)+=A->ptr[i]->ptr[j]->ptr2(k,l)*B->ptr1(j); \n\t\telse  C->ptr[i]->ptr[j]->ptr2(k,l)=A->ptr[i]->ptr[j]->ptr2(k,l)*B->ptr1(j);", "pragma": "parallel for ", "hash": "daad2ca04f25e53b2013ccd62ae6a3c053ec82ee71ef47a8e59d31a214b2a117"}
{"code": "for (i = 0; i < nlocal; i++) { \n    dbl3_t xM; \n    int iH1,iH2; \n \n    if (type[i] == typeO) { \n      find_M_thr(i,iH1,iH2,xM); \n    } else { \n      xM = x[i]; \n    } \n \n     \n \n     \n \n     \n \n \n    const int nx = static_cast<int> ((xM.x-boxlox)*delxinv+shift) - OFFSET; \n    const int ny = static_cast<int> ((xM.y-boxloy)*delyinv+shift) - OFFSET; \n    const int nz = static_cast<int> ((xM.z-boxloz)*delzinv+shift) - OFFSET; \n \n    p2g[i].a = nx; \n    p2g[i].b = ny; \n    p2g[i].t = nz; \n \n     \n \n \n    if (nx+nlower < nxlo_out || nx+nupper > nxhi_out || \n        ny+nlower < nylo_out || ny+nupper > nyhi_out || \n        nz+nlower < nzlo_out || nz+nupper > nzhi_out) \n      flag++; \n  }", "pragma": "parallel for reduction(+:flag) private(i)", "hash": "82fe3346b6432068d9e8227ef0fc53d0b6390c9b7dd5b3f05274d1fb89ab8c82"}
{"code": "for (int p = 0; p < pc; p++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tconst int th = omp_get_thread_num(); \n \n\t\t\t\t\t\tif (th == 0) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tLog::updateProgress(p); \n\t\t\t\t\t\t} \n \n\t\t\t\t\t\tAberrationFit::considerParticle( \n\t\t\t\t\t\t\tparticles[t][p], tomogram, referenceMap, particleSet, \n\t\t\t\t\t\t\taberrationsCache, flip_value, freqWeights, doseWeight, \n\t\t\t\t\t\t\tf, f, \n\t\t\t\t\t\t\tevenData_thread[th], oddData_thread[th]); \n\t\t\t\t\t}", "pragma": "parallel for ", "hash": "739a94c0d691e69f9e31820255f21205598757d39a8e41c7ffd2f4d41412a842"}
{"code": "for (k = 0; k < nz; k++) { \n    for (j = 0; j < ny; j++) { \n      for (i = 0; i < nx; i++) { \n        for (m = 0; m < 5; m++) { \n          frct[k][j][i][m] = 0.0; \n        } \n      } \n    } \n  }", "pragma": "for ", "hash": "a8ba287bf60095cb86f03eb8e8c0ad6603f69732fef988e1297463b05ab697ad"}
{"code": "for (i = 0; i < imageSizeRef[box]; i++) { \n    sumReal = 0.0; \n    sumImaginary = 0.0; \n    dotProduct = 0.0; \n \n    for (p = 0; p < length; ++p) { \n      if(particleHasNoCharge[start + p]) { \n        continue; \n      } \n      dotProduct = Dot(p + start, kxRef[box][i], kyRef[box][i], kzRef[box][i], \n                       currentCoords); \n      sumReal += particleCharge[p + start] * cos(dotProduct); \n      sumImaginary += particleCharge[p + start] * sin(dotProduct); \n    } \n    for(s = 0; s < lambdaSize; s++) { \n       \n \n      coefDiff = sqrt(lambda_Coul[s]) - sqrt(lambda_Coul[iState]); \n      energyRecip[s] += prefactRef[box][i] * \n                        ((sumRref[box][i] + coefDiff * sumReal) * \n                         (sumRref[box][i] + coefDiff * sumReal) + \n                         (sumIref[box][i] + coefDiff * sumImaginary) * \n                         (sumIref[box][i] + coefDiff * sumImaginary)); \n    } \n  }", "pragma": "parallel for reduction(+:energyrecip[:lambdasize]) private(       coefdiff dotproduct i p s sumimaginary sumreal)", "hash": "2b0f5e4752b5250f87ed233843ace10d4b9798cc66c7fcd2f75efb025653ba4a"}
{"code": "for(int index = 0; index < npixels; index++) \n  { \n    out[index] = (0.3f * in[4*index+0] + 0.59f * in[4*index+1] + 0.11f * in[4*index+2]) * 256.0; \n  }", "pragma": "parallel for ", "hash": "8ec4090070296f5596177fbe7dbf4086e3554febc98fc4a31b841d2efe3153c3"}
{"code": "for (i2=0; i2<n2; i2++) { \n    for (i1=0; i1<n1; i1++) { \n      cc[i2][i1] = ((i2%2==0)==(i1%2==0))? inp[i2*n1+i1]:-inp[i2*n1+i1]; \n      cc[i2][i1] = ((i2%2==0)==(i1%2==0))? inp[i2*n1+i1]:sf_cneg(inp[i2*n1+i1]); \n    } \n  }", "pragma": "parallel for private(i1 i2)", "hash": "0576eeeaeb6dd8de58e125004932305f261a274c22862e8147ec71df4c797fdc"}
{"code": "for( size_t i = 0; i < m_baseNodes1.size(); ++i ) \n    { \n         \n \n        fileManagerFactory nodeFileMF1( m_meanTractFolder1 ); \n        fileManager& nodeFM1( nodeFileMF1.getFM() ); \n        nodeFM1.readAsLog(); \n        nodeFM1.readAsUnThres(); \n        fileManagerFactory nodeFileMF2( m_meanTractFolder2 ); \n        fileManager& nodeFM2( nodeFileMF2.getFM() ); \n        nodeFM2.readAsLog(); \n        nodeFM2.readAsUnThres(); \n \n         \n \n        WHcoord baseCoord1( m_baseCoords1[i] ); \n \n         \n \n        compactTract baseTract1; \n        nodeFM1.readNodeTract( m_baseNodes1[i], &baseTract1 ); \n        baseTract1.threshold( m_tractThreshold1 ); \n        baseTract1.computeNorm(); \n \n        for( size_t j = 0; j < m_baseNodes2.size(); ++j ) \n        { \n            float pDist( baseCoord1.getPhysDist( m_baseCoords2[j] ) ); \n            if( pDist > m_maxPhysDist && m_maxPhysDist > 0 ) \n            { \n                #pragma omp atomic \n                ++progCount; \n                continue;  \n \n            } \n \n            compactTract baseTract2; \n            nodeFM2.readNodeTract( m_baseNodes2[j], &baseTract2 ); \n            baseTract2.threshold( m_tractThreshold2 ); \n            baseTract2.computeNorm(); \n            baseDistMatrix[i][j] = baseTract1.tractDistance( baseTract2 ); \n        } \n \n        #pragma omp atomic \n        ++progCount; \n        #pragma omp single nowait  \n \n        if( m_verbose ) \n        { \n            time_t currentTime( time( NULL ) ); \n            if( currentTime - lastTime > 1 ) \n            { \n                lastTime = currentTime; \n                size_t currentCount( progCount ); \n                float progress = ( currentCount ) * 100. / ( m_baseNodes1.size() * m_baseNodes2.size() ); \n                size_t elapsedTime( difftime( currentTime, startTime ) ); \n                std::stringstream message; \n                message << \"\\r\" << ( int )progress << \" % completed. Expected remaining time: \"; \n                if( progress > 0 ) \n                { \n                    int expected_remain( difftime( currentTime, startTime ) * ( ( 100. - progress ) / progress ) ); \n                    message << expected_remain / 3600 << \"h \" << ( expected_remain % 3600 ) / 60 << \"' \" << ( ( expected_remain \n                                    % 3600 ) % 60 ) << \"\\\". \"; \n                } \n                message << \"Elapsed time: \"; \n                message << elapsedTime / 3600 << \"h \" << ( elapsedTime % 3600 ) / 60 << \"' \" << ( ( elapsedTime % 3600 ) % 60 ) \n                                << \"\\\". \"; \n                std::cout << message.str() << std::flush; \n            } \n        }  \n \n    }", "pragma": "parallel for ", "hash": "098e39ce089204e567ba6430e02e5b58f0f6cccbbf2f7ec1a4e10f9cfcb78d0e"}
{"code": "for (i=0; i < (ssize_t) image->colors; i++) \n    pixels[(ssize_t) image->colormap[i].opacity]=(unsigned short) i;", "pragma": "parallel for ", "hash": "e6c56d3bc7fb39876402731ae7a3a949c66b41f0563e4ccb39c8dbbeedefd56a"}
{"code": "for(int i=0;i<faces.rows();++i) { \n    auto vidx0 = faces(i, 0); \n    auto vidx1 = faces(i, 1); \n    auto vidx2 = faces(i, 2); \n \n    auto v0 = Vector3d(verts.row(vidx0)); \n    auto v1 = Vector3d(verts.row(vidx1)); \n    auto v2 = Vector3d(verts.row(vidx2)); \n \n    auto v0v1 = v1 - v0; \n    auto v0v2 = v2 - v0; \n    auto n = v0v1.cross(v0v2); \n    double area = n.norm(); \n \n    omp_set_lock(&writelock); \n    vertex_norms.row(vidx0) += n; \n    vertex_norms.row(vidx1) += n; \n    vertex_norms.row(vidx2) += n; \n \n    area_sum[vidx0] += area; \n    area_sum[vidx1] += area; \n    area_sum[vidx2] += area; \n    omp_unset_lock(&writelock); \n \n    n.normalize(); \n    norms.row(i) = n; \n  }", "pragma": "parallel for ", "hash": "7507586fe1d202ad20c2d07554c0ba2ac2b2dae2c77357264e488e4cbb7e683f"}
{"code": "for (unsigned int i = 0; i < X[j].size(); ++i) \n      for (unsigned int k = 0; k < K; ++k) \n      { \n        double LL = qZ[j][i].col(k).dot(clusters_k[k].Eloglike(X[j][i])); \n \n        #pragma omp atomic \n        ord[k].Fk -= LL; \n      }", "pragma": "parallel for ", "hash": "e2a7d779c772648dd632d4c5f9bf64d517696e4f1e7e39c1b947056b6a122fa8"}
{"code": "for (int yTile = 0; yTile < in.height(); yTile += 128) { \n            __m128i tmp[1024*4];  \n \n            for (int y = -2; y < 128; y++) { \n                 \n \n                __m128i *outPtr = (__m128i *)(&(out(0, yTile + y))); \n                 \n \n                const uint16_t *inPtr = &(in(0, yTile + y + 2)); \n                 \n \n                 \n \n                __m128i *tmpPtr0 = tmp + ((y+4) & 3) * vw; \n                __m128i *tmpPtr1 = tmp + ((y+3) & 3) * vw; \n                __m128i *tmpPtr2 = tmp + ((y+2) & 3) * vw; \n                for (int x = 0; x < vw; x++) { \n                     \n \n                    __m128i val = _mm_load_si128((__m128i *)(inPtr)); \n                    val = _mm_add_epi16(val, _mm_loadu_si128((__m128i *)(inPtr+1))); \n                    val = _mm_add_epi16(val, _mm_loadu_si128((__m128i *)(inPtr+2))); \n                    val = _mm_mulhi_epi16(val, one_third); \n                    _mm_store_si128(tmpPtr0++, val); \n \n                     \n \n                    if (y >= 0) { \n                        val = _mm_add_epi16(val, _mm_load_si128(tmpPtr1++)); \n                        val = _mm_add_epi16(val, _mm_load_si128(tmpPtr2++)); \n                        val = _mm_mulhi_epi16(val, one_third); \n                        _mm_store_si128(outPtr++, val); \n                    } \n \n                    inPtr += 8; \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "cefe7a01a165c4c827b943f7b6243de6f02c597a05532e829ecfb19bd0675c44"}
{"code": "for (int y = MARGIN_V + field_n; y<height - MARGIN_V; y += 2) \n\t\t\t{ \n\t\t\t\tconst int tidx = omp_get_thread_num(); \n\t\t\t\tconst int off = (y - MARGIN_V - field_n) >> 1; \n\t\t\t\tuint8_t* maskp = 0; \n\t\t\t\tif (maskp_base != 0) \n\t\t\t\t{ \n\t\t\t\t\tmaskp = maskp_base + mpitch * off; \n\t\t\t\t} \n\t\t\t\tif (hp) \n\t\t\t\t\tinterpLineHP(srcp + MARGIN_H + off * 2 * spitch, width - MARGIN_H * 2, spitch, alpha, beta, \n\t\t\t\t\tgamma, nrad, mdis, (float*)(workspace[tidx]), dstp + off * 2 * dpitch, \n\t\t\t\t\tdmapa + off*dpitch, ucubic, cost3, maskp); \n\t\t\t\telse \n\t\t\t\t\tinterpLineFP(srcp + MARGIN_H + off * 2 * spitch, width - MARGIN_H * 2, spitch, alpha, beta, \n\t\t\t\t\tgamma, nrad, mdis, (float*)(workspace[tidx]), dstp + off * 2 * dpitch, \n\t\t\t\t\tdmapa + off*dpitch, ucubic, cost3, maskp); \n\t\t\t}", "pragma": "parallel for ", "hash": "bac824e89eb84edc39d6afd83a4c5252ff40bdb4b454db1c6de00815b8410dc3"}
{"code": "for(int x = 0; x < testwindowBound; x++) {\r \n\t\tint y = (x >= 62) ? x : testwindowBound - 1 - x;\r \n\t\tshort angle = ((int)((unitchange / 2) + (y - 62) * unitchange)) % 360;\r \n\r \n\t\tif(x >= 52 && x <= 61)\r \n\t\t\tangle = (angle + 145) % 360;\r \n\t\telse if(x >= 62 && x <= 71)\r \n\t\t\tangle = abs(angle - 145) % 360;\r \n\r \n\t\tangleIndex[x] = AngleToIndex(angle);\r \n\t}", "pragma": "parallel ", "hash": "497323c01ccf840fcdee325f0a3f79a9d9d0e1b285bfb90b217cf56bdae8059a"}
{"code": "for(int col = 0; col < num_columns; col += 1) \n    { \n        const int bottom_v = u_v_ground_obstacle_boundary[col]; \n        const float stixel_disparity = \n                std::max<float>(min_float_disparity, u_disparity_ground_obstacle_boundary[col]); \n        const float stixel_distance = stereo_camera.disparity_to_depth(stixel_disparity); \n \n        for(int row=0; row < bottom_v; row += 1) \n        { \n            const float delta_distance = abs(stixel_distance - depth_map(row, col)) / distance_tolerance; \n            depth_cost(row, col) = pow(2, 1 - delta_distance) - 1; \n        } \n \n        depth_cost.col(col).segment(bottom_v, num_rows - bottom_v).setConstant(0); \n \n        const bool set_minimum_height = false; \n        if(set_minimum_height) \n        {  \n \n \n             \n \n            const float minimum_height = 1.0;  \n \n            const Eigen::Vector2f uv_point = \n                    stereo_camera.get_left_camera().project_ground_plane_point(the_ground_plane, \n                                                                               0, stixel_distance, minimum_height); \n            int top_v = std::min(bottom_v - 1, static_cast<int>(uv_point[1])); \n            top_v = std::min(num_rows - 1, std::max(0, top_v));  \n \n            depth_cost.col(col).segment(top_v, bottom_v - top_v).setConstant(1); \n        } \n \n    }", "pragma": "parallel for ", "hash": "a0fd298692b167b632f9cf08d3c98905a827cfdf99a58126379bf7ca0ed9bc52"}
{"code": "for (r = 0; r < rows; ++r) { \n        for (c = 0; c < cols; ++c) { \n            sum = Vec4f(0.0f); \n            for (fi = 0; fi < filt_size; ++fi) { \n                rx = r + fi - off; \n                if (rx < 0 || rx >= rows) \n                    continue; \n                else { \n                    v.load(in + IDX(rx, c, cols) * 4); \n                    f.load(filt + fi * 4); \n                    sum += v*f; \n                } \n            } \n            sum.store(out + IDX(r, c, cols) * 4); \n        } \n    }", "pragma": "parallel for private(c f fi r rx sum v)", "hash": "42cfdecbb5e44b7548644826aec30eb6ffed5ef70829b44a7627323ca5038ec7"}
{"code": "for (uint32_t i=0; i<(uint32_t) m_Height*m_Width; i++) {\r \n      for (short Ch=0; Ch<NrChannels; Ch++) {\r \n        MaskLayer->m_Image[i][Ch] = CLIP((int32_t) ((WPH-(int32_t)DenoiseLayer->m_Image[i][Ch])+m_Image[i][Ch]));\r \n        MaskLayer->m_Image[i][Ch] = Table[MaskLayer->m_Image[i][Ch]];\r \n      }\r \n    }", "pragma": "parallel for ", "hash": "ef895c7865ab8f68e6d0b61234fd4ce415324d25702503d6196710d6805c6ad1"}
{"code": "for (size_t i = 0; i < num_reads; i++) { \n    fq_read = (fastq_read_t *) array_list_get(i, reads); \n     \n \n     \n \n    bwt_map_inexact_seq(fq_read->sequence,  \n\t\t\tbwt_optarg, index,  \n\t\t\tlists[i]); \n  }", "pragma": "parallel for private(fq_read)", "hash": "fc0c077e85a315e74322cb93cc73798da098cb2a046d4159187fcceba0ebf679"}
{"code": "for(int vIndex = 0; vIndex < verticesCoordsPrepare.size(); ++vIndex) \n    { \n        if(pixSizePrepare[vIndex] == -1.0) \n        { \n            continue; \n        } \n        const double pixSizeScore = pixSizeMarginCoef * simScorePrepare[vIndex] * pixSizePrepare[vIndex] * pixSizePrepare[vIndex]; \n        if(pixSizeScore < std::numeric_limits<double>::epsilon()) \n        { \n            pixSizePrepare[vIndex] = -1.0; \n            continue; \n        } \n        static const std::size_t nbNeighbors = 20; \n        static const double nbNeighborsInv = 1.0 / (double)nbNeighbors; \n        std::array<GEO::index_t, nbNeighbors> nnIndex; \n        std::array<double, nbNeighbors> sqDist; \n         \n \n        kdTree.get_nearest_neighbors(nbNeighbors, vIndex, &nnIndex.front(), &sqDist.front()); \n \n        for(std::size_t n = 0; n < nbNeighbors; ++n) \n        { \n             \n \n             \n \n            if(sqDist[n] < pixSizeScore) \n            { \n                if(pixSizePrepare[nnIndex[n]] < pixSizePrepare[vIndex] || \n                   (pixSizePrepare[nnIndex[n]] == pixSizePrepare[vIndex] && nnIndex[n] < vIndex) \n                   ) \n                { \n                     \n \n                    pixSizePrepare[vIndex] = -1.0; \n                    break; \n                } \n            } \n             \n \n             \n \n             \n \n             \n \n        } \n \n        static const nanoflann::SearchParams searchParams(32, 0, false);  \n \n        SmallerPixSizeInRadius<double, std::size_t> resultSet(pixSizeScore, pixSizePrepare, simScorePrepare, vIndex); \n        kdTree.findNeighbors(resultSet, verticesCoordsPrepare[vIndex].m, searchParams); \n        if(resultSet.found) \n            pixSizePrepare[vIndex] = -1.0; \n    }", "pragma": "parallel for ", "hash": "6e13e0de99fb58fa21b21ff8ab1c7a6455108beab606dc9e00626294891a72d6"}
{"code": "for (int Tile = 0; Tile < NrTiles; Tile++) { \n    VTile = floor((double)Tile/(double)NrHTiles);    \n \n    HTile = Tile - VTile*NrHTiles; \n    top = -16 + (TS-32)* VTile; \n    left = -16 + (TS-32) * HTile; \n \n     \n \n \n   \n \n   \n \n     \n \n      bottom = MIN( top+TS,height+16); \n      right  = MIN(left+TS, width+16); \n      rr1 = bottom - top; \n      cc1 = right - left; \n       \n \n       \n \n       \n \n      if (top<0) {rrmin=16;} else {rrmin=0;} \n      if (left<0) {ccmin=16;} else {ccmin=0;} \n      if (bottom>height) {rrmax=height-top;} else {rrmax=rr1;} \n      if (right>width) {ccmax=width-left;} else {ccmax=cc1;} \n \n      for (rr=rrmin; rr < rrmax; rr++) \n        for (row=rr+top, cc=ccmin; cc < ccmax; cc++) { \n          col = cc+left; \n          c = FC(rr,cc); \n          indx=row*width+col; \n          indx1=rr*TS+cc; \n          rgb[indx1][c] = (ridata(row,col))/65535.0f; \n           \n \n \n          cfa[indx1] = rgb[indx1][c]; \n        } \n       \n \n       \n \n      if (rrmin>0) { \n        for (rr=0; rr<16; rr++) \n          for (cc=ccmin; cc<ccmax; cc++) { \n            c = FC(rr,cc); \n            rgb[rr*TS+cc][c] = rgb[(32-rr)*TS+cc][c]; \n            cfa[rr*TS+cc] = rgb[rr*TS+cc][c]; \n          } \n      } \n      if (rrmax<rr1) { \n        for (rr=0; rr<16; rr++) \n          for (cc=ccmin; cc<ccmax; cc++) { \n            c=FC(rr,cc); \n            rgb[(rrmax+rr)*TS+cc][c] = ridata((height-rr-2),(left+cc))/65535.0f; \n             \n \n            cfa[(rrmax+rr)*TS+cc] = rgb[(rrmax+rr)*TS+cc][c]; \n          } \n      } \n      if (ccmin>0) { \n        for (rr=rrmin; rr<rrmax; rr++) \n          for (cc=0; cc<16; cc++) { \n            c=FC(rr,cc); \n            rgb[rr*TS+cc][c] = rgb[rr*TS+32-cc][c]; \n            cfa[rr*TS+cc] = rgb[rr*TS+cc][c]; \n          } \n      } \n      if (ccmax<cc1) { \n        for (rr=rrmin; rr<rrmax; rr++) \n          for (cc=0; cc<16; cc++) { \n            c=FC(rr,cc); \n            rgb[rr*TS+ccmax+cc][c] = (ridata((top+rr),(width-cc-2)))/65535.0f; \n             \n \n            cfa[rr*TS+ccmax+cc] = rgb[rr*TS+ccmax+cc][c]; \n          } \n      } \n \n       \n \n      if (rrmin>0 && ccmin>0) { \n        for (rr=0; rr<16; rr++) \n          for (cc=0; cc<16; cc++) { \n            c=FC(rr,cc); \n            rgb[(rr)*TS+cc][c] = ridata((32-rr),(32-cc))/65535.0f; \n             \n \n            cfa[(rr)*TS+cc] = rgb[(rr)*TS+cc][c]; \n          } \n      } \n      if (rrmax<rr1 && ccmax<cc1) { \n        for (rr=0; rr<16; rr++) \n          for (cc=0; cc<16; cc++) { \n            c=FC(rr,cc); \n            rgb[(rrmax+rr)*TS+ccmax+cc][c] = (ridata((height-rr-2),(width-cc-2)))/65535.0f; \n             \n \n            cfa[(rrmax+rr)*TS+ccmax+cc] = rgb[(rrmax+rr)*TS+ccmax+cc][c]; \n          } \n      } \n      if (rrmin>0 && ccmax<cc1) { \n        for (rr=0; rr<16; rr++) \n          for (cc=0; cc<16; cc++) { \n            c=FC(rr,cc); \n            rgb[(rr)*TS+ccmax+cc][c] = (ridata((32-rr),(width-cc-2)))/65535.0f; \n             \n \n            cfa[(rr)*TS+ccmax+cc] = rgb[(rr)*TS+ccmax+cc][c]; \n          } \n      } \n      if (rrmax<rr1 && ccmin>0) { \n        for (rr=0; rr<16; rr++) \n          for (cc=0; cc<16; cc++) { \n            c=FC(rr,cc); \n            rgb[(rrmax+rr)*TS+cc][c] = (ridata((height-rr-2),(32-cc)))/65535.0f; \n             \n \n            cfa[(rrmax+rr)*TS+cc] = rgb[(rrmax+rr)*TS+cc][c]; \n          } \n      } \n \n       \n \n       \n \n \n      for (rr=1; rr < rr1-1; rr++) \n        for (cc=1, indx=(rr)*TS+cc; cc < cc1-1; cc++, indx++) { \n \n          delh[indx] = fabs(cfa[indx+1]-cfa[indx-1]); \n          delv[indx] = fabs(cfa[indx+v1]-cfa[indx-v1]); \n          delhsq[indx] = SQR(delh[indx]); \n          delvsq[indx] = SQR(delv[indx]); \n          delp[indx] = fabs(cfa[indx+p1]-cfa[indx-p1]); \n          delm[indx] = fabs(cfa[indx+m1]-cfa[indx-m1]); \n \n        } \n \n      for (rr=2; rr < rr1-2; rr++) \n        for (cc=2,indx=(rr)*TS+cc; cc < cc1-2; cc++, indx++) { \n \n          dirwts[indx][0] = eps+delv[indx+v1]+delv[indx-v1]+delv[indx]; \n \n           \n \n          dirwts[indx][1] = eps+delh[indx+1]+delh[indx-1]+delh[indx]; \n \n           \n \n \n          if (FC(rr,cc)&1) { \n             \n \n             \n \n             \n \n            Dgrbpsq1[indx]=(SQR(cfa[indx]-cfa[indx-p1])+SQR(cfa[indx]-cfa[indx+p1])); \n            Dgrbmsq1[indx]=(SQR(cfa[indx]-cfa[indx-m1])+SQR(cfa[indx]-cfa[indx+m1])); \n          } \n        } \n \n       \n \n       \n \n       \n \n \n       \n \n       \n \n \n \n \n \n      for (rr=4; rr<TS-4; rr++) \n         \n \n        for (cc=4,indx=rr*TS+cc; cc<TS-4; cc++,indx++) { \n          c=FC(rr,cc); \n          if (c&1) {sgn=-1;} else {sgn=1;} \n \n           \n \n          nyquist[indx]=0; \n           \n \n          rbint[indx]=0; \n \n           \n \n          cru = cfa[indx-v1]*(dirwts[indx-v2][0]+dirwts[indx][0])/ \n            (dirwts[indx-v2][0]*cfa[indx]+dirwts[indx][0]*cfa[indx-v2]); \n          crd = cfa[indx+v1]*(dirwts[indx+v2][0]+dirwts[indx][0])/ \n            (dirwts[indx+v2][0]*cfa[indx]+dirwts[indx][0]*cfa[indx+v2]); \n          crl = cfa[indx-1]*(dirwts[indx-2][1]+dirwts[indx][1])/ \n            (dirwts[indx-2][1]*cfa[indx]+dirwts[indx][1]*cfa[indx-2]); \n          crr = cfa[indx+1]*(dirwts[indx+2][1]+dirwts[indx][1])/ \n            (dirwts[indx+2][1]*cfa[indx]+dirwts[indx][1]*cfa[indx+2]); \n \n          guha=cfa[indx-v1]+0.5*(cfa[indx]-cfa[indx-v2]); \n          gdha=cfa[indx+v1]+0.5*(cfa[indx]-cfa[indx+v2]); \n          glha=cfa[indx-1]+0.5*(cfa[indx]-cfa[indx-2]); \n          grha=cfa[indx+1]+0.5*(cfa[indx]-cfa[indx+2]); \n \n \n \n \n          if (fabs(1-cru)<arthresh) {guar=cfa[indx]*cru;} else {guar=guha;} \n          if (fabs(1-crd)<arthresh) {gdar=cfa[indx]*crd;} else {gdar=gdha;} \n          if (fabs(1-crl)<arthresh) {glar=cfa[indx]*crl;} else {glar=glha;} \n          if (fabs(1-crr)<arthresh) {grar=cfa[indx]*crr;} else {grar=grha;} \n \n          hwt = dirwts[indx-1][1]/(dirwts[indx-1][1]+dirwts[indx+1][1]); \n          vwt = dirwts[indx-v1][0]/(dirwts[indx+v1][0]+dirwts[indx-v1][0]); \n \n           \n \n          Gintvar = vwt*gdar+(1-vwt)*guar; \n          Ginthar = hwt*grar+(1-hwt)*glar; \n          Gintvha = vwt*gdha+(1-vwt)*guha; \n          Ginthha = hwt*grha+(1-hwt)*glha; \n           \n \n          vcd[indx] = sgn*(Gintvar-cfa[indx]); \n          hcd[indx] = sgn*(Ginthar-cfa[indx]); \n          vcdalt[indx] = sgn*(Gintvha-cfa[indx]); \n          hcdalt[indx] = sgn*(Ginthha-cfa[indx]); \n \n           \n \n          dgintv[indx]=MIN(SQR(guha-gdha),SQR(guar-gdar)); \n          dginth[indx]=MIN(SQR(glha-grha),SQR(glar-grar)); \n        } \n       \n \n \n \n \n \n       \n \n      for (rr=4; rr<TS-4; rr++) \n         \n \n        for (cc=4,indx=rr*TS+cc; cc<TS-4; cc++,indx++) { \n          c=FC(rr,cc); \n \n          hcdvar = 3*(SQR(hcd[indx-2])+SQR(hcd[indx])+SQR(hcd[indx+2]))-SQR(hcd[indx-2]+hcd[indx]+hcd[indx+2]); \n          hcdaltvar = 3*(SQR(hcdalt[indx-2])+SQR(hcdalt[indx])+SQR(hcdalt[indx+2]))-SQR(hcdalt[indx-2]+hcdalt[indx]+hcdalt[indx+2]); \n          vcdvar = 3*(SQR(vcd[indx-v2])+SQR(vcd[indx])+SQR(vcd[indx+v2]))-SQR(vcd[indx-v2]+vcd[indx]+vcd[indx+v2]); \n          vcdaltvar = 3*(SQR(vcdalt[indx-v2])+SQR(vcdalt[indx])+SQR(vcdalt[indx+v2]))-SQR(vcdalt[indx-v2]+vcdalt[indx]+vcdalt[indx+v2]); \n           \n \n          if (hcdaltvar<hcdvar) hcd[indx]=hcdalt[indx]; \n          if (vcdaltvar<vcdvar) vcd[indx]=vcdalt[indx]; \n \n           \n \n          if (c&1) { \n            Ginth = -hcd[indx]+cfa[indx]; \n \n            Gintv = -vcd[indx]+cfa[indx]; \n \n \n            if (hcd[indx]>0) { \n              if (3*hcd[indx] > (Ginth+cfa[indx])) { \n                hcd[indx]=-ULIM(Ginth,cfa[indx-1],cfa[indx+1])+cfa[indx]; \n              } else { \n                hwt = 1-3*hcd[indx]/(eps+Ginth+cfa[indx]); \n                hcd[indx]=hwt*hcd[indx] + (1-hwt)*(-ULIM(Ginth,cfa[indx-1],cfa[indx+1])+cfa[indx]); \n              } \n            } \n            if (vcd[indx]>0) { \n              if (3*vcd[indx] > (Gintv+cfa[indx])) { \n                vcd[indx]=-ULIM(Gintv,cfa[indx-v1],cfa[indx+v1])+cfa[indx]; \n              } else { \n                vwt = 1-3*vcd[indx]/(eps+Gintv+cfa[indx]); \n                vcd[indx]=vwt*vcd[indx] + (1-vwt)*(-ULIM(Gintv,cfa[indx-v1],cfa[indx+v1])+cfa[indx]); \n              } \n            } \n \n            if (Ginth > 1) hcd[indx]=-ULIM(Ginth,cfa[indx-1],cfa[indx+1])+cfa[indx]; \n \n            if (Gintv > 1) vcd[indx]=-ULIM(Gintv,cfa[indx-v1],cfa[indx+v1])+cfa[indx]; \n             \n \n             \n \n \n          } else { \n \n            Ginth = hcd[indx]+cfa[indx]; \n \n            Gintv = vcd[indx]+cfa[indx]; \n \n            if (hcd[indx]<0) { \n              if (3*hcd[indx] < -(Ginth+cfa[indx])) { \n                hcd[indx]=ULIM(Ginth,cfa[indx-1],cfa[indx+1])-cfa[indx]; \n              } else { \n                hwt = 1+3*hcd[indx]/(eps+Ginth+cfa[indx]); \n                hcd[indx]=hwt*hcd[indx] + (1-hwt)*(ULIM(Ginth,cfa[indx-1],cfa[indx+1])-cfa[indx]); \n              } \n            } \n            if (vcd[indx]<0) { \n              if (3*vcd[indx] < -(Gintv+cfa[indx])) { \n                vcd[indx]=ULIM(Gintv,cfa[indx-v1],cfa[indx+v1])-cfa[indx]; \n              } else { \n                vwt = 1+3*vcd[indx]/(eps+Gintv+cfa[indx]); \n                vcd[indx]=vwt*vcd[indx] + (1-vwt)*(ULIM(Gintv,cfa[indx-v1],cfa[indx+v1])-cfa[indx]); \n              } \n            } \n \n            if (Ginth > 1) hcd[indx]=ULIM(Ginth,cfa[indx-1],cfa[indx+1])-cfa[indx]; \n \n            if (Gintv > 1) vcd[indx]=ULIM(Gintv,cfa[indx-v1],cfa[indx+v1])-cfa[indx]; \n             \n \n             \n \n          } \n \n          vcdsq[indx] = SQR(vcd[indx]); \n          hcdsq[indx] = SQR(hcd[indx]); \n          cddiffsq[indx] = SQR(vcd[indx]-hcd[indx]); \n        } \n \n \n \n \n      for (rr=6; rr<TS-6; rr++) \n        for (cc=6+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-6; cc+=2,indx+=2) { \n \n           \n \n          Dgrbvvaru = 4*(vcdsq[indx]+vcdsq[indx-v1]+vcdsq[indx-v2]+vcdsq[indx-v3])- \n            SQR(vcd[indx]+vcd[indx-v1]+vcd[indx-v2]+vcd[indx-v3]); \n          Dgrbvvard = 4*(vcdsq[indx]+vcdsq[indx+v1]+vcdsq[indx+v2]+vcdsq[indx+v3])- \n            SQR(vcd[indx]+vcd[indx+v1]+vcd[indx+v2]+vcd[indx+v3]); \n          Dgrbhvarl = 4*(hcdsq[indx]+hcdsq[indx-1]+hcdsq[indx-2]+hcdsq[indx-3])- \n            SQR(hcd[indx]+hcd[indx-1]+hcd[indx-2]+hcd[indx-3]); \n          Dgrbhvarr = 4*(hcdsq[indx]+hcdsq[indx+1]+hcdsq[indx+2]+hcdsq[indx+3])- \n            SQR(hcd[indx]+hcd[indx+1]+hcd[indx+2]+hcd[indx+3]); \n \n          hwt = dirwts[indx-1][1]/(dirwts[indx-1][1]+dirwts[indx+1][1]); \n          vwt = dirwts[indx-v1][0]/(dirwts[indx+v1][0]+dirwts[indx-v1][0]); \n \n          vcdvar = epssq+vwt*Dgrbvvard+(1-vwt)*Dgrbvvaru; \n          hcdvar = epssq+hwt*Dgrbhvarr+(1-hwt)*Dgrbhvarl; \n \n           \n \n          Dgrbvvaru = (dgintv[indx])+(dgintv[indx-v1])+(dgintv[indx-v2]); \n          Dgrbvvard = (dgintv[indx])+(dgintv[indx+v1])+(dgintv[indx+v2]); \n          Dgrbhvarl = (dginth[indx])+(dginth[indx-1])+(dginth[indx-2]); \n          Dgrbhvarr = (dginth[indx])+(dginth[indx+1])+(dginth[indx+2]); \n \n          vcdvar1 = epssq+vwt*Dgrbvvard+(1.0-vwt)*Dgrbvvaru; \n          hcdvar1 = epssq+hwt*Dgrbhvarr+(1.0-hwt)*Dgrbhvarl; \n \n           \n \n          varwt=hcdvar/(vcdvar+hcdvar); \n          diffwt=hcdvar1/(vcdvar1+hcdvar1); \n \n           \n \n           \n \n           \n \n          if ((0.5-varwt)*(0.5-diffwt)>0 && fabs(0.5-diffwt)<fabs(0.5-varwt)) \n            {hvwt[indx]=varwt;} \n          else \n            {hvwt[indx]=diffwt;} \n        } \n       \n \n \n \n \n \n       \n \n       \n \n       \n \n \n      for (rr=6; rr<TS-6; rr++) \n        for (cc=6+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-6; cc+=2,indx+=2) { \n \n           \n \n          nyqtest = (gaussodd[0]*cddiffsq[indx]+                   gaussodd[1]*(cddiffsq[indx-m1]+cddiffsq[indx+p1]+                        cddiffsq[indx-p1]+cddiffsq[indx+m1])+                   gaussodd[2]*(cddiffsq[indx-v2]+cddiffsq[indx-2]+                        cddiffsq[indx+2]+cddiffsq[indx+v2])+                   gaussodd[3]*(cddiffsq[indx-m2]+cddiffsq[indx+p2]+                        cddiffsq[indx-p2]+cddiffsq[indx+m2])); \n \n          nyqtest -= nyqthresh*(gaussgrad[0]*(delhsq[indx]+delvsq[indx])+                        gaussgrad[1]*(delhsq[indx-v1]+delvsq[indx-v1]+delhsq[indx+1]+delvsq[indx+1]+                              delhsq[indx-1]+delvsq[indx-1]+delhsq[indx+v1]+delvsq[indx+v1])+                        gaussgrad[2]*(delhsq[indx-m1]+delvsq[indx-m1]+delhsq[indx+p1]+delvsq[indx+p1]+                              delhsq[indx-p1]+delvsq[indx-p1]+delhsq[indx+m1]+delvsq[indx+m1])+                        gaussgrad[3]*(delhsq[indx-v2]+delvsq[indx-v2]+delhsq[indx-2]+delvsq[indx-2]+                              delhsq[indx+2]+delvsq[indx+2]+delhsq[indx+v2]+delvsq[indx+v2])+                        gaussgrad[4]*(delhsq[indx-2*TS-1]+delvsq[indx-2*TS-1]+delhsq[indx-2*TS+1]+delvsq[indx-2*TS+1]+                              delhsq[indx-TS-2]+delvsq[indx-TS-2]+delhsq[indx-TS+2]+delvsq[indx-TS+2]+                              delhsq[indx+TS-2]+delvsq[indx+TS-2]+delhsq[indx+TS+2]+delvsq[indx-TS+2]+                              delhsq[indx+2*TS-1]+delvsq[indx+2*TS-1]+delhsq[indx+2*TS+1]+delvsq[indx+2*TS+1])+                        gaussgrad[5]*(delhsq[indx-m2]+delvsq[indx-m2]+delhsq[indx+p2]+delvsq[indx+p2]+                              delhsq[indx-p2]+delvsq[indx-p2]+delhsq[indx+m2]+delvsq[indx+m2])); \n \n \n          if (nyqtest>0) {nyquist[indx]=1;} \n \n        } \n \n      for (rr=8; rr<TS-8; rr++) \n        for (cc=8+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-8; cc+=2,indx+=2) { \n \n          areawt=(nyquist[indx-v2]+nyquist[indx-m1]+nyquist[indx+p1]+                nyquist[indx-2]+nyquist[indx]+nyquist[indx+2]+                nyquist[indx-p1]+nyquist[indx+m1]+nyquist[indx+v2]); \n           \n \n          if (areawt>4) nyquist[indx]=1; \n           \n \n          if (areawt<4) nyquist[indx]=0; \n        } \n \n       \n \n       \n \n       \n \n \n \n \n \n       \n \n       \n \n       \n \n      for (rr=8; rr<TS-8; rr++) \n        for (cc=8+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-8; cc+=2,indx+=2) { \n \n          if (nyquist[indx]) { \n             \n \n             \n \n \n            sumh=sumv=sumsqh=sumsqv=areawt=0; \n            for (i=-6; i<7; i+=2) \n              for (j=-6; j<7; j+=2) { \n                indx1=(rr+i)*TS+cc+j; \n                if (nyquist[indx1]) { \n                  sumh += cfa[indx1]-0.5*(cfa[indx1-1]+cfa[indx1+1]); \n                  sumv += cfa[indx1]-0.5*(cfa[indx1-v1]+cfa[indx1+v1]); \n                  sumsqh += 0.5*(SQR(cfa[indx1]-cfa[indx1-1])+SQR(cfa[indx1]-cfa[indx1+1])); \n                  sumsqv += 0.5*(SQR(cfa[indx1]-cfa[indx1-v1])+SQR(cfa[indx1]-cfa[indx1+v1])); \n                  areawt +=1; \n                } \n              } \n \n             \n \n            hcdvar=epssq+MAX(0.f, areawt*sumsqh-sumh*sumh); \n            vcdvar=epssq+MAX(0.f, areawt*sumsqv-sumv*sumv); \n            hvwt[indx]=hcdvar/(vcdvar+hcdvar); \n \n             \n \n             \n \n \n          } \n        } \n       \n \n       \n \n \n       \n \n       \n \n      for (rr=8; rr<TS-8; rr++) \n        for (cc=8+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-8; cc+=2,indx+=2) { \n \n           \n \n          hvwtalt = 0.25*(hvwt[indx-m1]+hvwt[indx+p1]+hvwt[indx-p1]+hvwt[indx+m1]); \n          vo=fabs(0.5-hvwt[indx]); \n          ve=fabs(0.5-hvwtalt); \n          if (vo<ve) {hvwt[indx]=hvwtalt;} \n \n          Dgrb[indx][0] = (hcd[indx]*(1-hvwt[indx]) + vcd[indx]*hvwt[indx]); \n \n          rgb[indx][1] = cfa[indx] + Dgrb[indx][0]; \n \n \n           \n \n          if (nyquist[indx]) { \n            Dgrbh2[indx] = SQR(rgb[indx][1] - 0.5*(rgb[indx-1][1]+rgb[indx+1][1])); \n            Dgrbv2[indx] = SQR(rgb[indx][1] - 0.5*(rgb[indx-v1][1]+rgb[indx+v1][1])); \n          } \n        } \n \n       \n \n       \n \n       \n \n \n \n       \n \n       \n \n \n      for (rr=8; rr<TS-8; rr++) \n        for (cc=8+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-8; cc+=2,indx+=2) { \n \n          if (nyquist[indx]) { \n             \n \n            gvarh = epssq + (gquinc[0]*Dgrbh2[indx]+                       gquinc[1]*(Dgrbh2[indx-m1]+Dgrbh2[indx+p1]+Dgrbh2[indx-p1]+Dgrbh2[indx+m1])+                       gquinc[2]*(Dgrbh2[indx-v2]+Dgrbh2[indx-2]+Dgrbh2[indx+2]+Dgrbh2[indx+v2])+                       gquinc[3]*(Dgrbh2[indx-m2]+Dgrbh2[indx+p2]+Dgrbh2[indx-p2]+Dgrbh2[indx+m2])); \n            gvarv = epssq + (gquinc[0]*Dgrbv2[indx]+                       gquinc[1]*(Dgrbv2[indx-m1]+Dgrbv2[indx+p1]+Dgrbv2[indx-p1]+Dgrbv2[indx+m1])+                       gquinc[2]*(Dgrbv2[indx-v2]+Dgrbv2[indx-2]+Dgrbv2[indx+2]+Dgrbv2[indx+v2])+                       gquinc[3]*(Dgrbv2[indx-m2]+Dgrbv2[indx+p2]+Dgrbv2[indx-p2]+Dgrbv2[indx+m2])); \n             \n \n            Dgrb[indx][0] = (hcd[indx]*gvarv + vcd[indx]*gvarh)/(gvarv+gvarh); \n            rgb[indx][1] = cfa[indx] + Dgrb[indx][0]; \n          } \n        } \n \n       \n \n \n       \n \n       \n \n       \n \n       \n \n       \n \n \n      for (rr=8; rr<TS-8; rr++) \n        for (cc=8+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-8; cc+=2,indx+=2) { \n \n \n          rbvarp = epssq + (gausseven[0]*(Dgrbpsq1[indx-v1]+Dgrbpsq1[indx-1]+Dgrbpsq1[indx+1]+Dgrbpsq1[indx+v1]) +                    gausseven[1]*(Dgrbpsq1[indx-v2-1]+Dgrbpsq1[indx-v2+1]+Dgrbpsq1[indx-2-v1]+Dgrbpsq1[indx+2-v1]+                            Dgrbpsq1[indx-2+v1]+Dgrbpsq1[indx+2+v1]+Dgrbpsq1[indx+v2-1]+Dgrbpsq1[indx+v2+1])); \n           \n \n \n          wtse= eps+delm[indx]+delm[indx+m1]+delm[indx+m2]; \n \n          wtnw= eps+delm[indx]+delm[indx-m1]+delm[indx-m2]; \n          wtne= eps+delp[indx]+delp[indx+p1]+delp[indx+p2]; \n          wtsw= eps+delp[indx]+delp[indx-p1]+delp[indx-p2]; \n \n \n          rbm[indx] = (wtse*rbnw+wtnw*rbse)/(wtse+wtnw); \n          rbp[indx] = (wtne*rbsw+wtsw*rbne)/(wtne+wtsw); \n \n          pmwt[indx] = rbvarm/(rbvarp+rbvarm); \n \n           \n \n           \n \n          if (rbp[indx]<cfa[indx]) { \n            if (2*rbp[indx] < cfa[indx]) { \n              rbp[indx] = ULIM(rbp[indx] ,cfa[indx-p1],cfa[indx+p1]); \n            } else { \n              pwt = 2*(cfa[indx]-rbp[indx])/(eps+rbp[indx]+cfa[indx]); \n              rbp[indx]=pwt*rbp[indx] + (1-pwt)*ULIM(rbp[indx],cfa[indx-p1],cfa[indx+p1]); \n            } \n          } \n          if (rbm[indx]<cfa[indx]) { \n            if (2*rbm[indx] < cfa[indx]) { \n              rbm[indx] = ULIM(rbm[indx] ,cfa[indx-m1],cfa[indx+m1]); \n            } else { \n              mwt = 2*(cfa[indx]-rbm[indx])/(eps+rbm[indx]+cfa[indx]); \n              rbm[indx]=mwt*rbm[indx] + (1-mwt)*ULIM(rbm[indx],cfa[indx-m1],cfa[indx+m1]); \n            } \n          } \n \n          if (rbp[indx] > 1) rbp[indx]=ULIM(rbp[indx],cfa[indx-p1],cfa[indx+p1]); \n \n          if (rbm[indx] > 1) rbm[indx]=ULIM(rbm[indx],cfa[indx-m1],cfa[indx+m1]); \n           \n \n           \n \n           \n \n           \n \n \n           \n \n        } \n \n \n \n      for (rr=8; rr<TS-8; rr++) \n        for (cc=8+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-8; cc+=2,indx+=2) { \n \n           \n \n          pmwtalt = 0.25*(pmwt[indx-m1]+pmwt[indx+p1]+pmwt[indx-p1]+pmwt[indx+m1]); \n          vo=fabs(0.5-pmwt[indx]); \n          ve=fabs(0.5-pmwtalt); \n          if (vo<ve) {pmwt[indx]=pmwtalt;} \n \n          rbint[indx] = 0.5*(cfa[indx] + rbm[indx]*(1-pmwt[indx]) + rbp[indx]*pmwt[indx]); \n \n        } \n \n      for (rr=8; rr<TS-8; rr++) \n        for (cc=8+(FC(rr,2)&1),indx=rr*TS+cc; cc<TS-8; cc+=2,indx+=2) { \n \n           \n \n \n           \n \n           \n \n           \n \n \n          cru = cfa[indx-v1]*2/(eps+rbint[indx]+rbint[indx-v2]); \n          crd = cfa[indx+v1]*2/(eps+rbint[indx]+rbint[indx+v2]); \n          crl = cfa[indx-1]*2/(eps+rbint[indx]+rbint[indx-2]); \n          crr = cfa[indx+1]*2/(eps+rbint[indx]+rbint[indx+2]); \n \n           \n \n          if (fabs(1-cru)<arthresh) {gu=rbint[indx]*cru;} \n          else {gu=cfa[indx-v1]+0.5*(rbint[indx]-rbint[indx-v2]);} \n          if (fabs(1-crd)<arthresh) {gd=rbint[indx]*crd;} \n          else {gd=cfa[indx+v1]+0.5*(rbint[indx]-rbint[indx+v2]);} \n          if (fabs(1-crl)<arthresh) {gl=rbint[indx]*crl;} \n          else {gl=cfa[indx-1]+0.5*(rbint[indx]-rbint[indx-2]);} \n          if (fabs(1-crr)<arthresh) {gr=rbint[indx]*crr;} \n          else {gr=cfa[indx+1]+0.5*(rbint[indx]-rbint[indx+2]);} \n \n           \n \n           \n \n           \n \n           \n \n \n           \n \n          Gintv = (dirwts[indx-v1][0]*gd+dirwts[indx+v1][0]*gu)/(dirwts[indx+v1][0]+dirwts[indx-v1][0]); \n          Ginth = (dirwts[indx-1][1]*gr+dirwts[indx+1][1]*gl)/(dirwts[indx-1][1]+dirwts[indx+1][1]); \n \n           \n \n           \n \n          if (Gintv<rbint[indx]) { \n            if (2*Gintv < rbint[indx]) { \n              Gintv = ULIM(Gintv ,cfa[indx-v1],cfa[indx+v1]); \n            } else { \n              vwt = 2*(rbint[indx]-Gintv)/(eps+Gintv+rbint[indx]); \n              Gintv=vwt*Gintv + (1-vwt)*ULIM(Gintv,cfa[indx-v1],cfa[indx+v1]); \n            } \n          } \n          if (Ginth<rbint[indx]) { \n            if (2*Ginth < rbint[indx]) { \n              Ginth = ULIM(Ginth ,cfa[indx-1],cfa[indx+1]); \n            } else { \n              hwt = 2*(rbint[indx]-Ginth)/(eps+Ginth+rbint[indx]); \n              Ginth=hwt*Ginth + (1-hwt)*ULIM(Ginth,cfa[indx-1],cfa[indx+1]); \n            } \n          } \n \n          if (Ginth > 1) Ginth=ULIM(Ginth,cfa[indx-1],cfa[indx+1]); \n \n          if (Gintv > 1) Gintv=ULIM(Gintv,cfa[indx-v1],cfa[indx+v1]); \n           \n \n           \n \n           \n \n           \n \n \n          rgb[indx][1] = Ginth*(1-hvwt[indx]) + Gintv*hvwt[indx]; \n          Dgrb[indx][0] = rgb[indx][1]-cfa[indx]; \n \n          rgb[indx][2-FC(rr,cc)]=2*rbint[indx]-cfa[indx]; \n        } \n       \n \n       \n \n       \n \n       \n \n \n       \n \n       \n \n       \n \n      for (rr=13-ey; rr<TS-12; rr+=2) \n        for (cc=13-ex,indx=rr*TS+cc; cc<TS-12; cc+=2,indx+=2) { \n \n          Dgrb[indx][1]=Dgrb[indx][0]; \n \n          Dgrb[indx][0]=0; \n        } \n      for (rr=12; rr<TS-12; rr++) \n        for (cc=12+(FC(rr,2)&1),indx=rr*TS+cc,c=1-FC(rr,cc)/2; cc<TS-12; cc+=2,indx+=2) { \n          f[0]=1.0/(eps+fabs(Dgrb[indx-m1][c]-Dgrb[indx+m1][c])+fabs(Dgrb[indx-m1][c]-Dgrb[indx-m3][c])+fabs(Dgrb[indx+m1][c]-Dgrb[indx-m3][c])); \n          f[1]=1.0/(eps+fabs(Dgrb[indx+p1][c]-Dgrb[indx-p1][c])+fabs(Dgrb[indx+p1][c]-Dgrb[indx+p3][c])+fabs(Dgrb[indx-p1][c]-Dgrb[indx+p3][c])); \n          f[2]=1.0/(eps+fabs(Dgrb[indx-p1][c]-Dgrb[indx+p1][c])+fabs(Dgrb[indx-p1][c]-Dgrb[indx+m3][c])+fabs(Dgrb[indx+p1][c]-Dgrb[indx-p3][c])); \n          f[3]=1.0/(eps+fabs(Dgrb[indx+m1][c]-Dgrb[indx-m1][c])+fabs(Dgrb[indx+m1][c]-Dgrb[indx-p3][c])+fabs(Dgrb[indx-m1][c]-Dgrb[indx+m3][c])); \n \n          g[0]=Dgrb[indx-m1][c]; \n          g[1]=Dgrb[indx+p1][c]; \n          g[2]=Dgrb[indx-p1][c]; \n          g[3]=Dgrb[indx+m1][c]; \n          Dgrb[indx][c]=(f[0]*g[0]+f[1]*g[1]+f[2]*g[2]+f[3]*g[3])/(f[0]+f[1]+f[2]+f[3]); \n        } \n      for (rr=12; rr<TS-12; rr++) \n        for (cc=12+(FC(rr,1)&1),indx=rr*TS+cc,c=FC(rr,cc+1)/2; cc<TS-12; cc+=2,indx+=2) \n          for(c=0;c<2;c++){ \n \n            Dgrb[indx][c]=((hvwt[indx-v1])*Dgrb[indx-v1][c]+(1-hvwt[indx+1])*Dgrb[indx+1][c]+(1-hvwt[indx-1])*Dgrb[indx-1][c]+(hvwt[indx+v1])*Dgrb[indx+v1][c])/              ((hvwt[indx-v1])+(1-hvwt[indx+1])+(1-hvwt[indx-1])+(hvwt[indx+v1])); \n \n          } \n      for(rr=12; rr<TS-12; rr++) \n        for(cc=12,indx=rr*TS+cc; cc<TS-12; cc++,indx++){ \n          rgb[indx][0]=(rgb[indx][1]-Dgrb[indx][0]); \n          rgb[indx][2]=(rgb[indx][1]-Dgrb[indx][1]); \n        } \n       \n \n \n       \n \n       \n \n \n       \n \n      for (rr=16; rr < rr1-16; rr++) \n        for (row=rr+top, cc=16; cc < cc1-16; cc++) { \n          col = cc + left; \n \n          indx=rr*TS+cc; \n \n          m_OutImage[row*width+col][0] = CLIP((int)(65535.0f*rgb[indx][0] + 0.5f)); \n          m_OutImage[row*width+col][1] = CLIP((int)(65535.0f*rgb[indx][1] + 0.5f)); \n          m_OutImage[row*width+col][2] = CLIP((int)(65535.0f*rgb[indx][2] + 0.5f)); \n \n           \n \n           \n \n           \n \n           \n \n \n \n        } \n       \n \n \n    }", "pragma": "for private( left top)", "hash": "93eef5e6fc3adcab86344805b3671723c0951029b73a742e182cb6ce698db7fd"}
{"code": "for (size_t k = 0; k < normals_cloud.points.size (); k++) \n    { \n        Eigen::Vector3f nt (normals_cloud.points[k].normal_x, normals_cloud.points[k].normal_y, normals_cloud.points[k].normal_z); \n        normals_aligned.points[k].normal_x = static_cast<float> (transform (0, 0) * nt[0] + transform (0, 1) * nt[1] \n                + transform (0, 2) * nt[2]); \n        normals_aligned.points[k].normal_y = static_cast<float> (transform (1, 0) * nt[0] + transform (1, 1) * nt[1] \n                + transform (1, 2) * nt[2]); \n        normals_aligned.points[k].normal_z = static_cast<float> (transform (2, 0) * nt[0] + transform (2, 1) * nt[1] \n                + transform (2, 2) * nt[2]); \n \n        normals_aligned.points[k].curvature = normals_cloud.points[k].curvature; \n    }", "pragma": "parallel for ", "hash": "4f7eec561538096f5ae2ff235ea5b123a52558c49e80b05a2d7c24f22dc6da80"}
{"code": "for(long i=0;i<dat.nx*dat.ny;i++) \n\t{\tx.a[i] = cos(tet.a[i])*cos(phi.a[i]); \n\t\ty.a[i] = cos(tet.a[i])*sin(phi.a[i]); \n\t\tz.a[i] = sin(tet.a[i]);\t}", "pragma": "parallel for ", "hash": "85119603373531d07419c0311a8db1f61d23d5ee9a4047d7c186b31e51b90d5d"}
{"code": "for( int j = 0 ; j < train_num ; j++ ) \n            { \n                pcl::PointCloud<PointT>::Ptr mycloud = train_objects[0][j].cloud; \n            \tpcl::PointCloud<NormalT>::Ptr mycloud_normals(new pcl::PointCloud<NormalT>()); \n            \tcomputeNormals(mycloud, mycloud_normals, radius); \n\t\tMulInfoT tmp_data = convertPCD(mycloud, mycloud_normals); \n                tmp_data.img = train_objects[0][j].img; \n                tmp_data.map2d = train_objects[0][j].map2d; \n                tmp_data._3d2d = train_objects[0][j]._3d2d; \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n               \n                cv::Mat cur_atlas = cv::Mat::zeros(tmp_data.img.rows, tmp_data.img.cols, CV_32SC1); \n                for(int k = 0 ; k < tmp_data._3d2d.rows ; k++ ) \n                    cur_atlas.at<int>(tmp_data._3d2d.at<int>(k, 1), tmp_data._3d2d.at<int>(k, 0) ) = 1; \n                 \n                std::vector<cv::Mat> cur_final_vec = SIFTPooling(tmp_data, sift_det_vec, sift_ext, hie_producer, sift_pooler_set, cur_atlas, 1); \n\t\tcv::Mat ext_fea; \n\t\t{ \n         \t    pcl::VoxelGrid<PointT> sor; \n                    sor.setInputCloud(tmp_data.cloud); \n                    sor.setLeafSize(down_ss, down_ss, down_ss); \n                    sor.filter(*tmp_data.down_cloud); \n                    PreCloud(tmp_data, -1, false); \n                    std::vector<cv::Mat> main_fea = hie_producer.getHierFea(tmp_data, 0); \n                     \n                     \n \n                     \n\t\t    cv::Mat lab_fea = multiPool(lab_pooler_set, tmp_data, main_fea); \n\t\t    cv::Mat fpfh_fea = multiFPFHPool(fpfh_pooler_set, tmp_data, main_fea, radius); \n\t\t    cv::hconcat(fpfh_fea, lab_fea, ext_fea); \n\t\t} \n\t\tcv::Mat cur_final; \n\t\tcv::hconcat(cur_final_vec[1], ext_fea, cur_final); \n                 \n \n \n \n \n \n                if( fea_dim > 0 && cur_final.cols != fea_dim ) \n                { \n                    std::cerr << \"Error: fea_dim > 0 && cur_final.cols != fea_dim   \" << fea_dim << \" \" << cur_final.cols << std::endl; \n                    exit(0); \n                } \n                else if( fea_dim < 0 ) \n\t\t{ \n  #pragma omp critical \n\t\t{ \n                    fea_dim = cur_final.cols; \n\t\t    std::cerr << \"Fea Dim: \" << fea_dim << std::endl; \n\t\t} \n\t\t}\t \n                std::vector< sparseVec> this_sparse; \n                sparseCvMat(cur_final, this_sparse); \n                #pragma omp critical \n                { \n                    final_train.push_back(this_sparse[0]); \n                } \n                 \n            }", "pragma": "parallel for ", "hash": "7890618cb48d7246ff6ffe8ab6df1e9177452c70fb36c0f803c1becbea3a5795"}
{"code": "for (int j = 0; j < N; ++j) \n                { \n                int tid = omp_get_thread_num(); \n                int seed = (j+1)*(tid+1)*time(0); \n                std::minstd_rand0 generator (seed); \n                rval[j] =  distribution(generator); \n                }", "pragma": "parallel for private(n)", "hash": "a1f5fc916d80aa1e596d1c2b746a89b25235994e86dff2ac571b739bd5002c95"}
{"code": "for (int j = index_min; j <= index_max; ++j) \n      { \n        unsigned short intensity; \n        sscanf(fields[j + offset], \"%hx\", &intensity); \n        msg.intensities[j - index_min] = intensity; \n        if(intensity>233 && filter) \n        { \n          #pragma omp parallel for \n          for (int i = -20; i <= 20; i++) \n          { \n            int tmpIdx = j - index_min + i; \n            if(tmpIdx<0) \n            { \n              i -= tmpIdx; \n              tmpIdx = 0; \n            } \n            unsigned short tmpIntensity; \n            sscanf(fields[j + offset + i], \"%hx\", &tmpIntensity); \n            if(tmpIntensity<233) \n            { \n              if(calcEucDistance(msg.ranges[j - index_min],msg.angle_min+msg.angle_increment*(j - index_min),msg.ranges[tmpIdx],msg.angle_min+msg.angle_increment*(tmpIdx))<0.55) \n                msg.ranges[tmpIdx] = std::numeric_limits<float>::infinity(); \n            } \n          } \n        } \n      }", "pragma": "parallel for ", "hash": "27ce89815853d7a41f6e0dc74d67fae71316d41fcb2347e28cf9c191c9b1b241"}
{"code": "for(int i=0; i<num[0]; ++i)\r \n        {\r \n            c_idx[buck_id][i] = c_idx[0][i];\r \n            c_idx[0][i] = 0;\r \n        }", "pragma": "parallel for ", "hash": "b692897a8ce74dadb1e60c425c31f2610a360ddf718ba151f83f7b7b64e8dfb0"}
{"code": "for(uint i=0; i<nTraining1; i++){ \n\t\t\ttemp = *(trainingPhotosDescriptors1[i]); \n\t\t\ttemp = bag(temp, bag_indexes, 154); \n\t\t\ttrainingPhotosDescriptors1Temp[i] = new Mat(); \n\t\t\t*(trainingPhotosDescriptors1Temp[i]) = temp.clone(); \n\t\t}", "pragma": "parallel for private(temp)", "hash": "528c2c167f9c493abdc698435addd29a2f16c85268855cadbc12b404054922b8"}
{"code": "for (i = 0 ; i < d ; i++) \n\t\t{ \n\t\t\tacc       += w[i]*X[i+kd]; \n\t\t}", "pragma": "parallel for reduction(+:acc) private(i)", "hash": "9e9f07dc26124e0e6aec8f22bc03421e9c4bd868d6c91d11f17be5c39405b09f"}
{"code": "for (int64_t t = 0; t < T; t++) \n    for (int64_t z = 0; z < LZ; z++) \n      for (int64_t y = 0; y < LY; y++) \n        for (int64_t v = 0; v < nVecs; v++) { \n          int64_t block = (t * Pxyz + z * Pxy) / ngy + (y / ngy) * nVecs + v; \n \n          for (int dim = 0; dim < 4; dim++)      \n \n            for (int c1 = 0; c1 < Nc1; c1++)     \n \n              for (int c2 = 0; c2 < Nc2; c2++)   \n \n                for (int x_soa = 0; x_soa < SOALEN; x_soa++) { \n                  int64_t xx = (y % ngy) * SOALEN + x_soa; \n                  int64_t q_cb_x_coord = x_soa + v * SOALEN; \n                  int64_t tm_x_coord_cb0 = q_cb_x_coord * 2 + (((t + y + z) & 1) ^ 0); \n                  int64_t tm_x_coord_cb1 = q_cb_x_coord * 2 + (((t + y + z) & 1) ^ 1); \n \n                  int64_t tm_idx_cb0; \n                  int64_t tm_idx_cb1; \n \n                   \n \n                  for (int dir = 0; dir < 2; dir++) { \n                    if (dir == 0) { \n                      tm_idx_cb0 = g_idn[g_ipt[t][tm_x_coord_cb0][y][z]][change_dim[dim]]; \n                      tm_idx_cb1 = g_idn[g_ipt[t][tm_x_coord_cb1][y][z]][change_dim[dim]]; \n                    } else { \n                      tm_idx_cb0 = g_ipt[t][tm_x_coord_cb0][y][z]; \n                      tm_idx_cb1 = g_ipt[t][tm_x_coord_cb1][y][z]; \n                    } \n                    for (int reim = 0; reim < Nz; reim++) { \n                       \n \n                       \n \n                       \n \n                       \n \n                       \n \n                       \n \n                       \n \n                       \n \n                      int q_mu = 2 * dim + dir; \n \n                      qphix_gauge_cb0[block][q_mu][c1][c2][reim][xx] = QPhiX::rep<FT, double>( \n                        su3_get_elem(&(g_gauge_field[tm_idx_cb0][change_dim[dim]]), c2, c1, reim ) ); \n                      qphix_gauge_cb1[block][q_mu][c1][c2][reim][xx] = QPhiX::rep<FT, double>( \n                        su3_get_elem(&(g_gauge_field[tm_idx_cb1][change_dim[dim]]), c2, c1, reim ) ); \n                    } \n                  } \n                }   \n \n        }", "pragma": "parallel for ", "hash": "314eb16c61a3989a20864921a2769e469a51d2b4a51354f8735a336219400b93"}
{"code": "for (i=0; i<q; i++) {\r \n\t\t\t\tint ij=i^j;\r \n\t\t\t\tif ((ij)>i) {\r \n\t\t\t\t\tif ((i&k)==0 && a[i] > a[ij]) \r \n\t\t\t\t\t\texchange(i,ij);\r \n\t\t\t\t\tif ((i&k)!=0 && a[i] < a[ij])\r \n\t\t\t\t\t\texchange(i,ij);\r \n\t\t\t\t}\r \n\t\t\t}", "pragma": "parallel for ", "hash": "eee049509b83745470614bc6d2f597c5f31218dc067730f3ee171caf0e6c4147"}
{"code": "for (int i = 0; i < static_cast<int>(roadmap.size()); ++i) { \n\t\tfor (int j = 0; j < static_cast<int>(roadmap.size()); ++j) { \n\t\t\tif (sim->queryVisibility(roadmap[i].position, roadmap[j].position, sim->getAgentRadius(0))) { \n\t\t\t\troadmap[i].neighbors.push_back(j); \n\t\t\t} \n\t\t} \n \n\t\t \n \n\t\troadmap[i].distToGoal.resize(4, 9e9f); \n\t}", "pragma": "parallel for ", "hash": "7ab802e3bd33bb77a8165bb6a0f90a62e3a8c1c37454dc503a634dfd5d0466c0"}
{"code": "for (int ibody = 0; ibody < nbody; ibody++) { \n    fcm[ibody][0] = all[ibody][0] + langextra[ibody][0]; \n    fcm[ibody][1] = all[ibody][1] + langextra[ibody][1]; \n    fcm[ibody][2] = all[ibody][2] + langextra[ibody][2]; \n    torque[ibody][0] = all[ibody][3] + langextra[ibody][3]; \n    torque[ibody][1] = all[ibody][4] + langextra[ibody][4]; \n    torque[ibody][2] = all[ibody][5] + langextra[ibody][5]; \n  }", "pragma": "parallel for ", "hash": "1aeff4f0f3067a27229978c7983ca20d5f77a1c43f42effd8c39844694c73ea2"}
{"code": "for(long i=0;i<n1*n2;i++)\tmemcpy(b+i*nx, d->a, nx*sizeof(dual));", "pragma": "parallel for ", "hash": "84a52058bf1d2d8d13a5ab9c68047ddd8a32016286512ec0109f1c4f1feaa565"}
{"code": "for (int i = 0; i < n; ++i) { \n    nparents[i] = diagptr[i] - rowptr[i]; \n    if (nparents[i] == 0) { \n      *tailPtr = i; \n      *(rowPtr + 1) = *rowPtr + extptr[i] - diagptr[i] - 1; \n \n      ++tailPtr; \n      ++rowPtr; \n    } \n  }", "pragma": "for ", "hash": "1d48b5b3ea11d402101ff6af3542c3fbb7cff9aa9853cde55e0fb9bd2c1e2c41"}
{"code": "for(int j = 0; j < data.cols(); ++j) { \n\t\t\tMatrixXd vAt = v.col(j).asDiagonal() * At; \n\t\t\tY.col(j) = WX.col(j) + Q * (Y.col(j) + vAt * (A * vAt).llt().solve(X.col(j))); \n\t\t}", "pragma": "parallel for ", "hash": "c70b0872e6df95875b9c043901e8c108cf57fd5a15cf6c50b73d57081d12dd33"}
{"code": "for(i = 0; i < 2; ++i) \n\t{ \n\t\tSHA512_Context ctx; \n\t\topt_SHA512t256_Init(&ctx); \n\t\topt_SHA512t256_Update(&ctx, pos[i], len[i]); \n\t\topt_SHA512t256_Final(&ctx, cksum[i]); \n\t}", "pragma": "parallel for ", "hash": "530295350c2dbbde7581d18ea84dd4bb6d95a098766a53e5f2d6a3f16caa504e"}
{"code": "for(auto layer = layers.begin() ; layer < layers.end() ; ++layer) \n\t\t\t{ \n\t\t\t\tconst double z = layer->first; \n\t\t\t\tVec2d prev(std::numeric_limits<double>::infinity(), \n\t\t\t\t\t\t   std::numeric_limits<double>::infinity()); \n\t\t\t\tsize_t i = local_cached_lines.size(); \n\t\t\t\tfor(const Vec2d &p : layer->second) \n\t\t\t\t{ \n\t\t\t\t\tif (p.x() == std::numeric_limits<double>::infinity() \n\t\t\t\t\t\t\t|| prev.x() == std::numeric_limits<double>::infinity()) \n\t\t\t\t\t{ \n\t\t\t\t\t\tprev = p; \n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t} \n\t\t\t\t\tlocal_cached_lines.push_back(Vec3f(prev.x(), prev.y(), z)); \n\t\t\t\t\tlocal_cached_lines.push_back(Vec3f(p.x(), p.y(), z)); \n\t\t\t\t\tprev = p; \n\t\t\t\t} \n\t\t\t\tconst float n = local_cached_lines.size() - i; \n\t\t\t\tfor(float k = 0.f ; i < local_cached_lines.size() ; ++i, ++k) \n\t\t\t\t\tlocal_cached_color.push_back(Vec3f(k/n, k/n, k/n)); \n\t\t\t}", "pragma": "for ", "hash": "76d1147d87ea9d63a95ed4feb35197ffbfc68e82999b6ee33a019c203d706b92"}
{"code": "for (int n = 0; n < nchains; n++) { \n            int size = kls[n][0]->size; \n \n            gsl_matrix* dev = KL_getElementsStats(kls[n][0], STAT_STDDEV); \n            gsl_vector* dev_p = KL_getParsStats(kls[n][0], STAT_STDDEV); \n            gsl_matrix* avg = KL_getElementsStats(kls[n][0], STAT_MEAN); \n            gsl_vector* avg_p = KL_getParsStats(kls[n][0], STAT_MEAN); \n \n            int np = 0; \n            for (int i = 1; i < k[0]->system->nplanets + 1; i++) \n                for (int j = 0; j < ELEMENTS_SIZE; j++) \n                    if (K_getElementFlag(k[0], i, j) & MINIMIZE) { \n                        devs[np][n] = MGET(dev, i, j); \n                        avgs[np][n] = MGET(avg, i, j); \n \n                        np++; \n                    } \n            for (int i = 0; i < PARAMS_SIZE; i++) \n                if (K_getParFlag(k[0], i) & MINIMIZE) { \n                    devs[np][n] = VGET(dev_p, i); \n                    avgs[np][n] = VGET(avg_p, i); \n \n                    np++; \n                } \n \n            kls[n][0]->size = (int) (0.9 * size); \n \n            gsl_matrix* dev_90 = KL_getElementsStats(kls[n][0], STAT_STDDEV); \n            gsl_vector* dev_90_p = KL_getParsStats(kls[n][0], STAT_STDDEV); \n            gsl_matrix* avg_90 = KL_getElementsStats(kls[n][0], STAT_MEAN); \n            gsl_vector* avg_90_p = KL_getParsStats(kls[n][0], STAT_MEAN); \n \n            np = 0; \n            for (int i = 1; i < k[0]->system->nplanets + 1; i++) \n                for (int j = 0; j < ELEMENTS_SIZE; j++) \n                    if (K_getElementFlag(k[0], i, j) & MINIMIZE) { \n                        devs_90[np][n] = MGET(dev_90, i, j); \n                        avgs_90[np][n] = MGET(avg_90, i, j); \n                        vals[np][n] = KL_getElement(kls[n][0], size - 1, i, j); \n \n                        if (n == 0) \n                            printf(\"%d %e\\n\", np, vals[np][n]); \n                        np++; \n \n                    } \n            for (int i = 0; i < PARAMS_SIZE; i++) \n                if (K_getParFlag(k[0], i) & MINIMIZE) { \n                    devs_90[np][n] = VGET(dev_90_p, i); \n                    avgs_90[np][n] = VGET(avg_90_p, i); \n                    vals[np][n] = KL_getPar(kls[n][0], size - 1, i); \n                    if (n == 0) \n                        printf(\"%d %e\\n\", np, vals[np][n]); \n                    np++; \n                } \n \n            kls[n][0]->size = (int) (0.5 * size); \n \n            gsl_matrix* dev_2 = KL_getElementsStats(kls[n][0], STAT_STDDEV); \n            gsl_vector* dev_p_2 = KL_getParsStats(kls[n][0], STAT_STDDEV); \n            gsl_matrix* avg_2 = KL_getElementsStats(kls[n][0], STAT_MEAN); \n            gsl_vector* avg_p_2 = KL_getParsStats(kls[n][0], STAT_MEAN); \n \n \n            np = 0; \n            for (int i = 1; i < k[0]->system->nplanets + 1; i++) \n                for (int j = 0; j < ELEMENTS_SIZE; j++) \n                    if (K_getElementFlag(k[0], i, j) & MINIMIZE) { \n                        devs_2[np][n] = MGET(dev_2, i, j); \n                        avgs_2[np][n] = MGET(avg_2, i, j); \n                        np++; \n                    } \n            for (int i = 0; i < PARAMS_SIZE; i++) \n                if (K_getParFlag(k[0], i) & MINIMIZE) { \n                    devs_2[np][n] = VGET(dev_p_2, i); \n                    avgs_2[np][n] = VGET(avg_p_2, i); \n                    np++; \n                } \n \n            kls[n][0]->size = size; \n \n            gsl_matrix_free(dev); \n            gsl_vector_free(dev_p); \n            gsl_matrix_free(avg); \n            gsl_vector_free(avg_p); \n \n            gsl_matrix_free(dev_2); \n            gsl_vector_free(dev_p_2); \n            gsl_matrix_free(avg_2); \n            gsl_vector_free(avg_p_2); \n \n            gsl_matrix_free(dev_90); \n            gsl_vector_free(dev_90_p); \n            gsl_matrix_free(avg_90); \n            gsl_vector_free(avg_90_p); \n        }", "pragma": "parallel for ", "hash": "7d8a610e15157a38e8d3bd48ab9fa6108d82ae32ec344f32bd718b6e81880078"}
{"code": "for(i = 0; i < oldGroupSize; ++i)  \n\t   tempRanks[i] = i;", "pragma": "parallel for ", "hash": "a50ca3f7a4231e49413dc8be3794534952c50d73ee0370c72daaed237fca6cb2"}
{"code": "for (p = 0; p < nbatch; p++) \n    { \n      THNN_(VolumetricMaxUnpooling_updateOutput_frame)( \n        input_data+p*nslices*iT*iW*iH, \n        output_data+p*nslices*oT*oW*oH, \n        indices_data+p*nslices*iT*iW*iH, \n        nslices, \n        iT, iW, iH, \n        oT, oW, oH, \n        dT, dW, dH, \n        pT, pW, pH \n      ); \n    }", "pragma": "parallel for private(p)", "hash": "35aee0b65a2bc6d63c7c02296ec508c86bc36d5904b4b88c4161daead838ca19"}
{"code": "for (size_t j = 0; j < n; j++) { \n          if (alpha != one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          for (size_t k = 0; k < m; k++) { \n            if (B[j * ldb + k] != zero) { \n              if (diag == CBlasNonUnit) B[j * ldb + k] /= A[k * lda + k]; \n              register float complex temp = B[j * ldb + k]; \n              for (size_t i = k + 1; i < m; i++) \n                B[j * ldb + i] -= temp * A[k * lda + i]; \n            } \n          } \n        }", "pragma": "parallel for ", "hash": "802e8d4b181848294b870781ea469373028c4a1a00b4ed2b92ac3f14058289b4"}
{"code": "for (int z = 1; z < _zRes - 1; z++) \n      for (int y = 1; y < _yRes - 1; y++) \n        for (int x = 1; x < _xRes - 1; x++) { \n          int index = z * _slabSize + y * _xRes + x; \n          if (_nodeSolidVolumeFraction[index] >= 1) continue; \n          int up = \n              _nodeSolidVolumeFraction[index + _xRes] >= 1 || y == _yRes - 2 \n                  ? index \n                  : index + _xRes; \n          int down = _nodeSolidVolumeFraction[index - _xRes] >= 1 || y == 1 \n                         ? index \n                         : index - _xRes; \n          Real dy = (up == index || down == index) ? _dhInv : gridSize; \n \n          int out = \n              _nodeSolidVolumeFraction[index + _slabSize] >= 1 || z == _zRes - 2 \n                  ? index \n                  : index + _slabSize; \n          int in = _nodeSolidVolumeFraction[index - _slabSize] >= 1 || z == 1 \n                       ? index \n                       : index - _slabSize; \n \n          Real dz = (out == index || in == index) ? _dhInv : gridSize; \n          int right = _nodeSolidVolumeFraction[index + 1] >= 1 || x == _xRes - 2 \n                          ? index \n                          : index + 1; \n          int left = _nodeSolidVolumeFraction[index - 1] >= 1 || x == 1 \n                         ? index \n                         : index - 1; \n          Real dx = (right == index || left == index) ? _dhInv : gridSize; \n \n          _vorticity[index][0] = ((_velocity[up][2] - _velocity[down][2]) + \n                                  (-_velocity[out][1] + _velocity[in][1])) * \n                                 dz; \n          _vorticity[index][1] = ((_velocity[out][0] - _velocity[in][0]) + \n                                  (-_velocity[right][2] + _velocity[left][2])) * \n                                 dx; \n          _vorticity[index][2] = ((_velocity[right][1] - _velocity[left][1]) + \n                                  (-_velocity[up][0] + _velocity[down][0])) * \n                                 dy; \n          _workspace[index] = _vorticity[index].norm(); \n        }", "pragma": "parallel for ", "hash": "910b1882a80356d6da33eafbe5ce76c9b2ffb2efcc62e1d7c00d85fac0e705c2"}
{"code": "for ( i = 0; i < size; ++i ) \n    { \n        INT k, j, l; \n        INT tid = 0; \n        DOUBLE tD[9] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}; \n        tid = omp_get_thread_num( ); \n        for ( k = g_id; k < i; k += g_numprocs ) \n        { \n            compute_Dij( i , k, tD ); \n            for ( j = 0; j < 3; ++j ) \n            { \n                for ( l = 0; l < 3; ++l ) \n                { \n                    _Rf[tid][ i * DIMS0 + j ] += F[0][ k * DIMS0 + l ] * tD[ j * DIMS0 + l ]; \n \n                    _Rf[tid][ k * DIMS0 + l ] += F[0][ i * DIMS0 + j ] * tD[ j * DIMS0 + l ]; \n \n                } \n            } \n        } \n        if ( g_id == 0 ) \n        { \n            compute_Dij( i , i, tD ); \n            _Rf[tid][ i * DIMS0    ] += F[0][ i * DIMS0    ] * tD[0]; \n            _Rf[tid][ i * DIMS0 + 1] += F[0][ i * DIMS0 + 1] * tD[4]; \n            _Rf[tid][ i * DIMS0 + 2] += F[0][ i * DIMS0 + 2] * tD[8]; \n        } \n    }", "pragma": "parallel for ", "hash": "1c342b16031a4fe4719e1a7bf955ba5703883a7260d92530c361e0007d601e81"}
{"code": "for (vertexID_t i = 0; i < vertices_.size(); ++i) { \n        if (!vertices_[i].is_deleted && vertices_[i].depth < min_depth) { \n            vertices_[i].is_dead = true; \n            ++num_removed; \n        } \n    }", "pragma": "parallel for reduction(+: num_removed) ", "hash": "aae813100f7e7198bae63c8e8defda44c15c02b0fe4b44787241ac25c6011001"}
{"code": "for(size_t i=0; i<np; ++i) { \n    Float rx[3]; \n    double w = weight == nullptr ? 1.0 : *weight; \n    double nb = nbar == nullptr ? 1.0 : *nbar; \n     \n    const double w2 = w*w; \n    w_sum += w; \n    w2_sum += w2; \n    nw2_sum += nb*w2; \n     \n    rx[0] = (xyz[0] - x0[0])*dx_inv; \n    rx[1] = (xyz[1] - x0[1])*dx_inv; \n    rx[2] = (xyz[2] - x0[2])*dx_inv; \n     \n    f(rx, w, grid); \n       \n    xyz    = (float_type*) ((char*) xyz    + xyz_stride); \n     \n    if(weight) \n      weight = (float_type*) ((char*) weight + weight_stride); \n    if(nbar) \n      nbar   = (float_type*) ((char*) nbar   + nbar_stride); \n  }", "pragma": "parallel for ", "hash": "f5b355cca8e5077b865f2e7a23f0d71dccd0fe03b68a92affa60e30b0dce0e14"}
{"code": "for (int i = 0; i < nParticles; i++) { \n    const int id_i = m_colToId.at(i); \n \n    const vector<pair<int, vector<double>>> &PDconnections = \n        m_particles.pdConnections(id_i); \n    const int nConnections = PDconnections.size(); \n    double m = 0; \n    for (int l_j = 0; l_j < nConnections; l_j++) { \n      auto &con = PDconnections[l_j]; \n      if (con.second[m_iConnected] <= 0.5) \n        continue; \n \n      const int id_j = con.first; \n      const int j = m_idToCol_v[id_j]; \n      const double volumeScaling = con.second[m_iVolumeScaling]; \n      const double vol_j = m_data(j, m_iVolume); \n      const double dr0 = con.second[m_iDr0]; \n      const double w = weightFunction(dr0); \n \n      m += w * dr0 * dr0 * vol_j * volumeScaling; \n    } \n \n     \n \n    if (m_analyticalM || nConnections < 3) { \n      if (m_dim == 3) { \n         \n \n        m = M_PI * pow(m_delta, 5);  \n \n      } else { \n         \n \n        m = 2. * m_h * M_PI / 3. * pow(m_delta, 4);  \n \n      } \n    } \n \n    m_data(i, m_iMass) = m; \n    const double alpha = m_data(i, m_iA); \n    m_data(i, m_iMicromodulus) = m_delta * alpha / m; \n  }", "pragma": "parallel for ", "hash": "bb9466b8b6b054b951c6046c8b9d1f3fbd31df8a33905cea5094734c91df4769"}
{"code": "for (int j = 0; j < length; j++) \n\t\t{ \n\t\t\tfloat zj = glm::dot(abc, vec3(Points1[j].x, Points1[j].y, 1)); \n\t\t\tfloat err = abs(Points1[j].z - zj); \n\t\t\tif (err < z_threshold) \n\t\t\t{ \n\t\t\t\tnumber++; \n\t\t\t} \n\t\t}", "pragma": "parallel for reduction(+:number) ", "hash": "e703059a086de4e98df7d2a2fe20e8c0e4f6f72267e43505a70e4d70cd81ffa5"}
{"code": "for (unsigned k = 0; k < cols; k++) \n        fft1d<complex<float>>(fftrows.get() + k, rows, output + k, cols * sizeof(complex<float>), cols * sizeof(complex<float>), twiddleFactors.get() + quickLog2(rows));", "pragma": "parallel for ", "hash": "2d9a2ef768fecad2ab75837ce4dd7178b7d735b1396d085d11b6b07ffd6d9420"}
{"code": "for (int i = 1; i < Nx-1; i++) { \n      for (int j = 1; j < Ny; j++) { \n\tfor (int k = 0; k < Nz; k++) { \n\t   \n \n\t  Ez[i][j][k] = c1e[i][j][k] * Ez[i][j][k] + c2e[i][j][k] *  \t    ( ( Hy[i][j][k] - Hy[i-1][j][k] ) / dx -  \t      ( Hx[i][j][k] - Hx[i][j-1][k] ) / dy ) - c2e[i][j][k] * Jez[i][j][k]; \n\t} \n      } \n       \n \n      Ezinc[i] = c1e0 * Ezinc[i] + c2e0 * ( Hyinc[i] - Hyinc[i-1] ) / dx; \n    }", "pragma": "parallel for ", "hash": "0943765c120fa4d2101aa6a37871e47f547ae944aab83f4dfc0b17ad45feccfb"}
{"code": "for(int col = 0; col < num_cols; col++) {\r \n       for(int row = 0; row < num_rows; row++) {\r \n           int i = col + row * num_cols;\r \n           c[i] = a[i] + b[i];\r \n       }\r \n    }", "pragma": "parallel for ", "hash": "9a88ed7beb93d20a6143e4d477c3c26b42cb705385f6c9bd8887b8bb82c01522"}
{"code": "for( int x0=0; x0<T; x0++ ) \n    for( int x1=0; x1<LX; x1++ ) \n      for( int x2=0; x2<LY; x2++ ) \n        for( int x3=0; x3<LZ; x3++ ) { \n          int j = x3 + LZ*x2 + LY*LZ*x1 + LX*LY*LZ*x0; \n          int tm_idx = x1 + LX*x2 + LY*LX*x3 + LZ*LY*LX*x0; \n          int j = x1 + LX*x2 + LY*LX*x3 + LZ*LY*LX*x0; \n          int tm_idx   = x3 + LZ*x2 + LY*LZ*x1 + LX*LY*LZ*x0; \n          int oddBit = (x0+x1+x2+x3) & 1; \n \n          if( doublet ) { \n            memcpy( &(sp[24*(oddBit*VOLUME+j/2)]),          &(tempSpinor[24* tm_idx        ]), 24*sizeof(double)); \n            memcpy( &(sp2[24*(oddBit*VOLUME+j/2+VOLUME/2)]), &(tempSpinor[24*(tm_idx+VOLUME)]), 24*sizeof(double)); \n          } \n          else { \n            memcpy( &(sp[24*(oddBit*VOLUME/2+j/2)]), &(tempSpinor[24*tm_idx]), 24*sizeof(double)); \n          } \n \n        }", "pragma": "parallel for ", "hash": "f706140a143ac63147aecf8009c1fd410e960928ed2e076cd45dadeb75a4f432"}
{"code": "for(long j=0;j<n;j++)\r \n\t{\r \n\t\tlong jp = (j+1)%n;\r \n\t\tmreal h1=real(h[n*j]), h2=real(h[n-1+n*j]);\r \n\t\tmreal g1=(h1+real(h[n*jp]))/2, g2=(h2+real(h[n-1+n*jp]))/2;\r \n\t\tmreal k1=M_PI*2*j/n, k2 = M_PI*(2*j+1)/n;\r \n\t\tfor(long i=0;i<i1;i++)\r \n\t\t{\r \n\t\t\tf[2*j] += a[i]*exp(dual(0,h1+i*k1));\r \n\t\t\tf[2*j+1] += a[i]*exp(dual(0,g1+i*k2));\r \n\t\t}\r \n\t\tfor(long i=i1;i<i2;i++)\r \n\t\t{\r \n\t\t\tmreal hh = real(h[i-i1+n*j]);\r \n\t\t\tf[2*j] += a[i]*exp(dual(0,hh+i*k1));\r \n\t\t\tf[2*j+1] += a[i]*exp(dual(0,(hh+real(h[i-i1+n*jp]))/2+i*k2));\r \n\t\t}\r \n\t\tfor(long i=i2;i<2*n;i++)\r \n\t\t{\r \n\t\t\tf[2*j] += a[i]*exp(dual(0,h2+i*k1));\r \n\t\t\tf[2*j+1] += a[i]*exp(dual(0,g2+i*k2));\r \n\t\t}\r \n\t}", "pragma": "parallel ", "hash": "ad4c13bfb8e10be3792a4e898dbf261aac94edb11100979fa5a6f652368047fe"}
{"code": "for (x = 0; x < width; ++x) { \n        HEMAN_FLOAT* pl1 = NEW(HEMAN_FLOAT, height * 2); \n        HEMAN_FLOAT* pl2 = NEW(HEMAN_FLOAT, height * 2); \n        HEMAN_FLOAT* f = ff + height * x; \n        HEMAN_FLOAT* d = dd + height * x; \n        HEMAN_FLOAT* z = zz + (height + 1) * x; \n        uint16_t* w = ww + height * x; \n        for (int y = 0; y < height; ++y) { \n            f[y] = SDISTFIELD_TEXEL(x, y); \n            pl1[y * 2] = COORDFIELD_TEXEL(x, y, 0); \n            pl1[y * 2 + 1] = COORDFIELD_TEXEL(x, y, 1); \n        } \n        edt_with_payload(f, d, z, w, height, pl1, pl2); \n        for (int y = 0; y < height; ++y) { \n            SDISTFIELD_TEXEL(x, y) = d[y]; \n            COORDFIELD_TEXEL(x, y, 0) = pl2[2 * y]; \n            COORDFIELD_TEXEL(x, y, 1) = pl2[2 * y + 1]; \n        } \n        free(pl1); \n        free(pl2); \n    }", "pragma": "parallel for ", "hash": "1f27f83cf7604557eb3f06a163167605a7631668f3d0441a6929cdcf8e338a3f"}
{"code": "for (int64_t pixelIndex = 0; pixelIndex < int64_t(state.pixelCount); ++pixelIndex) \n\t{ \n\t\ttry \n\t\t{ \n\t\t\tif (interrupted) \n\t\t\t\tcontinue; \n \n\t\t\tuint64_t offsetPixelIndex = uint64_t(pixelIndex) + state.pixelStartOffset; \n\t\t\tdouble x = double(offsetPixelIndex % state.filmWidth); \n\t\t\tdouble y = double(offsetPixelIndex / state.filmWidth); \n\t\t\tVector2 pixelCoordinate = Vector2(x, y); \n\t\t\tstd::mt19937& generator = generators[omp_get_thread_num()]; \n \n\t\t\tgenerateMultiSamples(*state.scene, *state.film, pixelCoordinate, uint64_t(pixelIndex), generator, interrupted); \n\t\t\t \n\t\t\t \n \n\t\t\tif ((pixelIndex + 1) % 100 == 0) \n\t\t\t\tstate.pixelsProcessed += 100; \n\t\t} \n\t\tcatch (...) \n\t\t{ \n\t\t\tstd::lock_guard<std::mutex> lock(ompThreadExceptionMutex); \n \n\t\t\tif (ompThreadException == nullptr) \n\t\t\t\tompThreadException = std::current_exception(); \n \n\t\t\tinterrupted = true; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "fa47dd6ed4224f926a7dcd645da914f888ffe1b1919644416991f18859f2f775"}
{"code": "for(long j=0;j<m*l;j++)\tb.a[j+m*l*i] = b.a[j+m*l*i]*sqrt(asum/asum0)/amax;", "pragma": "parallel for ", "hash": "488bab8dbf095e805831ab7a745ec1131bce020ef9d90f9815e1d7637341153b"}
{"code": "for (int i = 0; i <= m_nReaches; i++) \n        m_percSubbasin[i] = 0.f;", "pragma": "parallel for ", "hash": "66d6a203a94a4d3c7dd89aee9351fc0b91ed55bbd98aa0d67fb212df934b435d"}
{"code": "for (long j = 1; j < ny - 1; ++j) {\r \n\t\tu(nx, j) = u(nx - 1, j);\r \n\t}", "pragma": "parallel ", "hash": "d5157de9f0d3226ea5ffe1c7198f279fcc747495ca32e3f0cc958c28b25dc104"}
{"code": "for(auto it = this->values.begin(); \n      it < this->values.end(); it++) { \n     \n \n     \n \n    if(it->iterations == this->total_iterations) { \n       \n \n      for(int i = 0; i < n && \n\t    it->current.smagnitude() <= max_squared; i++) { \n\t \n \n\tit->current = it->current.square() + it->initial; \n\tit->iterations++; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "a667ece62aee1603da12150b301d3302a2b28baf781214f657075084f6c88b51"}
{"code": "for (isym = 0; isym < nsym; ++isym) { \n \n        for (i = 0; i < 3; ++i) { \n            for (j = 0; j < 3; ++j) { \n                rot_double[i][j] = static_cast<double>(SymmData[isym].rotation[i][j]); \n            } \n        } \n \n        for (itype = 0; itype < natomtypes; ++itype) { \n \n            for (ii = 0; ii < atomtype_group[itype].size(); ++ii) { \n \n                iat = atomtype_group[itype][ii]; \n \n                for (i = 0; i < 3; ++i) x_tmp[i] = cell.x_fractional[iat][i]; \n                rotvec(xnew, x_tmp, rot_double); \n \n                for (i = 0; i < 3; ++i) xnew[i] += SymmData[isym].tran[i]; \n \n                for (jj = 0; jj < atomtype_group[itype].size(); ++jj) { \n \n                    jat = atomtype_group[itype][jj]; \n \n                    for (i = 0; i < 3; ++i) { \n                        tmp[i] = std::fmod(std::abs(cell.x_fractional[jat][i] - xnew[i]), 1.0); \n                        tmp[i] = std::min<double>(tmp[i], 1.0 - tmp[i]); \n                    } \n                    diff = tmp[0] * tmp[0] + tmp[1] * tmp[1] + tmp[2] * tmp[2]; \n                    if (diff < tolerance * tolerance) { \n                        map_sym[iat][isym] = jat; \n                        break; \n                    } \n                } \n                if (map_sym[iat][isym] == -1) { \n                    exit(\"gen_mapping_information\", \n                         \"cannot find symmetry for operation # \", \n                         isym + 1); \n                } \n            } \n        } \n    }", "pragma": "parallel for private(            diff i iat ii isym itype j jat jj rot_double tmp x_tmp xnew)", "hash": "247ff39fbabbaccd34ab8b49b689519e446326b43c1ec46b5cc1bc6e8ac60ccf"}
{"code": "for (int j = 0; j < Y; j++) {\r \n            for (int _batch_idx = 0; _batch_idx < BatchSize; _batch_idx++) {\r \n\r \n                 \n \n                float _wk7 = 0;\r \n                for(int i = 0; i < X; i++){\r \n                    _wk7 += wOin[X * j + i] * x[(X * t + i) * BatchSize + _batch_idx];\r \n                }\r \n                float _wk8 = 0;\r \n                for(int i = 0; i < Y; i++){\r \n                    _wk8 += wOr[Y * j + i] * (0 <= t - 1 ? y[(Y * (t -1) + i) * BatchSize + _batch_idx] : 0);\r \n                }\r \n                uO[(Y * t + j) * BatchSize + _batch_idx] = _wk7 + _wk8 + wO[j] * s[(Y * t + j) * BatchSize + _batch_idx] + bO[j];\r \n\r \n            }\r \n        }", "pragma": "parallel ", "hash": "8ca391cbd3f9b066cfb62a18451e3b346cf200834517a8e33f17937f4fa7e18b"}
{"code": "for (int color_index = 0; color_index < 2; color_index++) { \n    Color the_color = flags.at(color_index); \n \n    std::vector<CCharacter> charVec; \n    charVec.reserve(128); \n \n    match.at(color_index) = Mat::zeros(image.rows, image.cols, image.type()); \n \n    Mat result = image.clone(); \n\t \n \n    cvtColor(result, result, COLOR_GRAY2BGR); \n \n    size_t size = all_contours.at(color_index).size(); \n \n    int char_index = 0; \n    int char_size = 20; \n \n     \n \n    int char_max_count = 7; \n\tfloat delta_heightEnlargeRatio = 0.0f; \n \n     \n \n    for (size_t index = 0; index < size; index++) { \n      Rect rect = all_boxes.at(color_index)[index]; \n      std::vector<Point>& contour = all_contours.at(color_index)[index]; \n \n      if (usePlateMser) { \n        RotatedRect rrect = minAreaRect(Mat(contour)); \n        if (verifyRotatedPlateSizes(rrect)) { \n           \n \n          if (the_color == BLUE) out_plateRRect_blue.push_back(rrect); \n          if (the_color == YELLOW) out_plateRRect_yellow.push_back(rrect); \n        } \n      } \n \n       \n \n      if (verifyCharSizes(rect)) { \n        Mat mserMat = adaptive_image_from_points(contour, rect, Size(char_size, char_size)); \n        Mat charInput = preprocessChar(mserMat, char_size); \n        Rect charRect = rect; \n \n        Point center(charRect.tl().x + charRect.width / 2, charRect.tl().y + charRect.height / 2); \n        Mat tmpMat; \n\t\t \n \n        double ostu_level = cv::threshold(image(charRect), tmpMat, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU); \n \n         \n \n \n         \n \n         \n \n        if (judegMDOratio2(image, rect, contour, result)) { \n          CCharacter charCandidate; \n          charCandidate.setCharacterPos(charRect); \n          charCandidate.setCharacterMat(charInput); \n          charCandidate.setOstuLevel(ostu_level); \n          charCandidate.setCenterPoint(center); \n          charCandidate.setIsChinese(false); \n          charVec.push_back(charCandidate); \n        } \n      } \n    } \n \n\t \n \n\tif (show_flag){ \n\t\tcv::String win_name; \n\t\tfor (int i = 0; i < charVec.size(); i++){ \n\t\t\trectangle(image_charVec.at(color_index), charVec.at(i).getCharacterPos(), Scalar(0,0,255)); \n\t\t} \n\t\tif (color_index == 0){ \n\t\t\twin_name = \"image_charVec_BLUE\"; \n\t\t} \n\t\telse if (color_index == 1){ \n\t\t\twin_name = \"image_charVec_YELLOW\"; \n\t\t} \n\t\timshow(win_name, image_charVec.at(color_index)); \n\t\twaitKey(0); \n\t\tdestroyWindow(win_name); \n\t} \n \n\tif (write_flag){ \n\t\tcv::String win_name; \n\t\tif (color_index == 0){ \n\t\t\twin_name = \"image_charVec_BLUE\"; \n\t\t} \n\t\telse if (color_index == 1){ \n\t\t\twin_name = \"image_charVec_YELLOW\"; \n\t\t} \n\t\tfor (int i = 0; i < charVec.size(); i++){ \n\t\t\trectangle(image_charVec.at(color_index), charVec.at(i).getCharacterPos(), Scalar(0, 0, 255)); \n\t\t} \n\t\tstd::string path = \"resources/image/interface/show_detect/\" + win_name + \".png\"; \n\t\tcv::imwrite(path, image_charVec.at(color_index)); \n\t} \n\t \n     \n \n     \n \n     \n \n     \n \n     \n \n     \n \n\t \n \n\t \n \n    CharsIdentify::instance()->classify(charVec); \n \n\t \n \n    double overlapThresh = 0.6; \n     \n \n\t \n \n    NMStoCharacter(charVec, overlapThresh); \n    charVec.shrink_to_fit(); \n \n\t \n \n\tif (show_flag){ \n\t\tfor (int i = 0; i < charVec.size(); i++){ \n\t\t\trectangle(image_charVec.at(color_index + 2), charVec.at(i).getCharacterPos(), Scalar(0, 0, 255)); \n\t\t} \n\t\timshow(\"charVec_remove_overlap\", image_charVec.at(color_index + 2)); \n\t\twaitKey(0); \n\t\tdestroyWindow(\"charVec_remove_overlap\"); \n\t} \n \n\tif (write_flag){ \n\t\tcv::String win_name; \n\t\tif (color_index == 0){ \n\t\t\twin_name = \"charVec_remove_overlap_BLUE\"; \n\t\t} \n\t\telse if (color_index == 1){ \n\t\t\twin_name = \"charVec_remove_overlap_YELLOW\"; \n\t\t} \n\t\tfor (int i = 0; i < charVec.size(); i++){ \n\t\t\trectangle(image_charVec.at(color_index + 2), charVec.at(i).getCharacterPos(), Scalar(0, 0, 255)); \n\t\t} \n\t\tstd::string path = \"resources/image/interface/show_detect/\" + win_name + \".png\"; \n\t\tcv::imwrite(path, image_charVec.at(color_index + 2)); \n\t} \n \n    std::vector<CCharacter> strongSeedVec; \n    strongSeedVec.reserve(64); \n    std::vector<CCharacter> weakSeedVec; \n    weakSeedVec.reserve(64); \n    std::vector<CCharacter> littleSeedVec; \n    littleSeedVec.reserve(64); \n \n     \n \n    for (auto charCandidate : charVec) { \n       \n      Rect rect = charCandidate.getCharacterPos(); \n      double score = charCandidate.getCharacterScore(); \n\t   \n \n      if (charCandidate.getIsStrong()) { \n        strongSeedVec.push_back(charCandidate); \n      } \n \n      else if (charCandidate.getIsWeak()) { \n        weakSeedVec.push_back(charCandidate); \n         \n \n      } \n \n      else if (charCandidate.getIsLittle()) { \n        littleSeedVec.push_back(charCandidate); \n         \n \n      } \n    } \n \n    std::vector<CCharacter> searchCandidate = charVec; \n \n     \n \n\t \n \n    overlapThresh = 0.3; \n    NMStoCharacter(strongSeedVec, overlapThresh); \n \n     \n \n    std::vector<std::vector<CCharacter>> charGroupVec; \n    charGroupVec.reserve(64); \n    mergeCharToGroup(strongSeedVec, charGroupVec); \n \n\t \n \n\t \n \n\t \n \n\t \n \n    std::vector<CPlate> plateVec; \n    plateVec.reserve(16); \n    for (auto charGroup : charGroupVec) { \n\t   \n \n      Rect plateResult = charGroup[0].getCharacterPos(); \n      std::vector<Point> points; \n      points.reserve(32); \n \n      Vec4f line; \n      int maxarea = 0; \n      Rect maxrect; \n      double ostu_level_sum = 0; \n\t   \n \n\t   \n \n      int leftx = image.cols; \n      Point leftPoint(leftx, 0); \n      int rightx = 0; \n      Point rightPoint(rightx, 0); \n \n      std::vector<CCharacter> mserCharVec; \n      mserCharVec.reserve(32); \n \n       \n \n      std::vector<CCharacter> roCharGroup; \n      roCharGroup.reserve(32); \n      removeRightOutliers(charGroup, roCharGroup, 0.2, 0.5, result); \n \n      for (auto character : roCharGroup) { \n        Rect charRect = character.getCharacterPos(); \n\t\t \n \n        cv::rectangle(result, charRect, Scalar(0, 255, 0), 1); \n\t\t \n\t\t \n \n        plateResult |= charRect; \n \n        Point center(charRect.tl().x + charRect.width / 2, charRect.tl().y + charRect.height / 2); \n        points.push_back(center); \n        mserCharVec.push_back(character); \n         \n \n \n        ostu_level_sum += character.getOstuLevel(); \n\t\t \n \n        if (charRect.area() > maxarea) { \n          maxrect = charRect; \n          maxarea = charRect.area(); \n        } \n        if (center.x < leftPoint.x) { \n          leftPoint = center; \n        } \n        if (center.x > rightPoint.x) { \n          rightPoint = center; \n        } \n      } \n \n\t  if (show_flag){ \n\t\t  imshow(\"result_strong_seed\", result); \n\t\t  waitKey(0); \n\t\t  destroyWindow(\"result_strong_seed\"); \n\t  } \n\t  if (write_flag){ \n\t\t  cv::String win_name; \n\t\t  if (color_index == 0){ \n\t\t\t  win_name = \"result_strong_seed_BLUE\"; \n\t\t  } \n\t\t  else if (color_index == 1){ \n\t\t\t  win_name = \"result_strong_seed_YELLOW\"; \n\t\t  } \n\t\t  std::string path = \"resources/image/interface/show_detect/\" + win_name + \".png\"; \n\t\t  cv::imwrite(path, result); \n\t  } \n \n\t  int count_yellow = 0, count_green = 0; \n \n\t   \n \n\t   \n \n\t   \n \n\t  if (color_index == 1){ \n\t\t  cv::rectangle(result, plateResult, Scalar(255, 255, 0)); \n\t\t  Mat plateResultColor = src_color(plateResult); \n\t\t  if (0) { \n\t\t\t  imshow(\"plateResult\", result); \n\t\t\t  waitKey(0); \n\t\t\t  destroyWindow(\"plateResult\"); \n\t\t  } \n\t\t  if (0) { \n\t\t\t  imshow(\"plateResultColor\", plateResultColor); \n\t\t\t  waitKey(0); \n\t\t\t  destroyWindow(\"plateResultColor\"); \n\t\t  } \n\t\t  Mat yellow_b_match, green_b_match; \n\t\t  colorMatch(plateResultColor, yellow_b_match, YELLOW, true); \n\t\t  colorMatch(plateResultColor, green_b_match, GREEN, true); \n\t\t  if (0){ \n\t\t\t  imshow(\"yellow_b_match\", yellow_b_match); \n\t\t\t  waitKey(0); \n\t\t\t  destroyWindow(\"yellow_b_match\"); \n\t\t  } \n\t\t  if (0){ \n\t\t\t  imshow(\"green_b_match\", green_b_match); \n\t\t\t  waitKey(0); \n\t\t\t  destroyWindow(\"green_b_match\"); \n\t\t  } \n \n\t\t  for (int i = 0; i < yellow_b_match.rows; i++){ \n\t\t\t  for (int j = 0; j < yellow_b_match.cols; j++){ \n\t\t\t\t  if (yellow_b_match.at<uchar>(i, j) != 0){ \n\t\t\t\t\t  count_yellow++; \n\t\t\t\t  } \n\t\t\t  } \n\t\t  } \n\t\t  for (int i = 0; i < green_b_match.rows; i++){ \n\t\t\t  for (int j = 0; j < green_b_match.cols; j++){ \n\t\t\t\t  if (green_b_match.at<uchar>(i, j) != 0){ \n\t\t\t\t\t  count_green++; \n\t\t\t\t  } \n\t\t\t  } \n\t\t  } \n\t  } \n \n      double ostu_level_avg = ostu_level_sum / (double)roCharGroup.size(); \n      if (1 && showDebug) { \n        std::cout << \"ostu_level_avg:\" << ostu_level_avg << std::endl; \n      } \n\t   \n \n      float ratio_maxrect = (float)maxrect.width / (float)maxrect.height; \n \n\t   \n \n      if (points.size() >= 2 && ratio_maxrect >= 0.3) { \n        fitLine(Mat(points), line, CV_DIST_L2, 0, 0.01, 0.01); \n \n        float k = line[1] / line[0]; \n         \n \n         \n \n         \n \n         \n \n         \n \n \n        std::sort(mserCharVec.begin(), mserCharVec.end(), \n          [](const CCharacter& r1, const CCharacter& r2) { \n          return r1.getCharacterPos().tl().x < r2.getCharacterPos().tl().x; \n        }); \n \n\t\t \n \n        CCharacter midChar = mserCharVec.at(int(mserCharVec.size() / 2.f)); \n        Rect midRect = midChar.getCharacterPos(); \n        Point midCenter(midRect.tl().x + midRect.width / 2, midRect.tl().y + midRect.height / 2); \n \n        int mindist = 7 * maxrect.width; \n        std::vector<Vec2i> distVecVec; \n        distVecVec.reserve(32); \n \n        Vec2i mindistVec; \n        Vec2i avgdistVec; \n \n\t\t \n \n\t\t \n \n\t\t \n \n        for (size_t mser_i = 0; mser_i + 1 < mserCharVec.size(); mser_i++) { \n          Rect charRect = mserCharVec.at(mser_i).getCharacterPos(); \n           \n \n \n          Rect charRectCompare = mserCharVec.at(mser_i + 1).getCharacterPos(); \n           \n \n           \n \n \n           \n \n          Vec2i distVec(charRectCompare.x - charRect.x, charRectCompare.y - charRect.y); \n          distVecVec.push_back(distVec); \n \n           \n \n           \n \n           \n \n           \n \n        } \n \n        std::sort(distVecVec.begin(), distVecVec.end(), \n          [](const Vec2i& r1, const Vec2i& r2) { \n          return r1[0] < r2[0]; \n        }); \n \n        avgdistVec = distVecVec.at(int((distVecVec.size() - 1) / 2.f)); \n \n\t\t \n \n        float step = (float)avgdistVec[0]; \n \n         \n \n        cv::line(result, Point2f(midCenter.x - step, midCenter.y - k*step), Point2f(midCenter.x + step, k*step + midCenter.y), Scalar(255, 255, 255)); \n\t\tif (show_flag){ \n\t\t\timshow(\"white_line\", result); \n\t\t\twaitKey(0); \n\t\t\tdestroyWindow(\"white_line\"); \n\t\t} \n\t\tif (write_flag){ \n\t\t\tcv::String win_name; \n\t\t\tif (color_index == 0){ \n\t\t\t\twin_name = \"white_line_BLUE\"; \n\t\t\t} \n\t\t\telse if (color_index == 1){ \n\t\t\t\twin_name = \"white_line_YELLOW\"; \n\t\t\t} \n\t\t\tstd::string path = \"resources/image/interface/show_detect/\" + win_name + \".png\"; \n\t\t\tcv::imwrite(path, result); \n\t\t} \n \n        CPlate plate; \n        plate.setPlateLeftPoint(leftPoint); \n        plate.setPlateRightPoint(rightPoint); \n \n        plate.setPlateLine(line); \n        plate.setPlatDistVec(avgdistVec); \n        plate.setOstuLevel(ostu_level_avg); \n \n        plate.setPlateMergeCharRect(plateResult); \n        plate.setPlateMaxCharRect(maxrect); \n        plate.setMserCharacter(mserCharVec); \n\t\t \n \n\t\tif (count_green > count_yellow){ \n\t\t\tchar_max_count += 2; \n\t\t\tdelta_heightEnlargeRatio = 0.2; \n\t\t\tplate.setIsNewEnergy(true); \n\t\t} \n        plateVec.push_back(plate); \n      } \n    } \n \n\t \n \n\t \n \n\t \n \n\t \n \n    for (auto plate : plateVec) { \n      Vec4f line = plate.getPlateLine(); \n      Point leftPoint = plate.getPlateLeftPoint(); \n      Point rightPoint = plate.getPlateRightPoint(); \n \n      Rect plateResult = plate.getPlateMergeCharRect(); \n      Rect maxrect = plate.getPlateMaxCharRect(); \n      Vec2i dist = plate.getPlateDistVec(); \n      double ostu_level = plate.getOstuLevel(); \n \n      std::vector<CCharacter> mserCharacter = plate.getCopyOfMserCharacters(); \n      mserCharacter.reserve(16); \n \n      float k = line[1] / line[0]; \n      float x_1 = line[2]; \n      float y_1 = line[3]; \n \n      std::vector<CCharacter> searchWeakSeedVec; \n      searchWeakSeedVec.reserve(16); \n \n      std::vector<CCharacter> searchRightWeakSeed; \n      searchRightWeakSeed.reserve(8); \n      std::vector<CCharacter> searchLeftWeakSeed; \n      searchLeftWeakSeed.reserve(8); \n \n      std::vector<CCharacter> slideRightWindow; \n      slideRightWindow.reserve(8); \n      std::vector<CCharacter> slideLeftWindow; \n      slideLeftWindow.reserve(8); \n \n       \n \n       \n \n      if (1 && showDebug) { \n        std::cout << \"search for mser rect:\" << std::endl; \n      } \n \n      if (0 && showDebug) { \n        std::stringstream ss(std::stringstream::in | std::stringstream::out); \n        ss << \"resources/image/tmp/\" << img_index << \"_1_\" << \"searcgMserRect.jpg\"; \n        imwrite(ss.str(), result); \n      } \n      if (1 && showDebug) { \n        std::cout << \"mserCharacter:\" << mserCharacter.size() << std::endl; \n      } \n \n\t   \n \n\t   \n \n      if (mserCharacter.size() < char_max_count) { \n        double thresh1 = 0.15; \n        double thresh2 = 2.0; \n\t\t \n \n        searchWeakSeed(searchCandidate, searchRightWeakSeed, thresh1, thresh2, line, rightPoint, \n          maxrect, plateResult, result, CharSearchDirection::RIGHT); \n        if (1 && showDebug) { \n          std::cout << \"searchRightWeakSeed:\" << searchRightWeakSeed.size() << std::endl; \n        } \n\t\t \n \n        for (auto seed : searchRightWeakSeed) { \n          cv::rectangle(result, seed.getCharacterPos(), Scalar(255, 0, 0), 1); \n          mserCharacter.push_back(seed); \n        } \n\t\t \n \n        searchWeakSeed(searchCandidate, searchLeftWeakSeed, thresh1, thresh2, line, leftPoint, \n          maxrect, plateResult, result, CharSearchDirection::LEFT); \n        if (1 && showDebug) { \n          std::cout << \"searchLeftWeakSeed:\" << searchLeftWeakSeed.size() << std::endl; \n        } \n\t\t \n \n        for (auto seed : searchLeftWeakSeed) { \n          cv::rectangle(result, seed.getCharacterPos(), Scalar(255, 0, 0), 1); \n          mserCharacter.push_back(seed); \n        } \n      } \n \n\t   \n \n\t   \n \n      float min_thresh = 0.3f; \n      float max_thresh = 2.5f; \n      reFoundAndCombineRect(mserCharacter, min_thresh, max_thresh, dist, maxrect, result); \n \n\t   \n \n\t   \n \n      if (mserCharacter.size() < char_max_count) { \n        if (1 && showDebug) { \n          std::cout << \"search chinese:\" << std::endl; \n          std::cout << \"judege the left is chinese:\" << std::endl; \n        } \n \n         \n \n\t\t \n \n        bool leftIsChinese = false; \n        if (1) { \n          std::sort(mserCharacter.begin(), mserCharacter.end(), \n            [](const CCharacter& r1, const CCharacter& r2) { \n            return r1.getCharacterPos().tl().x < r2.getCharacterPos().tl().x; \n          }); \n \n          CCharacter leftChar = mserCharacter[0]; \n \n           \n \n          Rect theRect = leftChar.getCharacterPos(); \n           \n \n \n          Mat region = image(theRect); \n          Mat binary_region; \n \n          ostu_level = cv::threshold(region, binary_region, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU); \n          if (1 && showDebug) { \n            std::cout << \"left : ostu_level:\" << ostu_level << std::endl; \n          } \n           \n\t\t   \n \n          Mat charInput = preprocessChar(binary_region, char_size); \n          if (0  \n) { \n            imshow(\"charInput\", charInput); \n            waitKey(0); \n            destroyWindow(\"charInput\"); \n          } \n \n          std::string label = \"\"; \n          float maxVal = -2.f; \n          leftIsChinese = CharsIdentify::instance()->isCharacter(charInput, label, maxVal, true); \n           \n \n           \n \n          if (0  \n) { \n            std::cout << \"isChinese:\" << leftIsChinese << std::endl; \n            std::cout << \"chinese:\" << label; \n            std::cout << \"__score:\" << maxVal << std::endl; \n          } \n        } \n \n         \n \n        float ratioWindow  = 0.4f; \n        float threshIsCharacter = 0.8f; \n         \n        if (!leftIsChinese) { \n          slideWindowSearch(image, slideLeftWindow, line, leftPoint, dist, ostu_level, ratioWindow, threshIsCharacter, \n            maxrect, plateResult, CharSearchDirection::LEFT, true, result); \n          if (1 && showDebug) { \n            std::cout << \"slideLeftWindow:\" << slideLeftWindow.size() << std::endl; \n          } \n          for (auto window : slideLeftWindow) { \n\t\t\t \n \n            cv::rectangle(result, window.getCharacterPos(), Scalar(0, 0, 255), 1); \n            mserCharacter.push_back(window); \n          } \n        } \n      } \n \n       \n \n\t   \n \n      if (mserCharacter.size() < char_max_count) { \n         \n \n        float ratioWindow  = 0.4f; \n        float threshIsCharacter = 0.8f; \n         \n        slideWindowSearch(image, slideRightWindow, line, rightPoint, dist, plate.getOstuLevel(), ratioWindow, threshIsCharacter, \n          maxrect, plateResult, CharSearchDirection::RIGHT, false, result); \n        if (1 && showDebug) { \n          std::cout << \"slideRightWindow:\" << slideRightWindow.size() << std::endl; \n        } \n        for (auto window : slideRightWindow) { \n          cv::rectangle(result, window.getCharacterPos(), Scalar(0, 0, 255), 1); \n          mserCharacter.push_back(window); \n        } \n      } \n \n       \n \n      float angle = atan(k) * 180 / (float)CV_PI; \n      if (1 && showDebug) { \n        std::cout << \"k:\" << k << std::endl; \n        std::cout << \"angle:\" << angle << std::endl; \n      } \n \n       \n \n      float widthEnlargeRatio = 1.25f; \n \n\t  float heightEnlargeRatio = 1.3f + delta_heightEnlargeRatio; \n \n      RotatedRect platePos(Point2f((float)plateResult.x + plateResult.width / 2.f, (float)plateResult.y + plateResult.height / 2.f), \n        Size2f(plateResult.width * widthEnlargeRatio, maxrect.height * heightEnlargeRatio), angle); \n \n\t   \n \n\t  if (show_flag) { \n\t\t  imshow(\"all_searched\", result); \n\t\t  waitKey(0); \n\t\t  destroyWindow(\"all_searched\"); \n\t  } \n\t  if (write_flag){ \n\t\t  cv::String win_name; \n\t\t  if (color_index == 0){ \n\t\t\t  win_name = \"all_searched_BLUE\"; \n\t\t  } \n\t\t  else if (color_index == 1){ \n\t\t\t  win_name = \"all_searched_YELLOW\"; \n\t\t  } \n\t\t  std::string path = \"resources/image/interface/show_detect/\" + win_name + \".png\"; \n\t\t  cv::imwrite(path, result); \n\t  } \n \n       \n \n      if (verifyRotatedPlateSizes(platePos)) { \n        rotatedRectangle(result, platePos, Scalar(0, 0, 255), 1); \n \n        plate.setPlatePos(platePos); \n        plate.setPlateColor(the_color); \n        plate.setPlateLocateType(CMSER); \n \n        if (the_color == BLUE) out_plateVec_blue.push_back(plate); \n        if (the_color == YELLOW) out_plateVec_yellow.push_back(plate); \n      } \n \n\t   \n \n      if (1) { \n        for (auto mserChar : mserCharacter) { \n          Rect rect = mserChar.getCharacterPos(); \n          match.at(color_index)(rect) = 255; \n        } \n        cv::line(match.at(color_index), rightPoint, leftPoint, Scalar(255)); \n      } \n    } \n \n    if (0  \n) { \n      imshow(\"result\", result); \n      waitKey(0); \n      destroyWindow(\"result\"); \n    } \n \n\tif (show_flag) { \n      imshow(\"match\", match.at(color_index)); \n      waitKey(0); \n      destroyWindow(\"match\"); \n    } \n\tif (write_flag){ \n\t\tcv::String win_name; \n\t\tif (color_index == 0){ \n\t\t\twin_name = \"match_BLUE\"; \n\t\t} \n\t\telse if (color_index == 1){ \n\t\t\twin_name = \"match_YELLOW\"; \n\t\t} \n\t\tstd::string path = \"resources/image/interface/show_detect/\" + win_name + \".png\"; \n\t\tcv::imwrite(path, match.at(color_index)); \n\t} \n\t \n \n\tif (show_flag) { \n      std::stringstream ss(std::stringstream::in | std::stringstream::out); \n      ss << \"resources/image/tmp/plateDetect/plate_\" << img_index << \"_\" << the_color << \".jpg\"; \n\t  imwrite(ss.str(), result); \n\t  imshow(\"mser_result\", result); \n\t  waitKey(0); \n\t  destroyWindow(\"mser_result\"); \n    } \n\tif (write_flag){ \n\t\tcv::String win_name; \n\t\tif (color_index == 0){ \n\t\t\twin_name = \"mser_result_BLUE\"; \n\t\t} \n\t\telse if (color_index == 1){ \n\t\t\twin_name = \"mser_result_YELLOW\"; \n\t\t} \n\t\tstd::string path = \"resources/image/interface/show_detect/\" + win_name + \".png\"; \n\t\tcv::imwrite(path, result); \n\t} \n  }", "pragma": "parallel for ", "hash": "482fcc89366334d606303c1d3fa3cbd0f787ce5fa97a9b4afaa3b6295ea175a9"}
{"code": "for (size_t sampler=0; sampler<n_samplers; sampler++) { \n        PRNG_SEED_t seed_cache = local_seeds[sampler]; \n \n        PyObject *sampler_params = PyTuple_GET_ITEM(params, sampler); \n \n        PyObject *aaa = PyTuple_GET_ITEM(sampler_params, 0); \n        PyArrayObject *counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 1); \n        PyArrayObject *counts_sum_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 2); \n        PyArrayObject *jump_counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 3); \n        PyArrayObject *fert_counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 4); \n \n        COUNT_t *counts = (COUNT_t*) PyArray_GETPTR1(counts_array, 0); \n        COUNT_t *counts_sum = (COUNT_t*) PyArray_GETPTR1(counts_sum_array, 0); \n        COUNT_t *jump_counts = ((PyObject*)jump_counts_array == Py_None) \n            ? NULL \n            : PyArray_GETPTR1(jump_counts_array, 0); \n        COUNT_t *fert_counts = ((PyObject*)fert_counts_array == Py_None) \n            ? NULL \n            : PyArray_GETPTR1(fert_counts_array, 0); \n \n        const size_t counts_size = PyArray_DIM(counts_array, 0); \n \n        for (size_t i=0; i<f_voc_size; i++) \n            counts[i] = null_alpha; \n        for (size_t i=f_voc_size; i<counts_size; i++) \n            counts[i] = lexical_alpha; \n \n        counts_sum[0] = null_alpha*(COUNT_t)f_voc_size; \n        for (size_t i=1; i<e_voc_size; i++) \n            counts_sum[i] = lexical_alpha*(COUNT_t)f_voc_size; \n \n        for (size_t sent=0; sent<n_sents; sent++) { \n            PyArrayObject *ee_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(eee, sent); \n            PyArrayObject *ff_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(fff, sent); \n            const size_t ee_len = (size_t) PyArray_DIM(ee_array, 0); \n            const size_t ff_len = (size_t) PyArray_DIM(ff_array, 0); \n \n            if (ee_len == 0 || ff_len == 0) continue; \n \n            PyArrayObject *aa_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n            PyArrayObject *counts_idx_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(counts_idx_arrays, sent); \n \n            const TOKEN_t *ee = (const TOKEN_t*) PyArray_GETPTR1(ee_array, 0); \n            const TOKEN_t *ff = (const TOKEN_t*) PyArray_GETPTR1(ff_array, 0); \n            LINK_t *aa = (LINK_t*) PyArray_GETPTR1(aa_array, 0); \n            const INDEX_t *counts_idx = (const INDEX_t*) PyArray_GETPTR1( \n                counts_idx_array, 0); \n \n            int aa_jm1 = -1; \n            if (randomize) { \n                for (size_t j=0; j<ff_len; j++) { \n                    if (prng_next_count(&seed_cache) < 0.1) { \n                        aa[j] = null_link; \n                        counts[ff[j]] += (COUNT_t)1.0; \n                        counts_sum[0] += (COUNT_t)1.0; \n                    } else { \n                        const size_t i = prng_next_int(&seed_cache, ee_len); \n                        aa[j] = i; \n                        counts[counts_idx[i]] += (COUNT_t)1.0; \n                        counts_sum[ee[i]] += (COUNT_t)1.0; \n                        if (jump_counts != NULL) { \n                            const size_t jump = \n                                get_jump_index(aa_jm1, i, ee_len); \n                            aa_jm1 = i; \n                            jump_counts[jump] += (COUNT_t)1.0; \n                            jump_counts[JUMP_SUM] += (COUNT_t)1.0; \n                        } \n                    } \n                    counts_idx += ee_len; \n                } \n            } else { \n                for (size_t j=0; j<ff_len; j++) { \n                    if (aa[j] == null_link) { \n                        counts[ff[j]] += (COUNT_t)1.0; \n                        counts_sum[0] += (COUNT_t)1.0; \n                    } else { \n                        const size_t i = (size_t)aa[j]; \n                        counts[counts_idx[i]] += (COUNT_t)1.0; \n                        counts_sum[ee[i]] += (COUNT_t)1.0; \n                        if (jump_counts != NULL) { \n                            const size_t jump = \n                                get_jump_index(aa_jm1, i, ee_len); \n                            aa_jm1 = i; \n                            jump_counts[jump] += (COUNT_t)1.0; \n                            jump_counts[JUMP_SUM] += (COUNT_t)1.0; \n                        } \n                    } \n                    counts_idx += ee_len; \n                } \n            } \n            if (fert_counts != NULL) { \n                int fert[ee_len]; \n                for (size_t i=0; i<ee_len; i++) \n                    fert[i] = 0; \n                for (size_t j=0; j<ff_len; j++) \n                    if (aa[j] != null_link) fert[aa[j]]++; \n                for (size_t i=0; i<ee_len; i++) \n                    fert_counts[get_fert_index(ee[i], fert[i])] += \n                        (COUNT_t)1.0; \n            } \n            if (jump_counts != NULL && aa_jm1 >= 0) { \n                jump_counts[get_jump_index(aa_jm1, ee_len, ee_len)] += \n                    (COUNT_t)1.0; \n                jump_counts[JUMP_SUM] += (COUNT_t)1.0; \n            } \n        } \n \n        for (size_t e=0; e<e_voc_size; e++) \n            counts_sum[e] = (COUNT_t)1.0 / counts_sum[e]; \n \n        local_seeds[sampler] = seed_cache; \n    }", "pragma": "parallel for ", "hash": "5da7c40aa2aff07592e1d580dbacdc2ad37503505a3adec861f4d4d7864bc074"}
{"code": "for(i = 0; i < (int)data->num_data; ++i) \n\t\t\t{ \n\t\t\t\tj=omp_get_thread_num(); \n \n\t\t\t\tfann_type* temp_predicted_output=fann_test(ann_vect[j], data->input[i],data->output[i]); \n\t\t\t\tfor(unsigned int k=0;k<data->num_output;++k) \n\t\t\t\t{ \n\t\t\t\t\tpredicted_outputs[i][k]=temp_predicted_output[k]; \n\t\t\t\t} \n \n\t\t\t}", "pragma": "for ", "hash": "4d99f04877e73f2f0623d0c996b7242183f4e88f3b3f2098a1862744b9a2a292"}
{"code": "for    (ix=0; ix<fdm->nxpad; ix++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t   \tup[ix][iz] = (2*uo[ix][iz]  \n\t\t\t   - (1-cdtele[ix][iz])*um[ix][iz]  \n\t\t\t   + ua[ix][iz]*(magele[ix][iz]))/(1+cdtele[ix][iz]); \n\t    } \n\t}", "pragma": "parallel for private(ix iz)", "hash": "58bbdda59e81360b2706b344d5ed0ba3503745c5500d120e6ac380ae746ad4ef"}
{"code": "for( int i = 0 ; i < num ; i++ ) \n    { \n        cv::normalize(depth_fea.row(i),depth_fea.row(i)); \n        cv::normalize(color_fea.row(i),color_fea.row(i)); \n    }", "pragma": "parallel for ", "hash": "db8638c8ef9a80c9c53cfa5cf2edb0c7f8009c588fc29b8ccc0b9776f4c34427"}
{"code": "for (i=0; i<sz; i++) { \n          rp[i] = tp[i] | value; \n      }", "pragma": "parallel for private(i)", "hash": "437e1f515faab76ae2e1f88dd5294248573ee113fb4a810734e004c0a8a8d129"}
{"code": "for (int x=0; x<width*height; x++) { \n    double v[40]; \n    double s[40]; \n \n \n     \n \n    for (int z=0; z<labels; z++) { \n      v[z] = u[x + z*width*height]; \n      s[z] = v[z]; \n    } \n     \n    double sumResult = -1, tmpValue, tmax;  \n    bool bget = false; \n     \n    Quicksort(s,labels); \n    for(int j = labels-1; j >= 1; j--){    \t \n      sumResult = sumResult + s[j]; \n      tmax = sumResult/(labels-j); \n      if(tmax >= s[j-1]){ \n        bget = true; \n        break; \n      } \n    } \n     \n     \n \n    if(!bget){ \n      sumResult = sumResult + s[0]; \n      tmax = sumResult/labels; \n    } \n     \n     \n \n    for (int z=0; z<labels; z++) { \n      u[x + z*width*height] = std::max((double)0, v[z]-tmax); \n    } \n     \n  }", "pragma": "parallel for ", "hash": "7f0dcb5f0b62bfec89c834dc9d41982799f7c109e7002b86d5e36e5557131814"}
{"code": "for (int y = -7; y <= 7; ++y) \n    { \n        for (int x = -7; x <= 7; ++x) \n        { \n            int sx = ix + x; \n            if (sx < 0) { \n                sx += width; \n            } \n            if (sx >= width) { \n                sx -= width; \n            } \n \n            int sy = iy + y; \n            if (sy < 0) { \n                sy += height; \n            } \n            if (sy >= height) { \n                sy -= height; \n            } \n \n            int dx = abs(ix - sx); \n            if (dx > width / 2) { \n                dx = width - dx; \n            } \n \n            int dy = abs(iy - sy); \n            if (dy > height / 2) { \n                dy = height - dy; \n            } \n \n            const float a = (dx * dx + dy * dy) / (sigma_i * sigma_i); \n \n             \n \n            const float b = sqrt(abs(buffer.at(ix, iy).x - buffer.at(sx, sy).x)) / (sigma_s * sigma_s); \n            const float da = abs(buffer.at(ix, iy)[0] - buffer.at(sx, sy)[0]); \n            const float db = abs(buffer.at(ix, iy)[1] - buffer.at(sx, sy)[1]); \n \n            const float b = sqrtf(da * da + db * db) / (sigma_s * sigma_s); \n \n            sum[sy] += exp(-a - b); \n        } \n    }", "pragma": "parallel for ", "hash": "02b1f14f44be00f7bbd9f46c78a595d82e9f2c0f84e2f067752387c8f903d115"}
{"code": "for (int atom = nLocalStart; atom < nLocalEnd; ++atom) { \n        std::vector<double> coordX; \n        std::vector<double> coordY; \n        std::vector<double> coordZ; \n        std::vector<double> weight; \n \n         \n \n        DfGenerateGrid::generateGrid_atom(O, atom, &coordX, &coordY, &coordZ, &weight); \n         \n \n         \n \n         \n \n         \n \n \n         \n \n        const std::size_t numOfAtomGrids = weight.size(); \n        if (numOfAtomGrids == 0) { \n            continue; \n        } \n \n#pragma omp critical(DfGenerateGrid__generateGrid) \n        { \n            this->grdMat_.resize(numOfGrids + numOfAtomGrids, this->numOfColsOfGrdMat_); \n            for (std::size_t i = 0; i < numOfAtomGrids; ++i) { \n                this->grdMat_.set(numOfGrids, 0, coordX[i]); \n                this->grdMat_.set(numOfGrids, 1, coordY[i]); \n                this->grdMat_.set(numOfGrids, 2, coordZ[i]); \n                this->grdMat_.set(numOfGrids, 3, weight[i]); \n                this->grdMat_.set(numOfGrids, 4, atom); \n                ++numOfGrids; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "e73c2a20c7c0436efe06df920add31daac5e142ce28683e3465642376227be26"}
{"code": "for (int  _i1 = 2; (_i1 <= (R + 1)); _i1 = (_i1 + 1)) \n    { \n          #pragma ivdep \n      for (int  _i2 = 2; (_i2 <= (C + 1)); _i2 = (_i2 + 1)) \n      { \n        blury[(((_i0 * (R * C)) + ((_i1 - 2) * C)) + (_i2 - 2))] = (((((blurx[(((_i0 * (R * (4 + C))) + ((-2 + _i1) * (4 + C))) + (-2 + _i2))] * 0.0625f) + (blurx[(((_i0 * (R * (4 + C))) + ((-2 + _i1) * (4 + C))) + (-1 + _i2))] * 0.25f)) + (blurx[(((_i0 * (R * (4 + C))) + ((-2 + _i1) * (4 + C))) + _i2)] * 0.375f)) + (blurx[(((_i0 * (R * (4 + C))) + ((-2 + _i1) * (4 + C))) + (1 + _i2))] * 0.25f)) + (blurx[(((_i0 * (R * (4 + C))) + ((-2 + _i1) * (4 + C))) + (2 + _i2))] * 0.0625f)); \n      } \n    }", "pragma": "parallel for ", "hash": "f84a56d9d0e3f72e64cf8e9c8036f0c72e54246fdb91cac89f02985e0f59e2ac"}
{"code": "for (int iterator = 0; iterator < upSize; iterator++) \n        temp[iterator]->update(graph, degrees, membership);", "pragma": "parallel for ", "hash": "e7ee647f59ca9df08ecf7140a6e2d0ddfc892f32036bb38dd7b253d317350ede"}
{"code": "for (int a = 1; a < nAtoms_; ++a) { \n      Utils::ElementType elA = elementTypes_[a]; \n      SKAtom* parA = atomParameters[Utils::ElementInfo::Z(elA)].get(); \n      int nAOsA = aoIndexes_.getNOrbitals(a); \n      int indexA = aoIndexes_.getFirstOrbitalIndex(a); \n \n      for (int b = 0; b < a; ++b) { \n        Utils::ElementType elB = elementTypes_[b]; \n        SKAtom* parB = atomParameters[Utils::ElementInfo::Z(elB)].get(); \n        int nAOsB = aoIndexes_.getNOrbitals(b); \n        int indexB = aoIndexes_.getFirstOrbitalIndex(b); \n \n         \n \n         \n \n        double spinTerm = 0.0; \n        for (int l = 0; l < 3; l++) { \n          spinTerm += parA->getSpinConstant(0, l) * pdif[3 * a + l]; \n        } \n        for (auto i = 0; i < nAOsB; ++i) { \n#pragma omp atomic \n          spinContribution_(indexA, indexB + i) += 0.5 * spinTerm; \n        } \n \n        if (nAOsA > 1) { \n           \n \n          spinTerm = 0.0; \n          for (int l = 0; l < 3; l++) { \n            spinTerm += parA->getSpinConstant(1, l) * pdif[3 * a + l]; \n          } \n           \n \n          for (int i = 1; i < 4; i++) { \n            for (auto j = 0; j < nAOsB; ++j) \n#pragma omp atomic \n              spinContribution_(indexA + i, indexB + j) += 0.5 * spinTerm; \n          } \n \n          if (nAOsA > 4) { \n             \n \n            spinTerm = 0.0; \n            for (int l = 0; l < 3; l++) { \n              spinTerm += parA->getSpinConstant(2, l) * pdif[3 * a + l]; \n            } \n             \n \n            for (int i = 4; i < 9; i++) { \n              for (auto j = 0; j < nAOsB; ++j) \n#pragma omp atomic \n                spinContribution_(indexA + i, indexB + j) += 0.5 * spinTerm; \n            } \n          } \n        } \n \n         \n \n         \n \n        spinTerm = 0.0; \n        for (int l = 0; l < 3; l++) { \n          spinTerm += parB->getSpinConstant(0, l) * pdif[3 * b + l]; \n        } \n        for (auto i = 0; i < nAOsA; ++i) { \n#pragma omp atomic \n          spinContribution_(indexA + i, indexB) += 0.5 * spinTerm; \n        } \n \n        if (nAOsB > 1) { \n           \n \n          spinTerm = 0.0; \n          for (int l = 0; l < 3; l++) { \n            spinTerm += parB->getSpinConstant(1, l) * pdif[3 * b + l]; \n          } \n           \n \n          for (int i = 1; i < 4; i++) { \n            for (auto j = 0; j < nAOsA; ++j) \n#pragma omp atomic \n              spinContribution_(indexA + j, indexB + i) += 0.5 * spinTerm; \n          } \n \n          if (nAOsB > 4) { \n             \n \n            spinTerm = 0.0; \n            for (int l = 0; l < 3; l++) { \n              spinTerm += parB->getSpinConstant(2, l) * pdif[3 * b + l]; \n            } \n             \n \n            for (int i = 4; i < 9; i++) { \n              for (auto j = 0; j < nAOsA; ++j) \n#pragma omp atomic \n                spinContribution_(indexA + j, indexB + i) += 0.5 * spinTerm; \n            } \n          } \n        } \n      } \n    }", "pragma": "for ", "hash": "2956779f9f7f2ad78d9c7fe4cc254e26be540964ee792cf9866ab7920a2ca13e"}
{"code": "for (i = 15; i < 64; i++) \n    { \n      ++t; \n      if ((a[i] % 5) == 3) \n\tu = i; \n      if ((a[i] % 7) == 2) \n\tx = &a[i]; \n    }", "pragma": "for reduction( +: t task) private( conditional: u x)", "hash": "a33d74a2540251061de761c20e6957a92ff10cdc9c45f603bed4e156c99dd6e4"}
{"code": "for (i=0; i<ndeps; i++) { \n        Dep *dep = deps[i]; \n \n        if (options->rar == 0 && IS_RAR(dep->type))  { \n            continue; \n        } \n \n        if (!depcst[i]) { \n             \n \n \n             \n \n            depcst[i] = get_permutability_constraints_nonuniform_dep(dep, prog); \n \n            IF_DEBUG(fprintf(stdout, \"After dep: %d; num_constraints: %d\\n\", i+1, depcst[i]->nrows)); \n            total_cst_rows += depcst[i]->nrows; \n             \n \n             \n \n        } \n    }", "pragma": "parallel for reduction(+:total_cst_rows) ", "hash": "bcc7854b027268d26a85c21a0a77ced6b15a4b3c581e3670586f588255dd3695"}
{"code": "for( int planeNr=0; planeNr < nrOfPlanes; planeNr++ ) \n    { \n        IPLImagePlane* plane = image->plane( planeNr ); \n        IPLImagePlane* newplane = _result->plane( planeNr ); \n        ipl_basetype background = 0.0; \n \n        if(planeNr == 0) \n            background = color.red(); \n        else if(planeNr == 1) \n            background = color.green(); \n        if(planeNr == 2) \n            background = color.blue(); \n \n        for(int y=0; y<new_height; y++) \n        { \n             \n \n           notifyProgressEventHandler(100*progress++/maxProgress); \n \n            for(int x=0; x<new_width; x++) \n            { \n                int from_x = x - offset_x; \n                int from_y = y - offset_y; \n \n                 \n \n                if(from_x < 0 || from_y < 0 || from_x > plane->width() || from_y > plane->height()) \n                { \n                    newplane->p(x, y) = background; \n                } \n                else \n                { \n                    newplane->p(x, y) = plane->p(from_x, from_y); \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "002b6297db7aa92d0190974df85f76a185af050d50134736eb31b8a943609873"}
{"code": "for (int i = 0; i < num_regions; ++i) { \n        int tid = omp_get_thread_num(); \n        Region& region = regions[i]; \n        PathChunker& chunker = chunkers[tid]; \n        unique_ptr<MutablePathMutableHandleGraph> subgraph; \n        map<string, int> trace_thread_frequencies; \n        if (!component_ids.empty()) { \n            subgraph = vg::io::new_output_graph<MutablePathMutableHandleGraph>(output_format); \n            chunker.extract_component(component_ids[i], *subgraph, false); \n            output_regions[i] = region; \n        } \n        else if (id_range == false) { \n            subgraph = vg::io::new_output_graph<MutablePathMutableHandleGraph>(output_format); \n            if (components == true) { \n                chunker.extract_path_component(region.seq, *subgraph, output_regions[i]); \n            } else { \n                chunker.extract_subgraph(region, context_steps, context_length, \n                                         trace, *subgraph, output_regions[i]); \n            } \n        } else { \n            if (chunk_graph || context_steps > 0) { \n                subgraph = vg::io::new_output_graph<MutablePathMutableHandleGraph>(output_format); \n                output_regions[i].seq = region.seq; \n                chunker.extract_id_range(region.start, region.end, \n                                         components ? numeric_limits<int64_t>::max() : context_steps, \n                                         context_length, trace && !components, \n                                         *subgraph, output_regions[i]); \n            } else { \n                 \n \n                 \n \n                output_regions[i] = region; \n            } \n        } \n \n         \n \n        if (trace && subgraph && gbwt_index.get() != nullptr) { \n            int64_t trace_start; \n            int64_t trace_end; \n            if (id_range) { \n                trace_start = output_regions[i].start; \n                trace_end = output_regions[i].end; \n            } else { \n                path_handle_t path_handle = graph->get_path_handle(output_regions[i].seq); \n                step_handle_t trace_start_step = graph->get_step_at_position(path_handle, output_regions[i].start); \n                trace_start = graph->get_id(graph->get_handle_of_step(trace_start_step)); \n                step_handle_t trace_end_step = graph->get_step_at_position(path_handle, output_regions[i].end); \n                trace_end = graph->get_id(graph->get_handle_of_step(trace_end_step)); \n            } \n            int64_t trace_steps = trace_end - trace_start; \n            Graph g; \n            trace_haplotypes_and_paths(*graph, *gbwt_index.get(), trace_start, trace_steps, \n                                       g, trace_thread_frequencies, false); \n            subgraph->for_each_path_handle([&trace_thread_frequencies, &subgraph](path_handle_t path_handle) { \n                    trace_thread_frequencies[subgraph->get_path_name(path_handle)] = 1;}); \n            VG* vg_subgraph = dynamic_cast<VG*>(subgraph.get()); \n            if (vg_subgraph != nullptr) { \n                 \n \n                vg_subgraph->extend(g); \n            } else { \n                 \n \n                 \n \n                VG vg; \n                handlealgs::copy_path_handle_graph(subgraph.get(), &vg); \n                subgraph.reset(); \n                vg.extend(g); \n                subgraph = vg::io::new_output_graph<MutablePathMutableHandleGraph>(output_format); \n                handlealgs::copy_path_handle_graph(&vg, subgraph.get()); \n            } \n        } \n \n        ofstream out_file; \n        ostream* out_stream = NULL; \n        if (chunk_graph) { \n            if ((!region_strings.empty() || !node_range_string.empty()) && \n                (regions.size()  == 1) && chunk_size == 0) { \n                 \n \n                 \n \n                out_stream = &cout; \n            } else { \n                 \n \n                 \n \n                string name = chunk_name(out_chunk_prefix, i, output_regions[i], \".\" + output_format, 0, components); \n                out_file.open(name); \n                if (!out_file) { \n                    cerr << \"error[vg chunk]: can't open output chunk file \" << name << endl; \n                    exit(1); \n                } \n                out_stream = &out_file; \n            } \n \n            assert(subgraph); \n            vg::io::save_handle_graph(subgraph.get(), *out_stream); \n        } \n         \n         \n \n        if (chunk_gam) { \n            if (!components) { \n                 \n \n                for (size_t gi = 0; gi < gam_indexes.size(); ++gi) { \n                    auto& gam_index = gam_indexes[gi]; \n                    assert(gam_index.get() != nullptr); \n                    GAMIndex::cursor_t& cursor = cursors_vec[gi][tid]; \n             \n                    string gam_name = chunk_name(out_chunk_prefix, i, output_regions[i], \".gam\", gi, components); \n                    ofstream out_gam_file(gam_name); \n                    if (!out_gam_file) { \n                        cerr << \"error[vg chunk]: can't open output gam file \" << gam_name << endl; \n                        exit(1); \n                    } \n             \n                     \n \n                    vector<pair<vg::id_t, vg::id_t>> region_id_ranges; \n                    if (subgraph) { \n                         \n \n                        region_id_ranges = vg::algorithms::sorted_id_ranges(subgraph.get()); \n                    } else { \n                         \n \n                        region_id_ranges = {{region.start, region.end}}; \n                    } \n             \n                    gam_index->find(cursor, region_id_ranges, vg::io::emit_to<Alignment>(out_gam_file), fully_contained); \n                } \n            } else { \n#pragma omp critical (node_to_component) \n                { \n                     \n \n                    subgraph->for_each_handle([&](handle_t sg_handle) { \n                             \n \n                             \n \n                            node_to_component[subgraph->get_id(sg_handle)] = i; \n                        }); \n                } \n            } \n        } \n         \n \n        if (trace) { \n             \n \n             \n \n            string annot_name = chunk_name(out_chunk_prefix, i, output_regions[i], \".annotate.txt\", 0, components); \n            ofstream out_annot_file(annot_name); \n            if (!out_annot_file) { \n                cerr << \"error[vg chunk]: can't open output trace annotation file \" << annot_name << endl; \n                exit(1); \n            } \n            for (auto tf : trace_thread_frequencies) { \n                out_annot_file << tf.first << \"\\t\" << tf.second << endl; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "1ae8b581e893e08ac89abcfb7219ed04cf5e3d487b1e62e53afd1876b2aa4168"}
{"code": "for( i = 0 ; i < LCU ; i++ ) { \n    GLU_complex A1[ NCNC ] GLUalign ; \n    GLU_complex A2[ NCNC ] GLUalign ; \n    GLU_complex B[ NCNC ] GLUalign ; \n    GLU_complex C[ NCNC ] GLUalign ; \n    double loc_v[ LINE_NSTEPS ] ; \n    size_t mu , n ; \n    for( mu = 0 ; mu < LINE_NSTEPS ; mu++ ) { \n      loc_v[ mu ] = 0.0 ; \n    } \n     \n \n    set_gauge_matrix( A1 , in , PC1 , i ) ; \n    set_gauge_matrix( A2 , in , PC2 , i ) ; \n    for( mu = 0 ; mu < ND-1 ; mu++ ) { \n      const size_t fwd = lat[i].neighbor[mu] ; \n      memcpy( C , lat[i+LCU*t].O[mu] , NCNC*sizeof( GLU_complex ) ) ; \n      gtransform_local( gauge[i] , C , gauge[fwd] ) ; \n \n      loc_v[0] += creal( trace( C ) ) ; \n       \n       \n \n      set_gauge_matrix( B , in , PC1 , fwd ) ; \n      loc_v[1] += Re_trace_abc_dag_suNC( A1 , C , B ) ; \n       \n \n      set_gauge_matrix( B , in , PC2 , fwd ) ; \n      loc_v[2] += Re_trace_abc_dag_suNC( A2 , C , B ) ;       \n    } \n    const size_t th = get_GLU_thread() ; \n     \n \n    for( n = 0 ; n < LINE_NSTEPS ; n++ ) { \n      const double y = loc_v[n] - c[n] ; \n      const double t = red[ n + th * CLINE ] + y ; \n      c[n] = ( t - red[ n + th * CLINE ] ) - y ; \n      red[ n + th * CLINE ] = t ; \n    } \n  }", "pragma": "for private(i)", "hash": "324106728235696a2428d9f8324a03b75013a14439d583f187a14f76c75a2472"}
{"code": "for(int i=0; i < nnz; i++) \n    colidx[i]++;", "pragma": "parallel for ", "hash": "e77f94f6fe31b25942db085dad655bb689c9d250dcd75aad5f4281bebbbb1dd0"}
{"code": "for (long i = 0; i < items.size(); i++) \n\t{ \n\t\tsum += items[i]; \n\t}", "pragma": "parallel for reduction(+:sum) ", "hash": "bd9c68747de2d7ad83e4f36c141a94d6bf0bf2a5dcca52963dcbb68e33199456"}
{"code": "for (ompIndexType i = 0; i < static_cast<ompIndexType>(evals.rows()); ++i) { \n        evals(i) = tan(evals(i)); \n    }", "pragma": "parallel for ", "hash": "65c506b5dccb099bf8840856ac9419a1a16ac146b554f3f598a0445625e620d1"}
{"code": "for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = (int)floor((float)i / oheight * iheight); \n      int y_end   = (int)ceil((float)(i + 1) / oheight * iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n \n        int x_start = (int)floor((float)j / owidth * iwidth); \n        int x_end   = (int)ceil((float)(j + 1) / owidth * iwidth); \n        int kW = x_end-x_start; \n \n         \n \n        real *ip = input_p   + k*strided + y_start*strideh + x_start*stridew; \n        real *op = output_p  + k*owidth*oheight + i*owidth + j; \n        real *indyp = indy_p + k*owidth*oheight + i*owidth + j; \n        real *indxp = indx_p + k*owidth*oheight + i*owidth + j; \n \n         \n \n        long maxindex = -1; \n        real maxval = -FLT_MAX; \n        long tcntr = 0; \n        int x,y; \n        for(y = 0; y < kH; y++) \n        { \n          for(x = 0; x < kW; x++) \n          { \n            real val = *(ip + y*strideh + x*stridew); \n            if (val > maxval) \n            { \n              maxval = val; \n              maxindex = tcntr; \n            } \n            tcntr++; \n          } \n        } \n \n         \n \n        *op = maxval; \n \n         \n \n        *indyp = (int)(maxindex / kW) + TH_INDEX_BASE; \n        *indxp = (maxindex % kW) + TH_INDEX_BASE; \n      } \n    } \n  }", "pragma": "parallel for private(k)", "hash": "b3f10d3c0094ce9acaa0b9186be529523ccb5771252a95203abb5fdf41c709f0"}
{"code": "for (int i = 0; i < lena; ++i) { \n    integer_index_accumulate_real(alpha + i, aarray, astrings[i]); \n    alpha[i] = exp(alpha[i]); \n  }", "pragma": "parallel for ", "hash": "e2ebba18e0d926a6616276d426394e1697595b2da98962750bd8e338549ce4e5"}
{"code": "for (i=0; i <= (ssize_t) MaxMap; i++) \n      { \n        x_map[i].x=(MagickRealType) (1.0*(double) i); \n        x_map[i].y=(MagickRealType) 0.0; \n        x_map[i].z=(MagickRealType) 0.0; \n        y_map[i].x=(MagickRealType) 0.0; \n        y_map[i].y=(MagickRealType) (1.0*(double) i); \n        y_map[i].z=(MagickRealType) 0.0; \n        z_map[i].x=(MagickRealType) 0.0; \n        z_map[i].y=(MagickRealType) 0.0; \n        z_map[i].z=(MagickRealType) (1.0*(double) i); \n      }", "pragma": "parallel for ", "hash": "b2d0211137fe75c05cb490db73b2a976e230cbc50ea3e5960fc7652fa4a0b488"}
{"code": "for (i = a; i < b; i += c) \n    { \n      bar (&j); \n      #pragma omp ordered \n      j++; \n    }", "pragma": "for reduction( *: j task) ", "hash": "ba8f9a59d288119424d7d334c2acd5b8343517166a72d6579d75f572cb833d71"}
{"code": "for (ompIndexType i = 0; i < (ompIndexType)elementCount * 2; i = i + 2) { \n            if (!std::isnan((double)spx[i]) && !std::isnan((double)spx[i + 1])) { \n                sumReal += (double)spx[i]; \n                sumImag += (double)spx[i + 1]; \n                nbNotNaN += 1; \n            } \n        }", "pragma": "parallel for reduction(  + : nbnotnan sumimag sumreal) ", "hash": "1609a19441207b80b9d2677939b1947b70f38b700678acb14de2a6b4595d7712"}
{"code": "for(size_t j = 0; j < rows; ++j) { \n    size_t dst = j; \n \n     \n \n     \n \n    size_t src = (size_t)indices->data<IndexType>()[j]; \n \n    float* rowOut = out + dst * cols; \n    const float* rowIn = in + src * cols; \n \n    std::copy(rowIn, rowIn + cols, rowOut); \n  }", "pragma": "parallel for ", "hash": "69c8dd5feceda219c68b4fc63a69417292b519a63169473467de6e5da24c8c3e"}
{"code": "for (int y=0; y < iHeight ; y++) { \n             \n             \n \n             \n \n            float **fpODenoised = new float*[iChannels]; \n            for (int ii=0; ii < iChannels; ii++) \n                fpODenoised[ii] = new float[iwl]; \n            float *fTotalWeight = new float[iwl]; \n             \n            for (int x=0 ; x < iWidth;  x++) { \n                 \n                 \n \n                int iDWin0 = MIN(iDWin,MIN(iWidth-1-x, \n                                           MIN(iHeight-1-y,MIN(x,y)))); \n                 \n                 \n \n                int imin=MAX(x-iDBloc,iDWin0); \n                int jmin=MAX(y-iDBloc,iDWin0); \n                 \n                int imax=MIN(x+iDBloc,iWidth-1-iDWin0); \n                int jmax=MIN(y+iDBloc,iHeight-1-iDWin0); \n                 \n                 \n                 \n \n                for (int ii=0; ii < iChannels; ii++) \n                    fpClear(fpODenoised[ii], 0.0f, iwl); \n                 \n                 \n                 \n \n                 \n \n                fpClear(fTotalWeight, 0.0f, iwl); \n                 \n                int dj = jmax-jmin+1; \n                int di = imax-imin+1; \n                 \n                int *ovect_ind = new int[dj*di]; \n                float *fDif_all = new float[dj*di]; \n                 \n                for (int j=jmin; j <= jmax; j++) \n                    for (int i=imin ; i <= imax; i++) \n                    { \n                         \n                        int df = 0; \n                        float fDifHist = fiChiSquareNDfFloatDist(&df,fhI,fhI, \n                                                                 x,y, \n                                                                 i,j,iDWin0, \n                                                                 iBins, \n                                                                 iWidth, \n                                                                 iWidth); \n                         \n                        fDif_all[(j-jmin)+(i-imin)*dj] = fDifHist/(df+(float)EPSILON); \n                         \n                    } \n                 \n                compute_knn_index(knnT, fDif_all, ovect_ind, dj*di); \n                 \n                 \n \n                int kk; \n                for(kk=0;kk<knnT;kk++) \n                { \n                     \n \n                    int i = ovect_ind[kk]/dj + imin; \n                    int j = ovect_ind[kk]%dj + jmin; \n                     \n                    for (int is=-iDWin0; is <=iDWin0; is++) { \n                        int aiindex = (iDWin+is) * ihwl + iDWin; \n                        int ail = (j+is)*iWidth+i; \n                         \n                        for (int ir=-iDWin0; ir <= iDWin0; ir++) { \n                             \n                            int iindex = aiindex + ir; \n                            int il= ail +ir; \n                             \n                            const float weight = alpha ? alpha[il] : 1.f; \n                            fTotalWeight[iindex] += weight; \n                            for (int ii=0; ii < iChannels; ii++) \n                                fpODenoised[ii][iindex] += weight*fpI[ii][il]; \n                        } \n                    } \n                } \n                 \n                 \n \n                for (kk=knnT;kk<dj*di;kk++) \n                { \n                    if (fDif_all[kk] < fDistance) \n                    { \n                        int i = ovect_ind[kk]/dj + imin; \n                        int j = ovect_ind[kk]%dj + jmin; \n                         \n                        for (int is=-iDWin0; is <=iDWin0; is++) { \n                            int aiindex = (iDWin+is) * ihwl + iDWin; \n                            int ail = (j+is)*iWidth+i; \n                             \n                            for (int ir=-iDWin0; ir <= iDWin0; ir++) { \n                                 \n                                int iindex = aiindex + ir; \n                                int il= ail +ir; \n                                 \n                                const float weight = alpha ? alpha[il] : 1.f; \n                                fTotalWeight[iindex] += weight; \n                                for (int ii=0; ii < iChannels; ii++) \n                                \tfpODenoised[ii][iindex] += weight*fpI[ii][il]; \n                            } \n                        } \n                    } \n                } \n                 \n                 \n \n                 \n                for (int is=-iDWin0; is <=iDWin0; is++) { \n                    int aiindex = (iDWin+is) * ihwl + iDWin; \n                    int ail=(y+is)*iWidth+x; \n                     \n                    for (int ir=-iDWin0; ir <= iDWin0; ir++) { \n                        int iindex = aiindex + ir; \n                        int il=ail+ ir; \n                         \n                        const float weight = fTotalWeight[iindex]; \n#pragma omp atomic \n                        fpCount[il]++; \n                        for (int ii=0; ii < iChannels; ii++) { \n#pragma omp atomic \n                             \n                            fpO[ii][il] += weight == 0.f ? 0.f : fpODenoised[ii][iindex]/weight; \n                        } \n                    } \n                } \n                 \n                delete[] ovect_ind; \n                delete[] fDif_all; \n                 \n            } \n \n             \n             \n            for (int ii=0; ii < iChannels; ii++) delete[] fpODenoised[ii]; \n            delete[] fpODenoised; \n            delete[] fTotalWeight; \n            printf (\"[%d%%]\\r\", y*100/(iHeight-1)); \n            fflush (stdout); \n        }", "pragma": "for ", "hash": "42b34c49c312ba7f2273163ff24292e5df4fb2828f9e6caba6332e1c78d50c92"}
{"code": "for(long i0=t->id;i0<nn;i0+=mglNumThr)\r \n\t{\r \n\t\tlong i=i0%nx, j=((i0/nx)%ny), k=i0/(nx*ny);\r \n\t\tif(i==0)\r \n\t\t{\r \n\t\t\tau = 3*a[i0]-4*a[i0+1]+a[i0+2];\r \n\t\t\txu = 3*x->vthr(i0)-4*x->vthr(i0+1)+x->vthr(i0+2);\r \n\t\t\tyu = 3*y->vthr(i0)-4*y->vthr(i0+1)+y->vthr(i0+2);\r \n\t\t\tzu = 3*z->vthr(i0)-4*z->vthr(i0+1)+z->vthr(i0+2);\r \n\t\t}\r \n\t\telse if(i==nx-1)\r \n\t\t{\r \n\t\t\tau = 3*a[i0]-4*a[i0-1]+a[i0-2];\r \n\t\t\txu = 3*x->vthr(i0)-4*x->vthr(i0-1)+x->vthr(i0-2);\r \n\t\t\tyu = 3*y->vthr(i0)-4*y->vthr(i0-1)+y->vthr(i0-2);\r \n\t\t\tzu = 3*z->vthr(i0)-4*z->vthr(i0-1)+z->vthr(i0-2);\r \n\t\t}\r \n\t\telse\r \n\t\t{\r \n\t\t\tau = a[i0+1]-a[i0-1];\r \n\t\t\txu = x->vthr(i0+1)-x->vthr(i0-1);\r \n\t\t\tyu = y->vthr(i0+1)-y->vthr(i0-1);\r \n\t\t\tzu = z->vthr(i0+1)-z->vthr(i0-1);\r \n\t\t}\r \n\t\tif(j==0)\r \n\t\t{\r \n\t\t\tav = 3*a[i0]-4*a[i0+nx]+a[i0+2*nx];\r \n\t\t\txv = 3*x->vthr(i0)-4*x->vthr(i0+nx)+x->vthr(i0+2*nx);\r \n\t\t\tyv = 3*y->vthr(i0)-4*y->vthr(i0+nx)+y->vthr(i0+2*nx);\r \n\t\t\tzv = 3*z->vthr(i0)-4*z->vthr(i0+nx)+z->vthr(i0+2*nx);\r \n\t\t}\r \n\t\telse if(j==ny-1)\r \n\t\t{\r \n\t\t\tav = 3*a[i0]-4*a[i0-nx]+a[i0+(ny-3)*nx];\r \n\t\t\txv = 3*x->vthr(i0)-4*x->vthr(i0-nx)+x->vthr(i0-2*nx);\r \n\t\t\tyv = 3*y->vthr(i0)-4*y->vthr(i0-nx)+y->vthr(i0-2*nx);\r \n\t\t\tzv = 3*z->vthr(i0)-4*z->vthr(i0-nx)+z->vthr(i0-2*nx);\r \n\t\t}\r \n\t\telse\r \n\t\t{\r \n\t\t\tav = a[i0+nx]-a[i0-nx];\r \n\t\t\txv = x->vthr(i0+nx)-x->vthr(i0-nx);\r \n\t\t\tyv = y->vthr(i0+nx)-y->vthr(i0-nx);\r \n\t\t\tzv = z->vthr(i0+nx)-z->vthr(i0-nx);\r \n\t\t}\r \n\t\tif(k==0)\r \n\t\t{\r \n\t\t\taw = 3*a[i0]-4*a[i0+n2]+a[i0+2*n2];\r \n\t\t\txw = 3*x->vthr(i0)-4*x->vthr(i0+n2)+x->vthr(i0+2*n2);\r \n\t\t\tyw = 3*y->vthr(i0)-4*y->vthr(i0+n2)+y->vthr(i0+2*n2);\r \n\t\t\tzw = 3*z->vthr(i0)-4*z->vthr(i0+n2)+z->vthr(i0+2*n2);\r \n\t\t}\r \n\t\telse if(k==nz-1)\r \n\t\t{\r \n\t\t\taw = 3*a[i0]-4*a[i0-n2]+a[i0-2*n2];\r \n\t\t\txw = 3*x->vthr(i0)-4*x->vthr(i0-n2)+x->vthr(i0-2*n2);\r \n\t\t\tyw = 3*y->vthr(i0)-4*y->vthr(i0-n2)+y->vthr(i0-2*n2);\r \n\t\t\tzw = 3*z->vthr(i0)-4*z->vthr(i0-n2)+z->vthr(i0-2*n2);\r \n\t\t}\r \n\t\telse\r \n\t\t{\r \n\t\t\taw = a[i0+n2]-a[i0-n2];\r \n\t\t\txw = x->vthr(i0+n2)-x->vthr(i0-n2);\r \n\t\t\tyw = y->vthr(i0+n2)-y->vthr(i0-n2);\r \n\t\t\tzw = z->vthr(i0+n2)-z->vthr(i0-n2);\r \n\t\t}\r \n\t\tb[i0] = (au*yv*zw-av*yu*zw-au*yw*zv+aw*yu*zv+av*yw*zu-aw*yv*zu) / (xu*yv*zw-xv*yu*zw-xu*yw*zv+xw*yu*zv+xv*yw*zu-xw*yv*zu);\r \n\t}", "pragma": "parallel for private(au av aw xu xv xw yu yv yw zu zv zw)", "hash": "08d806bb598ef831aa902bbe7746e68a0b7fe1694f85ac358cfd6c3f793a4dfd"}
{"code": "for (i=0; i < n1*n2*(2*nh+1); i++) { \n\t    for (its=0; its < uts; its++) { \n\t\tr[i] += tempr[its][i]; \n\t\ttempr[its][i] = 0.; \n\t    } \n\t}", "pragma": "parallel for private(its)", "hash": "3edd21b959fb4b0d766d6891ae1128d4be2d822d68baae228d269816c609cc28"}
{"code": "for (i=0; i<nPri; i++) { \n      indr=i*(nPri); \n      chib=0.0000000e0; \n      for (j=(i+1); j<nPri; j++) { \n         chib+=(cab[indr+j]*chi[j]); \n      } \n      chii=chi[i]; \n      rho+=(cab[indr+i]*chii*chii+2.00000000e0*chib*chii); \n   }", "pragma": "parallel for reduction(+: rho) private(chib chii i indr j)", "hash": "5b322c700aa19973346cf426d5a5c090f24d8d42376cc427d238b5fb7e074544"}
{"code": "for( size_t i = 0; i < cand_vec.size(); ++i ) { \n        auto const ce_idx = cand_vec[i]; \n \n        assert( ce_idx < data.tree.edge_count() ); \n        auto const& edge = data.tree.edge_at( ce_idx ); \n \n         \n \n        assert( ! is_leaf( edge )); \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n         \n \n        auto const p_indices = phylo_factor_subtree_indices( \n            Subtree{ edge.primary_link() }, candidate_edges \n        ); \n        if( p_indices.empty() ) { \n            continue; \n        } \n        auto const s_indices = phylo_factor_subtree_indices( \n            Subtree{ edge.secondary_link() }, candidate_edges \n        ); \n        if( s_indices.empty() ) { \n            continue; \n        } \n \n         \n \n        assert( s_indices.count( edge.index() ) == 0 ); \n        assert( p_indices.count( edge.index() ) == 0 ); \n \n         \n \n        auto const balances = mass_balance( data, s_indices, p_indices ); \n \n         \n \n        auto const ov = objective( balances ); \n        result.all_objective_values[ ce_idx ] = ov; \n \n         \n \n        #pragma omp critical( GENESIS_TREE_MASS_TREE_PHYLO_FACTOR_OBJECTIVE_UPDATE ) \n        { \n            if( ov > result.objective_value ) { \n                result.edge_index = ce_idx; \n                result.edge_indices_primary   = p_indices; \n                result.edge_indices_secondary = s_indices; \n                result.balances = balances; \n                result.objective_value = ov; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "7916651a60b33a3b18d57353e329856f0efe474d517ba3f49af54b06ff6c1945"}
{"code": "for (int i = 0; i < TestNum; i++){ \n\t\tCStr fName = _bbResDir + _voc.testSet[i]; \n\t\tValStructVec<float, Vec4i> &boxes = boxesTests[i]; \n\t\tFILE *f = fopen(_S(fName + \".txt\"), \"w\"); \n\t\tfprintf(f, \"%d\\n\", boxes.size()); \n\t\tfor (size_t k = 0; k < boxes.size(); k++) \n\t\t\tfprintf(f, \"%g, %s\\n\", boxes(k), _S(strVec4i(boxes[k]))); \n\t\tfclose(f); \n \n\t\t_boxesTests[i].resize(boxesTests[i].size()); \n\t\tfor (int j = 0; j < boxesTests[i].size(); j++) \n\t\t\t_boxesTests[i][j] = boxesTests[i][j]; \n\t}", "pragma": "parallel for ", "hash": "381c55066b92b08341b4c6dcb50dd1af796a626cc15c67accb3286c8a1036fd7"}
{"code": "for (int c = 0; c < channels; c++) { \n        resultCh[c]->fill(0.f); \n    }", "pragma": "parallel for ", "hash": "3a6e8d68f2025e340e5be528e8d30f5b5c41e626507b19f05b42b5f5c5bedd16"}
{"code": "for( int i=0;i<max;++i ) { \n      basics::multTranspose((*m_buf3)[i],m_W->X()[i],m_GLL2G,'N','T'); \n      basics::multTranspose((*m_buf)[i],m_GLL2G,(*m_buf3)[i],'N','N'); \n      basics::multPointwise((*m_buf2)[i],(*m_buf)[i],(*m_J)[m_division[m_rank].elements[i]]); \n    }", "pragma": "parallel for ", "hash": "5afc3308b7d13af9b990b516cf16cafef4aa64efdd23f16127ae74367d48e3a4"}
{"code": "for (int c = 1; c <= grid.NCM; c++) \n\t{ \n\t\tint c_ptr\t= grid.cells.whereis[c]; \n\t\tint cl, cr; \n\t\tint f; \n \n\t\tfor (int k = 0; k <= grid.cells.data_ptr[c_ptr]->NF-1; k++) \n\t\t{ \n\t\t\tf \t= grid.faces.whereis[grid.cells.data_ptr[c_ptr]->face[k]]; \n\t\t\tcl\t= grid.faces.data_ptr[f]->cl[0]; \n\t\t\tcr\t= grid.faces.data_ptr[f]->cr[0]; \n \n\t\t\tif (cl == c) \n\t\t\t{ \n\t\t\t\tfor (int j = 0; j <= NVAR-1; j++) \n\t\t\t\t\tfor (int k = 0; k <= NVAR-1; k++) \n\t\t\t\t\t\tM_cl[c_ptr](j+1, k+1) += Solution.Jacobian_inviscid_plus[f][j][k]; \n\t\t\t} \n \n\t\t\tif (cr == c) \n\t\t\t{ \n\t\t\t\tfor (int j = 0; j <= NVAR-1; j++) \n\t\t\t\t\tfor (int k = 0; k <= NVAR-1; k++) \n\t\t\t\t\t\tM_cl[c_ptr](j+1, k+1) += -Solution.Jacobian_inviscid_minus[f][j][k];; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "b15b18f814040538d803a6ece18ff210b6736e155827f4d31349b53c59fced38"}
{"code": "for (size_t i = 0; i < pSceneDescriptors->size(); ++i) \n\t{ \n\t\tflann::Matrix<float> p = flann::Matrix<float>(new float[inputsize], 1, inputsize); \n\t\tmemcpy(&p.ptr()[0], &pSceneDescriptors->at(i).descriptor[0], p.cols * p.rows * sizeof(float)); \n \n\t\tflann::Matrix<int> indices; \n\t\tflann::Matrix<float> distances; \n\t\tindices = flann::Matrix<int>(new int[kValue], 1, kValue); \n\t\tdistances = flann::Matrix<float>(new float[kValue], 1, kValue); \n \n\t\tint neighborsFound = 0; \n\t\tneighborsFound = index.knnSearch(p, indices, distances, kValue, flann::SearchParams(512)); \n \n  #pragma omp critical \n\t\t{ \n\t\t\tif (neighborsFound == 1) \n\t\t\t{ \n\t\t\t\tdistance += distances[0][0]; \n\t\t\t\t++neighbors; \n\t\t\t} \n \n\t\t\tif (neighborsFound == 1 && distances[0][0] < pThreshold) \n\t\t\t{ \n\t\t\t\tpcl::Correspondence correspondence(indices[0][0], static_cast<int>(i), distances[0][0]); \n\t\t\t\tpCorrespondences->push_back(correspondence); \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(index)", "hash": "29c28ce3d9b3ce10be2dff23de06872314bbf4547089efec0ac8b41099ea3d26"}
{"code": "for (unsigned int j = 0; j < materials[i]->get_num_particles(); ++j) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\trho0[j] += m_grid[vrt_1[j]] * phi_1[j] / V_grid[vrt_1[j]]; \n\t\t\t\trho0[j] += m_grid[vrt_2[j]] * phi_2[j] / V_grid[vrt_2[j]]; \n \n\t\t\t\t \n \n\t\t\t\tif (gdim == 2 or gdim == 3) \n\t\t\t\t\trho0[j] += m_grid[vrt_3[j]] * phi_3[j] / V_grid[vrt_3[j]]; \n \n\t\t\t\t \n \n\t\t\t\tif (gdim == 3) \n\t\t\t\t\trho0[j] += m_grid[vrt_4[j]] * phi_4[j] / V_grid[vrt_4[j]]; \n \n\t\t\t\trho[j] = rho0[j];   \n \n\t\t\t}", "pragma": "parallel for simd ", "hash": "e2b2f9463d3a353b66e941c9a9ed974385e8cd0d7e7ec5e1e4582ee93031128f"}
{"code": "for(int keyframe_i_Indx=0;keyframe_i_Indx<globalPoses.size();keyframe_i_Indx++) \n    { \n         \n \n        CFrameRGBD* keyframe_i = new CFrameRGBD(); \n        loadKeyframeFromFile(keyframe_i_Indx,*keyframe_i); \n \n         \n \n        pcl::PointCloud<pcl::PointXYZRGBA> transformedCloud; \n        pcl::transformPointCloud(*keyframe_i->getDownsampledPointCloud(cameraMatrix),transformedCloud,globalPoses[keyframe_i_Indx]); \n \n         \n \n        std::stringstream keyframeFileName_ss;keyframeFileName_ss<<keyframe_i_Indx;std::string keyframeFileName; keyframeFileName_ss>>keyframeFileName; \n        pcl::io::savePCDFile(std::string(\"../../../results/pcd_files/transformed_keyframe_\").append(keyframeFileName).append(\".pcd\"),transformedCloud); \n \n         \n \n        delete keyframe_i; \n    }", "pragma": "parallel for ", "hash": "4ce41021ffbf9dd462628ce7a3143ae6eb7da0aa127b31bbd7a6456265063af0"}
{"code": "for(index=0; index<targetVoxelNumber; index++){ \n \n            if(maskPtr[index]>-1){ \n                world[0]=(FieldTYPE) deformationFieldPtrX[index]; \n                world[1]=(FieldTYPE) deformationFieldPtrY[index]; \n                world[2]=(FieldTYPE) deformationFieldPtrZ[index]; \n \n                 \n \n                reg_mat44_mul(sourceIJKMatrix, world, position); \n \n                previous[0] = (int)round(position[0]); \n                previous[1] = (int)round(position[1]); \n                previous[2] = (int)round(position[2]); \n \n                if( -1<previous[2] && previous[2]<sourceImage->nz && \n                        -1<previous[1] && previous[1]<sourceImage->ny && \n                        -1<previous[0] && previous[0]<sourceImage->nx){ \n                    intensity = sourceIntensity[(previous[2]*sourceImage->ny+previous[1]) * \n                            sourceImage->nx+previous[0]]; \n                    resultIntensity[index]=intensity; \n                } \n                else resultIntensity[index]=(SourceTYPE)bgValue; \n            } \n            else resultIntensity[index]=(SourceTYPE)bgValue; \n        }", "pragma": "parallel for private(    index intensity position previous world)", "hash": "b61927ae1829d24cd894f55dfae97005a4049d04649b0a4dec2777c4c461783a"}
{"code": "for (int i = 0; i < queue_size; ++i) \n    { \n      int v = queue[i]; \n      in_queue[v] = false; \n      int part = parts[v]; \n      for (int p = 0; p < num_parts; ++p) \n        part_counts[p] = 0.0; \n \n      unsigned out_degree = out_degree(g, v); \n      int* outs = out_vertices(g, v); \n      for (unsigned j = 0; j < out_degree; ++j) \n      { \n        int out = outs[j]; \n        int part_out = parts[out]; \n        part_counts[part_out] += 1.0; \n      } \n       \n      int max_part = part; \n      double max_val = 0.0; \n      int part_count = (int)part_counts[part]; \n      int max_count = 0; \n      for (int p = 0; p < num_parts; ++p) \n      { \n        int count_init = (int)part_counts[p]; \n        if (part_weights[p] > 0.0 && part_edge_weights[p] > 0.0) \n          part_counts[p] *= (part_weights[p]*part_edge_weights[p]*weight_exponent_e); \n        else \n          part_counts[p] = 0.0; \n         \n        if (part_counts[p] > max_val) \n        { \n          max_val = part_counts[p]; \n          max_count = count_init; \n          max_part = p; \n        } \n      } \n \n      if (max_part != part) \n      { \n        parts[v] = max_part; \n        ++num_swapped_1; \n    #pragma omp atomic \n        --part_sizes[part]; \n    #pragma omp atomic \n        ++part_sizes[max_part]; \n    #pragma omp atomic \n        part_edge_sizes[part] -= out_degree; \n    #pragma omp atomic \n        part_edge_sizes[max_part] += out_degree; \n \n        if (!in_queue_next[v]) \n        { \n          in_queue_next[v] = true; \n          thread_queue[thread_queue_size++] = v; \n \n          if (thread_queue_size == THREAD_QUEUE_SIZE) \n          { \n#pragma omp atomic capture \n            thread_start = next_size += thread_queue_size; \n             \n            thread_start -= thread_queue_size; \n            for (int l = 0; l < thread_queue_size; ++l) \n              queue_next[thread_start+l] = thread_queue[l]; \n            thread_queue_size = 0; \n          } \n        } \n        for (int j = 0; j < out_degree; ++j) \n        { \n          if (!in_queue_next[outs[j]]) \n          { \n            in_queue_next[outs[j]] = true; \n            thread_queue[thread_queue_size++] = outs[j]; \n \n            if (thread_queue_size == THREAD_QUEUE_SIZE) \n            { \n#pragma omp atomic capture \n              thread_start = next_size += thread_queue_size; \n               \n              thread_start -= thread_queue_size; \n              for (int l = 0; l < thread_queue_size; ++l) \n                queue_next[thread_start+l] = thread_queue[l]; \n              thread_queue_size = 0; \n            } \n          } \n        } \n \n        part_weights[part] = vert_balance * avg_size / (double)part_sizes[part] - 1.0;    \n        part_edge_weights[part] = max_e * avg_edge_size / (double)part_edge_sizes[part] - 1.0; \n \n        part_weights[max_part] = vert_balance * avg_size / (double)part_sizes[max_part]  - 1.0;    \n        part_edge_weights[max_part] = max_e * avg_edge_size / (double)part_edge_sizes[max_part] - 1.0; \n \n        if (part_weights[part] < 0.0) \n          part_weights[part] = 0.0; \n        if (part_edge_weights[part] < 0.0) \n          part_edge_weights[part] = 0.0; \n \n        if (part_weights[max_part] < 0.0) \n          part_weights[max_part] = 0.0; \n        if (part_edge_weights[max_part] < 0.0) \n          part_edge_weights[max_part] = 0.0; \n      } \n    }", "pragma": "for reduction(+:num_swapped_1) ", "hash": "b5ce42adee94afca6e51dbbc60f96258fa5075c6eb4bd4b975edaa190ae8a1f1"}
{"code": "for(index=0; index<referenceVoxelNumber; index++) \n    { \n \n        grad[0]=0.0; \n        grad[1]=0.0; \n        grad[2]=0.0; \n \n        position[0]=(FieldTYPE) deformationFieldPtrX[index]; \n        position[1]=(FieldTYPE) deformationFieldPtrY[index]; \n        position[2]=(FieldTYPE) deformationFieldPtrZ[index]; \n \n        previous[0] = static_cast<int>(reg_floor(position[0])); \n        previous[1] = static_cast<int>(reg_floor(position[1])); \n        previous[2] = static_cast<int>(reg_floor(position[2])); \n         \n \n        relative=position[0]-(FieldTYPE)previous[0]; \n        xBasis[0]= (FieldTYPE)(1.0-relative); \n        xBasis[1]= relative; \n         \n \n        relative=position[1]-(FieldTYPE)previous[1]; \n        yBasis[0]= (FieldTYPE)(1.0-relative); \n        yBasis[1]= relative; \n         \n \n        relative=position[2]-(FieldTYPE)previous[2]; \n        zBasis[0]= (FieldTYPE)(1.0-relative); \n        zBasis[1]= relative; \n \n         \n \n        if(tBoundary == resampler_boundary_e::ZEROPAD && paddingValue==paddingValue) \n        { \n          for(c=0; c<2; c++) \n          { \n            Z=previous[2]+c; \n            if(Z>-1 && Z<floatingImage->nz) \n            { \n              zPointer = &floatingIntensity[Z*floatingImage->nx*floatingImage->ny]; \n              xxTempNewValue=0.0; \n              yyTempNewValue=0.0; \n              zzTempNewValue=0.0; \n              for(b=0; b<2; b++) \n              { \n                Y=previous[1]+b; \n                if(Y>-1 && Y<floatingImage->ny) \n                { \n                  xyzPointer = &zPointer[Y*floatingImage->nx+previous[0]]; \n                  xTempNewValue=0.0; \n                  yTempNewValue=0.0; \n                  for(a=0; a<2; a++) \n                  { \n                    X=previous[0]+a; \n                    if(X>-1 && X<floatingImage->nx) \n                    { \n                      coeff = *xyzPointer; \n                      xTempNewValue +=  coeff * deriv[a]; \n                      yTempNewValue +=  coeff * xBasis[a]; \n                    }  \n \n                    else \n                    { \n                      xTempNewValue +=  paddingValue * deriv[a]; \n                      yTempNewValue +=  paddingValue * xBasis[a]; \n                    } \n                    xyzPointer++; \n                  }  \n \n                  xxTempNewValue += xTempNewValue * yBasis[b]; \n                  yyTempNewValue += yTempNewValue * deriv[b]; \n                  zzTempNewValue += yTempNewValue * yBasis[b]; \n                }  \n \n                else \n                { \n                  xxTempNewValue += paddingValue * yBasis[b]; \n                  yyTempNewValue += paddingValue * deriv[b]; \n                  zzTempNewValue += paddingValue * yBasis[b]; \n                } \n              }  \n \n              grad[0] += xxTempNewValue * zBasis[c]; \n              grad[1] += yyTempNewValue * zBasis[c]; \n              grad[2] += zzTempNewValue * deriv[c]; \n            }  \n \n            else \n            { \n              grad[0] += paddingValue * zBasis[c]; \n              grad[1] += paddingValue * zBasis[c]; \n              grad[2] += paddingValue * deriv[c]; \n            } \n          }  \n \n        }  \n \n        else if(reg_checkImageDimensionIndex<tBoundary>(previous[0],floatingImage->nx - 1) \n                && reg_checkImageDimensionIndex<tBoundary>(previous[1],floatingImage->ny - 1) \n                && reg_checkImageDimensionIndex<tBoundary>(previous[2],floatingImage->nz - 1)) { \n          for(c=0; c<2; c++) \n          { \n            Z = reg_applyBoundary<tBoundary>(previous[2] + c, floatingImage->nz); \n            zPointer = &floatingIntensity[Z*floatingImage->nx*floatingImage->ny]; \n            xxTempNewValue=0.0; \n            yyTempNewValue=0.0; \n            zzTempNewValue=0.0; \n            for(b=0; b<2; b++) \n            { \n              Y = reg_applyBoundary<tBoundary>(previous[1] + b, floatingImage->ny); \n              xyzPointer = &zPointer[Y*floatingImage->nx]; \n              xTempNewValue=0.0; \n              yTempNewValue=0.0; \n              for(a=0; a<2; a++) \n              { \n                X = reg_applyBoundary<tBoundary>(previous[0] + a, floatingImage->nx); \n                coeff = xyzPointer[X]; \n                xTempNewValue +=  coeff * deriv[a]; \n                yTempNewValue +=  coeff * xBasis[a]; \n              }  \n \n              xxTempNewValue += xTempNewValue * yBasis[b]; \n              yyTempNewValue += yTempNewValue * deriv[b]; \n              zzTempNewValue += yTempNewValue * yBasis[b]; \n            }  \n \n            grad[0] += xxTempNewValue * zBasis[c]; \n            grad[1] += yyTempNewValue * zBasis[c]; \n            grad[2] += zzTempNewValue * deriv[c]; \n          }  \n \n        }  \n \n        else grad[0]=grad[1]=grad[2]=0; \n \n        warpedGradientPtrX[index] = (GradientTYPE)grad[0]; \n        warpedGradientPtrY[index] = (GradientTYPE)grad[1]; \n        warpedGradientPtrZ[index] = (GradientTYPE)grad[2]; \n    }", "pragma": "parallel for private(                          a b c coeff grad index position previous relative x xbasis xtempnewvalue xxtempnewvalue xyzpointer y ybasis ytempnewvalue yytempnewvalue z zbasis zpointer zztempnewvalue)", "hash": "8c2a2b4d325e97610c310ef831cac15b9bbd11732693b1cd3a8ce538fc8e7ef1"}
{"code": "for(nip = 0; nip < nInputPlane; nip++) \n  { \n    size_t kw, kh, y, x; \n    long long ix = 0, iy = 0; \n    for(kh = 0; kh < kH; kh++) \n    { \n      for(kw = 0; kw < kW; kw++) \n      { \n        real *src = finput_data + nip*(kH*kW*outputHeight*outputWidth) + kh*(kW*outputHeight*outputWidth) + kw*(outputHeight*outputWidth); \n        real *dst = input_data + nip*(inputHeight*inputWidth); \n        if (padW > 0 || padH > 0) { \n          size_t lpad,rpad; \n          for(y = 0; y < outputHeight; y++) { \n            iy = (long long)(y*dH - padH + kh); \n            if (iy < 0 || iy >= inputHeight) { \n            } else { \n              if (dW==1){ \n                 ix = (long long)(0 - padW + kw); \n                 lpad = fmaxf(0,(int)(padW-kw)); \n                 rpad = fmaxf(0,(int)(padW-(kW-kw-1))); \n                 THVector_(add)(dst+(size_t)(iy*inputWidth+ix+lpad), src+(size_t)(y*outputWidth+lpad), 1, outputWidth - lpad - rpad);  \n \n              } \n              else{ \n                for (x=0; x<outputWidth; x++){ \n                   ix = (long long)(x*dW - padW + kw); \n                   if (ix < 0 || ix >= inputWidth){ \n                   }else \n                     THVector_(add)(dst+(size_t)(iy*inputWidth+ix), src+(size_t)(y*outputWidth+x), 1, 1); \n                } \n              } \n            } \n          } \n        } else { \n          for(y = 0; y < outputHeight; y++) { \n            iy = (long long)(y*dH + kh); \n            ix = (long long)(0 + kw); \n            if (dW == 1 ) \n               THVector_(add)(dst+(size_t)(iy*inputWidth+ix), src+(size_t)(y*outputWidth), 1, outputWidth);  \n \n            else{ \n              for(x = 0; x < outputWidth; x++) \n                THVector_(add)(dst+(size_t)(iy*inputWidth+ix+x*dW), src+(size_t)(y*outputWidth+x), 1, 1); \n            } \n          } \n        } \n      } \n    } \n  }", "pragma": "parallel for private(nip)", "hash": "721e756d2e140d64c5f7ca0b9cff9e4b488453b64ebbd240ecac394645161efb"}
{"code": "for (iz=0; iz < nzx; iz++) { \n      refl[is][iz]=0; \n    }", "pragma": "parallel for private(iz)", "hash": "29197fa76332fef9704cf947a9172d6b5dc2835e4983cb67c37e4548586d4f70"}
{"code": "for (size_t i = 2; i < HALF - 2; ++i) { \n        double power = square(out[i] - 0.5 * (out[i-1] + out[i+1])) \n            + square(out[size-i] - 0.5 * (out[size-i-1] + out[size-i+1])); \n        if (UNLIKELY(power > max_power)) \n#pragma omp critical(max_power) \n            if (power > max_power) { \n                max_power = power; \n                peak_index = i; \n            } \n    }", "pragma": "parallel for ", "hash": "441ae5890c7dddbd8a478b7613e0c7bc32b19b95488e474a44c9f8e3247dafbf"}
{"code": "for( unsigned int k = 0; k < Acols; k++){ \n        double Acol_tot = 0.0; \n         \n        for( unsigned int j = 0; j < rows; j++){ \n            Acol_tot = Acol_tot + A2(j, k); \n        } \n         \n        for( unsigned int j = 0; j < rows; j++){ \n            A2(j , k) = A2(j , k) / Acol_tot; \n        } \n         \n        for( unsigned int j = 0; j < rows; j++){ \n            A2(j , k) = std::sqrt(double(A2(j , k))); \n        } \n    }", "pragma": "parallel for ", "hash": "d7723dab43d640ff44a4b78619af0f442c4a6044feb0b29b8f7c9fe74cf48f51"}
{"code": "for( SizeT d = 0; d<nEl; ++d) \n\t{ \n\t  dest[ d] = src[ d]; \n\t}", "pragma": "for ", "hash": "b9b406b71bf026864d5dc50907e52b5b85b0818bda4d546c4e34fffdc92c5f86"}
{"code": "for (int sensorIdx = 0; sensorIdx < (int)maxNumSensors; sensorIdx++) { \n\t\tconst int thread = omp_get_thread_num(); \n\t\tNormalExtractor& extractor = *extractors[thread]; \n\t\textractor.computeMeshNormals(m_sds[sensorIdx], mesh, GAS::get().s_renderDepthMin, GAS::get().s_renderDepthMax, m_normals[sensorIdx]); \n\t}", "pragma": "parallel for ", "hash": "2549000ce613645f1dbb27d2ad75b0bffb4f64626548b9ec82417c64849688e1"}
{"code": "for (i = 1; i < n; i++) { \n            #pragma omp critical \n            if (a[i] < a[i - 1]) { \n                t = a[i]; \n                a[i] = a[i - 1]; \n                a[i - 1] = t; \n                s = 1; \n            } \n        }", "pragma": "parallel for ", "hash": "7c67f5ffa4b45aca293051b1912904e2a483329551222d22013a585ddde24ca6"}
{"code": "for (int i=0; i<nombre_symboles;i++) \n\t\t\t{ \n\t\t\t\tpostcomputation(dechiffre[i], message[i], evalue[i], private_key);\t \n\t\t\t}", "pragma": "for ", "hash": "05392eda6712405eba4fbe2ff23786ccd8ea5007f353589105aa6efe77782d1b"}
{"code": "for (i = 0; i < c_nx; i++) { \n            for (ii = 0; ii < 2; ii++) { \n               idi = 2 * i + ii; \n               if (idi < f_nx) { \n                  if (ii == 0) \n                     f->f1d[idi] = c->f1d[i]; \n                  else if (ii == 1) \n                     f->f1d[idi] = 0.5 * (c->f1d[i] + c->f1d[i + 1]); \n               } \n            } \n         }", "pragma": "for ", "hash": "50e9f3c14c71e6066af0d488c604e5ce1a946d2001580c62bf264ef131a27cba"}
{"code": "for (int u = 0; u < F.Len(); u++) { \n      double LU = LikelihoodForRow(u); \n      #pragma omp atomic \n        L += LU; \n    }", "pragma": "parallel for ", "hash": "a2087ef3b1f905e066c35074d660935aaad686364c23c69e08e0bfab99da5f93"}
{"code": "for (i=0; i <= (ssize_t) MaxMap; i++) \n      { \n        x_map[i].x=(MagickRealType) i; \n        y_map[i].x=0.000000f; \n        z_map[i].x=0.701000f*(2.00000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        x_map[i].y=(MagickRealType) i; \n        y_map[i].y=(-0.172068f)*(2.00000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        z_map[i].y=0.357068f*(2.00000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        x_map[i].z=(MagickRealType) i; \n        y_map[i].z=0.88600f*(2.00000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        z_map[i].z=0.00000f; \n      }", "pragma": "parallel for ", "hash": "0f1491e431f2e236b4646130e8d37afdf5ee39825351f124c6ac9b29c595316d"}
{"code": "for (ptrIdx = 0; ptrIdx < numEffectedF; ptrIdx++) { \n\t\tCCGFace *f = (CCGFace *) effectedF[ptrIdx]; \n\t\tint S, x, y; \n \n\t\tfor (S = 0; S < f->numVerts; S++) { \n\t\t\tNormCopy(FACE_getIFNo(f, lvl, (S + 1) % f->numVerts, 0, gridSize - 1), \n\t\t\t         FACE_getIFNo(f, lvl, S, gridSize - 1, 0)); \n\t\t} \n \n\t\tfor (S = 0; S < f->numVerts; S++) { \n\t\t\tfor (y = 0; y < gridSize; y++) { \n\t\t\t\tfor (x = 0; x < gridSize; x++) { \n\t\t\t\t\tfloat *no = FACE_getIFNo(f, lvl, S, x, y); \n\t\t\t\t\tNormalize(no); \n\t\t\t\t} \n\t\t\t} \n \n\t\t\tVertDataCopy((float *)((byte *)FACE_getCenterData(f) + normalDataOffset), \n\t\t\t             FACE_getIFNo(f, lvl, S, 0, 0), ss); \n \n\t\t\tfor (x = 1; x < gridSize - 1; x++) \n\t\t\t\tNormCopy(FACE_getIENo(f, lvl, S, x), \n\t\t\t\t         FACE_getIFNo(f, lvl, S, x, 0)); \n\t\t} \n\t}", "pragma": "parallel for private(ptridx)", "hash": "302949b95037f7a64b3ba1f9c37052106d7d46f1b7828c46b6f27fb94c0c2afb"}
{"code": "for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    rhs[i][j][k][m] = forcing[i][j][k][m]; \n                } \n            } \n        } \n    }", "pragma": "for ", "hash": "5ebcf666dea2409542063873de6573eea3b4b529e9c2fd85157ef8085fe227e7"}
{"code": "for(i = 0; i < height; i+=pitch) { \n    i1=i/pitch; \n    for(j = 0; j < width; j+=pitch) { \n      j1=j/pitch; \n      float dirwt_l, dirwt_ab, norm_l, norm_ab; \n      float Lout, aout, bout; \n      norm_l = norm_ab = 0; \n \n      Lout = 0; \n      aout = 0; \n      bout = 0; \n \n      for(int32_t inbr=MAX(0,i-scalewin); inbr<=MIN(height-1,i+scalewin); inbr+=scale) { \n        for (int32_t jnbr=MAX(0,j-scalewin); jnbr<=MIN(width-1,j+scalewin); jnbr+=scale) { \n          Temp = inbr*width+jnbr; \n          dirwt_l = DIRWT_L(Temp, i, j); \n          dirwt_ab = DIRWT_AB(Temp, i, j); \n          Lout += dirwt_l*data_fine->m_Image[Temp][0]; \n          aout += dirwt_ab*data_fine->m_Image[Temp][1]; \n          bout += dirwt_ab*data_fine->m_Image[Temp][2]; \n          norm_l += dirwt_l; \n          norm_ab += dirwt_ab; \n        } \n      } \n \n      Temp = i1*outwidth+j1; \n      data_coarse->m_Image[Temp][0]=Lout/norm_l; \n \n      data_coarse->m_Image[Temp][1]=aout/norm_ab; \n      data_coarse->m_Image[Temp][2]=bout/norm_ab; \n    } \n  }", "pragma": "parallel for private( i i1 j j1 temp)", "hash": "2cd73005cb61e285a9c45b54546c7706cecac13fa9c6ef0b0bc0b0057dd9d0c9"}
{"code": "for (int i = 0; i < N; i++) { \n    half f16 = from[i]; \n    FP32 f32; \n    f32.u = (f16 & 0x7fff) << 13;      \n \n    uint exp = shifted_exp & f32.u;    \n \n    f32.u += (127 - 15) << 23;         \n \n     \n \n    if (exp == shifted_exp) {        \n \n      f32.u += (128 - 16) << 23;     \n \n    } else if (exp == 0) {           \n \n      f32.u += 1 << 23;              \n \n      f32.f -= magic.f;              \n \n    } \n    f32.u |= (f16 & 0x8000) << 16;   \n \n    to[i] = f32.f; \n  }", "pragma": "parallel for ", "hash": "2268c054f64c64d868052c3ac5c538d5e203576c3e28943a2f2fd1d2d5e9ba8f"}
{"code": "for(size_t y = 0; y < stride; y++) \n  { \n    float *const in = image + y * ch; \n \n    __m128 xyz = { 0.0f }; \n    __m128 lab = _mm_load_ps(in); \n \n    xyz = dt_Lab_to_XYZ_sse2(lab); \n    lab = _ioppr_xyz_to_linear_rgb_matrix_sse(xyz, profile_info); \n    const float a = in[3]; \n    _mm_stream_ps(in, lab); \n    in[3] = a; \n  }", "pragma": "parallel for ", "hash": "413d8eb1f6a5b00ef1115415f7fb23e71c8c9aa02e050397888b107763efb201"}
{"code": "for(int idx = 0; idx < depth * height * width; ++idx) { \n    int n = norm[idx]; \n    if(n > 0) { \n      for(int f = 0; f < feature_size; ++f) { \n        vol[f * depth * height * width + idx] /= n; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "0e7f349e54d8acb3723261cfc042a2fd1b8f5db62368f3656fb9de9c34d2fd76"}
{"code": "for(i = 0; i < rgridNumber; ++i){ \n\t\t\tfor(int j = goodMomentum; j < pgridNumber; ++j){ \n\t\t\t\tcrflux[i][j] = - electron_charge*(diffusionCoef[i][j]*(distributionFunction[i+1][j] - distributionFunction[i][j])/deltaR[i])*deltaLogP; \n\t\t\t\t \n \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "2a9051db7aa3bbe813392e9962836c945b81194962739bc3a078dfa7323c14fe"}
{"code": "for( size_t i = 0; i < test_height; ++i ) \n    { \n        u_data[i] = distribution(generator); \n    }", "pragma": "parallel for simd ", "hash": "9801be8ed8b17bb6847406a0777514b2a266d24545afefb2e4bb1d693133ee5c"}
{"code": "for(int i=0; i<particles.nParticles(); i++) \n    { \n        pair<int, int> id(i, i); \n        pdForce->calculateForces(id); \n    }", "pragma": "parallel for ", "hash": "c54a5c1011866aa7c1768b03c1b4609cd2101b957e9cf6c7292bb651e43aa3d9"}
{"code": "for (size_t id = 0; id < resultReader->getSize(); id++) { \n            progress.updateProgress(); \n \n            char *results = resultReader->getData(id, thread_idx); \n            if (onlyResultDb) { \n                T stat = (*call)(results); \n                buffer.append(SSTR(stat)); \n                buffer.append(\"\\n\"); \n            } else { \n                 \n \n                int cnt = 0; \n                while (*results != '\\0') { \n                    Util::parseKey(results, dbKey); \n                    char *rest; \n                    errno = 0; \n                    const unsigned int key = (unsigned int) strtoul(dbKey, &rest, 10); \n                    if ((rest != dbKey && *rest != '\\0') || errno == ERANGE) { \n                        Debug(Debug::WARNING) << \"Invalid key in entry \" << id << \"!\\n\"; \n                        continue; \n                    } \n \n                    const size_t edgeId = targetReader->getId(key); \n                    const char *dbSeqData = targetReader->getData(edgeId, thread_idx); \n \n                    T stat = (*call)(dbSeqData); \n                    buffer.append(SSTR(stat)); \n                    buffer.append(\"\\n\"); \n \n                    results = Util::skipLine(results); \n                    cnt++; \n                } \n            } \n            statWriter->writeData(buffer.c_str(), buffer.length(), resultReader->getDbKey(id), thread_idx); \n            buffer.clear(); \n        }", "pragma": "for ", "hash": "5f18641b03acb8ca9ee74643ac73f66ff53e09ef3fec7ab15ef4e168cc739c4f"}
{"code": "for (i=1; i<N-1; i++) { \n \n     \n \n    u = Ydata[IDX(i,0)]; \n    v = Ydata[IDX(i,1)]; \n    w = Ydata[IDX(i,2)]; \n \n     \n \n    BAND_ELEM(Jac,IDX(i,0),IDX(i,0)) += c*(RCONST(2.0)*u*v-(w+RCONST(1.0))); \n    BAND_ELEM(Jac,IDX(i,1),IDX(i,0)) += c*(w - RCONST(2.0)*u*v); \n    BAND_ELEM(Jac,IDX(i,2),IDX(i,0)) += c*(-w); \n \n     \n \n    BAND_ELEM(Jac,IDX(i,0),IDX(i,1)) += c*(u*u); \n    BAND_ELEM(Jac,IDX(i,1),IDX(i,1)) += c*(-u*u); \n \n     \n \n    BAND_ELEM(Jac,IDX(i,0),IDX(i,2)) += c*(-u); \n    BAND_ELEM(Jac,IDX(i,1),IDX(i,2)) += c*(u); \n    BAND_ELEM(Jac,IDX(i,2),IDX(i,2)) += c*(-RCONST(1.0)/ep - u); \n \n  }", "pragma": "parallel for private(i u v w)", "hash": "98826772feebccd779c7522fa1bb64a73db770a4784d0421970b57c262a1aeb4"}
{"code": "for (i = 0; i < 16; i++) \n    { \n      if (x) \n #pragma omp ordered depend(source)  \n \n      ; \n      if (x) \n #pragma omp ordered depend(sink: i-1)  \n \n      ; \n    }", "pragma": "for ", "hash": "6a3538ef01fd01fbaf5b2f0b54a541fb2b90312a74bbc170d0d8520cfc16f834"}
{"code": "for (int i = 0; i < chunk(ichunk__).num_atoms_; i++) { \n                    for (int xi = 0; xi < chunk(ichunk__).desc_(static_cast<int>(beta_desc_idx::nbf), i); xi++) { \n                        pw_coeffs_a_g0_(chunk(ichunk__).desc_(static_cast<int>(beta_desc_idx::offset), i) + xi) = \n                            pw_coeffs_t_(0, chunk(ichunk__).desc_(static_cast<int>(beta_desc_idx::offset_t), i) + xi, j__); \n                    } \n                }", "pragma": "parallel for ", "hash": "7a487879e3218859af1784a69bf025b681e425494713e1d9e0e2386fc269e360"}
{"code": "for (int i = 0; i < 10; ++i) { \n#pragma omp scan exclusive(a) \n  }", "pragma": "parallel for reduction( +:a inscan) ", "hash": "4d3a9ba6bb194798406a2d7644e6b043c995bc2cbaf2ca8c9a6d9ceaef5ca152"}
{"code": "for(long ii=0;ii<nx*ny*nz;ii++)\r \n\t\t\t{\tlong i=ii%nx;\ta[ii] = b?b[i]:v->v(i);\t}", "pragma": "parallel ", "hash": "2354c2bd75deca1296c82d47d3e3c2ec2d27b0dd3ab3e3753b15b1f99247c6a2"}
{"code": "for( OMPInt i=0; i<nEl; ++i) \n\t      { \n\t\t(*res)[ i] = asin((*p0D)[ i]);  \n\t      }", "pragma": "for ", "hash": "1aaf94a16be3596ecd148f720fa5e595eba3a5fd620c228c9f67e5f6381602e0"}
{"code": "for (int i = 0; i < length; i++) { \n                 \n \n                u0[i] = apply_arctg_slope10(u0[i], norm * iu[i], norm * u2[i], norm * u3[i], \n                                            norm * u4[i], norm * u5[i], norm * u6[i], norm * u7[i]); \n \n                 \n \n                u0[i] = max(min(u0[i], 1.f), -1.f); \n            }", "pragma": "parallel for ", "hash": "0ce87bbfa5da6cdc8520e7fddd3d3725d69d481e4fb029fd017f643bd9cccf3b"}
{"code": "for (int i = 0; i < src->row_count; ++i)\r \n        memcpy(dst->values[i], src->values[i], src->col_count * sizeof(T));", "pragma": "parallel ", "hash": "8680a54a0491ed3aec8047875ea8a1a1a609037bd553d4691f15b3e42533e8a9"}
{"code": "for(int x=0; x<System.Get_NX(); x++) \n\t\t{ \n\t\t\tCSG_Regression_Weighted\tModel; \n \n\t\t\tif( Get_Model(x, y, Model) ) \n\t\t\t{ \n\t\t\t\tm_pQuality->Set_Value(x, y, Model.Get_R2()); \n \n\t\t\t\tm_pModel[m_nPredictors]->Set_Value(x, y, Model[0]);\t \n \n \n\t\t\t\tfor(int i=0; i<m_nPredictors; i++) \n\t\t\t\t{ \n\t\t\t\t\tm_pModel[i]->Set_Value(x, y, Model[i + 1]); \n\t\t\t\t} \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tm_pQuality->Set_NoData(x, y); \n \n\t\t\t\tfor(int i=0; i<=m_nPredictors; i++) \n\t\t\t\t{ \n\t\t\t\t\tm_pModel[i]->Set_NoData(x, y); \n\t\t\t\t} \n \n\t\t\t\tm_pResiduals->Set_NoData(x, y); \n\t\t\t} \n\t\t}", "pragma": "parallel for ", "hash": "89e8575982a6006f4308aa1225a250d4477cbecff86fa870be75696826961d85"}
{"code": "for (auto row_idx = 0U; row_idx < m_num_rows; ++row_idx) \n\t{ \n\t\tmodel_elem = (float*)((char*)m_model + row_idx * m_step); \n\t\timg_elem = in_img + row_idx * in_step; \n\t\t__m128i img_block_8; \n\t\t__m128 block[4]; \n\t\tfor (auto block_idx = 0U; block_idx < num_blocks; ++block_idx) \n\t\t{ \n\t\t\timg_block_8 = _mm_loadu_si128((__m128i*)img_elem); \n      ConvertInt8ToFloat(img_block_8, block); \n\t\t\tfor (auto var_idx = 0U; var_idx < 4; ++var_idx) \n        _mm_store_ps(model_elem + 4 * var_idx, block[var_idx]); \n \n\t\t\tmodel_elem += m_BYTES_PER_BLOCK; \n\t\t\timg_elem += m_BYTES_PER_BLOCK; \n\t\t} \n\t\tfor (auto col_idx = 0U; col_idx < num_left_elems; ++col_idx) \n\t\t\tmodel_elem[col_idx] = img_elem[col_idx];\t \n\t\tauto num_elems_per_row = 3 * m_num_cols; \n\t\tfor (auto col_idx = 0U; col_idx < num_elems_per_row; ++col_idx) \n\t\t\tmodel_elem[col_idx] = img_elem[col_idx]; \n\t}", "pragma": "parallel for private( img_elem model_elem)", "hash": "43b98f64000acdc46c6f9aab2d628260c1b81e5dae3045fc587e71908ae2c106"}
{"code": "for ( int i = 0; i < numCells; i++ ) \n    { \n        if ( !visibility->val( i ) && activeCellInfo->isActive( i ) ) \n        { \n            size_t cellResultIndex        = activeCellInfo->cellResultIndex( i ); \n            resultValues[cellResultIndex] = defaultValue; \n        } \n    }", "pragma": "parallel for ", "hash": "ba2e2a0a62b93ef02779f75c2ad08d8ce26eb3a33092e22ab42967a1fd72be55"}
{"code": "for (ix=ioXx; ix<nx+1; ix++) { \n#pragma ivdep \n\t\tfor (iz=ioXz; iz<nz+1; iz++) { \n\t\t\ttx[ix*n1+iz] -= mul[ix*n1+iz]*( \n\t\t\t\t\t\tc1*(vz[ix*n1+iz]     - vz[(ix-1)*n1+iz]) + \n\t\t\t\t\t\tc2*(vz[(ix+1)*n1+iz] - vz[(ix-2)*n1+iz])); \n\t\t} \n\t}", "pragma": "for private( ix iz)", "hash": "2cd3a9fe26aba349f8d0536edb94712a10044236f5a03f633f19cc21ee4d1787"}
{"code": "for(int l = 0; l < loci; l++){ \n \n      #pragma omp critical \n      { \n        while(newVals[l] < 0){ \n          newVals[l] = r->normalRv(vals[l], tune); \n        } \n      } \n \n      newLogLiks[l] = calcLogLik(gLiks, freqs, ind, l, ploidy, newVals[l]); \n \n      lnMetropRatio = (newLogLiks[l] + r->lnGammaPdf(aa, bb, newVals[l])) \n                      - (currLogLiks[l] + r->lnGammaPdf(aa, bb, vals[l])); \n \n      lnU = log(r->uniformRv()); \n \n      if(lnU < lnMetropRatio){ \n        vals[l] = newVals[l]; \n        currLogLiks[l] = newLogLiks[l]; \n        nAccepted[l]++; \n        nProposals[l]++; \n        acceptRatio[l] = nAccepted[l] / (double) nProposals[l]; \n      } else { \n        nProposals[l]++; \n        acceptRatio[l] = nAccepted[l] / (double) nProposals[l]; \n      } \n \n    }", "pragma": "for ", "hash": "15c94c6fc054bd7b27eb7aae65edaff5dae39674d94b97334692cc0d44b60f8c"}
{"code": "for(size_t row = ymin; row < ymax; row++) \n    { \n      for(size_t col = xmin, s = row*width + col, d = (row-ymin)*(xmax-xmin); col < xmax; col++, s++, d++) \n        tmp[d] = gradient[s]; \n    }", "pragma": "parallel for ", "hash": "c28ffa48bb723705e11a03a70fd21e76cce703ba8167467a76749dc1d90d5f5e"}
{"code": "for (int i = argc; i < c; ++i) \n    a = 2;", "pragma": "for reduction(+:argv[0][:1]) ", "hash": "4648ff9f7f370d026389b95a2ac8cd6527c1aa5d611fca2aba62cf4858802aaa"}
{"code": "for (p = 0; p < nbatch; p++) \n    { \n      THNN_(SpatialMaxUnpooling_updateOutput_frame)(input_data+p*nslices*iwidth*iheight, output_data+p*nslices*owidth*oheight, \n                                                indices_data+p*nslices*iwidth*iheight, \n                                                nslices, \n                                                iwidth, iheight, \n                                                owidth, oheight); \n    }", "pragma": "parallel for private(p)", "hash": "60ce294f18d2f742c677498009fb217c44b8c05a286e3b37d693ffbc302f2f04"}
{"code": "for (int i = 0; i < totalCount; ++i) { \n        diagElements[i] = getDiagValue(task, rank * n + i, coordStep) - eigenValue; \n    }", "pragma": "parallel for ", "hash": "f633a2462f256933bb2c66e06a1a0f4f3656efce31f4d9a2e530d4cf592fd5e3"}
{"code": "for(int i = 0; i < size.height; i++ ) \n\t{ \n\t\tconst uchar* sptr = sim.data + (i+radius)*sim.step + radius*cn; \n\t\tuchar* dptr = dst.data + i*dst.step; \n \n\t\tif( cn == 1) \n\t\t{ \n\t\t\tfor(int j = 0; j < size.width; j++ ) \n\t\t\t{ \n\t\t\t\tfloat sum = 0, wsum = 0; \n\t\t\t\tint val0 = sptr[j]; \n\t\t\t\tfor(int k = 0; k < maxk; k++ ) \n\t\t\t\t{ \n\t\t\t\t\tint val = sptr[j + space_ofs_src[k]]; \n\t\t\t\t\tfloat w = space_weight[k]*color_weight[(val - val0)*(val - val0)]; \n\t\t\t\t\tsum += val*w; \n\t\t\t\t\twsum += w; \n\t\t\t\t} \n\t\t\t\t \n \n\t\t\t\tdptr[j] = (uchar)cvRound(sum/wsum); \n\t\t\t} \n\t\t} \n\t\telse if(cn == 3) \n\t\t{ \n\t\t\tfor(int j = 0; j < size.width*3; j += 3 ) \n\t\t\t{ \n\t\t\t\tfloat sum_b = 0, sum_g = 0, sum_r = 0, wsum = 0; \n\t\t\t\tint b0 = sptr[j], g0 = sptr[j+1], r0 = sptr[j+2]; \n\t\t\t\tfor(int k = 0; k < maxk; k++ ) \n\t\t\t\t{ \n\t\t\t\t\tconst uchar* sptr_k = sptr + j + space_ofs_src[k]; \n\t\t\t\t\tint b = sptr_k[0], g = sptr_k[1], r = sptr_k[2]; \n \n\t\t\t\t\tfloat w = space_weight[k]*color_weight[(b - b0)*(b - b0) + abs(g - g0)*abs(g - g0) + (r - r0)*(r - r0)]; \n\t\t\t\t\tsum_b += b*w; sum_g += g*w; sum_r += r*w; \n\t\t\t\t\twsum += w; \n\t\t\t\t} \n\t\t\t\twsum = 1.f/wsum; \n\t\t\t\tb0 = cvRound(sum_b*wsum); \n\t\t\t\tg0 = cvRound(sum_g*wsum); \n\t\t\t\tr0 = cvRound(sum_r*wsum); \n\t\t\t\tdptr[j] = (uchar)b0; dptr[j+1] = (uchar)g0; dptr[j+2] = (uchar)r0; \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "320320340d05caeef82ccc58b97aa096ae0ac7573098ea1ac9b573eb5546907f"}
{"code": "for (int i = 0; i < nSize; i++) \n    force[i][0] = force[i][1] = force[i][2] = 0.0;", "pragma": "for ", "hash": "30dad979607548739ed31b743673df0e787ddc0cc865929ca9eb312e518045f3"}
{"code": "for(int img = 0; img < nImg; img++) { \n    for(int ofm = 0; ofm < nOfm; ofm++) { \n      for(int h = 0; h < ofh; h++) { \n        for(int w = 0; w < ofw; w++) { \n          int ifh = v[img].height(); \n          int ifw = v[img].width(); \n \n          assert(v[img].channels() == nOfm); \n          const unsigned char (* __restrict input)[ifh][ifw] = (const unsigned char (*)[*][*])v[img].data().c_str(); \n \n          int r_off = r_offset[img]; \n          int c_off = c_offset[img]; \n \n          float inp = (float)input[ofm][h+r_off][w+c_off]; \n          int fm = (gparams_.scale_values.size() == 1) ? 0 : ofm; \n \n          if(tv % 2 == 0) \n            output[img][ofm][h][w] = (inp - gparams_.mean_values[ofm]) * gparams_.scale_values[fm]; \n          else \n            output[img][ofm][ofh-h-1][ofw-w-1] = (inp - gparams_.mean_values[ofm]) * gparams_.scale_values[fm]; \n        } \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "b1776a4fa2a33f9704dfe97d3050dda0d15622421807739119dd06ed76001c47"}
{"code": "for (int i=0;i<dat.nx;i++) \n    for (int j=0;j<dat.ny;j++) \n    { \n        Cell * c0  = dom.Lat.GetCell(iVec3_t(i,j,       0)); \n        Cell * c0n = dom.Lat.GetCell(iVec3_t(i,j,       1)); \n        Cell * c1  = dom.Lat.GetCell(iVec3_t(i,j,dat.nz-1)); \n        Cell * c1n = dom.Lat.GetCell(iVec3_t(i,j,dat.nz-2)); \n \n         \n \n         \n \n        c0->Initialize(0.0,OrthoSys::O,OrthoSys::O,OrthoSys::O); \n        c1->Initialize(0.0,OrthoSys::O,OrthoSys::O,OrthoSys::O); \n    }", "pragma": "parallel for ", "hash": "e90d1ab71d3a27445f96c8050aaba0a1ea7fc2357d6f85d0d6718e0a832c985b"}
{"code": "for(int i=0;i<num_updates;i++) \n    { \n        auto it = update_set.begin(); \n        for(int j=0;j<i;j++) \n            it++; \n        NDTCell *cell = *it; \n        if(cell!=NULL) \n        { \n            cell->computeGaussian(cellupdatemode,maxnumpoints, occupancy_limit, origin,sensor_noise); \n             \n \n            if(cell->points_.size()>0) \n            { \n                cell->points_.clear(); \n            } \n            if (cv!=NULL) \n            { \n                 \n \n                Eigen::Vector3d mean = cell->getMean(); \n                pcl::PointXYZ pt; \n                pt.x = mean[0]; \n                pt.y = mean[1]; \n                pt.z = mean[2]; \n \n                cell->setCenter(pt); \n            } \n        } \n    }", "pragma": "for ", "hash": "e452f89fda80ad340a6aa5fc62333e8dc72fe6ee0c30be6d0d8932a7e47c5cea"}
{"code": "for(long i=0;i<n;i++)\td->a[i] /= a;", "pragma": "parallel ", "hash": "6884aff90fe18839abacf9a1b864824343ef64f187f19ea2ed12e2432fd5a8a0"}
{"code": "for (Iter0 I; I < end0; ++I) \n    ++I;", "pragma": "for simd ", "hash": "55c8e4208b06c0e28e4d6dbbc36b1730514bc7210ae94324893800ebaf869c4c"}
{"code": "for(int rule = 0; rule < committeeSize; rule++) \n            { \n            double featureValue = computeFeature(committee[rule].featureIndex, area, integralImage, true)/varianceNormalizer; \n            double vote = (featureValue > committee[rule].threshold ? 1 : -1)*committee[rule].toggle+tweak; \n            prediction += vote*committee[rule].logWeightedError; \n            }", "pragma": "parallel for ", "hash": "75c5b624b0fa488690b5d5ae9449636eeeb2b22491a20aa85f0b9a0f64042756"}
{"code": "for (int i=0; i < _sz; i++) \n                op(i,nodes,flags,vel,dt,u);", "pragma": "for ", "hash": "4c3b537e369337fb9e50cd086ba703587279cff184bcc9b8bf14d19249f35005"}
{"code": "for (i=0; i <= (ssize_t) MaxMap; i++) \n      { \n        x_map[i].x=1.0f*(MagickRealType) i; \n        y_map[i].x=0.0f*(MagickRealType) i; \n        z_map[i].x=0.0f*(MagickRealType) i; \n        x_map[i].y=0.0f*(MagickRealType) i; \n        y_map[i].y=1.0f*(MagickRealType) i; \n        z_map[i].y=0.0f*(MagickRealType) i; \n        x_map[i].z=0.0f*(MagickRealType) i; \n        y_map[i].z=0.0f*(MagickRealType) i; \n        z_map[i].z=1.0f*(MagickRealType) i; \n      }", "pragma": "parallel for ", "hash": "842af4eb93d149c8663ed36677b3fa77b8c59f1cace7e6f4c13aa65397694e66"}
{"code": "for(j=0; j<N; j++) { \n            resultado+=(matriz[i][j]*v1[j]); \n        }", "pragma": "parallel for reduction(+:resultado) ", "hash": "c8f2d05eae37739f346c24507a5fc5fd8d59df59b7fdc3f88b0caf80bd69e6d2"}
{"code": "for (i=0; i <= (long) MaxMap; i++) \n      { \n        x_map[i].x=(double) i; \n        y_map[i].x=0.500000*(2.000000*i-MaxMap); \n        z_map[i].x=(-0.333340)*(2.000000*i-MaxMap); \n        x_map[i].y=(double) i; \n        y_map[i].y=0.000000; \n        z_map[i].y=0.666665*(2.000000*i-MaxMap); \n        x_map[i].z=(double) i; \n        y_map[i].z=(-0.500000)*(2.000000*i-MaxMap); \n        z_map[i].z=(-0.333340)*(2.000000*i-MaxMap); \n      }", "pragma": "parallel for ", "hash": "7bf62183c58469c866edc739aa4a7647d19b888fd8057cc52a5dcb11407872ff"}
{"code": "for (int i = 0; i < gnx1*gnx2; i++) \n      contact[i] = 0.0;", "pragma": "parallel for ", "hash": "0ceaecb3a98e565c66492bde3a304a56b22e3feb1c97becc53ea97d8935345d7"}
{"code": "for(unsigned int i = 0;i < buffer_size;++i){ \n \n\t\t\t \n \n\t\t\tRead &r = m_buffer[i]; \n\t\t\t \n\t\t\ttry{ \n\t\t\t\tconst bool valid = trim_read( \n\t\t\t\t\tr, \n\t\t\t\t\tlocal_filter_stats, \n\t\t\t\t\tlocal_kmer_table, \n\t\t\t\t\tlocal_info, m_opt); \n\t\t\t\t \n\t\t\t\tif(!valid){ \n\t\t\t\t\tr.seq = r.qual = \"\"; \n\t\t\t\t} \n\t\t\t} \n\t\t\tcatch(const char *error){ \n \n\t\t\t\tcerr << \"Error: \" << error << endl; \n\t\t\t\tthrow error; \n\t\t\t} \n\t\t\tcatch(...){ \n \n\t\t\t\tcerr << \"Caught an unhandled error in trim()\" << endl; \n\t\t\t\tthrow __FILE__ \":trim: Caught an unhandled error\"; \n\t\t\t} \n\t\t}", "pragma": "for ", "hash": "9349a7604950468cd6e659db911f208c0c37dd2216a124485ace26379575d417"}
{"code": "for (t2=lbp;t2<=ubp;t2++) { \n    stddev[t2] /= float_n; stddev[t2] = SQRT_FUN(stddev[t2]); stddev[t2] = stddev[t2] <= eps ? SCALAR_VAL(1.0) : stddev[t2];; \n  }", "pragma": "parallel for private(lbv t3 t4 ubv)", "hash": "d4f602e53868c9f990dcc9b1891a94574119d9d637450ca74b954a63c53a9c4c"}
{"code": "for (y=0; y < (ssize_t) excerpt_image->rows; y++) \n  { \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,geometry->x,geometry->y+y, \n      geometry->width,1,exception); \n    q=GetCacheViewAuthenticPixels(excerpt_view,0,y,excerpt_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) excerpt_image->columns; x++) \n    { \n      register ssize_t \n        i; \n \n      if (GetPixelReadMask(image,p) == 0) \n        { \n          p+=GetPixelChannels(image); \n          q+=GetPixelChannels(excerpt_image); \n          continue; \n        } \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i); \n        PixelTrait traits=GetPixelChannelTraits(image,channel); \n        PixelTrait excerpt_traits=GetPixelChannelTraits(excerpt_image,channel); \n        if ((traits == UndefinedPixelTrait) || \n            (excerpt_traits == UndefinedPixelTrait)) \n          continue; \n        SetPixelChannel(excerpt_image,channel,p[i],q); \n      } \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(excerpt_image); \n    } \n    if (SyncCacheViewAuthenticPixels(excerpt_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor != (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_ExcerptImage) \n        proceed=SetImageProgress(image,ExcerptImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  }", "pragma": "parallel for ", "hash": "036121e2df565bd92da1639c565698d8a0991b56b0825a53bc34c5d9477bf8ea"}
{"code": "for(int path_idx = 0; path_idx < n_paths; ++path_idx) { \n    dense_read_prealloc_cpu(paths[path_idx], n_dim, dims_single, data + path_idx * offset); \n  }", "pragma": "parallel for ", "hash": "be31e10a49b771330b524569e3702c9108706b16f27df8a8e1ca2bb6b690e7f7"}
{"code": "for(int ichan = 0; ichan < numChannels; ichan++){ \n     int hpModDim,hpIndex,hp2Index; \n     double vpqrs; \n \n\t   \n     hpModDim = 0; \n     for(int i = 0; i < fermiLevel; i++){ \n       for(int a = fermiLevel; a < Nspstates; a++){ \n\t if( SPbasis->checkChanModSym(i,a,ichan) == 1 ){\t   \n\t   hpModDim++;\t\t   \n\t }  \n \n       }  \n \n     }  \n \n \n\t     \n     memoryUsed+= hpModDim*hpModDim; \n     vnn.hpph_hphp_mod[ichan].allocate(hpModDim,hpModDim); \n     vnn.hpph_hphp_mod[ichan].zeros();\t \n\t     \t     \t     \n     hpIndex = 0; \n     for(int i = 0; i < fermiLevel; i++){ \n       for(int b = fermiLevel; b < Nspstates; b++){ \n\t if( SPbasis->checkChanModSym(i,b,ichan) == 1 ){ \n\t   hp2Index = 0;\t\t    \n\t   for(int j = 0; j < fermiLevel; j++){ \n\t     for(int a = fermiLevel; a < Nspstates; a++){\t\t       \n\t       if( SPbasis->checkChanModSym(j,a,ichan) == 1 ){\t\t \n\t\t vpqrs = calcVpqrs(i,a,b,j,SPbasis);  \n\t\t vnn.hpph_hphp_mod[ichan].setElement(hpIndex,hp2Index,vpqrs); \n\t\t vnn.hpph_hphp_mod[ichan].rowMap[hpIndex][0] = i;\t\t \n\t\t vnn.hpph_hphp_mod[ichan].rowMap[hpIndex][1] = b; \n\t\t vnn.hpph_hphp_mod[ichan].colMap[hp2Index][0] = j; \n\t\t vnn.hpph_hphp_mod[ichan].colMap[hp2Index][1] = a; \n\t\t  \n\t\t hp2Index++; \n\t\t\t  \n\t       }  \n \n\t\t       \t       \n\t     }  \n \n\t   }  \n \n\t   hpIndex++; \n\t }  \n \n       }  \n \n     }\t \n \n\t      \n   }", "pragma": "parallel for reduction(+:memoryused) ", "hash": "f7407891ff7e76b05b29c6d20c6acaadea5dcf74f40d44da4a03f3f325213a46"}
{"code": "for (int i = 0; i < numParticles; i++) \n\t\t{ \n\t\t\t \n \n\t\t\tcomputeDensityChange(fluidModelIndex, i, h); \n\t\t\tif (m_simulationData.getDensityAdv(fluidModelIndex, i) > 0.0)\t\t\t\t \n\t\t\t\tm_simulationData.getKappaV(fluidModelIndex, i) = static_cast<Real>(0.5) * max(m_simulationData.getKappaV(fluidModelIndex, i), static_cast<Real>(-0.5)) * invH; \n\t\t\telse \n\t\t\t\tm_simulationData.getKappaV(fluidModelIndex, i) = 0.0; \n\t\t}", "pragma": "for ", "hash": "ca44ab7a01cf5915fba9f572eab6873d160b528dfab2a717e8fa3cf514a21ccc"}
{"code": "for(int i=0;i<len;i++) \n     \n \n    { \n      d[i]=d[i]*b[i]; \n    }", "pragma": "for ", "hash": "a2e410ce800d19d3be8833ecc471e5e3e9d52ae3bd4df5ba1875993f260a263c"}
{"code": "for (size_t uiI = 0; uiI < m_uiN; uiI++) \n\t\t{ \n\t\t\tm_lpdValues[uiI] -= i_vRHO.m_lpdValues[uiI]; \n\t\t}", "pragma": "for ", "hash": "d6c21e168096f1993bfcee3fb749fe5aebcb9051357d7771b772d24d1469d6bf"}
{"code": "for (size_t p = 0; p < npairs; ++p) { \n        int32_t flow = checkpairs[p].first; \n        int32_t fhigh = checkpairs[p].second; \n \n        bool failed1 = fpos[loc_indx.at(flow)].first; \n        fbg::shape const & shptheta1 = fpos[loc_indx.at(flow)].second.first; \n        fbg::shape const & shpphi1 = fpos[loc_indx.at(flow)].second.second; \n        bool failed2 = fpos[loc_indx.at(fhigh)].first; \n        fbg::shape const & shptheta2 = fpos[loc_indx.at(fhigh)].second.first; \n        fbg::shape const & shpphi2 = fpos[loc_indx.at(fhigh)].second.second; \n \n        bool hit = false; \n        if (failed1 || failed2) { \n            hit = true; \n        } else if (fbg::intersect(shpphi1, shpphi2)) { \n            hit = true; \n        } else if (fbg::intersect(shptheta1, shpphi2)) { \n            hit = true; \n        } else if (fbg::intersect(shptheta2, shpphi1)) { \n            hit = true; \n        } \n        if (hit) { \n            #pragma omp critical \n            { \n                result[loc_indx[flow]] = true; \n                result[loc_indx[fhigh]] = true; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "a66b4aeaecc7056cffd452dfa413bc911370c66ed86be16f3515f8e69f19cb64"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr) \n\t{ \n\t\tregister long k = i*nx; \n\t\tb[k] = -(3*a[k]-4*a[k+1]+a[k+2])*dd; \n\t\tb[k+nx-1] = (3*a[k+nx-1]-4*a[k+nx-2]+a[k+nx-3])*dd; \n\t\tfor(long j=1;j<nx-1;j++)\tb[j+k] = (a[j+k+1]-a[j+k-1])*dd; \n\t}", "pragma": "parallel for ", "hash": "531e841fd411381a3abe91fd85708eadfa9db37187efa98b9cfda4bbbe02187a"}
{"code": "for (auto it = inputs.begin(); it < inputs.end(); it++) { \n        const std::string &input = *it; \n \n         \n \n        unsigned int cpu_thread_id = omp_get_thread_num(); \n        unsigned int num_cpu_threads = omp_get_num_threads(); \n        CUDAHelper::checkError(cudaSetDevice(cpu_thread_id % num_gpus)); \n        int gpu_id = -1; \n        CUDAHelper::checkError(cudaGetDevice(&gpu_id)); \n        #pragma omp critical \n                clog(debug) << \"Processing '\" << input << \"' on GPU \" << gpu_id \n                            << \" in CPU thread \" << cpu_thread_id << \" (of \" \n                            << num_cpu_threads << \")\" << std::endl; \n \n         \n \n        boost::filesystem::path path(input); \n        if (!exists(path)) { \n            clog(error) << \"Input file does not exist\" << std::endl; \n            throw boost::program_options::validation_error( \n                boost::program_options::validation_error::invalid_option_value, \n                \"inputs\", input); \n        } \n        std::string basename = path.stem().string(); \n \n         \n \n        std::vector<Eigen::MatrixXi> components; \n        if (boost::iequals(path.extension().string(), \".pgm\") || \n            boost::iequals(path.extension().string(), \".ppm\")) { \n            components = readnetpbm(input); \n        } else { \n            clog(error) << \"Unrecognized input file format\" << std::endl; \n            throw boost::program_options::validation_error( \n                boost::program_options::validation_error::invalid_option_value, \n                \"inputs\", input); \n        } \n \n        int i = 0; \n        for (const auto &component : components) { \n             \n \n            i++; \n            std::string component_name; \n            if (components.size() == 1) \n                component_name = basename; \n            else \n                component_name = basename + \"_c\" + std::to_string(i); \n \n         \n \n            Transformer transformer(gray2mat(component), component_name, \n                                    vm[\"angle\"].as<unsigned int>(), \n                                    orthonormal); \n            Transformer transformer(gray2mat(component), component_name, \n                                    vm[\"angle\"].as<unsigned int>()); \n \n            if (mode == ProgramMode::CALCULATE) { \n                transformer.getTransform(tfunctionals, pfunctionals, true); \n            } else if (mode == ProgramMode::PROFILE) { \n                cudaProfilerStart(); \n                transformer.getTransform(tfunctionals, pfunctionals, false); \n                cudaProfilerStop(); \n            } else if (mode == ProgramMode::BENCHMARK) { \n                if (!vm.count(\"iterations\")) \n                    throw boost::program_options::required_option(\"iterations\"); \n \n                 \n \n                unsigned int iterations = vm[\"iterations\"].as<unsigned int>(); \n \n                 \n \n                transformer.getTransform(tfunctionals, pfunctionals, false); \n \n                 \n \n                 \n \n                 \n \n                 \n \n                std::chrono::time_point<std::chrono::high_resolution_clock> \n                last, current; \n                for (unsigned int n = 0; n < iterations; n++) { \n                    last = std::chrono::high_resolution_clock::now(); \n                    transformer.getTransform(tfunctionals, pfunctionals, false); \n                    current = std::chrono::high_resolution_clock::now(); \n \n                    clog(info) << \"t_\" << n + 1 << \"=\" \n                               << std::chrono::duration_cast< \n                                      std::chrono::microseconds>(current - last) \n                                          .count() / \n                                      1000000.0 << std::endl; \n                } \n            } \n        } \n \n        #pragma omp critical \n        if (showProgress) \n            ++indicator; \n    }", "pragma": "parallel for ", "hash": "f9a1ea1827ecbc21f59f9455b255651864f0d7f4dbb8d43f69c9159e6c079a64"}
{"code": "for (ompIndexType k = 0; k < elementCount; ++k) { \n            ptrCplxC[k] = std::log(ptrCplxA[k]) / std::log(2); \n            if (!((ptrCplxC[k].imag() == 0.) \n                    || (std::isnan(ptrCplxC[k].real()) && std::isnan(ptrCplxC[k].imag())))) { \n                allReal = false; \n            } \n        }", "pragma": "parallel for ", "hash": "3c64898bcb976f6bbeda65837042f10b8aa657cde92fbdcf3466cddb9c7bb29f"}
{"code": "for (i = 0; i < nrows; i++) { \n                    for (tsum = 0.0, ncand = 0, j = rowptr[i]; j < rowptr[i + 1]; j++, ncand++) { \n                        cand[ncand].val = rowind[j]; \n                        cand[ncand].key = rowval[j]; \n                        tsum += (norm == 1 ? rowval[j] : rowval[j] * rowval[j]); \n                    } \n                    gk_fkvsortd(ncand, cand); \n \n                    for (rsum = 0.0, j = 0; j < ncand && rsum <= fraction * tsum; j++) { \n                        rsum += (norm == 1 ? cand[j].key : cand[j].key * cand[j].key); \n                        nrowind[rowptr[i] + j] = cand[j].val; \n                        nrowval[rowptr[i] + j] = cand[j].key; \n                    } \n                    nrowptr[i + 1] = rowptr[i] + j; \n                }", "pragma": "for ", "hash": "0d7b7d801f5ea28cba216526659f408caeb66f7e56518745d3c2567148fbd817"}
{"code": "for (long j = 0; j < static_cast<long>(n); j++) { \n            akden += z[j] * pp[j]; \n        }", "pragma": "parallel for reduction(      + : akden) ", "hash": "f247e353bde54dbb9c88b1614e4c05d5b85468bac64524f165a34a583fc9c7d5"}
{"code": "for(long i=t->id;i<nn;i+=mglNumThr)\r \n\t{\r \n\t\tregister long k = long(n*(a->vthr(i)-v[0])/(v[1]-v[0]));\r \n\t\tif(k>=0 && k<n)\r \n#pragma omp critical(hist)\r \n\t\t\tb[k] += c ? c->vthr(i):1.;\r \n\t}", "pragma": "parallel ", "hash": "fcfc46af3bcb8afbc6872302186e9ce4327a13f1de7a00804c3f3f1dd22ceb94"}
{"code": "for(size_t i = 0 ; i < sp_num ; i++ ) \n    { \n        if( raw_data_seg[i].down_cloud->empty() == true ) \n            continue; \n         \n        PreCloud(raw_data_seg[i], -1, true); \n        for( int k = 1 ; k < pooler_num ; k++ ) \n        { \n            std::vector<cv::Mat> temp_fea1 = lab_pooler_set[k]->PoolOneDomain_Raw(raw_data_seg[i].rgb, raw_depth_fea[i], 1, max_pool_flag); \n            std::vector<cv::Mat> temp_fea2 = lab_pooler_set[k]->PoolOneDomain_Raw(raw_data_seg[i].rgb, raw_color_fea[i], 1, max_pool_flag); \n            raw_sp_lab[i].insert(raw_sp_lab[i].end(), temp_fea1.begin(), temp_fea1.end()); \n            raw_sp_lab[i].insert(raw_sp_lab[i].end(), temp_fea2.begin(), temp_fea2.end()); \n        } \n    }", "pragma": "parallel for ", "hash": "b11e251af9975f3d5ed79cf27318e4f81e486b732783ff772f602757aa98e825"}
{"code": "for (int xBlock = 0; xBlock < extents.XNbBlocks(); xBlock++)\r \n\t\t\t\t{\r \n\t\t\t\t\tint blockThreadNo = ::omp_get_thread_num();\r \n\r \n\t\t\t\t\t \n \n\t\t\t\t\tCGeoExtents blockExtents = extents.GetBlockExtents(xBlock, yBlock);\r \n\t\t\t\t\tif (AtLeastOnePointIn(blockExtents, ioFile))\r \n\t\t\t\t\t{\r \n\t\t\t\t\t\tReadBlock(xBlock, yBlock, bandHolder[blockThreadNo]);\r \n\t\t\t\t\t\tProcessBlock(xBlock, yBlock, bandHolder[blockThreadNo], ioFile, treated);\r \n\t\t\t\t\t}\r \n\t\t\t\t\telse\r \n\t\t\t\t\t{\r \n#pragma omp atomic\r \n\t\t\t\t\t\tm_options.m_xx += (int)ioFile.m_xy.size();\r \n\r \n\t\t\t\t\t\tm_options.UpdateBar();\r \n\t\t\t\t\t}\r \n\r \n\t\t\t\t}", "pragma": "parallel for ", "hash": "e11c674fc11da8e0604989861292383daca44a5153c61284ecad66f140eb324f"}
{"code": "for (int i = 0; i < (int)numParticles; i++) \n\t\t\t{ \n\t\t\t\tconst Vector3r &xi = m_simulationData.getLastPosition(i); \n \n\t\t\t\tVector3r &ai = m_simulationData.getPressureAccel(i); \n\t\t\t\tai.setZero(); \n \n\t\t\t\tconst Real dpi = m_simulationData.getPressure(i) / (density0*density0); \n\t\t\t\tfor (unsigned int j = 0; j < m_model->numberOfNeighbors(i); j++) \n\t\t\t\t{ \n\t\t\t\t\tconst CompactNSearch::PointID &particleId = m_model->getNeighbor(i, j); \n\t\t\t\t\tconst unsigned int &neighborIndex = particleId.point_id; \n \n\t\t\t\t\tif (particleId.point_set_id == 0) \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tconst Real dpj = m_simulationData.getPressure(neighborIndex) / (density0*density0); \n\t\t\t\t\t\tconst Vector3r &xj = m_simulationData.getLastPosition(neighborIndex); \n\t\t\t\t\t\tai -= m_model->getMass(neighborIndex) * (dpi + dpj) * m_model->gradW(xi - xj); \n\t\t\t\t\t} \n\t\t\t\t\telse \n\t\t\t\t\t{ \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tconst Vector3r &xj = m_model->getPosition(particleId.point_set_id, neighborIndex); \n\t\t\t\t\t\tconst Vector3r a = m_model->getBoundaryPsi(particleId.point_set_id, neighborIndex) * (dpi)* m_model->gradW(xi - xj); \n\t\t\t\t\t\tai -= a; \n \n\t\t\t\t\t\tm_model->getForce(particleId.point_set_id, neighborIndex) += m_model->getMass(i) * a; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "for ", "hash": "b8a0ee0c1ac7a16fc91662526252b2d8480d427b4cff1b1ed5c58143308ff459"}
{"code": "for(j=edge_limit;j<k;j++) \n\t{ \n\t\tfor(i=0;i<edge_limit;i++) \n\t\t{ \n\t\t\tmap[ i * imsize + j] = replacement_value; \n\t\t} \n \n\t\tfor(i = k; i<imsize;i++) \n\t\t{ \n\t\t\tmap[ i * imsize + j] = replacement_value; \n\t\t} \n\t}", "pragma": "parallel for private(i)", "hash": "10cec29175e7aa7350d3b64dfb078250ca14ce14a077693fa6a2acd0abaa9fc3"}
{"code": "for ( lm1 = lmo; lm1 < Bme; ++lm1 ) { \n           \n \n          for ( lk1 = 0; lk1 < Bk; ++lk1 ) { \n            __m512 vmone = _mm512_set1_ps( -1.0f ); \n            const __m512i perm_index = LIBXSMM_INTRINSICS_MM512_SET_EPI16(31, 15, 30, 14, 29, 13, 28, 12, 27, 11, 26, 10, 25, 9, 24, 8, 23, 7, 22, 6, 21, 5, 20, 4, 19, 3, 18, 2, 17, 1, 16, 0); \n            for ( lk2 = 0; lk2 < bk; lk2+=2 ) { \n              libxsmm_bfloat16* tmpaddr1 = tmpa + LIBXSMM_VLA_ACCESS( 2, offa, lm1, lk1, Bk ) + lk2*bm; \n              const float* tmpaddr2a = &LIBXSMM_VLA_ACCESS( 2, origa, (lk1*bk)+lk2, (lm1*bm), (*lda) ); \n              const float* tmpaddr2b = &LIBXSMM_VLA_ACCESS( 2, origa, (lk1*bk)+lk2+1, (lm1*bm), (*lda) ); \n              __m512i vba_0 = _mm512_cvtne2ps_pbh( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b    ) ), _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a    ) ) ); \n              __m512i vba_1 = _mm512_cvtne2ps_pbh( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b+16 ) ), _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a+16 ) ) ); \n              __m512i vba_2 = _mm512_cvtne2ps_pbh( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b+32 ) ), _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a+32 ) ) ); \n              __m512i vba_3 = _mm512_cvtne2ps_pbh( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b+48 ) ), _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a+48 ) ) ); \n              __m256i a_0 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a ) ) ); \n              __m256i a_1 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a+16 ) ) ); \n              __m256i a_2 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a+32 ) ) ); \n              __m256i a_3 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2a+48 ) ) ); \n              __m256i b_0 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b ) ) ); \n              __m256i b_1 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b+16 ) ) ); \n              __m256i b_2 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b+32 ) ) ); \n              __m256i b_3 = _mm512_bf16cvt( _mm512_mul_ps( vmone, _mm512_loadu_ps( tmpaddr2b+48 ) ) ); \n              __m512i vba_0 = _mm512_inserti64x4( _mm512_castsi256_si512(a_0), b_0, 1); \n              __m512i vba_1 = _mm512_inserti64x4( _mm512_castsi256_si512(a_1), b_1, 1); \n              __m512i vba_2 = _mm512_inserti64x4( _mm512_castsi256_si512(a_2), b_2, 1); \n              __m512i vba_3 = _mm512_inserti64x4( _mm512_castsi256_si512(a_3), b_3, 1); \n              _mm512_storeu_si512( tmpaddr1,    _mm512_permutexvar_epi16(perm_index, vba_0 ) ); \n              _mm512_storeu_si512( tmpaddr1+32, _mm512_permutexvar_epi16(perm_index, vba_1 ) ); \n              _mm512_storeu_si512( tmpaddr1+64, _mm512_permutexvar_epi16(perm_index, vba_2 ) ); \n              _mm512_storeu_si512( tmpaddr1+96, _mm512_permutexvar_epi16(perm_index, vba_3 ) ); \n            } \n          } \n        }", "pragma": "for private(   lk1 lk2 lm1 ln1)", "hash": "ec5c8ac3a93fa00c855dce488b150ae23a69ca71fe6ded8b7679bdc804b04d12"}
{"code": "for(int i=0; i<128; i++) \n        { \n            sum = sum + a[i]; \n        }", "pragma": "for reduction(+: sum) ", "hash": "b48bd0532fc3d0440fb22f7ad61d8d2ba6ab9a31fb03859190303a1725247e3e"}
{"code": "for (i=0; i<ncols; i++) \n          nnzcols += (collen[i] > 0 ? 1 : 0);", "pragma": "for reduction(+:nnzcols) ", "hash": "da495cd76267ff7528175603b5b60e99e7196ff07d87ce947d8aee696015fba1"}
{"code": "for(int s1=0; s1<Ns; s1++) {\r \n    for(int s2=0; s2<Ns; s2++) {\r \n    for(int s3=0; s3<Ns; s3++) {\r \n    for(int s4=0; s4<Ns; s4++) {\r \n\r \n      ret[s1*Ns*Ns*Ns+s2*Ns*Ns+s3*Ns+s4] = a[0*Ns*Ns+s1*Ns+s2] * b[0*Ns*Ns+s3*Ns+s4] +\r \n                                           a[3*Ns*Ns+s1*Ns+s2] * b[1*Ns*Ns+s3*Ns+s4] +\r \n                                           a[6*Ns*Ns+s1*Ns+s2] * b[2*Ns*Ns+s3*Ns+s4] +\r \n                                           a[1*Ns*Ns+s1*Ns+s2] * b[3*Ns*Ns+s3*Ns+s4] +\r \n                                           a[4*Ns*Ns+s1*Ns+s2] * b[4*Ns*Ns+s3*Ns+s4] +\r \n                                           a[7*Ns*Ns+s1*Ns+s2] * b[5*Ns*Ns+s3*Ns+s4] +\r \n                                           a[2*Ns*Ns+s1*Ns+s2] * b[6*Ns*Ns+s3*Ns+s4] +\r \n                                           a[5*Ns*Ns+s1*Ns+s2] * b[7*Ns*Ns+s3*Ns+s4] +\r \n                                           a[8*Ns*Ns+s1*Ns+s2] * b[8*Ns*Ns+s3*Ns+s4];\r \n    }}}}", "pragma": "parallel for ", "hash": "9955940fa17260885ee9732ad3811ce01783f5f0a9ca8c9bb928d8553514a0a8"}
{"code": "for ( int pos = 0; pos < n_pixel1; pos++) {\r \n\t\tint x1 = pos/height1;\r \n\t\tint y1 = pos%height1;\r \n\t\tif ( x1 < lx || x1 > rx || y1 < ty || y1 > dy ) continue;\r \n\r \n\t\tint ptr1_desc_idx = pos;\r \n\t\t\r \n\t\t \n \n\t\tfloat min_dist(FLT_MAX);\r \n\t\tint min_idx(-1);\r \n\t\tfor ( int i=0 ; i < n_search ; i++) {\r \n\t\t\tint dx = ref_dx + search_range[2*i];\r \n\t\t\tint dy = ref_dy + search_range[2*i+1];\r \n\t\t\r \n\t\t\tint x2 = x1 + dx;\r \n\t\t\tif ( x2 < 0 || x2 >= width2 ) continue;\r \n\r \n\t\t\tint y2 = y1 + dy;\r \n\t\t\tif ( y2 < 0 || y2 >= height2 ) continue;\r \n\r \n\t\t\t\r \n\t\t\t \n \n\t\t\tfloat l2(0.0f);\r \n\t\t\tint ptr2_desc_idx = y2 + x2*height2;\r \n\t\t\tfor  ( int dim=0 ; dim < desc_dim; dim++) {\r \n\t\t\t\tfloat val1 = desc1[ptr1_desc_idx + dim*n_pixel1];\r \n\t\t\t\tfloat val2 = desc2[ptr2_desc_idx + dim*n_pixel2];\r \n\t\t\t\tl2 += (val1-val2)*(val1-val2);\r \n\t\t\t}\r \n\t\t\tfloat dist_i = sqrt(l2) + deformation_cost[i];\r \n\t\t\tif ( min_dist > dist_i ) {\r \n\t\t\t\tmin_dist = dist_i;\r \n\t\t\t\tmin_idx = i;\r \n\t\t\t}\r \n\t\t}\r \n\r \n\t\t \n \n\t\tif ( match_cost[pos] > min_dist ) {\r \n\t\t\tmatch_cost[pos] = min_dist;\r \n\t\t\tpixel_disparity[2*pos] = ref_dx + search_range[2*min_idx];\r \n\t\t\tpixel_disparity[2*pos+1] = ref_dy + search_range[2*min_idx+1];\r \n\t\t}\r \n\r \n\t}", "pragma": "parallel for ", "hash": "c61c4a4babdda96c2037bf91b6e49043784070e0945dda7dfd17f3101f54b0f6"}
{"code": "for (i = 0; i < (int)n_rows_m; i++) {\r \n        for (j = 0; j < (int)n_cols_m; j++) {\r \n            t[j*n_rows_m + i] = m[i*n_cols_m + j];\r \n        }\r \n    }", "pragma": "parallel for private( i j)", "hash": "1bb3872e948a7c001dcd962b6f36ac5437257267db046435bc6cf3dd580f5a66"}
{"code": "for (int i = 0; i < row; i++) \n\t{ \n\t\tMat temp = Mat::zeros(Size(col, 1), CV_32FC1); \n \n\t\tfor (int j = 0; j < col; j++) \n\t\t{ \n\t\t\tfloat* sp = src.ptr<float>(i) + j; \n\t\t\tfloat* tp = temp.ptr<float>(0) + j; \n \n\t\t\tfloat sum = *sp; \n\t\t\tfor (int k = 1; k <= r; k++) \n\t\t\t{ \n\t\t\t\tconst float* sp1 = i - k >= 0 ? sp - k*col : src.ptr<float>(0) + j; \n\t\t\t\tconst float* sp2 = i + k < row ? sp + k*col : src.ptr<float>(row - 1) + j; \n\t\t\t\tsum += *sp1; \n\t\t\t\tsum += *sp2; \n\t\t\t} \n\t\t\t*tp = sum; \n\t\t} \n\t\tfor (int j = 0; j < col; j++) \n\t\t{ \n\t\t\tfloat* tp = temp.ptr<float>(0) + j; \n\t\t\tfloat* dp = dest.ptr<float>(i) + j; \n \n\t\t\tfloat sum = *tp; \n\t\t\tfor (int k = 1; k <= r; k++) \n\t\t\t{ \n\t\t\t\tconst float* tp1 = j - k >= 0 ? tp - k : temp.ptr<float>(0); \n\t\t\t\tconst float* tp2 = j + k < col ? tp + k : temp.ptr<float>(0) + (col - 1); \n\t\t\t\tsum += *tp1; \n\t\t\t\tsum += *tp2; \n\t\t\t} \n\t\t\t*dp = sum * div; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "a7fab301d68d4a2ed8ee17039b6c9c7674da8a0750872146db5b560c47a48506"}
{"code": "for (int i = 0; i < m; ++i) { \n    for (int j = rowptr[i]; j < rowptr[i + 1]; ++j) { \n      if (colidx[j] == i) { \n        diagptr[i] = j; \n        diag[i] = values[j]; \n        idiag[i] = 1/values[j]; \n      } \n    } \n  }", "pragma": "parallel for ", "hash": "4f99e829b0db1b43149ee4a41785caa2c6042a091398c93c52b96ffb3025d863"}
{"code": "for (ix=0; ix < nx; ix++) { \n\t    nxt[ix] = 0.0; \n\t     \n \n\t    x =  ix * dx; \n\t    for (ik=0; ik < nk; ik++) { \n\t\t \n \n\t\tk =  ik * dk*2.0*pi; \n\t\ttmpdt = v[ix]*fabs(k)*dt; \n\t\ttmp = x*k +0.5*v[ix]*(vx[ix]*k)*dt*dt; \n\t\ttmpex = sf_cmplx(cosf(tmp),sinf(tmp)); \n\t\tif (ik == 0 || ik == nk-1) nxt[ix] += creal(uk[ik]*tmpex)*cosf(tmpdt); \n\t\telse  nxt[ix] += creal(uk[ik]*tmpex)*cosf(tmpdt)*2.0; \n\t    } \n \n\t    for (ik=0; ik < nk; ik++) { \n\t\t \n \n\t\tk =  ik * dk*2.0*pi; \n\t\ttmpdt = v[ix]*fabs(k)*dt; \n\t\ttmp = x*k +0.5*v[ix]*(vx[ix]*k)*dt*dt; \n\t\ttmpex = sf_cmplx(cosf(tmp),sinf(tmp)); \n                if (ik == 0 || ik == nk-1) nxt[ix] += sf_crealf(sf_crmul(sf_cmul(uk[ik],tmpex),cosf(tmpdt))); \n                else nxt[ix] += sf_crealf(sf_crmul(sf_cmul(uk[ik],tmpex),cosf(tmpdt)*2.0)); \n\t    } \n\t    nxt[ix] /= (nk-1); \n\t    nxt[ix] -= old[ix]; \n\t}", "pragma": "parallel for private(ik ix k tmp tmpdt tmpex x)", "hash": "3b3b4b43cd0cd23eb3042eaaf9e8d65f34acd2c9f0f6cfc3832403e09337ba75"}
{"code": "for ( int k = 0; k < n_out; k++ ) { \n    if ( d_out[k] ) { continue; } \n    float *out_z_k = out_z[k]; \n    float b_k = b[k]; \n    for ( int i = 0; i < nI; i++ ) {  \n      out_z_k[i] = b_k; \n    } \n  }", "pragma": "parallel for ", "hash": "49dfa6ac11ee6836871543bc476e2dd1f853685582848a5950b2cfe6bc1747c7"}
{"code": "for(long i0=t->id;i0<t->n;i0+=mglNumThr)\tb[i0] = x1+dx*((i0/nx)%ny);", "pragma": "parallel for ", "hash": "7c502df4eb1b611147cf891f872e8e2f0e4cd2042b4292ec24e407fba7edc58b"}
{"code": "for (i=0; i < full_off_procNodes; i++) \n       P_marker[i] = 0;", "pragma": "parallel for private(i)", "hash": "851fbc826ab5e3b4eb6f67cb4c2b7ec32465ff35ae3858352a5aee3b2d48f687"}
{"code": "for (int loopIndex = 0; loopIndex < numActive; loopIndex++) { \n            int kPre = activeIndices[loopIndex].index; \n            int kx   = kxPos(kPre, nxPreExtended, nyPreExtended, nf) - preLoc.halo.lt; \n            int ky   = kyPos(kPre, nxPreExtended, nyPreExtended, nf) - preLoc.halo.up; \n            if (kx < 0 or kx >= nx or ky < 0 or ky >= ny) { \n               continue; \n            } \n            int kf    = featureIndex(kPre, nxPreExtended, nyPreExtended, nf); \n            int kPost = kIndex(kx, ky, kf, nx, ny, nf); \n            pvAssert(kPost >= 0 and kPost < numPostRestricted); \n            float a = activeIndices[loopIndex].value; \n            postGSynBuffer[kPost] += mScale * a; \n         }", "pragma": "parallel for ", "hash": "aabbe5681dc0e2e4d44f695e6d595a554fb18164a8c6566c714fe85fa88f3d6d"}
{"code": "for(int32_t i=0; i<N; ++i) \n    { \n      ASSERT(fabs(x.col(i).transpose()*ps.col(z(i)))<1e-6, \n          x.col(i).transpose()*ps.col(z(i))); \n \n      Matrix<T,Dynamic,1>  xNorth_i = northRs[z(i)] * x.col(i);  \n \n      ASSERT(fabs(xNorth_i(D_-1))<1e-6, xNorth_i.transpose()  \n          << \" dot prod of x and p: \"<<x.col(i).transpose()*ps.col(z(i))); \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n      xNorth.col(i) = xNorth_i.topRows(D_-1); \n    }", "pragma": "parallel for ", "hash": "c64c4c228559cb344435545645f2f2e1012dc72e4cd0dc5c5c867d4702427045"}
{"code": "for(int i=0; i<dim; i++) \n        data[i] = M.data[i];", "pragma": "parallel for ", "hash": "d996e73344767630ce3694969dc6bfee1737eb7e76fe67ae60920a9fc6740b55"}
{"code": "for(int i=0; i<num_steps; ++i) { \n        double x = (i+0.5)*w; \n        sum = sum + 4.0/(1.0+x*x); \n    }", "pragma": "parallel for reduction(+:sum) ", "hash": "a0338c8e4d7c7a58b551a390618412c6a5cf26913db3f99ca5b0497ed668ebfe"}
{"code": "for (int i = 0; i < n; i += 4) { \n         \n \n        r.load(raw + i); \n        d.load(darks + i); \n        g.load(gains + i * 4); \n        dot(g, r - d).store(out + i); \n    }", "pragma": "parallel for private(d g r)", "hash": "4bc43aab73c412e0478cb94222a65c7433e8679cd6ce467bb613e3d9dc3c5244"}
{"code": "for (i = 0; i < 10; i++) \n    baz (i);", "pragma": "for ", "hash": "a9155ef100a47a5ab98645154cbd3694a287beba7026ec8cb29944f5e3958a4c"}
{"code": "for (ptrdiff_t i = i_start; i < i_end; ++i) { \n      pred_vtx[i - i_start] = get_pred_from_pred_entry(pred[i]); \n    }", "pragma": "parallel for ", "hash": "f3fe9975999d8b0240318a7be73ef0a0bcf16c62aa26722635cd9dd30acdb49b"}
{"code": "for (i=0; i<r_Size; i++) \n      rp[i] = (tp[i] < min_value) ? min_value : (tp[i] > max_value ? max_value : tp[i]);", "pragma": "parallel for private(i)", "hash": "b082fe44d39712b81f4707eb197ce86a40f5ddc1b46f75fa1a1e9e47602e306d"}
{"code": "for(size_t i=0;i<n;i++) { \n      aux[i] = a[i]; \n    }", "pragma": "for ", "hash": "cd4b5b3cd2069fa72837c3448348392bf219af1e0eb144e0d08f99d36031a1af"}
{"code": "for (size_t j = 0; j < n; j++) { \n          C[j * ldc + j] = beta * crealf(C[j * ldc + j]); \n          for (size_t i = j + 1; i < n; i++) \n            C[j * ldc + i] *= beta; \n        }", "pragma": "parallel for ", "hash": "2ad45255a3540f11c7f3b8ef8ceaa7eae3d9a5b7aa21182892fd44c9a94bb2b2"}
{"code": "for (int i=0; i < N; ++i) \n    orc = orc || rcl[i];", "pragma": "parallel reduction(orc ||:) ", "hash": "ce546965f2349064881a5ae26cf5e90b924591eb3028f1cd9c5b26b603206d22"}
{"code": "for(int j = 0; j < roi_out->height; j++) \n        { \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 0, 1, j, clips, xtrans, 0); \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 0, -1, j, clips, xtrans, 1); \n        }", "pragma": "parallel for ", "hash": "2885c0448b8f6b604ce147ded44138f1787ff76b2d252fd7a109403168c6ca8d"}
{"code": "for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i) \n  { \n    make_rbhv(i); \n  }", "pragma": "parallel for ", "hash": "521957b02ea572017c522be18a8401318dd0eb4f798eabc7b578b64039476ca1"}
{"code": "for (ompIndexType i = 0; i < (ompIndexType)N; i++) { \n            Dp[i + N * i] = eigenvals[i]; \n        }", "pragma": "parallel for ", "hash": "7db428f8b0047742d15c3c0df0bb2e812515432716977a145ccf8c93fca33e90"}
{"code": "for ( i = 0; i < _pm->NX(); i++ ) \n\t\tfor ( j = 0; j < _pm->NY(); j++ ) \n\t\t\tfor ( k = 0; k < _pm->NZ(); k++ ) \n\t\t\t\tif ( _pm->data3D[i][j][k] == 1 ) { \n\t\t\t\t\tporosidade++; \n\t\t\t\t}", "pragma": "parallel for reduction(+:porosidade) private(i j k)", "hash": "df4bad9e7c2ec203551b3e68d70914e109482b1ef6902e145dcef1a58ee05253"}
{"code": "for (int i = 0; i < myParams.genomeSize; i++) \n  { \n    if (randBank[(randOffset + i) % randBankSize] < myParams.mutRate) \n    { \n      a.genome[i] = 0.0; \n    } \n  }", "pragma": "parallel for ", "hash": "58ae0f35493cc6431be8d87b655ddb89db32276da0a0a03d5bdbe7d68994535d"}
{"code": "for (int j = 0; j < n; ++j) { \n        for (int i = 0; i < n; ++i) { \n            int lij = lnew[j*n+i]; \n            for (int k = 0; k < n; ++k) { \n                int lik = l[k*n+i]; \n                int lkj = l[j*n+k]; \n                if (lik + lkj < lij) { \n                    lij = lik+lkj; \n                    done = 0; \n                } \n            } \n            lnew[j*n+i] = lij; \n        } \n    }", "pragma": "parallel for reduction(&& : done) ", "hash": "2c685694fd5e64c33cda6e7f4080dea39644dcef8745740a2c3e3321863e9d39"}
{"code": "for (j = i+1; j < numReads; ++j)\r \n\t\t{\t\t\r \n\t\t\tsum = 0;\r \n\t\t\tfor (k = 0; k < numSeeds; ++k) {\r \n\t\t\t\tdiff = eReads[i][k]-eReads[j][k];\r \n\t\t\t\tsum += diff * diff;\r \n\t\t\t\t\r \n\t\t\t}\r \n\t\t\tdist = sqrt(sum/numSeeds);\r \n\r \n   #pragma omp critical   \r \n\t\t\tif (dist < threshold || fabs(dist-threshold) < EPSILON)\r \n\t\t\t{\r \n\t\t\t\th_pairVector[count] = thrust::make_pair(i,j);\r \n\t\t\t\th_distVector[count] = dist;\r \n\t\t\t\t++count;\r \n\t\t\t}\t\t\t\r \n\t\t}", "pragma": "for private(    diff dist j k sum)", "hash": "3a38b12a63892b4e800ef4c02190459efb14d4dade7ce9211423c4d9496fc9cc"}
{"code": "for(unsigned int idx = 0; idx < out.size(); ++idx) \n            out[idx] += c*a.cross(b[idx]);", "pragma": "parallel for ", "hash": "8a1099ee40bab30da64c7f6c0ac5af9b60ca9946a170a6de1f9aae1b69727ef8"}
{"code": "for (j =  i; j < nclusters; ++j) { \n \n    \t\tif (THTensor_(get2d)(NNs, i, j) == 0 && THTensor_(get2d)(NNs, j, i) == 0) { \n    \t\t\tTHTensor_(set2d)(A_us, j, i, 0); \n    \t\t\tTHTensor_(set2d)(A_us, i, j, 0); \n    \t\t\tTHTensor_(set2d)(A_s, j, i, 0); \n    \t\t\tTHTensor_(set2d)(A_s, i, j, 0); \n    \t\t\tcontinue; \n    \t\t} \n \n    \t\tif (i == j) { \n    \t\t\tTHTensor_(set2d)(A_us, j, i, 0); \n    \t\t\tTHTensor_(set2d)(A_s, j, i, 0); \n    \t\t\tcontinue; \n    \t\t} \n \n             \n \n            int Y_i_size, Y_j_size; \n            Y_i_size = 0; \n            Y_j_size = 0; \n\t\t\tfor (m = 0; m < Y->size[1]; ++m) { \n\t\t\t\tif (THTensor_(get2d)(Y, i, m) != 0) {  \n \n\t\t\t\t\t++Y_i_size; \n\t\t\t\t} \n\t\t\t\tif (THTensor_(get2d)(Y, j, m) != 0) {  \n \n\t\t\t\t\t++Y_j_size; \n\t\t\t\t} \n\t\t\t} \n \n    \t\t \n \n\t\t\tA_c_i_j = 0; \n\t\t\t \n \n\t\t\tfor (m = 0; m < Y_i_size; ++m) { \n\t\t\t\ts_W_c_j_i = 0; \n\t\t\t\ts_W_c_i_j = 0; \n\t\t\t\tfor (n = 0; n < Y_j_size; ++n) { \n\t\t\t\t\t \n \n\t\t\t\t\ts_W_c_j_i += THTensor_(get2d)(W, THTensor_(get2d)(Y, j, n) - 1, THTensor_(get2d)(Y, i, m) - 1); \n\t\t\t\t\ts_W_c_i_j += THTensor_(get2d)(W, THTensor_(get2d)(Y, i, m) - 1, THTensor_(get2d)(Y, j, n) - 1); \n\t\t\t\t\t \n \n\t\t\t\t} \n\t\t\t\tA_c_i_j += s_W_c_j_i * s_W_c_i_j; \n\t\t\t} \n \n\t\t\t \n \n\t\t\tA_c_j_i = 0; \n\t\t\t \n \n\t\t\tfor (m = 0; m < Y_j_size; ++m) { \n\t\t\t\ts_W_c_j_i = 0; \n\t\t\t\ts_W_c_i_j = 0; \n\t\t\t\tfor (n = 0; n < Y_i_size; ++n) { \n\t\t\t\t\t \n \n\t\t\t\t\ts_W_c_j_i += THTensor_(get2d)(W, THTensor_(get2d)(Y, j, m) - 1, THTensor_(get2d)(Y, i, n) - 1); \n\t\t\t\t\ts_W_c_i_j += THTensor_(get2d)(W, THTensor_(get2d)(Y, i, n) - 1, THTensor_(get2d)(Y, j, m) - 1); \n\t\t\t\t\t \n \n\t\t\t\t} \n\t\t\t\tA_c_j_i += s_W_c_i_j * s_W_c_j_i; \n\t\t\t} \n \n\t\t\tTHTensor_(set2d)(A_us, j, i, A_c_i_j); \n\t\t\tTHTensor_(set2d)(A_us, i, j, A_c_j_i); \n\t\t\tTHTensor_(set2d)(A_s, i, j, A_c_i_j / (Y_j_size * Y_j_size)  + A_c_j_i / (Y_i_size * Y_i_size)); \n\t\t\tTHTensor_(set2d)(A_s, j, i, 0); \n    \t}", "pragma": "parallel for private(      a_c_i_j a_c_j_i j m n s_w_c_i_j s_w_c_j_i)", "hash": "e83509f3358df32a6f5a9601b47bb0d18c44887a1466efece15874717058c533"}
{"code": "for (p = 0; p < nbatch; p++) \n    { \n      THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)(gradInput_data+p*nslices*iwidth*iheight, gradOutput_data+p*nslices*owidth*oheight, \n                                                           nslices, \n                                                           iwidth, iheight, \n                                                           owidth, oheight); \n    }", "pragma": "parallel for private(p)", "hash": "a7b3112a93e4fa65a5c9ad33a95d1a8ae7c2d880be30763903699b0deb8e150a"}
{"code": "for (int i = 0; i <= NVAR-1; i++) \n\t{ \n\t\tdTc_dQ[i]\t= Tc * (a_T_tra*dT_tra_dQ[i] + b_T_rot*dT_rot_dQ[i] + c_T_vib*dT_vib_dQ[i] + d_T_e*dT_e_dQ[i]); \n\t}", "pragma": "parallel for ", "hash": "5fa4c21fc704c32b27b5445084d8d5c7d8d140e0973d198b46caf3bf20dcd233"}
{"code": "for (int i = 0; i < nlocal; i++) { \n    const int ibody = body[i]; \n    if (ibody < 0) continue; \n \n    const dbl3_t &xcmi = * ((dbl3_t *) xcm[ibody]); \n    const dbl3_t &vcmi = * ((dbl3_t *) vcm[ibody]); \n    const dbl3_t &omegai = * ((dbl3_t *) omega[ibody]); \n \n    const int xbox = (xcmimage[i] & IMGMASK) - IMGMAX; \n    const int ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX; \n    const int zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX; \n    const double deltax = xbox*xprd + (TRICLINIC ? ybox*xy + zbox*xz : 0.0); \n    const double deltay = ybox*yprd + (TRICLINIC ? zbox*yz : 0.0); \n    const double deltaz = zbox*zprd; \n \n     \n \n    double x0,x1,x2,vx,vy,vz; \n    if (EVFLAG) { \n      x0 = x[i].x + deltax; \n      x1 = x[i].y + deltay; \n      x2 = x[i].z + deltaz; \n      vx = v[i].x; \n      vy = v[i].y; \n      vz = v[i].z; \n    } \n \n     \n \n     \n \n \n    MathExtra::matvec(ex_space[ibody],ey_space[ibody], \n                      ez_space[ibody],displace[i],&x[i].x); \n \n    v[i].x = omegai.y*x[i].z - omegai.z*x[i].y + vcmi.x; \n    v[i].y = omegai.z*x[i].x - omegai.x*x[i].z + vcmi.y; \n    v[i].z = omegai.x*x[i].y - omegai.y*x[i].x + vcmi.z; \n \n     \n \n     \n \n     \n \n \n    x[i].x += xcmi.x - deltax; \n    x[i].y += xcmi.y - deltay; \n    x[i].z += xcmi.z - deltaz; \n \n     \n \n     \n \n     \n \n     \n \n     \n \n \n    if (EVFLAG) { \n      double massone,vr[6]; \n \n      if (rmass) massone = rmass[i]; \n      else massone = mass[type[i]]; \n \n      const double fc0 = 0.5*(massone*(v[i].x - vx)/dtf - f[i].x); \n      const double fc1 = 0.5*(massone*(v[i].y - vy)/dtf - f[i].y); \n      const double fc2 = 0.5*(massone*(v[i].z - vz)/dtf - f[i].z); \n \n      vr[0] = x0*fc0; vr[1] = x1*fc1; vr[2] = x2*fc2; \n      vr[3] = x0*fc1; vr[4] = x0*fc2; vr[5] = x1*fc2; \n \n       \n \n       \n \n      if (vflag_global) { \n        v0 += vr[0]; \n        v1 += vr[1]; \n        v2 += vr[2]; \n        v3 += vr[3]; \n        v4 += vr[4]; \n        v5 += vr[5]; \n      } \n \n       \n \n      if (vflag_atom) { \n        vatom[i][0] += vr[0]; \n        vatom[i][1] += vr[1]; \n        vatom[i][2] += vr[2]; \n        vatom[i][3] += vr[3]; \n        vatom[i][4] += vr[4]; \n        vatom[i][5] += vr[5]; \n      } \n    } \n  }", "pragma": "parallel for reduction(+:v0 v1 v2 v3 v4 v5) ", "hash": "ffde1c65fa7f3fe021c7e9bea21ed29e6042645d4f5dd153304a1ffe6595bf3b"}
{"code": "for (int i = 0; i < n; i++) { \n \n       \n \n      float const x = a + dx*(float(i) + 0.5f); \n \n       \n \n      float const f = 1.0f/sqrtf(x); \n     \n       \n \n      I_partial += f; \n \n    }", "pragma": "for ", "hash": "14526e68c1432ea60b93935d9e625bc5df67c0b57bbf6841f52de7e5cc0db075"}
{"code": "for (i=0; i <= (ssize_t) MaxMap; i++) \n  { \n    GetMagickPixelPacket(clut_image,clut_map+i); \n    (void) InterpolateMagickPixelPacket(clut_image,clut_view, \n      UndefinedInterpolatePixel,QuantumScale*i*(clut_image->columns-adjust), \n      QuantumScale*i*(clut_image->rows-adjust),clut_map+i,exception); \n  }", "pragma": "parallel for ", "hash": "f687a5520f6be8cef9e37d83c6184077040b272f38926cbf15d1e6dee51cb328"}
{"code": "for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 1; i <= grid_points[0]-2; i++) { \n        for (m = 0; m < 5; m++) { \n          forcing[k][j][i][m] = -1.0 * forcing[k][j][i][m]; \n        } \n      } \n    } \n  }", "pragma": "for ", "hash": "66fdb6c8456347f9e2b9b97e35158d76aa3657dd05a5a782be55a3663e11d6b5"}
{"code": "for (int i = 0; i < static_cast<int>(views.size()); ++i) \n    { \n      ++my_progress_bar; \n      auto view_it = views.begin(); \n      std::advance(view_it, i); \n      const View * view = view_it->second.get(); \n      if (!sfm_data.IsPoseAndIntrinsicDefined(view)) \n        continue; \n \n      Intrinsics::const_iterator iterIntrinsic = sfm_data.GetIntrinsics().find(view->id_intrinsic); \n \n       \n \n      const std::string srcImage = stlplus::create_filespec(sfm_data.s_root_path, view->s_Img_path); \n      std::ostringstream os; \n      os << std::setw(8) << std::setfill('0') << map_viewIdToContiguous[view->id_view]; \n      const std::string dstImage = stlplus::create_filespec( \n        stlplus::folder_append_separator(sOutDirectory) + \"visualize\", os.str(),\"jpg\"); \n \n      const IntrinsicBase * cam = iterIntrinsic->second.get(); \n      if (cam->have_disto()) \n      { \n         \n \n        ReadImage( srcImage.c_str(), &image); \n        UndistortImage(image, cam, image_ud, BLACK); \n        WriteImage(dstImage.c_str(), image_ud); \n      } \n      else  \n \n      { \n         \n \n        if (stlplus::extension_part(srcImage) == \"JPG\" || \n          stlplus::extension_part(srcImage) == \"jpg\") \n        { \n          stlplus::file_copy(srcImage, dstImage); \n        } \n        else \n        { \n          ReadImage( srcImage.c_str(), &image); \n          WriteImage( dstImage.c_str(), image); \n        } \n      } \n    }", "pragma": "parallel for private( image image_ud)", "hash": "e0344f8275156357bf3f8bd304832288d85f2f08400c43433da01a5efb713364"}
{"code": "for (int jj = 0; jj < nn; jj++) { \n      int ii = ilist[jj]; \n      if (atom->mask[ii] & groupbit) { \n        int indxI = 2 * ii; \n \n        d[indxI] = p[indxI] + beta_s * d[indxI]; \n        d[indxI+1] = p[indxI+1] + beta_t * d[indxI+1]; \n      } \n    }", "pragma": "for ", "hash": "2617ac9a038f2fd3858d267586769e80ab74db48271b11fc236a6b7a2c4fb20c"}
{"code": "for (size_t j = 0; j < sizeP; j++) { \n        m_vectors[sizeQ + j] = partP.m_vectors[j]; \n        m_vectors[sizeQ + j].SetFormat(Format::EVALUATION); \n    }", "pragma": "parallel for ", "hash": "c53706ba195737e9f57d6452e641cd1edc18fd86e1d47db1082e41b86d6c9da7"}
{"code": "for(long i=0; i<size; i++){ \n\t\t\tconst Body::id_t& id=ids[i]; \n\t\t#else \n\t\tFOREACH(Body::id_t id,ids){ \n\t\t#endif \n\t\t\tassert(id<(Body::id_t)scene->bodies->size()); \n\t\t\tBody* b=Body::byId(id,scene).get(); \n\t\t\tif(!b) continue; \n\t\t\tb->state->vel+=velocity*translationAxis; \n\t\t}", "pragma": "parallel for ", "hash": "da17922f9698c97f4a175054864b57ad76c3f3df868d955607d3c3e6fafa7244"}
{"code": "for (int j = 0; j < Y; j++) { \n        for (int k = 0; k < KSIZE; k++) { \n            for (int i = 0; i < X; i++) { \n                w_n[(k*Y*X)+(j*X)+i] = 0.5*w[(k*Y*X)+(j*X)+i]+0.5*w_n[(k*Y*X)+(j*X)+i]+0.5*dt*K[(k*Y*X)+(j*X)+i]; \n                w[(k*Y*X)+(j*X)+i] = w_n[(k*Y*X)+(j*X)+i]; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "8af0a4d73bdca592b774610345b3c46e0720340478e12e65a6f6d4ba654986a5"}
{"code": "for (int task_id = 0; task_id < num_copy_tasks; ++task_id) { \n    OMP_LOOP_EX_BEGIN(); \n    int group = group_ids[task_id]; \n    int subfeature = subfeature_ids[task_id]; \n    feature_groups_[group]->CopySubrowByCol(fullset->feature_groups_[group].get(), \n                                            used_indices, num_used_indices, subfeature); \n    OMP_LOOP_EX_END(); \n  }", "pragma": "parallel for ", "hash": "cfcc7a09268e0f45816d11def8340162d524bf580e2498938e01781d6680525e"}
{"code": "for (unsigned int i = 0; i < nodes.size(); i++){ \n\t\tvisited[i] = 0; \n\t}", "pragma": "parallel for ", "hash": "43c2c31b6826e491950d352af568bd5da5d8eac9544ed87da0a5dbe9d3680a1c"}
{"code": "for (int y = 0; y < image->ny; ++y) { \n        for (int x = 0; x < image->nx; ++x) { \n            for (int k = 0; k < kernel->adjacencyRelation->n; ++k) { \n                int coordenateX = x + kernel->adjacencyRelation->dx[k]; \n                int coordenateY = y + kernel->adjacencyRelation->dy[k]; \n                if(isValidPixelCoordinate(image,coordenateX,coordenateY)){ \n                    for (int c = 0; c < image->nchannels; ++c) { \n                        imageValCh(outputImage,x,y,c) += imageValCh(image,coordenateX,coordenateY,c)*kernel->weight[k]; \n                        if(saturateValue){ \n                            if(imageValCh(outputImage,x,y,c)>outputImage->scalingFactor){ \n                                imageValCh(outputImage,x,y,c) = outputImage->scalingFactor; \n                            } \n                            if(imageValCh(outputImage,x,y,c)<0){ \n                                imageValCh(outputImage,x,y,c) = 0; \n                            } \n                        } \n                    } \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "cbe420769075cc233f9d0a048235f132f44eb4603c9e5de3e82c66e6db785b71"}
{"code": "for (size_t y = 0; y < height; y++) \n    { \n      for (size_t x = 0; x < width; x++) \n      { \n          const float *in_pixel = &in_data[(size_t)4 * ((y * width) + x)]; \n          uint8_t *out_pixel = (uint8_t *)&out[(y * rowbytes) + (3 * sizeof(uint8_t) * x)]; \n \n          out_pixel[0] = (uint8_t)CLAMP(in_pixel[0] * max_channel_f, 0, max_channel_f); \n          out_pixel[1] = (uint8_t)CLAMP(in_pixel[1] * max_channel_f, 0, max_channel_f); \n          out_pixel[2] = (uint8_t)CLAMP(in_pixel[2] * max_channel_f, 0, max_channel_f); \n      } \n    }", "pragma": "parallel for simd ", "hash": "23c8cf5cf946c6880af665bdd1498a1cee2defb4c2744e18992dc449f02a472e"}
{"code": "for (int gene = 0; gene < numGenes; gene++) { \n        int  p_curr, qq, qq_curr, k; \n        double gamMa_snpCurr, gamMa_probsnpCurr, tempd; \n        double ccCurr = cc(gene), sigma2Curr = sigma2(gene); \n        uvec  maskCurr =  mask(gene); \n        bool update_bf=true; \n \n         \n \n        p_curr = maskCurr.size(); \n        if(p_curr > 0){ \n            int topp, bottomm; \n            uvec sort_inx; \n             \n \n            ransampl_ws* ws = ransampl_alloc( p_curr ); \n            vec sample_prob(p_curr); \n            double ret; \n            uvec bootstrapS(p_curr); \n            vec a1, a2; \n             \n \n            bootstrapS = linspace<uvec>(0, p_curr-1, p_curr); \n            double epiDiscount = 0; \n            uvec nonzero, zero, nonzero_curr; \n            vec  bfCurr(p_curr), gamMa_rate, randDraw; \n            double bf_snpCurr, prob_proposal, proposal_ratio, accept; \n            int accept_count = 0, proposal_count =0; \n            vec mm, WW; \n            mat TT1, TT_inv,VV, TT_proposal, TT_curr = TT(gene);  \n \n            int gene_start = gene1_start(gene), gene_end = gene1_end(gene); \n            colvec xbeTa(n), xbeTaM(n), residue(n); \n             \n \n            mat xCurr, xCurr_nonzero, xTxCurr; \n            xCurr = x.cols(maskCurr); \n            vec xTx_snp_gene; \n     \n \n            vec xTxdiag = x2(span(gene1_start(gene), gene1_end(gene))); \n            vec  gamMaCurr = gamMa(span(gene_start, gene_end)); vec gamMa_inclusion = zeros(p_curr); \n            vec logit_freqCurr = zeros(p_curr); \n            vec gamMaChange(p_curr); gamMaChange = gamMaCurr; \n             \n \n            vec  beTaCurr(p_curr), geneEpiCurr(4); \n             \n \n            vec featureMeanCurr = featureMean.col(gene); \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n \n \n            double gg1, gg0, gg_proposal, R2, gg_curr = gg(gene); \n             \n \n            k = gamMaCurr.size(); zero = find(gamMaCurr==0); nonzero = find(gamMaCurr > 0); qq  = nonzero.size(); \n             \n \n            gamMa_rate = gamMa_rateAll(span(gene_start, gene_end)); \n             \n \n            nonzero_curr = nonzero; \n             \n \n            vec gamMa_probCurr(p_curr); \n            gamMa_probCurr= gamMa_prob(span(gene_start, gene_end)); \n            vec aTfCurr = aTf(span(gene_start, gene_end)); \n             \n \n             \n \n             \n \n            double aTfbin; \n             \n \n \n             \n \n \n            if( qq > 0) { \n            WW = solve(trimatl(TT_curr.t()), xTy(maskCurr(nonzero))); \n            R2 = sum(square(WW))/y2(gene); \n            gg_curr = (n - qq -1.0)/2.0 * log(1 + ccCurr) - (n -1.0 )/2.0 * log(1.0+ccCurr*(1.0-R2)); \n            }else gg_curr = 0; \n             \n \n            for (int localiter = 0; localiter < localmaxiter; localiter++) { \n            if((useGibbs) ||  ((iter ==0) && (gamMa_initialized ==0) )){ \n                for(int snp = 0;  snp < p_curr; snp++){ \n                 \n \n                if(gamMaCurr(snp) ==1){ \n                    qq_curr = qq-1; \n                     \n \n                    gamMaChange(snp) = 0; \n                    if(qq_curr > 0 ){ \n                    nonzero_curr= nonzero(span(1, qq_curr));   \n \n                    nonzero(qq-1) = nonzero(0); nonzero(span(0, qq-2)) = nonzero_curr; \n                     \n \n                     xCurr_nonzero = xCurr.cols(nonzero); \n     \n \n                     xTxCurr = xCurr_nonzero.t() * xCurr_nonzero + small * eye(qq_curr, qq_curr); \n                     TT_curr = cholGivensRotateLeft(TT_curr, xTxCurr); \n                      \n \n                     \n \n                     \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n \n \n                    gg1 = gg_curr; \n                    WW = solve(trimatl(TT_curr(span(0,qq_curr-1), span(0, qq_curr-1) ).t()), xTy(maskCurr(nonzero_curr))); \n                     \n \n                    R2 = sum(square(WW))/y2(gene); \n                    gg0 = (n - qq_curr -1.0)/2.0 * log(1 + ccCurr) - (n -1.0 )/2.0 * log(1.0+ccCurr*(1.0-R2)); \n                     \n \n                    }else{ \n                     \n \n                    nonzero_curr.clear(); \n                     \n \n                    gg0 = 0; \n                     \n \n                     \n \n                    } \n                }else{ \n                     \n \n                     \n \n                    gamMaChange(snp) = 1; \n                    qq_curr = qq+1; \n                    gg0 = gg_curr; \n                     \n \n                    nonzero_curr = nonzero; \n                    nonzero_curr.resize(qq_curr); nonzero_curr(qq_curr-1) = snp; \n \n                     \n \n                    if(qq >  0){ \n                     xCurr_nonzero = xCurr.cols(nonzero_curr); \n     \n \n                     xTxCurr = xCurr_nonzero.t() * xCurr_nonzero + small * eye(qq_curr, qq_curr); \n     \n \n                     xTx_snp_gene = xCurr_nonzero.t() * xCurr.col(snp); \n                     xTx_snp_gene(qq_curr -1) = xTx_snp_gene(qq_curr -1) + small; \n     \n \n                      \n \n                    TT1 = cholAddCol(TT_curr, xTx_snp_gene, xTxCurr); \n \n     \n \n    \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n                    } else{ \n                    TT1.set_size(1,1); \n                     \n \n                    tempd = sqrt(xTxdiag(snp));  \n \n                     \n \n                    TT1(0,0) = (tempd > 0) ? tempd : (-1*tempd); \n                    } \n \n                     \n \n                    WW =  solve(trimatl(TT1.t()), xTy(maskCurr(nonzero_curr)));  \n \n                    R2 = sum(square(WW))/y2(gene); \n                    gg1 = (n - qq_curr -1.0)/2.0 * log(1 + ccCurr) - (n -1.0 )/2.0 * log(1.0+ccCurr*(1.0-R2)); \n                     \n \n                     \n \n                } \n                 \n \n                 \n \n                 \n \n \n     \n \n                aTfbin = logistic(aTfCurr(snp)); \n                randDraw = randu(3); \n                 \n \n                 \n \n                gamMa_probsnpCurr = logistic(aTfCurr(snp)); \n \n                bfCurr(snp) =  logistic(gg1  - gg0  + logit(.05)); \n                 \n \n                 \n \n                 \n \n                double pa1x; \n                pa1x = (iter==0)?  a10: a11 * gamMa_probsnpCurr + a10 * (1 - gamMa_probsnpCurr); \n                 \n \n                gamMa_rate(snp) = logistic(gg1 - gg0 +   logit(pa1x)); \n                double max_rate = .99*aTfbin + .8*(1-aTfbin); \n                 \n \n \n     \n \n                 \n \n                gamMa_snpCurr = 0; \n                 \n \n                if(dual_filter){ \n                    if ((gamMa_rate(snp) >= randDraw(1)) && (aTfbin > randDraw(2)) ) gamMa_snpCurr = 1; \n                }else{ \n                     \n \n                    if((gamMa_rate(snp) * max_rate) >= randDraw(1)  ) gamMa_snpCurr = 1; \n                } \n                double pax1 =  gamMa_snpCurr* log(a11/a10)  + (1-gamMa_snpCurr ) * log( (1 - a11)/(1 - a10)) ; \n                 \n \n                 \n \n                double temp1 = - theta_bias + pax1 + aTfCurr(snp);  \n \n                 \n \n                 \n \n                gamMa_probCurr(snp) = (iter == 0)? gamMa_snpCurr : temp1; \n                 \n \n                 \n \n                     \n \n                     \n \n                 \n \n \n \n \n                 \n \n                 \n \n \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n \n                 \n \n \n                 \n \n \n                 \n \n                 \n \n                 \n \n                if(gamMa_snpCurr != gamMaCurr(snp) ) { \n                    gamMaCurr(snp)   = gamMa_snpCurr; \n                    if(gamMa_snpCurr==1){ \n                    nonzero = nonzero_curr; \n                    gg_curr = gg1; \n                    qq = qq_curr; \n                    TT_curr = TT1; \n                    }else{ \n                    nonzero = nonzero_curr; \n                    gg_curr = gg0; \n                    qq = qq_curr; \n                    if(qq_curr >0){ \n                        TT_curr = TT_curr(span(0,qq-1), span(0,qq-1)); \n                    }else TT_curr = zeros<mat>(1,1); \n                    } \n                }else gamMaChange(snp)   = gamMa_snpCurr; \n                } \n                if(use_raoblackwell) gamMa_inclusion = gamMa_inclusion + gamMa_rate; \n                else gamMa_inclusion = gamMa_inclusion + gamMaCurr; \n            }else{ \n                int qqLD, qqLD_proposal, qq_proposal, qqLDLD, qqLDLD_proposal; \n                uvec nonzero_proposal, maxinx, mininx; \n                field<uvec> LDgene = LD(gene); \n                int ldcnt = LDgene.size(); \n                uvec LDCurr, snps_inx; \n                vec aTf_bin = logistic(aTfCurr); \n                 \n \n                vec pa1x_vec =   exp(log(a11) * aTf_bin + log(a10) * (1 - aTf_bin)); \n                vec pa1x_vecneg = 1 - pa1x_vec; \n                vec bf_singleCurr = bf_single(span(gene_start, gene_end)); \n                if(update_bf){ \n                vec xTy_gene = xTy(span(gene_start, gene_end)); \n                vec bf_temp; \n                for(int ldinx = 0;  ldinx < ldcnt; ldinx++){ \n                    snps_inx = LDgene(ldinx); \n                    xCurr_nonzero = xCurr.cols(snps_inx);  \n \n                     \n \n                     \n \n                    bf_temp =  (n - 2.0)/2.0 * log(1.0 + ccCurr) - (n -1.0 )/2.0 * log(1+ccCurr*(1.0- (square(xTy_gene(snps_inx))/(xTxdiag(snps_inx) * y2(gene))) )); \n                    maxinx = find(bf_temp > bf_max); \n                    if(maxinx.size() >0) \n                    bf_temp(maxinx) = ones<vec>(maxinx.size()) * bf_max; \n                    mininx = find(bf_temp < bf_min); \n                    if(mininx.size() >0) \n                    bf_temp(mininx) = ones<vec>(mininx.size()) * bf_thres; \n                    bf_temp = exp(bf_temp); \n                    bf_singleCurr(snps_inx) = bf_temp; \n                } \n                 bf_single(span(gene_start, gene_end)) = bf_singleCurr; \n                 \n \n                } \n                 \n \n                 \n \n                vec proposal_gamMa = bf_singleCurr % pa1x_vec; \n                vec proposal_gamMaCurr; \n                vec bf_LDgene = bf_LD(gene); \n                 \n \n                vec Randu = randu<vec>(p_curr);  \n \n                double prior_proposal, prior_curr, trans_proposal, trans_curr, prior_changeNotLD, trans_changeNotLD, pa1x_neg, pa1xNotLD_neg; \n                 \n \n                bfCurr = bf_singleCurr; \n                uvec LDLDInx, nonzeroNotLD, nonzeroNotLD_proposal, zeroNotLD_proposal; \n                uvec LDLD, zeroLDLDInx; \n                vec proposal_gamMaNotLD; \n                 \n \n                 \n \n                 \n \n                for(int ldinx = 0;  ldinx < ldcnt; ldinx++){ \n                 \n \n                 \n \n                snps_inx = LDgene(ldinx); \n                 \n \n                 \n \n                proposal_gamMaCurr = proposal_gamMa(snps_inx); \n                pa1x_neg = prod(pa1x_vecneg(snps_inx)); \n                pa1xNotLD_neg = 1; \n                double proposal_gamMaSum = sum(proposal_gamMaCurr); \n                 \n \n                 \n \n                uvec nonzeroLDInx =find( gamMaCurr(snps_inx) > 0.5); \n                uvec nonzeroLD = snps_inx(nonzeroLDInx); \n                uvec zeroLDInx =find( gamMaCurr(snps_inx) <= 0.5); \n                uvec zeroLD = snps_inx(zeroLDInx); \n \n                 \n \n                 \n \n                accept = 0; qqLD = nonzeroLD.size();  \n \n                 \n \n \n                 \n \n                 \n \n                int notqqLDLD = 0, cholEstimate =0; \n \n                 \n \n                 \n \n                if((qq > 0) && (qq > qqLD) && (qqLD > 0 )){  \n \n                    for (int rot = 0; rot < qqLD; rot++) TT_curr = cholGivensRotateLeft(TT_curr); \n                    nonzero_curr.set_size(qq); \n                    nonzero_curr(span(0,qq - qqLD - 1)) = nonzero(span( qqLD  , qq  -1 )); \n                     \n \n                    nonzero_curr(span(qq - qqLD , qq -1 )) = nonzero(span( 0  , qqLD  -1 )); \n                     \n \n                    nonzero = nonzero_curr;  \n \n \n                    nonzeroNotLD = nonzero(span(0,qq - qqLD - 1)); \n                }else{ \n                    nonzeroNotLD = nonzero; \n                } \n \n                int qqNotLD = qq - qqLD;  \n \n                if(  qqNotLD > 0){ \n                     \n \n     \n \n                    xTxCurr = xCurr.cols(nonzeroNotLD).t() * xCurr.cols(snps_inx); \n                     \n \n     \n \n                    umat xTxTemp = ( abs(xTxCurr) >= (LDthres ) ); \n                     \n \n                    uvec LDLDInx = find(sum(xTxTemp, 1) > 0); \n                    LDLD = nonzeroNotLD( LDLDInx); \n                     \n \n                     \n \n \n                    qqLDLD = LDLD.size(); \n                    if(  qqLDLD > 0){ \n                     \n \n                    vec RanduTemp = randu<vec>(LDLD.size());  \n \n                     \n \n                    pa1xNotLD_neg = prod(pa1x_vecneg(LDLD)); \n                    proposal_gamMaSum = proposal_gamMaSum + sum(proposal_gamMa(LDLD) ); \n                    proposal_gamMaNotLD = ( proposal_gamMa(LDLD))/( proposal_gamMaSum + (pa1xNotLD_neg * pa1x_neg)); \n                        zeroLDLDInx = find((proposal_gamMaNotLD - RanduTemp) < 0); \n \n                    cout << \"zeroLDLDInx \" << zeroLDLDInx << endl; \n                    zeroNotLD_proposal = LDLD(zeroLDLDInx);   \n \n                    cout << \"pa1xNotLD_neg \" <<pa1xNotLD_neg << \" proposal_gamMaNotLD \" << proposal_gamMaNotLD  << \"sum\"<<   ( proposal_gamMaSum + (pa1xNotLD_neg * pa1x_neg)) << \"zeroNotLD_proposal\" << zeroNotLD_proposal <<  endl; \n                    notqqLDLD = zeroNotLD_proposal.size();  \n \n                    if(notqqLDLD > 0){ \n                        uvec nonzeroNotLD_proposalInx = ones<uvec>(qqNotLD); \n                         \n \n                        nonzeroNotLD_proposalInx(LDLDInx(zeroLDLDInx)) = zeros<uvec>(notqqLDLD); \n                         \n \n                        nonzeroNotLD_proposal = nonzeroNotLD(find( nonzeroNotLD_proposalInx)); \n                         \n \n                        cholEstimate  = 1; \n                        accept = 0; \n                    } \n                    } \n                } \n                proposal_gamMaCurr = proposal_gamMaCurr /( proposal_gamMaSum +  (pa1xNotLD_neg * pa1x_neg)); \n                uvec nonzeroLD_proposalInx = find((proposal_gamMaCurr - Randu(snps_inx)) >= 0); \n                uvec nonzeroLD_proposal = snps_inx(nonzeroLD_proposalInx);  \n \n                uvec zeroLD_proposalInx = find((proposal_gamMaCurr - Randu(snps_inx)) < 0); \n                uvec zeroLD_proposal = snps_inx(zeroLD_proposalInx);  \n \n                qqLD_proposal = nonzeroLD_proposal.size(); \n                cout << gene << \" snps \"<< snps_inx.t() << \" LD \" <<  nonzeroLD.t() << \" proposal \" << nonzeroLD_proposal.t() << \" trans_curr \" << proposal_gamMaCurr.t() << \" pa1x \" << pa1x_vec(snps_inx).t() << \"bf_single \" << bf_singleCurr(snps_inx).t()   << endl; \n                 \n \n                 \n \n                 \n \n                     \n \n                     \n \n                     \n \n                     \n \n                 \n \n                if(cholEstimate ==0){ \n                    if(qqLD == qqLD_proposal ){ \n                    if( sum(nonzeroLD_proposal == nonzeroLD) == qqLD) accept = 1; \n                     \n \n                    } \n                } \n                 \n \n                if(accept !=1){ \n                    if(cholEstimate==1){ \n                         \n \n                     \n \n                     \n \n                    qq_proposal = qq - qqLD - notqqLDLD; \n                    qq_proposal = qq_proposal + qqLD_proposal; \n                     \n \n                    if(qq_proposal > 0){ \n                        nonzero_proposal = join_cols( nonzeroNotLD_proposal,  nonzeroLD_proposal); \n                         \n \n                     \n \n                         \n \n                        xCurr_nonzero = xCurr.cols(nonzero_proposal); \n     \n \n                        xTxCurr = xCurr_nonzero.t() * xCurr_nonzero + small * eye(qq_proposal, qq_proposal); \n                         \n \n                        TT_proposal = chol(xTxCurr); \n                    }else{ \n                        nonzero_proposal.clear(); \n                        TT_proposal.set_size(1,1); TT_proposal.zeros(); \n                    } \n                    prior_changeNotLD =  prod(1- pa1x_vec( zeroNotLD_proposal))/prod( pa1x_vec( zeroNotLD_proposal)); \n                    trans_changeNotLD  = prod( 1- proposal_gamMaNotLD(zeroLDLDInx)) / prod(  proposal_gamMaNotLD(zeroLDLDInx)); \n \n                    }else{ \n                     \n \n                    prior_changeNotLD = 1; trans_changeNotLD = 1; \n \n                    qq_proposal = qq - qqLD; \n                    if (qq_proposal > 0){ \n                        TT_proposal = TT_curr(span(0,qq_proposal -1), span(0, qq_proposal -1) ); \n                         \n \n                    }else{ \n                        TT_proposal.set_size(1,1); TT_proposal.zeros(); \n                         \n \n                         \n \n                    } \n                     \n \n                    qq_proposal = qq_proposal + qqLD_proposal; \n                    nonzero_proposal =  nonzero; \n                     \n \n                    nonzero_proposal.resize(qq_proposal); \n                     \n \n                    if(qqLD_proposal > 0){ \n                         \n \n                        nonzero_proposal(span(qq_proposal - qqLD_proposal , qq_proposal -1 )) = nonzeroLD_proposal; \n                         \n \n                         \n \n                        for (int rot = 0; rot < qqLD_proposal; rot++){ \n                         \n \n                         \n \n                         \n \n                         \n \n                        if((qq - qqLD + rot) > 0){ \n                            xTx_snp_gene = xCurr.cols(nonzero_proposal(span(0, qq - qqLD + rot))).t() * xCurr.col(nonzeroLD_proposal(rot)); \n                            xTx_snp_gene(qq - qqLD + rot) =  xTx_snp_gene(qq - qqLD + rot) + small; \n                            TT_proposal = cholAddCol(TT_proposal, xTx_snp_gene); \n                        }else{ \n                            TT_proposal.set_size(1,1); \n                            tempd = sqrt(xTxdiag(rot)); \n \n                             \n \n                            TT_proposal(0,0) = (tempd > 0) ? tempd : (-1*tempd); \n                        } \n                         \n \n                        } \n                    } \n                    } \n                     \n \n                     \n \n                    if(qq_proposal > 0) { \n                    WW =  solve(trimatl(TT_proposal.t()), xTy(maskCurr(nonzero_proposal))); \n                     \n \n                    R2 = sum(square(WW))/y2(gene); \n                    gg_proposal = (n - qq_proposal - 1.0)/2.0 * log(1 + ccCurr) - (n -1.0 )/2.0 * log(1.0+ccCurr*(1.0-R2)); \n                    }else{ \n                    gg_proposal = 0; \n                    } \n                     \n \n                     \n \n                     \n \n                     \n \n                     \n \n                     \n \n                     \n \n                     \n \n                     \n \n                    prior_proposal = prod( pa1x_vec(nonzeroLD_proposal)) * prod(1 - pa1x_vec(zeroLD_proposal)); \n                     \n \n                    trans_proposal = prod(proposal_gamMaCurr(nonzeroLD_proposalInx)) * prod(1 - proposal_gamMaCurr(zeroLD_proposalInx)); \n                     \n \n                    prior_curr = prod( pa1x_vec(nonzeroLD)) * prod(1 - pa1x_vec(zeroLD)); \n                     \n \n                    trans_curr = prod( proposal_gamMaCurr(nonzeroLDInx)) * prod(1 - proposal_gamMaCurr(zeroLDInx)); \n                     \n \n                    accept = exp( gg_proposal - gg_curr) * (prior_proposal/prior_curr) * (trans_curr/trans_proposal) * (prior_changeNotLD /trans_changeNotLD); \n                     \n \n                     \n \n                    randDraw = randu(1); \n                    if(verbose){ \n                     \n \n                     \n \n                    gamMa_rate(snps_inx) = zeros<vec>(snps_inx.size()); \n                    } \n \n                    if( accept > randDraw(0) ){ \n                    gamMaCurr(nonzeroLD) = zeros<vec>(qqLD); \n                    if(cholEstimate ==1) gamMaCurr(zeroNotLD_proposal) = zeros<vec>(zeroNotLD_proposal.size()); \n                    gamMaCurr(nonzeroLD_proposal) = ones<vec>(qqLD_proposal); \n                    nonzero = nonzero_proposal; \n                    gg_curr = gg_proposal; \n                    qq = qq_proposal; \n                    TT_curr = TT_proposal; \n                    if(verbose){ \n                        gamMa_rate(snps_inx) = ones<vec>(snps_inx.size()); \n                    } \n                    } \n                     \n \n                } \n                 \n \n                } \n                 \n \n                 \n \n                vec pax1_vec =  gamMaCurr* log(a11/a10)  + (1-gamMaCurr ) * log( (1 - a11)/(1 - a10)); \n                 \n \n                gamMa_probCurr = (iter == 0)? gamMaCurr : (- theta_bias + pax1_vec + aTfCurr); \n                 \n \n                 \n \n                 \n \n \n                 \n \n                 \n \n            } \n               gamMa_inclusion = gamMa_inclusion + gamMaCurr; \n            } \n             \n \n            if(sample_logit){ \n            if(oversample){ \n                double sum_inclusion = sum(gamMa_inclusion); \n                if((localmaxiter*p_curr  > sum_inclusion) && (sum_inclusion > 0)){ \n                sample_prob = (localmaxiter*p_curr - sum_inclusion) * gamMa_inclusion +  sum_inclusion *(localmaxiter- gamMa_inclusion); \n                } else sample_prob.ones(); \n                 \n \n                 \n \n                 \n \n                 \n \n                ransampl_set( ws, sample_prob.memptr() ); \n                a1.randu(bootstrap); a2.randu(bootstrap); \n                for (int ii = 0; ii < bootstrap; ii++) { \n                ret = ransampl_draw( ws, a1(ii), a2(ii)); \n                logit_freqCurr(ret) =   logit_freqCurr(ret)+1; \n                } \n \n            }else if(!balance){ \n                 \n \n                sort_inx = arma::sort_index(gamMa_inclusion); \n                if(p_curr >= 50) { \n                topp = 5; bottomm = 45; \n                }else{ \n                 \n \n                 \n \n                topp = p_curr; bottomm=0; \n                } \n            } \n             \n \n             \n \n            } \n            zero = find(gamMaCurr==0); \n             \n \n             \n \n             \n \n            if(qq > 0) { \n            TT_inv = solve(trimatu(TT_curr), eye(qq,qq)); \n            VV = ccCurr*sigma2Curr/(1+ccCurr) * (TT_inv * TT_inv.t() ); \n             \n \n            mm = VV * xTy(maskCurr(nonzero))/sigma2Curr; \n             \n \n             \n \n            beTaCurr.zeros(); \n            beTaCurr(nonzero) = mvrnormArma(1, mm, VV); \n             \n \n            xbeTa  = x.cols(maskCurr(nonzero)) * beTaCurr(nonzero); \n            xbeTaM =  x.cols(maskCurr(nonzero)) * mm; \n            }else{ \n            beTaCurr.zeros(); xbeTa.zeros(); xbeTaM.zeros(); \n \n            } \n             \n \n             \n \n            if(qq > 1){ \n            xCurr_nonzero = xCurr.cols(nonzero); \n            mat xTxcurr = xCurr_nonzero.t() * xCurr_nonzero + small*eye(qq, qq); \n            mat TTtemp = chol(xTxcurr); \n            if(sum(sum(TTtemp - TT_curr)) > .1){ \n                cout << sum(sum(TTtemp))<< \"\\t\" << sum(sum(TT_curr))  << endl; \n                cout << \"mismatch TT \\t \" << nonzero.t() << endl; \n                 \n \n                 \n \n                Rcpp::stop(\"mismatch occurred \\n\"); \n            } \n            } \n \n \n            residue = y.col(gene) - xbeTa; \n            double ev = var(y.col(gene) - xbeTaM)/varY(gene); \n            double weightCurr = 10* pow(2, -10*(1-ev)) + 1; \n            double    residue2sum = sum(square(residue)); double xbeta2sum = sum(square(xbeTa)); \n             \n \n             \n \n             \n \n \n             \n \n            { \n             \n \n             \n \n            sigma2Curr = rinvgammaC(( nu(gene)+ n + qq)/2.0, 1/2.0 * (residue2sum + xbeta2sum/ccCurr +  nu(gene) * lambdal(gene))); \n            ccCurr = rinvgammaC((qq+1)/2.0, (xbeta2sum/sigma2Curr + n) /2.0); \n            sigma2(gene) = sigma2Curr; \n            cc(gene) = ccCurr; \n             \n \n            evAll(gene) =1-ev; \n            if(evAll(gene) < 0) { \n                cout << ev << \" ev neg for gene\" <<  gene << endl; \n                cout <<   beTaCurr(nonzero) << endl; \n                cout <<  mm  << endl; \n                cout << nonzero.t() << endl; \n                 \n \n            } \n \n            zz(span(gene_start,gene_end)) = gamMa_inclusion/localmaxiter;  \n \n             \n \n             \n \n            if(sample_logit){ \n                if( oversample){ \n                logit_freq(span(gene_start,gene_end)) = logit_freqCurr;  \n \n                }else if (!balance) { \n                logit_freqtop(gene_start + sort_inx(span(p_curr - topp, p_curr-1))) = weightCurr* ones<vec>(topp); \n                logit_freq(gene_start + sort_inx(span(p_curr - topp, p_curr-1))) = weightCurr* ones<vec>(topp); \n                if(bottomm > 0) { \n                    logit_freqbottom(gene_start + sort_inx(span(0, bottomm -1))) = weightCurr*ones<vec>(bottomm); \n                    logit_freq(gene_start + sort_inx(span(0, bottomm -1))) = weightCurr*ones<vec>(bottomm); \n                } \n                } \n            }else{ \n                 \n \n                logit_freq(span(gene_start, gene_end)) = ones<vec>(gene_end - gene_start + 1); \n            } \n             \n \n \n            gamMa(span(gene_start, gene_end)) = gamMaCurr; \n            gamMa_prob(span(gene_start, gene_end)) = gamMa_probCurr; \n            bf(span(gene_start, gene_end)) = bfCurr; \n            gamMa_rateAll(span(gene_start, gene_end)) = gamMa_rate; \n            beTa(span(gene_start, gene_end)) = beTaCurr; \n             \n \n            TT(gene) = TT_curr; \n            if((((iter -burnIn +1) %thin)==0)  && (iter >= burnIn)){ \n                gamMa_rate_mat(span(gene_start, gene_end),count)= gamMa_rate; \n                bf_mat(span(gene_start, gene_end),count)= bfCurr; \n                gamMa_mat(span(gene_start, gene_end),count)= gamMaCurr; \n                gamMa_prob_mat(span(gene_start, gene_end),count)= gamMa_probCurr; \n                beTa_mat( span(gene_start, gene_end), count) = beTaCurr; \n                cc_mat(gene, count) = cc(gene); \n                ev_mat(gene, count) = evAll(gene); \n                sigma2_mat(gene, count) = sigma2(gene); \n            } \n            } \n \n            ransampl_free( ws ); \n        } \n         \n \n        }", "pragma": "parallel for ", "hash": "625b6414907901a6d2d0b5472e9e29df44f2b7ae4284be3e4078f7e913c0c49f"}
{"code": "for (int i0=0; i0 < write->shape()[0]; ++i0) { \n                    write->at<float>(i0) = in->at<float>(start + step*i0); \n                }", "pragma": "parallel for ", "hash": "46dec626e6c502585fd67844087c21ae5a8c22dcbacb83afddec1078eb513d2a"}
{"code": "for( i1 = 0; i1 < (int)(N*C*H*W); i1 += 16 ) { \n        _mm256_stream_si256( (__m256i *)&(out_buffer[i1]), _mm512_quantize_near_ps_epi16( &(in_buffer[i1]), vscfq ) ); \n      }", "pragma": "parallel for private(i1)", "hash": "3daee0516ddbffbcc3407a2e3f9312c80d28a67b39dea97a46d505c777179b78"}
{"code": "for(k = 0; k < nOutputPlane; k++) \n    { \n      for(zz = 0; zz < nInputPlane; zz++) \n      { \n        eex_(SAD)(output_data + k*output_w*output_h, output_h, output_w,  \n                  input_data + zz*input_w*input_h, input_w,  \n                  weight_data + k*nInputPlane*weight_w*weight_h + zz*weight_w*weight_h, weight_h, weight_w,  \n                  dH, dW); \n      } \n    }", "pragma": "parallel for private(k zz)", "hash": "38db7e8a7ea187b76a95498066b7bd70010c075e45d940d477f1fbb6d5af30e9"}
{"code": "for (int i = 0; i < 128; i++) \n    if (a[i]) \n      x = a[i] + 5;", "pragma": "parallel for simd private(conditional: x)", "hash": "f6c12259e4bcd3fa9469c9b8bb470702fe0aed840da8fbf811c8a8c3298ea161"}
{"code": "for (int i = 0; i < i_size; ++i) \n    { \n        for (int j = 0; j < (int)p10.size(); ++j) \n        { \n            if (i <= j) \n                continue; \n \n            const bool a = doTrianglesIntersect(p00[i], p01[i], p02[i], p10[j], p11[j], p12[j]); \n            if (a) \n            { \n                ++count; \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "728ec2e74939dbed0647222b6a236895a6d09f1d6e01098d6418284584dcedfb"}
{"code": "for(idx = 0; idx < count; ++idx) \n  { \n    dst[idx] = (float )(WLZ_CLAMP(src[idx], -(FLT_MAX), FLT_MAX)); \n  }", "pragma": "parallel for ", "hash": "0553d9cec217026d559752141aab2ce9d50734e7a96f33bffcf1b4be7e37764d"}
{"code": "for (usint i = 0; i < m_vectors.size(); i++) { \n            extra.m_vectors[i] *= t; \n            m_vectors[i] += extra.m_vectors[i]; \n            m_vectors[i] *= qlInvModq[i]; \n        }", "pragma": "parallel for ", "hash": "f419013442db30334d5e570dad8daa5566ab334b1a0182bd327fdb57f8eb374b"}
{"code": "for (i = 0; i < a_samples; ++i) \n\t{ \n\t\t \n \n \n\t\ta_init_time += a_interval;  \n \n\t\ta_einit_time += a_einterval; \n\t\tdelta = static_cast<double>(i)* inv_samples; \n\t\tt = a_init_time * delta; \n\t\tt2 = a_einit_time * delta; \n\t\ta_envelope.operator[](i) = params.envelope(TWO_PI * a_envfreq * t2); \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t\ta_phase.operator[](i) = 0.5 * a_chirp_rate * t * t;\t   \n \n\t\ta_chirp.operator[](i).operator=({ t, a_envelope.operator[](i) * a_sinusoid(a_phase.operator[](i)) }); \n\t}", "pragma": "parallel for reduction(+:a_init_time) reduction(+:a_einit_time) private(   delta i t t2)", "hash": "171797a25873d525256881587cc9f4eb30b4fc831b56dda1ef1fe1992601c088"}
{"code": "for(fint iface = m->gPhyBFaceStart(); iface < m->gPhyBFaceEnd(); iface++) \n\t{ \n\t\tconst fint ibpface = iface - m->gPhyBFaceStart(); \n\t\tconst fint ielem = m->gintfac(iface,0); \n \n\t\tscalar w2 = 0, dr[NDIM]; \n\t\tfor(short idim = 0; idim < NDIM; idim++) \n\t\t{ \n\t\t\tw2 += (rcm(ielem,idim)-rcbpm(ibpface,idim))*(rcm(ielem,idim)-rcbpm(ibpface,idim)); \n\t\t\tdr[idim] = rcm(ielem,idim)-rcbpm(ibpface,idim); \n\t\t} \n\t\tw2 = 1.0/(w2); \n \n\t\tfor(int i = 0; i<NDIM; i++) \n\t\t\tfor(int j = 0; j < NDIM; j++) { \n#pragma omp critical \n#pragma omp atomic update \n\t\t\t\tV[ielem](i,j) += w2*dr[i]*dr[j]; \n\t\t\t} \n\t}", "pragma": "parallel for ", "hash": "8dd2a5d65b36c576952ffa9b0193b17e5a14dae89a90104a6e384644cd2842c7"}
{"code": "for (int j = 0; j < height; j++) { \n        fftwf_execute_r2r(p, F.data() + width * j, Ftr.data() + width * j); \n    }", "pragma": "parallel for ", "hash": "97805ad154ccf732c3eaa79c46caf436e39a6840f4f1bf00430657f965192434"}
{"code": "for(index i = 0; i < mat.nbrows; i++)  \n\t\t\t{ \n\t\t\t\tscalar diff = xtemp[i] - xx[i]; \n\t\t\t\tdiffnorm += diff*diff; \n\t\t\t\txx[i] = xtemp[i]; \n\t\t\t}", "pragma": "parallel for simd reduction(+:diffnorm) ", "hash": "af8502f40c3ea1b5484fb0b4a481d4416b6170166793be56d095c0ca59d00a69"}
{"code": "for (i = 0; i < iScanSize; i++) { \n\t\tint iThreadId = omp_get_thread_num(); \n\t\tvpAllMS2Scans[i]->scorePeptidesMVH(psequenceIonMasses.at(iThreadId), _ppdAAforward.at(iThreadId), \n\t\t\t\t_ppdAAreverse.at(iThreadId), pSeqs.at(iThreadId)); \n\t}", "pragma": "parallel for ", "hash": "7877d2704c6cc4dbdfa460cb1257188bac73ec6d70998e10cd07d2c39a11b9d6"}
{"code": "for (j=0; j<bands; j++){ \n        for (k=0; k<bands; k++){ \n            for (l=0; l<cols; l++){ \n                if (buffer[j*cols+l]!=nvalue){ \n                    sumv[j][k]+=(buffer[(j*cols)+l]-mean[j])*(buffer[(k*cols)+l]-mean[k]); \n                    } \n                } \n            } \n        }", "pragma": "for ", "hash": "085329dcb981a35492d6e4bf8414c287f0c47e8496d5bd8bd298e3dd83c93358"}
{"code": "for (int32_t iNode = 0; iNode < nNodes; ++iNode) { \n      auto ii = start + iNode * dyna_ndim; \n      buffer->read_float_array(ii, dyna_ndim, vel_tmp); \n      db_nodes->get_nodeByIndex(iNode)->add_vel(vel_tmp); \n    }", "pragma": "for ", "hash": "ccbe406a720f9f4ae7df64b2da06c6c73f0fadc41e0505c0745b5a01527306d8"}
{"code": "for(loop_index = 0; loop_index < loop_num; loop_index++) { \n \n        bitmask = one << (threshold + 1); \n        start_index = loop_interval * loop_index; \n        p_index = CHAR_NUM * MIC_V_NUM * loop_index * word_num; \n        int bit_index = 0; \n        int char_index = 0; \n \n \n        for(int i = 0; i < threshold; i++) { \n \n            for(j = 0; j < MIC_V_NUM; j++) { \n                char_value = mapping_table[(int)itr[start_index + (read_seq->len + 1) * j]]; \n                result_reads[p_index + char_value * word_num * MIC_V_NUM + char_index * MIC_V_NUM + j] |= bitmask; \n            } \n \n            bitmask <<= 1; \n            start_index++; \n            bit_index++; \n        }  \n \n        bitmask = one; \n        bit_index = 0; \n        char_index++; \n        for(i = threshold; i < read_seq->len; i++) { \n \n            if(bit_index == word_size) { \n                bitmask = one; \n                bit_index = 0; \n                char_index++; \n            } \n \n            for(j = 0; j < MIC_V_NUM; j++) { \n                char_value = mapping_table[(int)itr[start_index + (read_seq->len + 1) * j]]; \n                result_reads[p_index + char_value * word_num * MIC_V_NUM + char_index * MIC_V_NUM + j] |= bitmask; \n            } \n            bitmask <<= 1; \n            start_index++; \n            bit_index++; \n        } \n    }", "pragma": "parallel for private(      bitmask char_value i j loop_index p_index start_index)", "hash": "d7f9b49e77ea142edd33ba04180a8cceb9e5844267f6f87e1420895111c0c8b9"}
{"code": "for(index=0;index<voxelNumber;index+=image->dim[n]){ \n                        for(x=0; x<image->dim[n]; x++){ \n                            startingIndex=index+x; \n \n                            current = startingIndex - increment*radius; \n                            value=0; \n                             \n \n                            if(timeImagePtr[startingIndex]==timeImagePtr[startingIndex]){ \n                                for(j=-radius; j<=radius; j++){ \n                                    if(-1<current && current<(int)voxelNumber){ \n                                        if(timeImagePtr[current]==timeImagePtr[current]) \n                                            value += (PrecisionTYPE)(timeImagePtr[current]*kernel[j+radius]); \n                                    } \n                                    current += increment; \n                                } \n                                resultValue[startingIndex]=value; \n                            } \n                            else{ \n                                resultValue[startingIndex]=timeImagePtr[startingIndex]; \n                            } \n                        } \n                    }", "pragma": "parallel for private( current index j startingindex value x)", "hash": "4985d8c4e92e6f820f3913bc487c24b990f3de7bb37481150e82e4d07a2b736e"}
{"code": "for (int i = 0; i < ndata; i++) \n  { \n    x[i] = (ndata*0.5-i)*2.0/ndata; \n    y[i] = 0.0; \n  }", "pragma": "parallel for ", "hash": "a3a65a0c1e2cb5482995f77c2ad3528cef60f321adca21c768d910a5efa5b86d"}
{"code": "for(int i=0; i<size; i++) \n          gbot1[i] = 0.0f;", "pragma": "parallel for ", "hash": "9e391d28cd0546ef1c6f43c30148b1dbe964f354fb41878836ef92bb111ced9b"}
{"code": "for(auto col = 0;col < Dim[1];col++) { \n        for(auto j = p[col];j < p[col + 1];j++) { \n          auto row = i[j] + 1; \n          if (row != index[0]) continue; \n          double value = x[j]; \n          retval[col] += value; \n        } \n      }", "pragma": "parallel for ", "hash": "ddcdf2dbe89a6a7f9ef32690ca477ed6f79ecbdd065610a9c42bb6df30e24bbc"}
{"code": "for (omp_iter_t som_y = 0; som_y < map.nSomY; som_y++) { \n                for (unsigned int som_x = 0; som_x < map.nSomX; som_x++) { \n\t            for (unsigned int n = 0; n < nVectorsPerRank; n++) { \n\t\t        if (itask * nVectorsPerRank + n < map.nVectors) { \n\t\t\t    float dist = 0.0f; \n                        if (map.gridType == \"rectangular\") { \n                            if (map.mapType == \"planar\") { \n                                dist = euclideanDistanceOnPlanarMap(som_x, som_y, bmus[2 * n], bmus[2 * n + 1]); \n                            } \n                            else if (map.mapType == \"toroid\") { \n                                dist = euclideanDistanceOnToroidMap(som_x, som_y, bmus[2 * n], bmus[2 * n + 1], map.nSomX, map.nSomY); \n                            } \n                        } \n                        else { \n                            if (map.mapType == \"planar\") { \n                                dist = euclideanDistanceOnHexagonalPlanarMap(som_x, som_y, bmus[2 * n], bmus[2 * n + 1]); \n                            } \n                            else if (map.mapType == \"toroid\") { \n                                dist = euclideanDistanceOnHexagonalToroidMap(som_x, som_y, bmus[2 * n], bmus[2 * n + 1], map.nSomX, map.nSomY); \n                            } \n                        } \n                        float neighbor_fuct = getWeight(dist, radius, scale, compact_support, gaussian, std_coeff); \n                        localDenominator[som_y * map.nSomX + som_x] += neighbor_fuct; \n                        for (unsigned int d = 0; d < map.nDimensions; d++) { \n                            localNumerator[som_y * map.nSomX * map.nDimensions + som_x * map.nDimensions + d] += \n                                1.0f * neighbor_fuct \n                                * (*(data + n * map.nDimensions + d)); \n                        } \n \n                        if (n == 0) { \n                            localDenominator = neighbor_fuct; \n                            for (unsigned int d = 0; d < map.nDimensions; d++) { \n                                localNumerator[d] = 1.0f * neighbor_fuct \n                                    * (*(data + n * map.nDimensions + d)); \n                            } \n                         } else { \n                            localDenominator += neighbor_fuct; \n                            for (unsigned int d = 0; d < map.nDimensions; d++) { \n                                localNumerator[d] += 1.0f * neighbor_fuct \n                                    * (*(data + n * map.nDimensions + d)); \n                            } \n                         } \n \n                    } \n                }  \n \n \n                for (unsigned int d = 0; d < map.nDimensions; d++) { \n                    if (localDenominator != 0) { \n                      float newWeight = localNumerator[d] / localDenominator; \n                      map.codebook[som_y * map.nSomX * map.nDimensions + som_x * map.nDimensions + d] = newWeight; \n                    } \n                } \n            }  \n \n        }", "pragma": "for ", "hash": "cc0b6c6f72bb07cd70206387305cc9f86c0a5a28f4227eddb8708f74827fc46c"}
{"code": "for (int i = 0; i < ratings.size(); ++i) { \n            ui = ratings.at(i).at(0) - 1;  \n \n            mi = ratings.at(i).at(1) - 1;  \n \n            ri = ratings.at(i).at(2);  \n \n            error = ri - U.row(ui) * M.col(mi); \n \n            tempU = U.row(ui) + eta * error * M.col(mi).transpose(); \n            M.col(mi) = M.col(mi) + eta * error * U.row(ui).transpose(); \n            U.row(ui) = tempU; \n        }", "pragma": "parallel for private(    error mi ri tempu ui)", "hash": "0d7a3871b755e2ab9a8f2ab0da6328e12f3424c63b9ae3e9b00b12defdccf0ea"}
{"code": "for(long i=0;i<N1;i++)\tfor(long j=0;j<N2;j++)\tfor(long k=0;k<N3;k++)\r \n\t\td->a[k+N3*(j+i*N2)] = A[i][j][k];", "pragma": "parallel for ", "hash": "83337949877a59f3a1960dae1a079cef2f38b277d0077579863c98cb40d11cb4"}
{"code": "for (int i = 0; i < j; i++) \n    for (int j = 0; j < 16; j++) \n      ;", "pragma": "for ", "hash": "c8f06b80bbf60210eb507e846398bae4dfbdf7e81ef19790c32fd2858f5f572b"}
{"code": "for(int i=0; i<nNodes; i++) \n    { \n        f(S_NDOF*nodes[i]->index + 0) = nodes[i]->loadValues[0]; \n        f(S_NDOF*nodes[i]->index + 1) = nodes[i]->loadValues[1]; \n        f(S_NDOF*nodes[i]->index + 2) = nodes[i]->loadValues[2]; \n        f(S_NDOF*nodes[i]->index + 3) = nodes[i]->loadValues[3]; \n        f(S_NDOF*nodes[i]->index + 4) = nodes[i]->loadValues[4]; \n        f(S_NDOF*nodes[i]->index + 5) = nodes[i]->loadValues[5]; \n    }", "pragma": "parallel for ", "hash": "c84eec70b353af37eaa56d060f3174ba4d61b8976d5b1619c303c2491fe4c4cb"}
{"code": "for (int i=0; i<_N_real; i++){ \n\t\tparticles[i].ax = 0.;  \n\t\tparticles[i].ay = 0.;  \n\t\tparticles[i].az = 0.;  \n\t\tcs[i].x = 0.; \n\t\tcs[i].y = 0.; \n\t\tcs[i].z = 0.; \n\t}", "pragma": "parallel for ", "hash": "c5df533ee13ca2c30edfc0a42c91e1a4ae55fe92f441915d16ce03183a20c3a2"}
{"code": "for (int g = 0; g < gc; g++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tstd::vector<Image<RFLOAT> > obsR; \n\t\t\t\t\t\t \n\t\t\t\t\t\ttry \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tobsR = StackHelper::loadStack(&mdts[g], image_path); \n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (RelionError XE) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tstd::cerr << \"warning: unable to load micrograph #\" << (g+1) << \"\\n\"; \n\t\t\t\t\t\t\tcontinue; \n\t\t\t\t\t\t} \n\t\t\t\t\t\t \n\t\t\t\t\t\tconst long pc = obsR.size(); \n\t\t\t\t\t\t \n\t\t\t\t\t\tfor (int p = 0; p < pc; p++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tint randSubset; \n\t\t\t\t\t\t\tmdts[g].getValue(EMDL_PARTICLE_RANDOM_SUBSET, randSubset, p); \n\t\t\t\t\t\t\trandSubset = randSubset - 1; \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tif (ref_dim == 2) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\trot = tilt = 0.; \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tmdts[g].getValue(EMDL_ORIENT_ROT, rot, p); \n\t\t\t\t\t\t\t\tmdts[g].getValue(EMDL_ORIENT_TILT, tilt, p); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tpsi = 0.; \n\t\t\t\t\t\t\tmdts[g].getValue(EMDL_ORIENT_PSI, psi, p); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (angular_error > 0.) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\trot += rnd_gaus(0., angular_error); \n\t\t\t\t\t\t\t\ttilt += rnd_gaus(0., angular_error); \n\t\t\t\t\t\t\t\tpsi += rnd_gaus(0., angular_error); \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tEuler_angles2matrix(rot, tilt, psi, A3D); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\ttrans.initZeros(); \n\t\t\t\t\t\t\tmdts[g].getValue( EMDL_ORIENT_ORIGIN_X, XX(trans), p); \n\t\t\t\t\t\t\tmdts[g].getValue( EMDL_ORIENT_ORIGIN_Y, YY(trans), p); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (shift_error > 0.) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tXX(trans) += rnd_gaus(0., shift_error); \n\t\t\t\t\t\t\t\tYY(trans) += rnd_gaus(0., shift_error); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (do_3d_rot) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\ttrans.resize(3); \n\t\t\t\t\t\t\t\tmdts[g].getValue( EMDL_ORIENT_ORIGIN_Z, ZZ(trans), p); \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tif (shift_error > 0.) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tZZ(trans) += rnd_gaus(0., shift_error); \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (do_fom_weighting) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tmdts[g].getValue( EMDL_PARTICLE_FOM, fom, p); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tMultidimArray<Complex> Fsub, F2D, F2DP, F2DQ; \n\t\t\t\t\t\t\tCenterFFT(obsR[p](), true); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\ttransformer.FourierTransform(obsR[p](), F2D); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (ABS(XX(trans)) > 0. || ABS(YY(trans)) > 0.) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tif (do_3d_rot) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tshiftImageInFourierTransform( \n\t\t\t\t\t\t\t\t\t\tF2D, F2D, XSIZE(obsR[p]()), XX(trans), YY(trans), ZZ(trans)); \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tshiftImageInFourierTransform( \n\t\t\t\t\t\t\t\t\t\tF2D, F2D, XSIZE(obsR[p]()), XX(trans), YY(trans)); \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tFctf.resize(F2D); \n\t\t\t\t\t\t\tFctf.initConstant(1.); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tif (do_ctf || do_reconstruct_ctf) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tCTF ctf; \n\t\t\t\t\t\t\t\tctf.read(mdts[g], mdts[g], p); \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tctf.getFftwImage(Fctf, mysize, mysize, angpix, \n\t\t\t\t\t\t\t\t\t\t\t\t ctf_phase_flipped, only_flip_phases, \n\t\t\t\t\t\t\t\t\t\t\t\t intact_ctf_first_peak, true); \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tif (do_beamtilt) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tif (!cl_beamtilt) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tif (mdts[g].containsLabel(EMDL_IMAGE_BEAMTILT_X)) \n\t\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\t\tmdts[g].getValue(EMDL_IMAGE_BEAMTILT_X, beamtilt_x, p); \n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\tif (mdts[g].containsLabel(EMDL_IMAGE_BEAMTILT_Y)) \n\t\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\t\tmdts[g].getValue(EMDL_IMAGE_BEAMTILT_Y, beamtilt_y, p); \n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tselfApplyBeamTilt( \n\t\t\t\t\t\t\t\t\t\tF2D, beamtilt_x, beamtilt_y,  \n\t\t\t\t\t\t\t\t\t\tctf.lambda, ctf.Cs, angpix, mysize); \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tif (do_ewald) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tapplyCTFPandCTFQ(F2D, ctf, transformer, F2DP, F2DQ); \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\tctf.applyWeightEwaldSphereCurvature( \n\t\t\t\t\t\t\t\t\t\tFctf, mysize, mysize, angpix, mask_diameter); \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\t\tr_ewald_sphere = mysize * angpix / ctf.lambda; \n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\tif (fn_sub != \"\") \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tobsModel.predictObservation( \n\t\t\t\t\t\t\t\t\tsubProjector, mdts[g], p, Fsub, do_ctf, do_beamtilt);  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tFOR_ALL_DIRECT_ELEMENTS_IN_MULTIDIMARRAY(Fsub) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(F2D, n) -= DIRECT_MULTIDIM_ELEM(Fsub, n); \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\tbackprojectors[randSubset][threadnum].set2DFourierTransform( \n\t\t\t\t\t\t\t\t\t\t\tF2D, A3D, IS_NOT_INV); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tif (do_reconstruct_ctf) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tFOR_ALL_DIRECT_ELEMENTS_IN_MULTIDIMARRAY(F2D) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(F2D, n) = DIRECT_MULTIDIM_ELEM(Fctf, n); \n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\tif (do_reconstruct_ctf2) \n\t\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(F2D, n) *= DIRECT_MULTIDIM_ELEM(Fctf, n); \n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(Fctf, n) = 1.; \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\telse if (do_ewald) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tFOR_ALL_DIRECT_ELEMENTS_IN_MULTIDIMARRAY(F2D) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(Fctf, n) *= DIRECT_MULTIDIM_ELEM(Fctf, n); \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\telse if (do_ctf) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tFOR_ALL_DIRECT_ELEMENTS_IN_MULTIDIMARRAY(F2D) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(F2D, n)  *= DIRECT_MULTIDIM_ELEM(Fctf, n); \n\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(Fctf, n) *= DIRECT_MULTIDIM_ELEM(Fctf, n); \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t\tif (do_fom_weighting) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tFOR_ALL_DIRECT_ELEMENTS_IN_MULTIDIMARRAY(F2D) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(F2D, n)  *= fom; \n\t\t\t\t\t\t\t\t\t\tDIRECT_MULTIDIM_ELEM(Fctf, n) *= fom; \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tif (read_weights) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tstd::string name, fullName; \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tmdts[g].getValue(EMDL_IMAGE_NAME, fullName, 0); \n\t\t\t\t\t\t\t\t\tname = fullName.substr(fullName.find(\"@\")+1); \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tif (image_path != \"\") \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tname = image_path + \"/\" + name.substr(name.find_last_of(\"/\")+1); \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tstd::string wghName = name; \n\t\t\t\t\t\t\t\t\twghName = wghName.substr(0, wghName.find_last_of('.')) + \"_weight.mrc\"; \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tImage<RFLOAT> wgh; \n\t\t\t\t\t\t\t\t\twgh.read(wghName); \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tif (   Fctf.ndim != wgh().ndim \n\t\t\t\t\t\t\t\t\t\t|| Fctf.zdim != wgh().zdim \n\t\t\t\t\t\t\t\t\t\t|| Fctf.ydim != wgh().ydim \n\t\t\t\t\t\t\t\t\t\t|| Fctf.xdim != wgh().xdim) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tREPORT_ERROR(wghName + \" and \" + name + \" are of unequal size.\\n\"); \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tfor (long int n = 0; n < Fctf.ndim; n++) \n\t\t\t\t\t\t\t\t\tfor (long int z = 0; z < Fctf.zdim; z++) \n\t\t\t\t\t\t\t\t\tfor (long int y = 0; y < Fctf.ydim; y++) \n\t\t\t\t\t\t\t\t\tfor (long int x = 0; x < Fctf.xdim; x++) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tDIRECT_NZYX_ELEM(Fctf, n, z, y, x) \n\t\t\t\t\t\t\t\t\t\t\t\t*= DIRECT_NZYX_ELEM(wgh(), n, z, y, x); \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tDIRECT_A2D_ELEM(F2D, 0, 0) = 0.0; \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tif (iter > 0) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tobsModel.predictObservation( \n\t\t\t\t\t\t\t\t\t\tprevProjectors[randSubset], mdts[g], p, prevSlice, \n\t\t\t\t\t\t\t\t\t\tdo_ctf, do_beamtilt); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tif (L1_freq) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tfor (long int y = 0; y < F2D.ydim; y++) \n\t\t\t\t\t\t\t\t\t\tfor (long int x = 0; x < F2D.xdim; x++) \n\t\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\t\tRFLOAT w1 = DIRECT_NZYX_ELEM(Fctf, 0, 0, y, x); \n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\tif (w1 == 0.0)  \n\t\t\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\t\t\tDIRECT_NZYX_ELEM(L1_weights, 0, 0, y, x) = 0.0; \n\t\t\t\t\t\t\t\t\t\t\t\tcontinue; \n\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\tComplex z0 = DIRECT_NZYX_ELEM(prevSlice, 0, 0, y, x); \n\t\t\t\t\t\t\t\t\t\t\tComplex z1 = DIRECT_NZYX_ELEM(F2D, 0, 0, y, x) / w1; \n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\tdouble dl = (z1 - z0).abs(); \n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\tDIRECT_NZYX_ELEM(L1_weights, 0, 0, y, x) =  \n\t\t\t\t\t\t\t\t\t\t\t\t\t1.0 / (dl + L1_eps); \n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tdouble avgW = 0.0; \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tfor (long int y = 0; y < L1_weights.ydim; y++) \n\t\t\t\t\t\t\t\t\tfor (long int x = 0; x < L1_weights.xdim; x++) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tavgW += DIRECT_NZYX_ELEM(L1_weights, 0, 0, y, x); \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tavgW /= (L1_weights.xdim * L1_weights.ydim); \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tfor (long int y = 0; y < L1_weights.ydim; y++) \n\t\t\t\t\t\t\t\t\tfor (long int x = 0; x < L1_weights.xdim; x++) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\tdouble wn = DIRECT_NZYX_ELEM(L1_weights, 0, 0, y, x) / avgW; \n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\tDIRECT_NZYX_ELEM(F2D, 0, 0, y, x) *= wn; \n\t\t\t\t\t\t\t\t\t\tDIRECT_NZYX_ELEM(Fctf, 0, 0, y, x) *= wn; \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tif (do_ewald) \n\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tbackprojectors[randSubset][threadnum].set2DFourierTransform( \n\t\t\t\t\t\t\t\t\t\t\t\tF2DP, A3D, IS_NOT_INV, &Fctf, r_ewald_sphere, true); \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\tbackprojectors[randSubset][threadnum].set2DFourierTransform( \n\t\t\t\t\t\t\t\t\t\t\t\tF2DQ, A3D, IS_NOT_INV, &Fctf, r_ewald_sphere, false); \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tbackprojectors[randSubset][threadnum].set2DFourierTransform( \n\t\t\t\t\t\t\t\t\t\t\t\tF2D, A3D, IS_NOT_INV, &Fctf); \n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (threadnum == 0) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tprogress_bar(g); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} \n\t\t\t\t\t}", "pragma": "for ", "hash": "ad8644969fc601e374e813400c0998e03d910b2774ae222a5faf207a53cebb1a"}
{"code": "for (int ty = ty1; ty <= ty2; ty++) { \n      for (int tx = tx1; tx <= tx2; tx++) { \n \n         \n \n        process_tile(self, tx, ty); \n \n        MyPaintTileRequest request_data; \n        const int mipmap_level = 0; \n        mypaint_tile_request_init(&request_data, mipmap_level, tx, ty, TRUE); \n \n        mypaint_tiled_surface_tile_request_start(self, &request_data); \n        uint16_t * rgba_p = request_data.buffer; \n        if (!rgba_p) { \n          printf(\"Warning: Unable to get tile!\\n\"); \n          break; \n        } \n \n         \n \n        uint16_t mask[MYPAINT_TILE_SIZE*MYPAINT_TILE_SIZE+2*MYPAINT_TILE_SIZE]; \n \n        render_dab_mask(mask, \n                        x - tx*MYPAINT_TILE_SIZE, \n                        y - ty*MYPAINT_TILE_SIZE, \n                        radius, \n                        hardness, \n                        aspect_ratio, angle \n                        ); \n \n         \n \n        #pragma omp critical \n        { \n        get_color_pixels_accumulate (mask, rgba_p, \n                                     &sum_weight, &sum_r, &sum_g, &sum_b, &sum_a); \n        } \n \n        mypaint_tiled_surface_tile_request_end(self, &request_data); \n      } \n    }", "pragma": "parallel for ", "hash": "16343252b3673920a87d570fae7af166cda2e680189a898eb074b5aee1d5c219"}
{"code": "for (i=0; i <= (ssize_t) MaxMap; i++) \n      { \n        x_map[i].x=(MagickRealType) i; \n        y_map[i].x=0.500000f*(2.000000*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        z_map[i].x=(-0.333340f)*(2.000000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        x_map[i].y=(MagickRealType) i; \n        y_map[i].y=0.000000f; \n        z_map[i].y=0.666665f*(2.000000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        x_map[i].z=(MagickRealType) i; \n        y_map[i].z=(-0.500000f)*(2.000000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n        z_map[i].z=(-0.333340f)*(2.000000f*(MagickRealType) i-(MagickRealType) \n          MaxMap); \n      }", "pragma": "parallel for ", "hash": "336146ca23361121ac68a86aaf3b6f6f940a26c028b017e58e15c67e7587e163"}
{"code": "for (int i = 0; i < m; i++) \n      diagptr[i]++;", "pragma": "parallel for ", "hash": "b6c6ed0757f0e7149a55df2d636a0250feaba1239f60b52cf4a1dc684ddb5580"}
{"code": "for (idx_t i = 0; i < n; i++) { \n        int64_t* heap_ids = labels + i * k; \n        float* heap_dis = distances + i * k; \n        heap_heapify<C>(k, heap_dis, heap_ids); \n        float* LUT = nullptr; \n \n        if (single_LUT) { \n            LUT = dis_tables.get() + i * dim12; \n        } \n        for (idx_t j = 0; j < nprobe; j++) { \n            if (!single_LUT) { \n                LUT = dis_tables.get() + (i * nprobe + j) * dim12; \n            } \n            idx_t list_no = coarse_ids[i * nprobe + j]; \n            if (list_no < 0) \n                continue; \n            size_t ls = orig_invlists->list_size(list_no); \n            if (ls == 0) \n                continue; \n            InvertedLists::ScopedCodes codes(orig_invlists, list_no); \n            InvertedLists::ScopedIds ids(orig_invlists, list_no); \n \n            float bias = biases.get() ? biases[i * nprobe + j] : 0; \n \n            estimators_from_tables_generic<C>( \n                    *this, \n                    codes.get(), \n                    ls, \n                    LUT, \n                    ids.get(), \n                    bias, \n                    k, \n                    heap_dis, \n                    heap_ids, \n                    scaler); \n            nlist_visited++; \n            ndis++; \n        } \n        heap_reorder<C>(k, heap_dis, heap_ids); \n    }", "pragma": "parallel for reduction( + : ndis nlist_visited) ", "hash": "84c91d6c230a164e06ebda0defd785c8db57bdec5b5a760535ddd1a1c8d96164"}
{"code": "for (int i1 = 0; i1 < numOfSoftBodies; i1++) \n    { \n        CParticleData& softBody1 = m_outputGroup.GetParticleData(i1); \n        vector<Vec3f>& vecSamplePos1 = softBody1.GetVecSamplePos(); \n        for (int i2 = i1 + 1; i2 < numOfSoftBodies; i2++) \n        { \n            CParticleData& softBody2 = m_outputGroup.GetParticleData(i2); \n            vector<Vec3f>& vecSamplePos2 = softBody2.GetVecSamplePos(); \n            for (int j1 = 0; j1 < numOfSamplesPerData; j1++) \n            { \n                for (int j2 = 0; j2 < numOfSamplesPerData; j2++) \n                { \n                    Vec3f p1 = vecSamplePos1[j1]; \n                    Vec3f p2 = vecSamplePos2[j2]; \n                    if (dist2(p1, p2) < repulsionDistSqr) \n                    { \n                        Vec3f pr = p2 - p1; \n                        normalize(pr); \n                        pr *= repulsionDist; \n                        int idx1 = i1 * numOfSamplesPerData + j1; \n                        int idx2 = i2 * numOfSamplesPerData + j2; \n                        UpdateCoeffMatPairVals(idx1, idx2, repulsionWt, -pr); \n                        repulsionCount++; \n                    } \n                } \n            } \n        } \n    }", "pragma": "parallel for ", "hash": "bc8875d8be5a35dcb15ee5fbf7802a896896b3d3e125bfba3428d5f5fe64c597"}
{"code": "for(int k=0;k<npol;k++) \n\t{ \n\t\tfor(int i=0;i<imsize2;i++) \n\t\t{ \n\t\t\tvec2[k][i] = vec1[k][i] - vec2[k][i]; \n\t\t} \n\t}", "pragma": "parallel for ", "hash": "bb6653373bf6f67330e1b1984d3ffe3a5ba46a80b3921c50efe16adc330fdc2a"}
{"code": "for (int i = 0; i < all_files.size(); i++) { \n    OctreeBuilder builder; \n    bool succ = builder.set_point_cloud(all_files[i]); \n \n    string filename = extract_filename(all_files[i]); \n    if (!succ) { \n      if (FLAGS_verbose) cout << \"Warning: \" + filename + \" is invalid!\\n\"; \n      continue; \n    } \n    builder.set_octree_info(); \n \n     \n \n    float angle = 2.0f * kPI / float(FLAGS_rot_num); \n    float axis[] = { 0.0f, 0.0f, 0.0f }; \n    if (FLAGS_axis == \"x\") axis[0] = 1.0f; \n    else if (FLAGS_axis == \"y\") axis[1] = 1.0f; \n    else axis[2] = 1.0f; \n \n    if (FLAGS_verbose) cout << \"Processing: \" + filename + \"\\n\"; \n    for (int v = 0; v < FLAGS_rot_num; ++v) { \n       \n \n      char file_suffix[64]; \n      sprintf(file_suffix, \"_%d_%d_%03d.octree\", FLAGS_depth, FLAGS_full_depth, v); \n \n       \n \n      builder.build_octree(); \n \n       \n \n      builder.save_octree(output_path + filename + file_suffix); \n \n       \n \n      builder.point_cloud_.rotate(angle, axis); \n \n       \n \n       \n \n    } \n  }", "pragma": "parallel for ", "hash": "6999c44a2e2be4fafce7e02eec7942a8db994c13adb0a9514ed3278ba591d375"}
{"code": "for(int j = 0; j < numSamples; ++j) { \n\t\tint i = 0; \n\t\tdouble urand = static_cast<double>(rand()) / (static_cast<long>(RAND_MAX) + 1l); \n \n\t\t \n \n\t\tfor(double cdf = mPriors[0]; cdf < urand; cdf += mPriors[i]) \n\t\t\t++i; \n \n\t\tscales[j] = mScales[i]; \n\t}", "pragma": "parallel for ", "hash": "f5b95724f37db4b122370dcfe9e265667380ffdbe3afaa6c3b6f56276fece5ca"}
{"code": "for (int y = 0; y < height; y++) \n\t\t\t{ \n\t\t\t\tAutoBuffer<uchar*> sptr(channels); \n\t\t\t\tuchar* dp = dst.ptr<uchar>(y); \n \n\t\t\t\tfor (int x = 0; x < width; x++) \n\t\t\t\t{ \n\t\t\t\t\tuchar* ip = dst.ptr<uchar>(y, x); \n\t\t\t\t\tfor (int c = 0; c < channels; c++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tsptr[c] = srcborder[c].ptr<uchar>(y, x); \n\t\t\t\t\t} \n \n\t\t\t\t\tfor (int i = 0, idx = 0; i < DD; i++) \n\t\t\t\t\t{ \n\t\t\t\t\t\tfor (int c = 0; c < channels; c++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tip[idx++] = sptr[c][scan[i]]; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}", "pragma": "parallel for ", "hash": "7e3df9102873b3aa443b63be4487d702412c8bc107050d34ca2f972aaed0f48e"}
{"code": "for (jj = 0; jj < nn; ++jj) { \n    i = ilist[jj]; \n    if (atom->mask[i] & groupbit) { \n      r[i] = b[i] - q[i]; \n      d[i] = r[i] * Hdia_inv[i];  \n \n \n      tmp1 += b[i] * b[i]; \n      tmp2 += r[i] * d[i]; \n    } \n  }", "pragma": "parallel for reduction(+:tmp1 tmp2) private(i)", "hash": "ed756826c299600b5981087e9650e630c2b89b934b5f55b262c5fab9545ae905"}
{"code": "for(int i = 0; i < (int)inputs_number; i++) \n    { \n        const size_t first_input_index = inputs_indices[i]; \n \n        const Vector<double> first_input_data = data.arrange_column(first_input_index, used_instances_indices); \n \n        for(size_t j = 0; j < inputs_number; j++) \n        { \n            const size_t second_input_index = inputs_indices[j]; \n \n            const Vector<double> second_input_data = data.arrange_column(second_input_index, used_instances_indices); \n \n            covariance_matrix(i,j) = first_input_data.calculate_covariance(second_input_data); \n            covariance_matrix(j,i) = covariance_matrix(i,j); \n        } \n    }", "pragma": "parallel for ", "hash": "57763def2eaeafe1e4d626e684fe81d2c3a2daf406e4c0d21c9a94c936ab93bb"}
{"code": "for (plane = 0; plane < numPlanes; ++plane) { \n     \n \n    real* randomSamplesForPlane = randomSamples + plane * 3; \n \n     \n \n    long* sequenceT = \n      THNN_(VolumetricFractionalMaxPooling_generateIntervals)( \n        randomSamplesForPlane[0], inputT, outputT, poolSizeT); \n    long* sequenceW = \n      THNN_(VolumetricFractionalMaxPooling_generateIntervals)( \n        randomSamplesForPlane[1], inputW, outputW, poolSizeW); \n    long* sequenceH = \n      THNN_(VolumetricFractionalMaxPooling_generateIntervals)( \n        randomSamplesForPlane[2], inputH, outputH, poolSizeH); \n \n     \n \n    long h, w, t; \n \n    real* inputForPlane = input + plane * inputT * inputW * inputH; \n    real* outputForPlane = output + plane * outputT * outputW * outputH; \n    THIndex_t* indicesForPlane = indices + plane * outputT * outputW * outputH; \n \n    for (h = 0; h < outputH; ++h) { \n      long inputHStart = sequenceH[h]; \n \n      for (w = 0; w < outputW; ++w) { \n        long inputWStart = sequenceW[w]; \n \n        for (t = 0; t < outputT; ++t) { \n          long inputTStart = sequenceT[t]; \n \n          real maxVal = -THInf; \n          long maxIndex = -1; \n \n          long h2, w2, t2; \n          for (h2 = inputHStart; h2 < inputHStart + poolSizeH; ++h2) { \n            for (w2 = inputWStart; w2 < inputWStart + poolSizeW; ++w2) { \n              for (t2 = inputTStart; t2 < inputTStart + poolSizeT; ++t2) { \n                THAssert(h2 >= 0 && h2 < inputH); \n                THAssert(w2 >= 0 && w2 < inputW); \n                THAssert(t2 >= 0 && t2 < inputT); \n \n                long planeIndex = h2 * inputW * inputT + w2 * inputT + t2; \n                real val = inputForPlane[planeIndex]; \n                if (val > maxVal) { \n                  maxVal = val; \n                  maxIndex = planeIndex; \n                } \n              } \n            } \n          } \n \n          THAssert(maxVal != -THInf); \n          THAssert(maxIndex != -1); \n \n          outputForPlane[h * outputW * outputT + w * outputT + t] = maxVal; \n           \n \n          indicesForPlane[h * outputW * outputT + w * outputT + t] = maxIndex + TH_INDEX_BASE; \n        } \n      } \n    } \n \n    THFree(sequenceT); \n    THFree(sequenceW); \n    THFree(sequenceH); \n  }", "pragma": "parallel for private(plane)", "hash": "9c5d0a1eff05f98db6815c6932bd92dbcc50c3d91b69cf10c1842b913f4846d1"}
{"code": "for (int i = 0 ; i < static_cast<int>(nbCurvePoints) ; ++i) { \n    curvePoints[i] = computeCatmullRomPointImpl(controlPointsCp, i / static_cast<float>(nbCurvePoints - 1), globalParameter, closedCurve, alpha); \n  }", "pragma": "parallel for ", "hash": "61639817f04cc41d9cc75ad0bfdb33cf1cbfe0aa16afa26a87afa191254d7508"}
{"code": "for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          C[j * ldc + i] *= beta; \n      }", "pragma": "parallel for ", "hash": "c3da9350cbf51eb1f74abba96b6b0a6b10675b2ee8fd18db5b011b1610cf72d3"}
{"code": "for (int i=0; i<this->size_; ++i) \n    this->vec_[i] = alpha*this->vec_[i] + cast_x->vec_[i];", "pragma": "parallel for ", "hash": "69563a9acd8db964291ef327cba5f454e8437dfd20554dc78958f5df147d82db"}
{"code": "for ( i = 0; i < N ; i++ )  \n    { \n        x = complex_add(x,vector[i]); \n        y = complex_mul(y,vector[i]); \n    }", "pragma": "parallel for reduction(complex_add:x) reduction(complex_mul:y) ", "hash": "678b6f5ef07fa9b4a842edf193be87d6d158c8b3800db95cfebe11da375b9abf"}
{"code": "for (int i = 0; i < numHiddenUnits; i++){ \n\t\t\toutput[i] = y[i] + biases[i]; \n\t\t\t}", "pragma": "parallel for ", "hash": "d28b18d93368834d4f59b8bfcce8eae3cfe0deab17f079cb199269ebe78b5fdd"}
{"code": "for (index tid = 0; tid < nf.size(); ++tid) { \n\t\t\ttmp += nf[tid][dist]; \n\t\t}", "pragma": "parallel for reduction(+:tmp) ", "hash": "80834512941a93cecabf21b863665e7af83b173e2904b1d94f6eb9dabc39dafa"}
{"code": "for (int i = 0; i < numOfNodes; ++i) { \n      int u = nodes[i]; \n      int degree = A->rowptr[u + 1] - A->rowptr[u]; \n      if (degree < temp_min) { \n        temp_min = degree; \n        temp_min_idx = u; \n      } \n    }", "pragma": "for ", "hash": "e8c58e81f254478b47f0dcbb800ec24957e35e54946a714737555ec8574c5360"}
{"code": "for(long i=0;i<n;i+=dx)\r \n\t\t\t{\r \n\t\t\t\tmglPoint p((x->v(i,mx)+x->v(i+1,mx))/2, y->v(i,my), zVal);\r \n\t\t\t\tdouble c = sh ? gr->NextColor(pal,i):gr->CDef;\r \n\t\t\t\tgr->AddPntQ(kq+i,p,c);\r \n\t\t\t}", "pragma": "parallel ", "hash": "9e830d42fd06dcf36952ced768bde7fef4bcffb0e26c2306155bda1be8d51ef0"}
{"code": "for(int i=0;i<nth;i++) { \n    if(doj) { \n      for(size_t j=0;j<P.size();j++) \n\tp[i].push_back(new JDigestor(arma::real(P[j]))); \n    } \n    if(dok) { \n      for(size_t j=0;j<P.size();j++) \n\tp[i].push_back(new cxKDigestor(P[j])); \n    } \n  }", "pragma": "parallel for ", "hash": "a6f7b7ac6ffdd91632ae3f9d0089cee6731b3e61ce7fa649b5e3b0b81ed22820"}
{"code": "for(i = 0; i < n; i++) r[i] = b[i] - r[i];", "pragma": "parallel for private(i)", "hash": "1d31449b9f7a5bb96c771353febb8932ecb8de321d6c4481e001cb25fcf18086"}
{"code": "for(k = 0; k < nInputPlane*kH*kW; k++) { \n\t\tlong nip = k / (kH*kW); \n\t\tlong rest = k % (kH*kW); \n\t\tlong kh = rest / kW; \n\t\tlong kw = rest % kW; \n\t\tlong x,y; \n\t\tlong long ix,iy; \n\t\tfloat *dst = finput_data + nip*(kH*kW*outputHeight*outputWidth) + kh*(kW*outputHeight*outputWidth) + kw*(outputHeight*outputWidth); \n\t\tfloat *src = input_data + nip*(inputHeight*inputWidth); \n\t\tif (padW > 0 || padH > 0) { \n\t\t\tlong lpad,rpad; \n\t\t\tfor(y = 0; y < outputHeight; y++) { \n\t\t\t\tiy = (long long)(y*dH - padH + kh); \n\t\t\t\tif (iy < 0 || iy >= inputHeight) { \n\t\t\t\t\tmemset(dst+y*outputWidth, 0, sizeof(float)*outputWidth); \n\t\t\t\t} else { \n\t\t\t\t\tif (dW==1){ \n\t\t\t\t\t\tix = (long long)(0 - padW + kw); \n\t\t\t\t\t\tlpad = fmaxf(0,padW-kw); \n\t\t\t\t\t\trpad = fmaxf(0,padW-(kW-kw-1)); \n\t\t\t\t\t\tif (outputWidth-rpad-lpad <= 0) { \n\t\t\t\t\t\t\tmemset(dst+(y*outputWidth), 0, sizeof(float)*outputWidth); \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tif (lpad > 0) memset(dst+y*outputWidth, 0, sizeof(float)*lpad); \n\t\t\t\t\t\t\tmemcpy(dst+(y*outputWidth+lpad), src+(iy*inputWidth+ix+lpad), sizeof(float)*(outputWidth-rpad-lpad)); \n\t\t\t\t\t\t\tif (rpad > 0) memset(dst+y*outputWidth + outputWidth - rpad, 0, sizeof(float)*rpad); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t\telse{ \n\t\t\t\t\t\tfor (x=0; x<outputWidth; x++){ \n\t\t\t\t\t\t\tix = (long long)(x*dW - padW + kw); \n\t\t\t\t\t\t\tif (ix < 0 || ix >= inputWidth) \n\t\t\t\t\t\t\t\tmemset(dst+(y*outputWidth+x), 0, sizeof(float)*1); \n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tmemcpy(dst+(y*outputWidth+x), src+(iy*inputWidth+ix), sizeof(float)*(1)); \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} else { \n\t\t\tfor(y = 0; y < outputHeight; y++) { \n\t\t\t\tiy = (long long)(y*dH + kh); \n\t\t\t\tix = (long long)(0 + kw); \n\t\t\t\tif (dW == 1) \n\t\t\t\t\tmemcpy(dst+(y*outputWidth), src+(iy*inputWidth+ix), sizeof(float)*outputWidth); \n\t\t\t\telse{ \n\t\t\t\t\tfor (x=0; x<outputWidth; x++) \n\t\t\t\t\t\tmemcpy(dst+(y*outputWidth+x), src+(iy*inputWidth+ix+x*dW), sizeof(float)*(1)); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t}", "pragma": "parallel for private(k)", "hash": "173518c4e5e7a895bbb84e7714823bfcb178498f1fce253f78f96d791e88dbe6"}
{"code": "for (cnt = 0; cnt < 2; ++cnt) \n    for (int j = 0; j < 4 + cnt; j++) \n    k = cnt;", "pragma": "for ", "hash": "569fa5f8fbd7700f8df2d2594d2e4bde6ea99130bad3fc4371c188ab16cf6b27"}
{"code": "for ( int i=0; i<m_dim_x; i++ ) \n    { \n      for ( int j=0; j<m_dim_y; j++ ) \n      { \n        this->Get_kx( i, i2, kx ); \n        kx = -kx*kx; \n        ij = j+m_dim_y*i; \n \n        m_out[ij][0] *= kx; \n        m_out[ij][1] *= kx; \n      } \n    }", "pragma": "parallel for private(i2 ij kx)", "hash": "9dab0befbf1caa21ff0d0d8a6255cdb8e95a8d6e236f1cfc4366875b4b578692"}
{"code": "for (int ia = 0; ia < unit_cell_.num_atoms(); ia++) { \n            auto& atom_to_grid_map = ctx_.atoms_to_grid_idx_map(ia); \n            vector3d<double> v     = unit_cell_.atom(ia).vector_field(); \n \n            for (auto coord : atom_to_grid_map) { \n                int ir   = coord.first; \n                double a = coord.second; \n                magnetization(0).f_rg(ir) += v[2] * w(a); \n                if (ctx_.num_mag_dims() == 3) { \n                    magnetization(1).f_rg(ir) += v[0] * w(a); \n                    magnetization(2).f_rg(ir) += v[1] * w(a); \n                } \n            } \n        }", "pragma": "parallel for ", "hash": "672e39c525ac7d8e93c1de0067263ca97bc61772acbd89bcce7e0c93b7bd8ef0"}
{"code": "for (i=0;i<d-1;i++) \n            { \n                PairCopulaFit(Vine->Thetas+Vine->NumbParams[d*j-j*(j+1)/2+i], Vine->Families[d*j-j*(j+1)/2+i], &U[i*n], &U[(i+1)*n], n); \n            }", "pragma": "parallel for private(i)", "hash": "bcb23201521786d24c1a1ca55f297569583c776e246ef90d94d5a9154f46b189"}
{"code": "for(int i=0;i<n->ptr1.size();++i) { \n\tint c=(i*s)%LUT; \n\tif (un[(c++)%LUT]<noiseb){ \n\t  n->ptr1(i)=1.0; \n\t} \n      }", "pragma": "parallel for ", "hash": "5285ce12081783cc9d1e64c23f7c69fce46e1f7f81553dc22e6bf6f7664c6a6c"}
{"code": "for(int nt=0; nt<nthread; nt++) { \n             \n \n             \n \n            T *M, *E, *V=NULL, *D, *Di, *ptr_M, *ptr_Mi, *ptr_V, *ptr_Vi; \n            mwSignedIndex m2, m22; \n            size_t msz; \n            char uplo = 'U'; \n            char range = 'A'; \n            char jobzn = 'N'; \n            T vu = std::numeric_limits<T>::max(); \n            T vl = -vu; \n            mwSignedIndex il = 0, iu; \n            T abstol = sqrt(std::numeric_limits<T>::epsilon()); \n            mwSignedIndex lda, ldz, numfind; \n            mwSignedIndex info, lwork, liwork, lzwork; \n            mwSignedIndex *isuppz, *iwork; \n            T *work, *zwork; \n            int ii, jj; \n            lda = m; \n            ldz = m; \n            iu = m; \n            m2 = m*m; \n            m22 = 2*m2; \n            msz = m2*sizeof(T); \n            lwork = do_orth ? ( (26*m>(2*m*(m+10))) ? 26*m : (2*m*(m+10)) )   \n                            : ( (26*m>(2*m*(m+3))) ? 26*m : (2*m*(m+3)) ); \n            liwork = 10*m; \n            isuppz = new mwSignedIndex[2*m]; \n            work = new T[lwork]; \n            iwork = new mwSignedIndex[liwork]; \n            if(is_complex) { \n                lzwork = 4*m; \n                M = new T[m22]; \n                zwork = new T[lzwork*2]; \n                if(nlhs>1) \n                    V = new T[m22]; \n            } \n            else \n                M = new T[m2]; \n             \n \n             \n \n            if(is_complex && anynonsym) { \n                D = new T[2*m]; \n            } \n            else if(nlhs>1 && nd==2) { \n                D = new T[m]; \n                if(anynonsym) \n                    Di = new T[m]; \n            } \n             \n \n            for(int ib=blkid[nt]; ib<blkid[nt+1]; ib++) { \n                if(!(is_complex && anynonsym)) { \n                    if(nlhs<=1) \n                        D = (T*)mxGetData(plhs[0]) + ib*m; \n                    else if(nd==3) \n                        D = (T*)mxGetData(plhs[1]) + ib*m; \n                } \n                if(is_complex) { \n                    ptr_M = mat + ib*m2; \n                    ptr_Mi = mat_i + ib*m2; \n                     \n \n                     \n \n                     \n \n                    for(ii=0; ii<m; ii++) { \n                        for(jj=0; jj<m; jj++) { \n                            M[ii*2+jj*2*m] = *ptr_M++; \n                            M[ii*2+jj*2*m+1] = *ptr_Mi++; \n                        } \n                    } \n                     \n \n                    if(anynonsym) { \n                        igeev(&jobz, &jobzn, &m, M, &lda, D, V, &ldz, V, &ldz, zwork, &lzwork, work, &info); \n                        if(do_sort) \n                            if(nlhs>1) \n                                sort(m, D, V, work, do_sort); \n                            else  \n                                sort(m, D, (T*)NULL, work, do_sort); \n                        if(nlhs>1 && do_orth) \n                            if(orth(m, D, V, work, 0)==1) { \n                                #pragma omp critical \n                                { \n                                    err_code = 1; \n                                } \n                                break; \n                            } \n                    } \n                    else { \n                        ievr(&jobz, &range, &uplo, &m, M, &lda, &vl, &vu, &il, &iu, &abstol, &numfind,  \n                                D, V, &ldz, isuppz, zwork, &lzwork, work, &lwork, iwork, &liwork, &info); \n                         \n \n                        if(do_sort==-1) { \n                            fliplr(D,1,m,work,1); \n                            if(nlhs>1)  \n                                fliplr(V,m,m,work,0); \n                        } \n                    } \n                    if(nlhs>1) { \n                        ptr_V = (T*)mxGetData(plhs[0]) + ib*m2; \n                        ptr_Vi = (T*)mxGetImagData(plhs[0]) + ib*m2; \n                        for(ii=0; ii<m; ii++) { \n                            for(jj=0; jj<m; jj++) { \n                                *ptr_V++ = V[ii*2*m+jj*2]; \n                                *ptr_Vi++ = -V[ii*2*m+jj*2+1]; \n                            } \n                        } \n                    } \n                } \n                else { \n                    ptr_M = mat + ib*m2; \n                    V = (T*)mxGetData(plhs[0]) + ib*m2; \n                    if(anynonsym) { \n                        if(nlhs<=1) \n                            Di = (T*)mxGetImagData(plhs[0]) + ib*m; \n                        else if(nd==3) \n                            Di = (T*)mxGetImagData(plhs[1]) + ib*m; \n                    } \n                     \n \n                     \n \n                     \n \n                    memcpy(M,ptr_M,msz); \n                     \n \n                    if(anynonsym) { \n                        geev(&jobzn, &jobz, &m, M, &lda, D, Di, V, &ldz, V, &ldz, work, &lwork, &info); \n                        if(do_sort) \n                            if(nlhs>1) \n                                sort(m, D, Di, V, work, do_sort); \n                            else \n                                sort(m, D, Di, (T*)NULL, work, do_sort); \n                        if(nlhs>1 && do_orth) \n                            if(orth(m, D, Di, V, (T*)mxGetImagData(plhs[0])+ib*m2, work, 1)==1) { \n                                #pragma omp critical \n                                { \n                                    err_code = 1; \n                                } \n                                break; \n                            } \n                    } \n                    else { \n                        evr(&jobz, &range, &uplo, &m, M, &lda, &vl, &vu, &il, &iu, &abstol, &numfind,  \n                                D, V, &ldz, isuppz, work, &lwork, iwork, &liwork, &info); \n                         \n \n                        if(do_sort==-1) { \n                            fliplr(D,1,m,work,1); \n                            if(nlhs>1)  \n                                fliplr(V,m,m,work,1); \n                        } \n                    } \n                     \n \n                     \n \n                    if(nlhs>1 && !issym[ib] && !do_orth) { \n                        ptr_V = (T*)mxGetData(plhs[0]) + ib*m2; \n                        ptr_Vi = (T*)mxGetImagData(plhs[0]) + ib*m2; \n                         \n \n                         \n \n                        for(ii=0; ii<m; ii++) { \n                            if(*(Di+ii)>0.) { \n                                for(jj=0; jj<m; jj++) { \n                                    *(ptr_Vi+(ii+1)*m+jj) = -*(ptr_V+(ii+1)*m+jj); \n                                    *(ptr_Vi+ii*m+jj) = *(ptr_V+(ii+1)*m+jj); \n                                    *(ptr_V+(ii+1)*m+jj) = *(ptr_V+ii*m+jj); \n                                } \n                            } \n                        } \n                    } \n                } \n                 \n \n                if(nlhs>1 && nd==2) {  \n                    if(is_complex && anynonsym) { \n                        E = (T*)mxGetData(plhs[1]) + ib*m2; \n                        for(ii=0; ii<m; ii++)  \n                            *(E+ii+ii*m) = *(D+2*ii); \n                        E = (T*)mxGetImagData(plhs[1]) + ib*m2; \n                        for(ii=0; ii<m; ii++)  \n                            *(E+ii+ii*m) = *(D+2*ii+1); \n                    } \n                    else { \n                        E = (T*)mxGetData(plhs[1]) + ib*m2; \n                        for(ii=0; ii<m; ii++)  \n                            *(E+ii+ii*m) = *(D+ii); \n                        if(anynonsym) { \n                            E = (T*)mxGetImagData(plhs[1]) + ib*m2;  \n                            for(ii=0; ii<m; ii++)  \n                                *(E+ii+ii*m) = *(Di+ii); \n                        } \n                    } \n                } \n                else if(is_complex && anynonsym) { \n                    if(nlhs<=1) \n                        E = (T*)mxGetData(plhs[0]) + ib*m; \n                    else if(nd==3) \n                        E = (T*)mxGetData(plhs[1]) + ib*m; \n                    for(ii=0; ii<m; ii++)  \n                        *(E+ii) = *(D+2*ii); \n                    if(nlhs<=1) \n                        E = (T*)mxGetImagData(plhs[0]) + ib*m; \n                    else if(nd==3) \n                        E = (T*)mxGetImagData(plhs[1]) + ib*m; \n                    for(ii=0; ii<m; ii++)  \n                        *(E+ii) = *(D+2*ii+1); \n                } \n                if(err_code!=0) \n                    break;      \n \n            } \n             \n \n            delete[]work; delete[]iwork; delete[]isuppz; delete[]M; \n            if(is_complex)  { \n                delete[]zwork; \n                if(nlhs>1) \n                    delete[]V; \n            } \n            if(is_complex && anynonsym) { \n                delete[]D; \n            } \n            else if(nlhs>1 && nd==2) { \n                delete[]D; \n                if(anynonsym) \n                    delete[]Di; \n            } \n            #ifndef _OPENMP \n                if(err_code!=0) \n                    break; \n            #endif \n        }", "pragma": "for ", "hash": "5cd01bcb9be739f7933e0949a6e245b7de98b2839f5de8a052a1748803361c57"}
{"code": "for (long long ele_id = 0; ele_id < mesh->eleNum(); ele_id++) \n    { \n        std::vector<Vector<Scalar, 3> > & ele_vert_pos = this->mesh_ele_pos_vec_[ele_id]; \n \n        SquareMatrix<Scalar, 3> A(0.0); \n        for (unsigned int n = 0; n < 3; n++) \n        for (unsigned int m = 0; m < 3; m++) \n            A(n, m) = ele_vert_pos[m+1][n] - ele_vert_pos[0][n]; \n \n         \n \n        A_inverse_vec[ele_id] = A.inverse(); \n    }", "pragma": "parallel for ", "hash": "036d41ff94ebca5ed3bc941350593ff795c2d29120d67eeb4f42f7c150cf7a8a"}
{"code": "for (unsigned i = 0; i < TAILS.size(); i++) \n  { \n    ZTailDistance = pbcDistance(Vector(0.0, 0.0, ZMems), getPosition(i + membraneBeads))[2]; \n    PositionS_Mem = (ZTailDistance + firstSliceZDist_Mem) / DSMEM[0]; \n     \n \n    if ((PositionS_Mem >= (-0.5 - HMEM[0])) && (PositionS_Mem <= (NSMEM[0] + 0.5 - 1.0 + HMEM[0]))) \n    { \n       \n \n      if (PositionS_Mem < 1) \n      { \n        s1_Mem = 0; \n        s2_Mem = 2; \n      } \n      else if (PositionS_Mem <= (NSMEM[0] - 2.0)) \n      { \n        s1_Mem = floor(PositionS_Mem) - 1; \n        s2_Mem = floor(PositionS_Mem) + 1; \n      } \n      else \n      { \n        s1_Mem = NSMEM[0] - 3; \n        s2_Mem = NSMEM[0] - 1; \n      } \n \n      TailPosition = getPbc().realToScaled(pbcDistance(Vector(0.0, 0.0, 0.0), getPosition(i + membraneBeads))); \n \n      for (unsigned s = s1_Mem; s <= s2_Mem; s++) \n      { \n        x = (ZTailDistance - (s + 0.5 - NSMEM[0] / 2.0) * DSMEM[0]) * 2.0 / DSMEM[0]; \n        if (!((x <= -1.0 - HMEM[0]) || (x >= 1.0 + HMEM[0]))) \n        { \n          if (((-1.0 + HMEM[0]) <= x) && (x <= (1.0 - HMEM[0]))) \n          { \n            faxial_Mem[i + TAILS.size() * s] = 1.0; \n            Fs_Mem[s] += 1.0; \n            sx_Mem[s] += sin(2.0 * M_PI * TailPosition[0]); \n            sy_Mem[s] += sin(2.0 * M_PI * TailPosition[1]); \n            cx_Mem[s] += cos(2.0 * M_PI * TailPosition[0]); \n            cy_Mem[s] += cos(2.0 * M_PI * TailPosition[1]); \n          } \n          else if (((1.0 - HMEM[0]) < x) && (x < (1.0 + HMEM[0]))) \n          { \n            aux = 0.5 - ((3.0 * x - 3.0) / (4.0 * HMEM[0])) + (pow((x - 1.0), 3) / (4.0 * pow(HMEM[0], 3))); \n            faxial_Mem[i + TAILS.size() * s] = aux; \n            Fs_Mem[s] += aux; \n            sx_Mem[s] += aux * sin(2.0 * M_PI * TailPosition[0]); \n            sy_Mem[s] += aux * sin(2.0 * M_PI * TailPosition[1]); \n            cx_Mem[s] += aux * cos(2.0 * M_PI * TailPosition[0]); \n            cy_Mem[s] += aux * cos(2.0 * M_PI * TailPosition[1]); \n          } \n          else if (((-1.0 - HMEM[0]) < x) && (x < (-1.0 + HMEM[0]))) \n          { \n            aux = 0.5 + ((3.0 * x + 3.0) / (4.0 * HMEM[0])) - (pow((x + 1.0), 3) / (4.0 * pow(HMEM[0], 3))); \n            faxial_Mem[i + TAILS.size() * s] = aux; \n            Fs_Mem[s] += aux; \n            sx_Mem[s] += (aux * sin(2.0 * M_PI * TailPosition[0])); \n            sy_Mem[s] += (aux * sin(2.0 * M_PI * TailPosition[1])); \n            cx_Mem[s] += (aux * cos(2.0 * M_PI * TailPosition[0])); \n            cy_Mem[s] += (aux * cos(2.0 * M_PI * TailPosition[1])); \n          } \n        } \n      } \n    } \n  }", "pragma": "parallel for reduction(    cx_mem cy_mem sx_mem sy_mem vec_double_plus:fs_mem) private(      aux positions_mem s1_mem s2_mem tailposition x ztaildistance)", "hash": "38734e522a68ffbdddb0a166bae1ff84b864cf4d26876c992fd82d14a5bac87a"}
{"code": "for(i=0; i<reps; i++) c = a*b;", "pragma": "parallel private(a b c d i)", "hash": "ddf56514a2952fe96056807b2e894d9cab2c3e0147d6d8e528dff3fc801b9537"}
{"code": "for(int t = 0; t < nTime; t++) { \n        for(int i = 0; i < nPoints; i++) { \n            output[t][i] = ivalues[t][I[i]][J[i]]; \n        } \n    }", "pragma": "parallel for ", "hash": "47036d8cedd6bf139a1d1e20ab82b1430cb2a80de546659dff681485165243d3"}
{"code": "for (int i = 0; i < numEngines; i++) { \n    BitonicSorting_actions_t actions; \n    actions.param_N = inSize / numEngines; \n    int offset = i * inSize / numEngines; \n    actions.instream_in_array = in_array + offset; \n    actions.outstream_out_array = out_array + offset; \n \n    char id[100]; \n    strncpy(id, \"local:\", 100); \n    strcat(id, dfeIds[i]); \n \n    max_engine_t *engine = max_load(maxfile, id); \n    BitonicSorting_run(engine, &actions); \n    max_unload(engine); \n  }", "pragma": "parallel for ", "hash": "362bf9b7f3a91631aaadfcac2f9ae9d1262234c05dc1ac23e72439201892790b"}
{"code": "for(i=0; i<size; i++){ \n    for(j=0; j<size; j++){ \n      y[i] = y[i] + A[i][j] * x[j]; \n    } \n  }", "pragma": "parallel for private( i j)", "hash": "f89a5dd3e4673cdebad382eef4a6ded68438bc6f44a5b2f76c3eadd60317289e"}
{"code": "for (i = 0; i < height; i++) { \n        unsigned char *b; \n        unsigned char *outY = output_ptr + i * width; \n        unsigned char *outU = output_ptr + (i / 2) * (width / 2) + size; \n        unsigned char *outV = output_ptr + (i / 2) * (width / 2) + size * 5 / 4; \n        if (!upsideDown) b = input_ptr + 2 * width * i; \n        else b = input_ptr - 2 * width * i + 2 * width * height - 4; \n \n        int j; \n        for (j = 0; j < width / 2; j++) { \n            unsigned char Y = b[0]; \n            unsigned char U = ALLDATAMONO ? 128 : b[1]; \n            unsigned char Y1 = b[2]; \n            unsigned char V = ALLDATAMONO ? 128 : b[3]; \n \n            if (!upsideDown) { \n                *(outY++) = Y; \n                *(outY++) = Y1; \n                b += 4; \n            } else { \n                *(outY++) = Y1; \n                *(outY++) = Y; \n                b -= 4; \n            } \n            *(outU++) = U; \n            *(outV++) = V; \n        } \n    }", "pragma": "parallel for private(i)", "hash": "2d28fa85bb9b5012cb0b1b3ed965041e7f83a3ac58080931b8e42dcfae8e6685"}
{"code": "for(j = 0; j < J; j++){ \n \n\t\t \n \n \n\t\tEbdd(j,0) = Eb(j,0)*Edd(j,0);  \n \n\t\t \n \n\t\t \n \n \n\t\t \n \n\t\tEbtdd(j,0) = ( Eb(j,0) * Etau(j,0)  )*Edd(j,0);  \n \n\t}", "pragma": "parallel for ", "hash": "eee7eb0440a3b44c6ea09e9a18fefc3b4eb7c952f24dcc38dc8f2dea2e8060af"}
{"code": "for(size_t y=0; y<sample_max_y; y+=2) \n    for(size_t x=0; x<sample_max_x; x+=2) \n    { \n       \n \n       \n \n       \n \n       \n \n       \n \n       \n \n       \n \n       \n \n       \n \n       \n \n       \n \n       \n \n      dt_aligned_pixel_t RGB = {0.f}, XYZ_D50, chromaticity; \n       \n \n       \n \n      const float *const restrict px = DT_IS_ALIGNED((const float *const restrict)input + \n                                                     4U * ((y + roi->crop_y) * roi->width + x + roi->crop_x)); \n      for(size_t xx=0; xx<2; xx++) \n        for(size_t yy=0; yy<2; yy++) \n          for_each_channel(ch, aligned(px,RGB:16)) \n            RGB[ch] += px[4U * (yy * roi->width + xx) + ch] * 0.25f; \n \n       \n \n      dt_ioppr_rgb_matrix_to_xyz(RGB, XYZ_D50, vs_prof->matrix_in_transposed, vs_prof->lut_in, \n                                 vs_prof->unbounded_coeffs_in, vs_prof->lutsize, vs_prof->nonlinearlut); \n       \n \n      if(vs_type == DT_LIB_HISTOGRAM_VECTORSCOPE_CIELUV) \n      { \n         \n \n        dt_aligned_pixel_t xyY_D50; \n        dt_XYZ_to_xyY(XYZ_D50, xyY_D50); \n         \n \n        dt_xyY_to_Luv(xyY_D50, chromaticity); \n      } \n      else \n      { \n         \n \n        dt_aligned_pixel_t XYZ_D65; \n         \n \n         \n \n         \n \n         \n \n         \n \n        dt_XYZ_D50_2_XYZ_D65(XYZ_D50, XYZ_D65); \n         \n \n        dt_XYZ_2_JzAzBz(XYZ_D65, chromaticity); \n      } \n       \n \n      if(vs_scale == DT_LIB_HISTOGRAM_SCALE_LOGARITHMIC) \n        log_scale(&chromaticity[1], &chromaticity[2], max_radius); \n      if(x == pt_sample_x && y == pt_sample_y) \n      { \n        d->vectorscope_pt[0] = chromaticity[1]; \n        d->vectorscope_pt[1] = chromaticity[2]; \n      } \n \n       \n \n      const int out_x = (diam_px-1) * (chromaticity[1] / max_diam + 0.5f); \n      const int out_y = (diam_px-1) * (chromaticity[2] / max_diam + 0.5f); \n \n       \n \n      if(out_x >= 0 && out_x <= diam_px-1 && out_y >= 0 && out_y <= diam_px-1) \n        dt_atomic_add_int(binned + out_y * diam_px + out_x, 1); \n    }", "pragma": "parallel for ", "hash": "132eb553f7ad3ea91dc7c47c81fa456fb6fd6c7b0bba55df4a9c0c6cf27ce7e9"}
{"code": "for (i3=off3; i3<m3; i3+=2){ \n                    for (i2=off2; i2<m2; i2+=2){ \n                        for (i1=off1; i1<m1; i1+=2){ \n                            idn = i1+ i2* inc_y+ i3*inc_z; \n                            comp = 0; \n                            for(r=0;r<3;r++){ \n                                rptr = yc+idn+comp; \n                                 \n \n                                yA[r] = *rptr; \n                                 \n \n                                rptr += inc_x; \n                                yB[r] = *rptr; \n                                 \n \n                                rptr += inc_y; \n                                yD[r] = *rptr; \n                                 \n \n                                rptr -= inc_x; \n                                yC[r] = *rptr; \n                                 \n \n                                rptr += inc_z; \n                                yG[r] = *rptr; \n                                 \n \n                                rptr += inc_x; \n                                yH[r] = *rptr; \n                                 \n \n                                rptr -= inc_y; \n                                yF[r] = *rptr; \n                                 \n \n                                rptr -= inc_x; \n                                yE[r] = *rptr; \n                                comp +=nn; \n                                 \n                                yABDC[r] = 0.25*(yA[r]+yB[r]+yD[r]+yC[r]); \n                                yBDHF[r] = 0.25*(yB[r]+yD[r]+yH[r]+yF[r]); \n                                yABFE[r] = 0.25*(yA[r]+yB[r]+yF[r]+yE[r]); \n                                yCAEG[r] = 0.25*(yC[r]+yA[r]+yE[r]+yG[r]); \n                                yDCGH[r] = 0.25*(yD[r]+yC[r]+yG[r]+yH[r]); \n                                yEFHG[r] = 0.25*(yE[r]+yF[r]+yH[r]+yG[r]); \n                                yM[r]    = 0.5 *(yABDC[r]+yEFHG[r]); \n                                if(doDerivative) { \n                                    rA[r] = 0.0; \n                                    rB[r] = 0.0; \n                                    rC[r] = 0.0; \n                                    rD[r] = 0.0; \n                                    rE[r] = 0.0; \n                                    rF[r] = 0.0; \n                                    rG[r] = 0.0; \n                                    rH[r] = 0.0; \n                                    rABDC[r] = 0.0; \n                                    rBDHF[r] = 0.0; \n                                    rABFE[r] = 0.0; \n                                    rCAEG[r] = 0.0; \n                                    rDCGH[r] = 0.0; \n                                    rEFHG[r] = 0.0; \n                                    rM[r] = 0.0; \n                                } \n                                 \n                                 \n                            } \n                             \n                            if (alphaArea>0) { \n                                sum += arTriangle3D(yABDC, yA, yB, ARef[0], rABDC, rA, rB, doDerivative,alphaArea); \n                                sum += arTriangle3D(yABDC, yB, yD, ARef[1], rABDC, rB, rD, doDerivative,alphaArea); \n                                sum += arTriangle3D(yABDC, yD, yC, ARef[2], rABDC, rD, rC, doDerivative,alphaArea); \n                                sum += arTriangle3D(yABDC, yC, yA, ARef[3], rABDC, rC, rA, doDerivative,alphaArea); \n                                 \n                                sum += arTriangle3D(yBDHF, yB, yD, ARef[4], rBDHF, rB, rD, doDerivative,alphaArea); \n                                sum += arTriangle3D(yBDHF, yD, yH, ARef[5], rBDHF, rD, rH, doDerivative,alphaArea); \n                                sum += arTriangle3D(yBDHF, yH, yF, ARef[6], rBDHF, rH, rF, doDerivative,alphaArea); \n                                sum += arTriangle3D(yBDHF, yF, yB, ARef[7], rBDHF, rF, rB, doDerivative,alphaArea); \n                                 \n                                sum += arTriangle3D(yABFE, yA, yB, ARef[8], rABFE, rA, rB, doDerivative,alphaArea); \n                                sum += arTriangle3D(yABFE, yB, yF, ARef[9], rABFE, rB, rF, doDerivative,alphaArea); \n                                sum += arTriangle3D(yABFE, yF, yE, ARef[10], rABFE, rF, rE, doDerivative,alphaArea); \n                                sum += arTriangle3D(yABFE, yE, yA, ARef[11], rABFE, rE, rA, doDerivative,alphaArea); \n                                 \n                                sum += arTriangle3D(yCAEG, yC, yA, ARef[12], rCAEG, rC, rA, doDerivative,alphaArea); \n                                sum += arTriangle3D(yCAEG, yA, yE, ARef[13], rCAEG, rA, rE, doDerivative,alphaArea); \n                                sum += arTriangle3D(yCAEG, yE, yG, ARef[14], rCAEG, rE, rG, doDerivative,alphaArea); \n                                sum += arTriangle3D(yCAEG, yG, yC, ARef[15], rCAEG, rG, rC, doDerivative,alphaArea); \n                                 \n                                sum += arTriangle3D(yDCGH, yD, yC, ARef[16], rDCGH, rD, rC, doDerivative,alphaArea); \n                                sum += arTriangle3D(yDCGH, yC, yG, ARef[17], rDCGH, rC, rG, doDerivative,alphaArea); \n                                sum += arTriangle3D(yDCGH, yG, yH, ARef[18], rDCGH, rG, rH, doDerivative,alphaArea); \n                                sum += arTriangle3D(yDCGH, yH, yD, ARef[19], rDCGH, rH, rD, doDerivative,alphaArea); \n                                 \n                                sum += arTriangle3D(yEFHG, yE, yF, ARef[20], rEFHG, rE, rF, doDerivative,alphaArea); \n                                sum += arTriangle3D(yEFHG, yF, yH, ARef[21], rEFHG, rF, rH, doDerivative,alphaArea); \n                                sum += arTriangle3D(yEFHG, yH, yG, ARef[22], rEFHG, rH, rG, doDerivative,alphaArea); \n                                sum += arTriangle3D(yEFHG, yG, yE, ARef[23], rEFHG, rG, rE, doDerivative,alphaArea); \n                            } \n                             \n                            if (alphaVolume>0) { \n                                 \n \n                                sum   +=  SvolTetra3D(yA, yB, yABDC, yM, VRef[0], doDerivative, rA, rB, rABDC, rM, -1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yB, yD, yABDC, yM, VRef[1], doDerivative, rB, rD, rABDC, rM, -1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yD, yC, yABDC, yM, VRef[2], doDerivative, rD, rC, rABDC, rM, -1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yC, yA, yABDC, yM, VRef[3], doDerivative, rC, rA, rABDC, rM, -1.0,alphaVolume); \n                                 \n                                sum   +=  SvolTetra3D(yB, yD, yBDHF, yM, VRef[4], doDerivative, rB, rD, rBDHF, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yD, yH, yBDHF, yM, VRef[5], doDerivative, rD, rH, rBDHF, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yH, yF, yBDHF, yM, VRef[6], doDerivative, rH, rF, rBDHF, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yF, yB, yBDHF, yM, VRef[7], doDerivative, rF, rB, rBDHF, rM, 1.0,alphaVolume); \n                                 \n                                sum   +=  SvolTetra3D(yA, yB, yABFE, yM, VRef[8], doDerivative, rA, rB, rABFE, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yB, yF, yABFE, yM, VRef[9], doDerivative, rB, rF, rABFE, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yF, yE, yABFE, yM, VRef[10], doDerivative, rF, rE, rABFE, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yE, yA, yABFE, yM, VRef[11], doDerivative, rE, rA, rABFE, rM, 1.0,alphaVolume); \n                                 \n                                sum   +=  SvolTetra3D(yC, yA, yCAEG, yM, VRef[12], doDerivative, rC, rA, rCAEG, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yA, yE, yCAEG, yM, VRef[13], doDerivative, rA, rE, rCAEG, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yE, yG, yCAEG, yM, VRef[14], doDerivative, rE, rG, rCAEG, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yG, yC, yCAEG, yM, VRef[15], doDerivative, rG, rC, rCAEG, rM, 1.0,alphaVolume); \n                                 \n                                sum   +=  SvolTetra3D(yD, yC, yDCGH, yM, VRef[16], doDerivative, rD, rC, rDCGH, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yC, yG, yDCGH, yM, VRef[17], doDerivative, rC, rG, rDCGH, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yG, yH, yDCGH, yM, VRef[18], doDerivative, rG, rH, rDCGH, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yH, yD, yDCGH, yM, VRef[19], doDerivative, rH, rD, rDCGH, rM, 1.0,alphaVolume); \n                                 \n                                sum   +=  SvolTetra3D(yE, yF, yEFHG, yM, VRef[20], doDerivative, rE, rF, rEFHG, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yF, yH, yEFHG, yM, VRef[21], doDerivative, rF, rH, rEFHG, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yH, yG, yEFHG, yM, VRef[22], doDerivative, rH, rG, rEFHG, rM, 1.0,alphaVolume); \n                                sum   +=  SvolTetra3D(yG, yE, yEFHG, yM, VRef[23], doDerivative, rG, rE, rEFHG, rM, 1.0,alphaVolume); \n                                 \n                            } \n                             \n                             \n \n                            if (doDerivative) { \n                                comp = 0; \n                                for (r=0; r < 3; r++){ \n                                     \n \n                                    rABDC[r] *= 0.25; \n                                    rBDHF[r] *= 0.25; \n                                    rABFE[r] *= 0.25; \n                                    rCAEG[r] *= 0.25; \n                                    rDCGH[r] *= 0.25; \n                                    rEFHG[r] *= 0.25; \n                                    rM[r]    *= 0.125; \n                                     \n \n                                    wptr = dS + idn + comp; \n                                    *wptr +=  rA[r]+ rABDC[r]+rABFE[r]+rCAEG[r] + rM[r]; \n                                     \n \n                                    wptr += inc_x; \n                                    *wptr +=  rB[r]+ rABDC[r]+rBDHF[r]+rABFE[r]+rM[r]; \n                                     \n \n                                    wptr += inc_y; \n                                    *wptr += rD[r]+rABDC[r]+rBDHF[r]+rDCGH[r]+rM[r]; \n                                     \n \n                                    wptr -= inc_x; \n                                    *wptr += rC[r]+rABDC[r]+rCAEG[r]+rDCGH[r]+rM[r]; \n                                     \n \n                                    wptr += inc_z; \n                                    *wptr += rG[r]+rCAEG[r]+rDCGH[r]+rEFHG[r]+rM[r]; \n                                     \n \n                                    wptr += inc_x; \n                                    *wptr += rH[r]+rBDHF[r]+rDCGH[r]+rEFHG[r]+rM[r]; \n                                     \n \n                                    wptr -= inc_y; \n                                    *wptr += rF[r]+rBDHF[r]+rABFE[r]+rEFHG[r]+rM[r]; \n                                     \n \n                                    wptr -= inc_x; \n                                    *wptr += rE[r]+rABFE[r]+rCAEG[r]+rEFHG[r]+rM[r]; \n                                    comp +=nn; \n                                } \n                            } \n                        } \n                    } \n                }", "pragma": "parallel for reduction(+ : sum) private(                                   comp i1 i2 i3 idn r ra rabdc rabfe rb rbdhf rc rcaeg rd rdcgh re refhg rf rg rh rm rptr wptr ya yabdc yabfe yb ybdhf yc ycaeg yd ydcgh ye yefhg yf yg yh ym)", "hash": "84f73127a2b768884902189df063f829fdca37276b5c8e553ad7ad4266ce12cd"}
{"code": "for(int i = 0; i < numMyRows; i++) { \n      int     NumEntries = NumEntriesPerRow[i]; \n      int*    RowIndices = Indices[i]; \n      double* RowValues  = srcValues[i]; \n      double sum = 0.0; \n      for(int j = 0; j < NumEntries; j++) \n  sum += *RowValues++ * x[*RowIndices++]; \n \n      y[i] = sum; \n \n    }", "pragma": "parallel for ", "hash": "25d0aa743b3f6be147757cf9f136805ee00e974e2bdf99613762bce2bf4a374e"}
{"code": "for(int j=0; j<D; j++){ \n \n\t\tdouble* delta_j = delta[j]; \n\t\tdouble* u_j = u[j]; \n\t\tvector<pair<int,double> >* fea = &(features[j]); \n \n\t\tCodeIndexMap code_ind_map; \n\t\tCodeIndexMapIter it; \n\t\tvector<int>* code; \n\t\tfor(int i=0;i<N;i++){ \n\t\t\tif( ins_old[i].size() == 0 ) \n\t\t\t\tcontinue; \n \n\t\t\tcode = compute_bin_num( &(ins_old[i]), delta_j,  u_j, d ); \n\t\t\t \n \n\t\t\tint ind; \n\t\t\tif( (it=code_ind_map.find(code)) == code_ind_map.end() ){ \n\t\t\t\tind = code_ind_map.size(); \n\t\t\t\tcode_ind_map.insert(make_pair(code, ind)); \n\t\t\t\t \n \n\t\t\t}else{ \n\t\t\t\tind = it->second; \n\t\t\t\tdelete code; \n\t\t\t} \n \n\t\t\t \n \n\t\t\t(*fea)[i] = make_pair(ind + 1, 1.0) ; \n\t\t} \n     \n \n    for(CodeIndexMap::iterator it=code_ind_map.begin(); it!=code_ind_map.end(); it++){ \n      delete (it->first); \n    } \n\t\t \n     \n \n\t\tif(j<D-1) \n\t\t\toffset[j+1] = code_ind_map.size(); \n\t}", "pragma": "parallel for ", "hash": "3a824820004063635e072f8bcb76930cc5edc71b7818aa6de9db256b026662be"}
{"code": "for (int i = 0; i < 10; ++i) { \n    foo(); \n    goto L2;  \n \n    #pragma omp ordered \n    { \n      L2: \n      foo(); \n    } \n  }", "pragma": "for ", "hash": "a052d9866f7ff8a9ce689fa583cac3b00d12104521d001563add602ee29b989f"}
{"code": "for(i = 0; i < (int)instances_number; i++) \n\t{ \n\t   instance_i = get_instance(i); \n \n       for(size_t j = i+1; j < instances_number; j++) \n\t   {\t       \n          instance_j = get_instance(j); \n \n          if(instances.get_use(j) != Instances::Unused \n          && instance_j == instance_i) \n\t\t  { \n              instances.set_use(j, Instances::Unused); \n              repeated_instances.push_back(j); \n\t\t  } \n\t   }\t     \n\t}", "pragma": "parallel for private(  i instance_i instance_j)", "hash": "e28ceb4c8bf30aa3188cb7060dae526e716ad64fdc56545fae502a5adef828df"}
{"code": "for (int readIndex= 0; readIndex < (int)reads.size(); readIndex++ ) { \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n            \t\tif (reads[readIndex].MapperSplit == false) \n                \t\tSearchFarEnd( chromosomeSeq, reads[readIndex], currentChromosome ); \n\t\t\t \n \n\t\t\t \n \n\t\t}", "pragma": "for ", "hash": "ec681401fcfb4af817412290115237c2a73aa3ed4f9ce126e38bfb096c95a7da"}
